quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability," #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for exa",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11924,down,download,11924,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['download']
Availability," - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This supp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25305,avail,available,25305,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability," Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The sp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18528,toler,tolerance,18528,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability, Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wikståhl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Giguère); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the c,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:70439,error,errors,70439,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability," a list over the expectation operators, trajectories and times in that order.; The averages are stored in ``result.average_expect`` and the standard derivation; of the expectation values in ``result.std_expect``. When the states are returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also contain a; list of times at which the collapse occurred, and which collapse operators did; the collapse. These can be obtained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:7659,error,errors,7659,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['error'],['errors']
Availability," and applied colorblind_safe to functions in visualization.py (#2170 by Yuji Tamakoshi); - Changed arguments and applied colorblind_safe to plot_wigner_sphere and matrix_histogram in visualization.py (#2193 by Yuji Tamakoshi); - Added Dia data layer which represents operators as multi-diagonal matrices. (#2196); - Added support for animated plots. (#2203 by Yuji Tamakoshi); - Improved sampling algorithm for mcsolve (#2218 by Daniel Weiss); - Added support for early termination of map functions. (#2222). Bug Fixes; ---------. - Add missing state transformation to floquet_markov_mesolve (#1952 by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 by Asier Galicia); - Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template. (#2107 by Valan Baptist Mathuranayagam); - Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05. (#2181 by SJUW); - Raise error on insufficient memory. (#2224); - Fixed fallback to fsesolve call in fmmesolve (#2225). Removals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:31413,error,error,31413,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability," bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then inst",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4420,avail,available,4420,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['avail'],['available']
Availability," dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15249,avail,available,15249,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability," do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6264,error,error,6264,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['error'],['error']
Availability," for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85628,error,errors,85628,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability," if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. Note that this merging operation only checks that the result are compatible --; i.e. that the ``e_ops`` and ``tlist`` are the same. It does not check that the same initial state or; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9871,toler,tolerance,9871,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['toler'],['tolerance']
Availability," isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coeff",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12877,avail,available,12877,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['avail'],['available']
Availability," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14026,failure,failure,14026,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['failure'],['failure']
Availability," np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varied according to the number of points and vectors added. But what if you want a different choice of color, or you want your sphere to be purple with different axes labels? Well then you are in luck as the Bloch class has 22 attributes which one can control. Assuming ``b=Bloch()``:. .. tabularcolumns:: | p{3cm} | p{7cm} | p{7cm} |. .. cssclass:: table-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4866,down,down,4866,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['down'],['down']
Availability," on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, Asier Galicia and Simon Cross); - Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (`#1837 <https://github.com/qutip/qutip/pull/1837>`_ by Xavier Spronken); - Support ``Path`` objects in ``qutip.fileio``. (`#1813 <https://github.com/qutip/qutip/pull/1813>`_ by Adrià Labay); - Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (`#1275 <https://github.com/qutip/qutip/pull/1275>`_ and `#1802 <https://github.com/qutip/qutip/pull/1802>`_ by NS2 Group at LPS and Simon Cross); - Added a ``color_style`` option to the ``hinton`` plotting function. (`#1595 <https://github.com/qutip/qutip/issues/1595>`_ by Cassandra Granade); - Improved the scaling of ``floquet_master_equation_rates`` and ``floquet_master_equation_tensor`` and fixed transposition and basis change errors in ``floquet_master_equation_tensor`` and ``floquet_markov_mesolve``. (`#1248 <https://github.com/qutip/qutip/pull/1248>`_ by Camille Le Calonnec, Jake Lishman and Eric Giguère); - Removed ``linspace_with`` and ``view_methods`` from ``qutip.utilities``. For the former it is far better to use ``numpy.linspace`` and for the later Python's in-built ``help`` function or other tools. (`#1680 <https://github.com/qutip/qutip/pull/1680>`_ by Eric Giguère); - Added support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``. (`#1655 <https://github.com/qutip/qutip/pull/1655>`_ by Marek Narożniak); - Added the function ``steadystate_floquet``, which returns the ""effective"" steadystate of a periodic driven system. (`#1660 <https://github.com/qutip/qutip/pull/1660>`_ by Alberto Mercurio); - Improved mcsolve memory efficiency by not storing final states when they are not needed. (`#1669 <https://github.com/quti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:59058,error,errors,59058,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability," same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3842,down,down,3842,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability," to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14794,down,down,14794,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['down']
Availability," where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution :math:`k=M`) can the be calculated as. .. math::. X(t_k):=X_k X_{k-1}\cdots X_1 X_0. If the objective is state-to-state transfer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0 = U(0) = \mathbb{1}` and the target :math:`X_{targ}=U_{targ}`. A *figure of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5429,error,error,5429,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['error'],['error']
Availability,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:350,avail,available,350,doc/guide/heom/history.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst,2,['avail'],['available']
Availability,"("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). Similarly, we can use the function :func:`qutip.visualization.hinton`, which is; used below to visualize the corresponding steadystate density matrix:. .. plot::; :context: close-figs. rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). .. _visual-qpt:. Quantum process tomography; ==========================. Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce. The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states. To see how this works (see e.g. [Moh08]_ for more details), consider a process that is described by quantum map :math:`\epsilon(\rho_{\rm in}) = \rho_{\rm out}`, which can be written. .. math::; :label: qpt-quantum-map. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,. where :math:`N` is the number of states of the system (that is, :math:`\rho` is represented by an :math:`[N\times N]` matrix). Given an orthogonal operator basis of our choice :math:`\{B_i\}_i^{N^2}`, which satisfies :math:`{\rm Tr}[B",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:10941,error,errors,10941,doc/guide/guide-visualization.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst,1,['error'],['errors']
Availability,"(modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning; is that it is only well defined for Hermitian matrices. Since the Liouvillian; is non-Hermitian, the ability to find a good preconditioner is not guaranteed.; And moreover, if a preconditioner is found, it is not guaranteed to have a good; condition number. QuTiP can make use of an incomplete LU preconditioner when; using the iterative ``'gmres'``, ``'lgmres'``, and ``'bicgstab'`` solvers by; setting ``use_precond=True``. The preconditioner optionally makes use of a; combination of symmetric and anti-symmetric matrix permutations that attempt to; improve the preconditioning process. These features are discussed in the; :ref:`steady-args` section. Even with these state-of-the-art permutations,; the generation of a successful preconditoner for non-symmetric matrices is; currently a trial-and-error process due to the lack of mathematical work done; in this area. It is always recommended to begin with the direct solver with no; additional arguments before selecting a different method. Finding the steady-state solution is not limited to the Lindblad form of the; master equation. Any time-independent Liouvillian constructed from a; Hamiltonian and collapse operators can be used as an input::. >>> rho_ss = steadystate(L). where ``L`` is the Louvillian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:6583,error,error,6583,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['error'],['error']
Availability,"******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1035,down,down,1035,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:933,error,error,933,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['error'],['error']
Availability,"*********************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1082,down,down,1082,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"*********************; Modifying Internal QuTiP Settings; *********************************. .. _settings-params:. User Accessible Parameters; ==========================. In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1109,toler,tolerance,1109,doc/guide/guide-settings.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst,1,['toler'],['tolerance']
Availability,"*:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15694,down,downarrow,15694,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['down'],['downarrow']
Availability,", 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2470,down,down,2470,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['down'],['down']
Availability,", for example, the construction of qutrit circuits. (`#1807 <https://github.com/qutip/qutip/pull/1807>`_ by Boxi Li); - Fixed the checking of ``method`` and ``offset`` parameters in ``coherent`` and ``coherent_dm``. (`#1469 <https://github.com/qutip/qutip/pull/1469>`_ and `#1741 <https://github.com/qutip/qutip/pull/1741>`_ by Joseph Fox-Rabinovitz and Simon Cross); - Removed the Hamiltonian saved in the ``sesolve`` solver results. (`#1689 <https://github.com/qutip/qutip/pull/1689>`_ by Eric Giguère); - Fixed a bug in rand_herm with ``pos_def=True`` and ``density>0.5`` where the diagonal was incorrectly filled. (`#1562 <https://github.com/qutip/qutip/pull/1562>`_ by Eric Giguère). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` test",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64309,error,errors,64309,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability,", just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:17698,avail,available,17698,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"- Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15089,avail,available,15089,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"- The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovso",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:17638,avail,available,17638,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"----+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +---------------+---------------+----------------------------------------+; | is Hermitian? | ``Q.isherm`` | Is the operator Hermitian or not? |; +---------------+---------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +---------------+---------------+----------------------------------------+. .. figure:: quide-basics-qobj-box.png; :align: center; :width: 3.5in. The ``Qobj`` Class viewed as a container for the properties needed to characterize a quantum operator or state vector. For the destruction operator above:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; Dia(shape=(4, 4), num_diag=1). The ``data`` attribute returns a Qutip diagonal matrix.; ``Qobj`` instances store their data in Qutip matrix format.; In the core qutip module, the ``Dense``, ``CSR`` and ``Dia`` formats are available, but other packages can add other formats.; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:13254,avail,available,13254,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['avail'],['available']
Availability,"-----------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix sever",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105311,error,errors,105311,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:70,error,error,70,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['error'],['error']
Availability,". .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2G",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10048,down,download,10048,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['down'],['download']
Availability,". New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime depe",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6150,avail,available,6150,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,"['avail', 'down']","['available', 'download']"
Availability,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12379,error,errors,12379,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,2,"['avail', 'error']","['available', 'errors']"
Availability,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:383,avail,available,383,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['avail'],['available']
Availability,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:995,avail,available,995,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['avail'],['available']
Availability,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:221,error,error,221,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,".. _copyright:. ***********************; Copyright and Licensing; ***********************. The text of this documentation is licensed under the `Creative Commons Attribution 3.0 Unported License <https://creativecommons.org/licenses/by/3.0/>`_.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text; ====================================. The canonical form of this license is available at `https://creativecommons.org/licenses/by/3.0/ <https://creativecommons.org/licenses/by/3.0/>`_, which should be considered the binding version of this license.; It is reproduced here for convenience. .. include:: LICENSE_cc-by-3.0.txt. License Terms for Source Code of QuTiP and Code Samples; =======================================================. .. include:: ../LICENSE.txt; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/copyright.rst:566,avail,available,566,doc/copyright.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/copyright.rst,1,['avail'],['available']
Availability,".. _development_ideas:. **********************************; Ideas for future QuTiP development; **********************************. Ideas for significant new features are listed here. For the general roadmap,; see :doc:`roadmap`. .. toctree::; :maxdepth: 1. ideas/qutip-interactive.rst; ideas/pulse-level-quantum-circuits.rst; ideas/quantum-error-mitigation.rst; ideas/heom-gpu.rst. Google Summer of Code; =====================. Many possible extensions and improvements to QuTiP have been documented as; part of `Google Summer of Code <https://summerofcode.withgoogle.com/>`_:. * `GSoC 2021 <https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2021/>`_; * `GSoC 2022 <https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2022/>`_. Completed Projects; ==================. These projects have been completed:. .. toctree::; :maxdepth: 1. ideas/tensorflow-data-backend.rst; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas.rst:341,error,error-mitigation,341,doc/development/ideas.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas.rst,1,['error'],['error-mitigation']
Availability,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:255,avail,available,255,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['avail'],['available']
Availability,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1194,toler,tolerance,1194,doc/guide/dynamics/dynamics-options.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst,1,['toler'],['tolerance']
Availability,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:979,avail,available,979,doc/guide/guide-overview.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst,2,"['avail', 'down']","['available', 'download']"
Availability,".; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14283,down,down,14283,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['down'],['down']
Availability,".toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9297,avail,available,9297,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['avail'],['available']
Availability,"/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4330,avail,available,4330,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4764,error,error,4764,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['error'],['error']
Availability,"4-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28337,error,errors,28337,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability,"::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectori",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9571,error,errors,9571,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['error'],['errors']
Availability,"; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12863,avail,available,12863,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['avail'],['available']
Availability,">`_,; and :math:`Nk` specifies the cut-off in the expansion. Evaluating the integral for the correlation functions gives:. .. math::. C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}. where:. .. math::. \eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}. \gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}. and :math:`\beta = \frac{1}{T}`. And now we calculate the same numbers in Python:. .. plot::; :context:; :nofigs:. # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Padé approxmation to Fermi distribution. """"""; f = 0.5; for ll in range(1, Nk + 1):; # kappa and epsilon are calculated further down; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. def kappa_epsilon(Nk):; """""" Calculate kappa and epsilon coefficients. """""". alpha = np.zeros((2 * Nk, 2 * Nk)); for j in range(2 * Nk):; for k in range(2 * Nk):; alpha[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) - 1) * (2 * (k + 1) - 1)); ). eps = [-2. / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:12641,down,down,12641,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['down'],['down']
Availability,"AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1527,down,downloads,1527,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['down'],['downloads']
Availability,"Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-blo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6233,down,download,6233,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['down'],['download']
Availability,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:1849,avail,available,1849,CODE_OF_CONDUCT.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md,1,['avail'],['available']
Availability,"Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` ar",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9155,error,error,9155,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['error'],['error']
Availability,"Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11478,error,errors,11478,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['error'],['errors']
Availability,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1279,toler,tolerance,1279,doc/guide/guide-settings.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst,2,['toler'],['tolerance']
Availability,"MALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24790,down,down,24790,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['down'],['down']
Availability,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6689,error,error,6689,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['error'],['error']
Availability,"Py arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96241,error,error,96241,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); - Fixed issue where `extract_states` did not preserve hermiticity.; Fixed issue where `rand_herm` did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); - ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). M",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:52273,error,error,52273,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25798,avail,available,25798,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50268,avail,available,50268,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11239,down,down,11239,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['down'],['down']
Availability,"``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:37896,avail,available,37896,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"`solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning; is that it is only well defined for Hermitian matrices. Since the Liouvillian; is non-Hermitian, the ability to find a good preconditioner is not guaranteed.; And moreover, if a preconditioner is found, it is not guaranteed to have a good; condition number. QuTiP can make use of an incomplete LU preconditioner when; using the iterative ``'gmres'``, ``'lgmres'``, and ``'bicgstab'`` solvers by; setting ``use_precond=True``. The preconditioner optionally makes use of a; combination of symmetric and anti-symmetric matrix permutations th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:5207,down,downside,5207,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['down'],['downside']
Availability,"ad only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); ++++++",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103258,error,error,103258,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"antum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `ri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2602,down,down,2602,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"asurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1175,down,down,1175,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"ate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance compared with; the standard SuperLU method used by SciPy. To verify that ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:2220,avail,available,2220,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['avail'],['available']
Availability,"ation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------------------------------------+; | Gate function | Description |; +================================================+=======================================================+; | :func:`~qutip.core.gates.rx` | Rotation around x axis |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.ry` | Rotation around y axis |; +",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16485,down,downarrow,16485,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['down'],['downarrow']
Availability,"btained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8385,error,errors,8385,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['error'],['errors']
Availability,"by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Giguère**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Giguère**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Giguère**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step function interpolation for array time-coefficient (by **Boxi Li**). - Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by **Boxi Li**). Bug Fixes; ---------. - Fixed the pickling but that made solver unable to run in parallel on Windows (Thank **lrunze** for reporting). - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**). - Fixed dimension che",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89945,error,error,89945,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"c arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42594,avail,available,42594,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13292,avail,available,13292,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['avail'],['available']
Availability,"ce may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Review X *8*, 031027 (2018). .. [4] Boxi Li's blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. .. [5] Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. .. [6] `Mitiq <https://mitiq.readthedocs.io/>`_; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:2804,error,error,2804,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['error'],['error']
Availability,"ch the state was evaluated (i.e. ``tlist``); - ``states``: the system states at each time; - ``expect``: a list with the values of each ``e_ops`` at each time; - ``e_data``: a dictionary with the values of each ``e_op`` at each time; - ``ado_states``: see below (an instance of; :class:`~qutip.solver.heom.HierarchyADOsState`). If ``ado_return=True`` is passed to ``.run(...)`` the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as ``.ado_states``. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see :ref:`heom-determining-currents`). If one has a full set of ADOs from a previous call of ``.run(...)`` you may; supply it as the initial state of the solver by calling; ``.run(result.ado_states[-1], tlist, ado_init=True)``. As with other QuTiP solvers, if expectation operators or functions are supplied; using ``.run(..., e_ops=[...])`` the expectation values are available in; ``result.expect`` and ``result.e_data``. Below we run the solver again, but use ``e_ops`` to store the expectation; values of the population of the system states and the coherence:. .. plot::; :context:. # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.e_data[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.e_data[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state; ------------. Using the same s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:4942,avail,available,4942,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['avail'],['available']
Availability,"cient and the full propagator; is desired. QuTiP has the :func:`.propagator` function to compute them:. .. code-block::. >>> H = sigmaz() + np.pi *sigmax(); >>> psi_t = sesolve(H, basis(2, 1), [0, 0.5, 1]).states; >>> prop = propagator(H, [0, 0.5, 1]). >>> print((psi_t[1] - prop[1] @ basis(2, 1)).norm()); 2.455965272327082e-06. >>> print((psi_t[2] - prop[2] @ basis(2, 1)).norm()); 2.0071900004562142e-06. The first argument is the Hamiltonian, any time dependent system format is; accepted. The function also accepts an optional `c_ops` argument for collapse operators.; When used, a propagator for density matrices is computed:; :math:`\rho(t) = U(t)(\rho(0))`:. .. code-block::. >>> rho_t = mesolve(H, fock_dm(2, 1), [0, 0.5, 1], c_ops=[sigmam()]).states; >>> prop = propagator(H, [0, 0.5, 1], c_ops=[sigmam()]). >>> print((rho_t[1] - prop[1](fock_dm(2, 1))).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - prop[2](fock_dm(2, 1))).norm()); 1.2666967766644768e-06. The propagator function is also available as a class:. .. code-block::. >>> U = Propagator(H, c_ops=[sigmam()]). >>> state_0_5 = U(0.5)(fock_dm(2, 1)); >>> state_1 = U(1., t_start=0.5)(state_0_5). >>> print((rho_t[1] - state_0_5).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - state_1).norm()); 8.355518501351504e-07. The :obj:`.Propagator` can take ``options`` and ``args`` as a solver instance. .. _propagator_solver:. Using a solver to compute a propagator; ======================================. Many solvers accept an operator as the initial state. When an identity matrix is; passed as the initial state, the propagator is computed. This can be used to compute; a propagator for Bloch-Redfield or Floquet equations:. .. code-block::. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> gamma1 = 0.5. >>> H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). >>> def ohmic_spectrum(w):; >>> if w == 0.0: # dephasing inducing noise; >>> return gamma1; >>> else: # relaxation inducing noise; >>> return gamma1 / 2 * ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst:1145,avail,available,1145,doc/guide/dynamics/dynamics-propagator.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst,1,['avail'],['available']
Availability,"d :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4821,avail,available,4821,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['avail'],['available']
Availability,"d documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79108,error,errors,79108,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['errors']
Availability,"d new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26048,avail,available,26048,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"ded for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6281,avail,available,6281,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['avail'],['available']
Availability,"desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-redfield-derivation:. Brief Derivation and Definitions; ================================. The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): :math:`H = H_{\rm S} + H_{\rm B} + H_{\rm I}`, where :math:`H` is the total system+bath Hamiltonian, :math:`H_{\rm S}` and :math:`H_{\rm B}` are the system and bath Hamiltonians, respectively, and :math:`H_{\rm I}` is the interaction Hamiltonian. The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (:math:`\dot\rho = -i\hbar^{-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:2185,robust,robust,2185,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['robust'],['robust']
Availability,"dm(distribution=""hs"")`` and ``rand_dm(distribution=""ginibre"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilati",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49576,toler,tolerance,49576,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"drey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); =================",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:1279,toler,tolerance,1279,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"e ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may st",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18204,avail,available,18204,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"e operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:. .. doctest:: [basics]; :options: +SKIP. >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators ""is equal"" `==` and ""is not equal"" `!=` are also supported. .. _basics-functions:. Functions operating on Qobj class; =================================. Like attributes, the quantum object class has defined functions (methods) that operate on ``Qobj`` class instances. For a general quantum object ``Q``:. .. cssclass:: table-striped. +-----------------+-------------------------------+----------------------------------------+; | Function | Command | Description ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:15643,error,error,15643,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['error'],['error']
Availability,"e"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49617,toler,tolerance,49617,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"e(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24665,down,down,24665,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['down'],['down']
Availability,"e. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of exter",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:1656,down,downloaded,1656,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['down'],['downloaded']
Availability,"e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9044,error,error,9044,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['error'],['error']
Availability,"ease from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list be",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13531,avail,available,13531,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['avail'],['available']
Availability,"ease to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Giguère**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Vers",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:86167,error,error,86167,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"ectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. Note that this merging operation only checks that the result are compatible --; i.e. that the ``e_ops`` and ``tlist`` are the same. It does not check that the same initial state or; Hamiltonian where used. This can be used to explore the convergence of the Monte Carlo solver.; For example, the following code block plots expectation values for 1, 10 and 100; trajectories:. .. plot::; :context: close-figs. solver = MCSolver(H, c_ops=[np.sqrt(0.1) * a]); c_ops=[np.sqrt(0.1) * a]; e_op",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:10102,error,error,10102,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['error'],['error']
Availability,"ed into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Giguère**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Giguère**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89202,error,error,89202,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"eels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16159,down,down,16159,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['down']
Availability,"efficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25504,avail,available,25504,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"elated to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing na",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2689,mainten,maintence,2689,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['mainten'],['maintence']
Availability,"endence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97176,robust,robust,97176,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['robust'],['robust']
Availability,"ent, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10130,down,downloads,10130,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['down'],['downloads']
Availability,"er of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9371,toler,tolerance,9371,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['toler'],['tolerance']
Availability,"er provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42129,avail,available,42129,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"erz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91951,avail,available,91951,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"es Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation values and states are averaged; over all trajectories, while a list over the runs are given when they are stored.; For a fix output format, ``average_expect`` return the average, while; ``runs_states`` return the list over trajectories. The ``runs_`` output will; return ``None`` when the trajectories are not saved. Standard derivation of the; expectation values is also available:. +-------------------------+----------------------+------------------------------------------------------------------------+; | Reduced result | Trajectories results | Description |; +=========================+======================+========================================================================+; | ``average_states`` | ``runs_states`` | State vectors or density matrices calculated at each times of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_final_state`` | ``runs_final_state`` | State vectors or density matrices calculated at the last time of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_expect`` | ``runs_expect`` | List/array of expectation values, if requested. |; +-------------------------+----------------------+------------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:5625,avail,available,5625,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['avail'],['available']
Availability,"evant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also crea",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9527,failure,failures,9527,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['error', 'failure']","['error', 'failures']"
Availability,"ew; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1720,error,error,1720,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['error'],['error']
Availability,"f doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitatio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:2115,avail,available,2115,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['avail'],['available']
Availability,"format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrödinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state. - New module `qutip.qip` with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures. - New module `qutip.distributions` with unified API for working with; distribution functions. - New format for defini",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:106678,failure,failure,106678,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['failure'],['failure']
Availability,"ft|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------------------------------------+; | Gate function | Description |; +================================================+=======================================================+; | :func:`~qutip.core.gates.rx` | Rotation around x axis |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.ry` | Rotation around y axis |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.rz` | Rotation around z axis |; +-------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16763,down,downarrow,16763,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['down'],['downarrow']
Availability,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12624,avail,available,12624,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['avail'],['available']
Availability,"github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:2121,avail,available,2121,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"he ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``.; - Dimensions use a class instead of layered lists.; - Allow measurement functions to support degenerate operators.; - Add ``qeye_like`` and ``qzero_like``.; - Added fermionic annihilation and creation operators. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:24558,toler,tolerance,24558,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"he class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15432,avail,available,15432,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"he current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15897,avail,available,15897,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"he most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedoc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:5110,avail,available,5110,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"hosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of meas",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3045,down,down,3045,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,2,['down'],['down']
Availability,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:15009,error,errors,15009,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['error'],['errors']
Availability,"ically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8061,error,error-prone,8061,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['error'],['error-prone']
Availability,"ing algorithm'); plt.xlabel(""time [ns]""); plt.ylabel(r""$p_{1}$""); plt.legend(); plt.show(). The original sampling algorithm samples the no-jump trajectory on average 96.7%; of the time, while the improved sampling algorithm only does so once. .. _monte-seeds:. Reproducibility; ---------------. For reproducibility of Monte-Carlo computations it is possible to set the seed of the random; number generator:. .. code-block::. >>> res1 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=1, ntraj=1); >>> res2 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=1, ntraj=1); >>> res3 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=2, ntraj=1); >>> np.allclose(res1, res2); True; >>> np.allclose(res1, res3); False. The ``seeds`` parameter can either be an integer or a numpy ``SeedSequence``, which; will then be used to create seeds for each trajectory. Alternatively it may be a list of; intergers or ``SeedSequence`` s with one seed for each trajectories. Seeds available in; the result object can be used to redo the same evolution:. .. code-block::. >>> res1 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, ntraj=10); >>> res2 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=res1.seeds, ntraj=10); >>> np.allclose(res1, res2); True. .. _monte-parallel:. Running trajectories in parallel; --------------------------------. Monte-Carlo evolutions often need hundreds of trajectories to obtain sufficient; statistics. Since all trajectories are independent of each other, they can be computed; in parallel. The option ``map`` can take ``""serial""``, ``""parallel""`` or ``""loky""``.; Both ``""parallel""`` and ``""loky""`` compute trajectories on multiple CPUs using; respectively the `multiprocessing <https://docs.python.org/3/library/multiprocessing.html>`_; and `loky <https://loky.readthedocs.io/en/stable/index.html>`_ python modules. .. code-block::. >>> res_par = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, options={""map"": ""parallel""}, seeds=1); >>> res_ser = mcsolve(H, psi0, tlist, c_ops, e_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:14841,avail,available,14841,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['avail'],['available']
Availability,"ion number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" sub",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14068,down,download,14068,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['download']
Availability,"is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:94946,error,error,94946,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['error'],['error']
Availability,"it package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#1580 <https://github.com/qutip/qutip/pull/1580>`_ by Jake Lishman); - The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (`#1509 <https://github.com/qutip/qutip/pull/1509>`_ by Purva Thakre). Bug Fixes; ---------; - Fix circuit index used when plotting circuits with non-reversed states. (`#1847 <https://github.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Giguère); - Ensured that tidyup's default tolerance is read from settings at each call. (`#1830 <https://github.com/qutip/qutip/pull/1830>`_ by Eric Giguère); - Fixed ``scipy.sparse`` deprecation warnings raised by ``qutip.fast_csr_matrix``. (`#1827 <https://github.com/qutip/qutip/pull/1827>`_ by Simon Cross); - Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (`#1818 <https://github.com/qutip/qutip/pull/1818>`_ by Simon Cross); - Fixed the displaying of ``Lattice1d`` instances and their unit cells. Previously calling them raised exceptions in simple cases. (`#1819 <https://github.com/qutip/qutip/pull/1819>`_, `#1697 <https://github.com/qutip/qutip/pull/1697>`_ and `#1702 <https://github.com/qutip/qutip/pull/1702>`_ by Simon Cross and Saumya Biswas); - Fixed the displaying of the title for ``hinton`` and ``matrix_histogram`` plots when a title is given. Previously the supplied title was not displayed. (`#1707 <https://github.com/qutip/qutip/pull/1707>`_ by Vladimir Vargas-Cal",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:62188,toler,tolerance,62188,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18712,down,download,18712,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['download']
Availability,"lity.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42004,avail,available,42004,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"lled using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical advice, please see the [""contributing to QuTiP development"" section of the documentation](https://qutip.readthedocs.io/en/stable/development/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:5360,avail,available,5360,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"lve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simon Cross.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:1652,avail,available,1652,doc/guide/heom/history.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst,1,['avail'],['available']
Availability,"ly for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; =============",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2007,error,error,2007,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['error'],['error']
Availability,"me-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the fun",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2039,error,error,2039,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['error'],['error']
Availability,"ment operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2704,down,down,2704,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16511,avail,available,16511,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['avail'],['available']
Availability,"n of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:7259,error,error,7259,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['error'],['error']
Availability,"nally makes use of a; combination of symmetric and anti-symmetric matrix permutations that attempt to; improve the preconditioning process. These features are discussed in the; :ref:`steady-args` section. Even with these state-of-the-art permutations,; the generation of a successful preconditoner for non-symmetric matrices is; currently a trial-and-error process due to the lack of mathematical work done; in this area. It is always recommended to begin with the direct solver with no; additional arguments before selecting a different method. Finding the steady-state solution is not limited to the Lindblad form of the; master equation. Any time-independent Liouvillian constructed from a; Hamiltonian and collapse operators can be used as an input::. >>> rho_ss = steadystate(L). where ``L`` is the Louvillian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:7236,avail,available,7236,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['avail'],['available']
Availability,"need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18632,down,downloaded,18632,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['downloaded']
Availability,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11836,failure,failures,11836,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,"['error', 'failure']","['errors', 'failures']"
Availability,"nt``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qubit states using ``ket`` function. - The module ``qutip.cyQ`` has been renamed to ``qutip.cy`` and the sparse; matrix-vector functions ``spmv`` and ``spmv1d`` has been combined into one; function ``spmv``. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., ``spmv_csr``). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:109593,avail,available,109593,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"objEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. M",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9560,mask,masking,9560,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['mask'],['masking']
Availability,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` par",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:43281,toler,tolerance,43281,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:16584,toler,tolerance,16584,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"on installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:10436,avail,available,10436,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"ontains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating cor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110602,avail,available,110602,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:118246,toler,tolerance,118246,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15650,avail,available,15650,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"or case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:55489,error,error,55489,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"ors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50018,avail,available,50018,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"ossibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28811,redundant,redundant,28811,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['redundant'],['redundant']
Availability,"p``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80880,error,error,80880,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"patibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical advice, please see the [""contributing to QuTiP development"" section of the documentation](https://qutip.readthedocs.io/en/stable/development/contributing.html). Citing QuTiP; ------------. If you use QuTiP in your researc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:5453,avail,available,5453,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"plying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15307,avail,available,15307,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"ported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; ----------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:7419,avail,available,7419,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['avail'],['available']
Availability,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:5901,avail,available,5901,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['avail'],['available']
Availability,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1853,error,error,1853,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['error'],['error']
Availability,"r supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the late",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3953,avail,available,3953,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,2,"['avail', 'down']","['available', 'download']"
Availability,"r this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous rel",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17135,down,download,17135,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['download']
Availability,"rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` functio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2150,error,error,2150,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['error'],['error']
Availability,"ransforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2626,down,down,2626,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"rator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``.; - Dimensions use a class instead of layered lists.; - Allow measurement functions to support degenerate operators.; - Add ``qeye_like`` and ``qzero_like``.; - Added fermionic annihilation and creation operators. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided pri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:24599,toler,tolerance,24599,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"rement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49823,avail,available,49823,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"rgs={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104789,avail,available,104789,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4762,avail,available,4762,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['avail'],['available']
Availability,"rpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6213,reliab,reliably,6213,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['reliab'],['reliably']
Availability,"ructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41786,avail,available,41786,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"s been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12459,down,down,12459,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['down']
Availability,"s, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-redfield-derivation:. Brief Derivation and Definitions; ================================. The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): :math:`H = H_{\rm S} + H_{\rm B} + H_{\rm I}`, where :math:`H` is the total system+bath Hamiltonian, :math:`H_{\rm S}` and ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1813,down,downside,1813,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['down'],['downside']
Availability,"search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, an",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11311,avail,available,11311,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['avail'],['available']
Availability,"sfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1442,error,error,1442,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['error'],['error']
Availability,"st.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. Note that this merging operation only checks that the result are compatible --; i.e. that th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9780,toler,tolerance,9780,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['toler'],['tolerance']
Availability,"t> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]. We therefore first calculate :math:`\rho(t)=V(t, 0)\left\{\rho(0)\right\}` using one of the QuTiP evolution solvers with :math:`\rho(0)` as initial state, and then again use the same solver to calculate :math:`V(t+\tau, t)\left\{B\rho(t)\right\}` using :math:`B\rho(t)` as initial state. Note that if the initial state is the steady state, then :math:`\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}` and. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,. which is independent of :math:`t`, so that we only have one time coordinate :math:`\tau`. QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument ``solver``. .. cssclass:: table-striped. +----------------------------------+--------------------------------------------------+; | QuTiP function | Correlation function |; +==================================+==================================================+; | | :math:`\left<A(t+\tau)B(t)\right>` or |; | :func:`qutip.correlation_2op_2t` | :math:`\left<A(t)B(t+\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | | :math:`\left<A(\tau)B(0)\right>` or |; | :func:`qutip.correlation_2op_1t` | :math:`\left<A(0)B(\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_1t` | :math:`\left<A(0)B(\tau)C(0)\right>`. |; +----------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:1759,avail,available,1759,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['avail'],['available']
Availability,"te tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12852,avail,available,12852,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['avail'],['available']
Availability,"tegrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42347,avail,available,42347,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"ter the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:67596,fault,faults,67596,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['fault'],['faults']
Availability,"ther changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85427,error,error,85427,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"ther up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2174,down,down,2174,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"thon dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41946,avail,available,41946,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"tion no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The sp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:44309,toler,tolerance,44309,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"tip.utilities``. For the former it is far better to use ``numpy.linspace`` and for the later Python's in-built ``help`` function or other tools. (`#1680 <https://github.com/qutip/qutip/pull/1680>`_ by Eric Giguère); - Added support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``. (`#1655 <https://github.com/qutip/qutip/pull/1655>`_ by Marek Narożniak); - Added the function ``steadystate_floquet``, which returns the ""effective"" steadystate of a periodic driven system. (`#1660 <https://github.com/qutip/qutip/pull/1660>`_ by Alberto Mercurio); - Improved mcsolve memory efficiency by not storing final states when they are not needed. (`#1669 <https://github.com/qutip/qutip/pull/1669>`_ by Eric Giguère); - Improved the default colors and styling of matrix_histogram and provided additional styling options. (`#1573 <https://github.com/qutip/qutip/pull/1573>`_ and `#1628 <https://github.com/qutip/qutip/pull/1628>`_ by Mahdi Aslani); - Sped up ``state_number_enumerate``, ``state_number_index``, ``state_index_number``, and added some error checking. ``enr_state_dictionaries`` now returns a list for ``idx2state``. (`#1604 <https://github.com/qutip/qutip/pull/1604>`_ by Johannes Feist); - Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new ``qutip.QFunc`` class, instead of the ``qutip.qfunc`` function. (`#934 <https://github.com/qutip/qutip/pull/934>`_ and `#1583 <https://github.com/qutip/qutip/pull/1583>`_ by Daniel Weigand and Jake Lishman); - Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (`#1579 <https://github.com/qutip/qutip/pull/1579>`_ by Jake Lishman); - Removed the vendored copy of LaTeX's qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#15",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:60369,error,error,60369,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['error'],['error']
Availability,"tip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical advice, please see the [""contributing to QuTiP development"" section of the documentation](https://qutip.readthedocs.io/en/stable/development/contributing.html). Citing QuTiP; ------------. If you use QuTiP in your research, please cite the original QuTiP papers that are available [here](https://dml.riken.jp/?s=QuTiP).; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:6494,avail,available,6494,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"tps://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1378,down,downloads,1378,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['down'],['downloads']
Availability,"tter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15715,down,down,15715,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['down'],['down']
Availability,"u want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; ---------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7004,avail,available,7004,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['avail'],['available']
Availability,"ubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()``. (by **pschindler**); - Fix invalid string literals in docstrings and some unclosed files. (by **Élie Gouzien**); - Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by **Jake Lishman**); - Fix the trace norm being incorrectly reported as 0 for small matrices. (by **Jake Lishman**); - Fix issues with ``dnorm`` when using CVXPy 1.1 with sparse matrices. (by **Felipe Bivort Haiek**); - Fix segfaults in ``mesolve`` when passed a bad initial ``Qobj`` as the state. (by **Jake Lishman**); - Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by **Drew Parsons**); - Fix ``zspmv_openmp.cpp`` missing from the pip sdist. (by **Christoph Gohlke**); - Fix correlation functions throwing away imaginary components. (by **Asier Galicia Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:82076,toler,tolerance,82076,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['toler'],['tolerance']
Availability,"up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for ea",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3814,down,down,3814,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"urement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1)",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4891,down,down,4891,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,2,['down'],['down']
Availability,"w properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92177,avail,available,92177,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avail'],['available']
Availability,"wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Giguère); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71524,fault,fault,71524,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['fault'],['fault']
Availability,"x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2420,down,down,2420,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['down'],['down']
Availability,"y installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11590,down,down,11590,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['down'],['down']
Availability,"y.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3449,avail,available,3449,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['avail'],['available']
Availability,"ytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minim",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4235,avail,available,4235,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['avail'],['available']
Deployability," - Daniel Weiss (Improved sampling algorithm for mcsolve, `#2218 <https://github.com/qutip/qutip/pull/2218>`); - SJUW (Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05, `#2181 <https://github.com/qutip/qutip/pull/2181>`); - Valan Baptist Mathuranayagam (Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template, `#2107 <https://github.com/qutip/qutip/pull/2107>`); - Gerardo Jose Suarez (Added information on sec_cutoff to the documentation, `#2136 <https://github.com/qutip/qutip/pull/2136>`); - Cristian Emiliano Godinez Ramirez (Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver, `#2167 <https://github.com/qutip/qutip/pull/2167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operation",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:9441,install,installed,9441,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability," - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This supp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25281,install,installed,25281,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability," = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); data2 = solver.run(psi1, times, e_ops=e_ops). plt.figure(); plt.plot(times, data1.expect[0], ""b"", times, data1.expect[1], ""r"", lw=2); plt.plot(times, data2.expect[0], 'b--', times, data2.expect[1], 'r--', lw=2); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). Note that as shown, options can be set at initialization or with the; ``options`` property. The simulation parameters, the ``args`` of the :class:`.QobjEvo` passed as system; operators, can be updated at the start of a run:. .. plot::; :context: close-figs. data1 = solver.run(psi0, times, e_ops=e_ops); data2 = solver.run(psi0, times, e_ops=e_ops, args={""A"": 0.25*np.pi}); data3 = solver.run(psi0, times, e_ops=e_ops, args={""A"": 0.125*np.pi}). plt.figure(); plt.plot(times, data1.expect[0], label=""A=pi/2""); plt.plot(times, data2.expect[0], label=""A=pi/4""); plt.plot(times, data3.expect[0], label=""A=pi/8""); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend(); plt.show(). Stepping through the run; ------------------------. The solver class also allows to run through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equati",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:2650,update,updated,2650,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['update'],['updated']
Deployability," Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and mer",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8267,release,release,8267,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability," Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ----------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8883,integrat,integrated,8883,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability," The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14549,integrat,integrated,14549,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Deployability," [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discuss",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4992,release,release,4992,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['release'],['release']
Deployability," _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milest",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:13034,toggle,toggle,13034,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['toggle'],['toggle']
Deployability," at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you lik",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4135,release,release,4135,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability," badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66559,release,release,66559,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability," bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then inst",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4444,install,install,4444,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability," been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the adm",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2717,release,released,2717,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['released']
Deployability," before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3362,install,install,3362,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,3,['install'],"['install', 'installation']"
Deployability," dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15177,integrat,integrator,15177,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability," handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114012,release,release,114012,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14070,install,installed,14070,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installed']
Deployability," new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3933,update,updated,3933,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability," nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4036,integrat,integrated,4036,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['integrat'],['integrated']
Deployability," of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) file",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1422,install,install,1422,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,3,"['install', 'release']","['install', 'release']"
Deployability," or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solv",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26593,release,release,26593,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability," push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7062,release,release,7062,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability," qutip.coefficient(f, args=args)`` is equivalent to; ``qutip.QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy ls",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14268,integrat,integrator,14268,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability," runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80073,configurat,configuration,80073,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['configurat'],['configuration']
Deployability," should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =====================",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8764,install,install,8764,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability," solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15927,integrat,integrator,15927,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability," tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20168,integrat,integration,20168,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['integrat'],['integration']
Deployability," the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpret",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4446,install,installed,4446,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,['install'],"['install', 'installed']"
Deployability," the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. I",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17264,release,release,17264,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['release', 'update']","['release', 'updated']"
Deployability," the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` v",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42624,integrat,integrator,42624,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability," the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11021,release,release,11021,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability," the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12817,deploy,deployment,12817,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deployment']
Deployability," understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/lates",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:8223,release,release,8223,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['release'],['release']
Deployability," value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18696,integrat,integrator,18696,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability," want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7929,release,release,7929,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"# Contributor Covenant Code of Conduct. As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:306,patch,patches,306,CODE_OF_CONDUCT.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md,1,['patch'],['patches']
Deployability,"(#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton vis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53654,release,release,53654,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"(files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits tryi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6580,release,release,6580,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,['release'],['release']
Deployability,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:141,release,release,141,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,2,"['integrat', 'release']","['integration', 'release']"
Deployability,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:888,toggle,toggle,888,doc/development/ideas/qutip-interactive.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst,1,['toggle'],['toggle']
Deployability,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md:611,update,update,611,.github/pull_request_template.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md,1,['update'],['update']
Deployability,", but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools w",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7371,install,installs,7371,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['install', 'installs']"
Deployability,"- Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65661,configurat,configuration,65661,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['configurat'],['configuration']
Deployability,"- Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15075,integrat,integrator,15075,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"----------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual envir",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4494,install,install,4494,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"-----------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix sever",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105299,integrat,integration,105299,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integration']
Deployability,". (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84988,install,installations,84988,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installations']
Deployability,". New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime depe",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6128,release,releases,6128,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['release'],['releases']
Deployability,". The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, wi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8325,release,release,8325,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,"['install', 'release']","['installed', 'release']"
Deployability,". conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes ru",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12966,release,release,12966,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['install', 'release']","['install', 'release']"
Deployability,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12187,integrat,integration,12187,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,4,"['install', 'integrat', 'upgrade']","['installed', 'integration', 'upgraded']"
Deployability,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:320,install,install,320,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,7,['install'],"['install', 'install-from-', 'install-on-', 'install-with-', 'installation']"
Deployability,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:255,update,updates,255,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,7,"['deploy', 'release', 'update']","['deploy', 'deploying', 'release', 'releases', 'updates']"
Deployability,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:222,install,installation,222,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['install'],['installation']
Deployability,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65,release,release,65,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,3,['release'],['release']
Deployability,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:253,patch,patches,253,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,1,['patch'],['patches']
Deployability,".. _development:. *************************; Development Documentation; *************************. This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. .. toctree::; :maxdepth: 3. contributing.rst; roadmap.rst; ideas.rst; docs.rst; release_distribution.rst; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/development.rst:199,release,releases,199,doc/development/development.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/development.rst,1,['release'],['releases']
Deployability,".. _development_roadmap:. *************************; QuTiP Development Roadmap; *************************. Preamble; ========. This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome. In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version. There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. .. _what-is-qutip:. What is QuTiP?; --------------. The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation). QuTiP is also an organisation, in the Github sense, and in the sense of a group; of people working collaboratively towards common objectives, and also a web; presence `qutip.org <https://qutip.org/>`_. The QuTiP Community includes all the; people who have supported the project since in conception in 2010, including; manager, funders, developers, maintainers and users. These related, and overlapping, uses of the QuTiP name are of little consequence; until one starts to consider how to organise all the software packages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:388,release,release,388,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['release'],['release']
Deployability,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:243,integrat,integration,243,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['integrat'],['integration']
Deployability,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:798,release,release,798,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,2,['release'],['release']
Deployability,".. _monte:. *******************************************; Monte Carlo Solver; *******************************************. .. _monte-intro:. Introduction; =============. Where as the density matrix formalism describes the ensemble average over many; identical realizations of a quantum system, the Monte Carlo (MC), or; quantum-jump approach to wave function evolution, allows for simulating an; individual realization of the system dynamics. Here, the environment is; continuously monitored, resulting in a series of quantum jumps in the system; wave function, conditioned on the increase in information gained about the; state of the system via the environmental measurements. In general, this; evolution is governed by the Schrödinger equation with a **non-Hermitian**; effective Hamiltonian. .. math::; :label: heff. H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},. where again, the :math:`C_{n}` are collapse operators, each corresponding to a; separate irreversible process with rate :math:`\gamma_{n}`. Here, the strictly; negative non-Hermitian portion of Eq. :eq:`heff` gives rise to a reduction in; the norm of the wave function, that to first-order in a small time; :math:`\delta t`, is given by; :math:`\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p` where. .. math::; :label: jump. \delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,. and :math:`\delta t` is such that :math:`\delta p \ll 1`. With a probability; of remaining in the state :math:`\left|\psi(t+\delta t)\right>` given by; :math:`1-\delta p`, the corresponding quantum jump probability is thus Eq.; :eq:`jump`. If the environmental measurements register a quantum jump, say via; the emission of a photon into the environment, or a change in the spin of a; quantum dot, the wave function undergoes a jump into a state defined by; projecting :math:`\left|\psi(t)\right>` using the collapse operator; :math:`C_{n}` corresponding to the measurement. .. math::; :label: project. \lef",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:468,continuous,continuously,468,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['continuous'],['continuously']
Deployability,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:641,integrat,integration,641,doc/guide/dynamics/dynamics-options.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst,5,['integrat'],"['integration', 'integrator']"
Deployability,".. _stochastic:. *******************************************; Stochastic Solver; *******************************************. .. _stochastic-intro:. When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations.; The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record. In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. .. math::; :label: general_form. d \rho (t) = d_1 \rho \, dt + \sum_n d_{2,n} \rho \, dW_n,. where :math:`dW_n` is a Wiener increment, which has the expectation values :math:`E[dW] = 0` and :math:`E[dW^2] = dt`. Stochastic Schrodinger Equation; ===============================. .. _sse-solver:. The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]_). .. math::; :label: jump_ssesolve. d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,. where :math:`H` is the Hamiltonian, :math:`S_n` are the stochastic collapse operators, and :math:`e_n` is. .. math::; :label: jump_matrix_element. e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic opera",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:187,continuous,continuous,187,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['continuous'],['continuous']
Deployability,.. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :member,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3230,integrat,integrator,3230,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:450,install,installation,450,doc/index.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst,1,['install'],['installation']
Deployability,".; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, excep",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6145,release,release,6145,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,".org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1193,install,install,1193,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['install'],['install']
Deployability,"//github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78523,install,install,78523,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['install']
Deployability,"/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4359,install,installed,4359,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['installed']
Deployability,"/qutip/pull/1628>`_ by Mahdi Aslani); - Sped up ``state_number_enumerate``, ``state_number_index``, ``state_index_number``, and added some error checking. ``enr_state_dictionaries`` now returns a list for ``idx2state``. (`#1604 <https://github.com/qutip/qutip/pull/1604>`_ by Johannes Feist); - Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new ``qutip.QFunc`` class, instead of the ``qutip.qfunc`` function. (`#934 <https://github.com/qutip/qutip/pull/934>`_ and `#1583 <https://github.com/qutip/qutip/pull/1583>`_ by Daniel Weigand and Jake Lishman); - Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (`#1579 <https://github.com/qutip/qutip/pull/1579>`_ by Jake Lishman); - Removed the vendored copy of LaTeX's qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#1580 <https://github.com/qutip/qutip/pull/1580>`_ by Jake Lishman); - The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (`#1509 <https://github.com/qutip/qutip/pull/1509>`_ by Purva Thakre). Bug Fixes; ---------; - Fix circuit index used when plotting circuits with non-reversed states. (`#1847 <https://github.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Giguère); - Ensured that tidyup's default tolerance is read from settings at each ca",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:61238,install,installed,61238,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3855,release,release,3855,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['release'],['release']
Deployability,:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qut,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3414,integrat,integrator,3414,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,"============. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5309,install,installed,5309,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['install', 'installed']"
Deployability,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7052,install,install,7052,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,3,['install'],"['install', 'installation']"
Deployability,">`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile ma",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4534,install,install,4534,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['install']
Deployability,">`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/quti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:76414,release,release,76414,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,">`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13199,upgrade,upgrades,13199,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['release', 'upgrade']","['releases', 'upgrades']"
Deployability,"EP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84320,patch,patch,84320,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['patch', 'release']","['patch', 'release']"
Deployability,"Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3687,install,install,3687,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['install']
Deployability,"I deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15672,release,release,15672,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"NCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES. 7. Termination. a. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License. b. Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. 8. Miscellaneous. a. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License. b. Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License. c. If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:14302,release,release,14302,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['release'],['release']
Deployability,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:388,install,install,388,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['install'],['install']
Deployability,"SR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Inte",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:1969,update,update,1969,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['update']
Deployability,"The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1948,update,updated,1948,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['update'],['updated']
Deployability,"This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9545,install,install,9545,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['install', 'installing']"
Deployability,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11120,integrat,integration,11120,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['integrat'],['integration']
Deployability,"_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2008,release,release,2008,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"`MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:44477,integrat,integrator,44477,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78151,release,release,78151,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['install', 'release']","['installed', 'release']"
Deployability,"`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4989,install,installation,4989,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,3,['install'],"['install-on-windows', 'installation']"
Deployability,"`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8146,update,update,8146,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['update'],['update']
Deployability,"``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:11492,update,updated,11492,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['update'],['updated']
Deployability,"``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66411,update,updated,66411,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7522,release,released,7522,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['patch', 'release']","['patch', 'released']"
Deployability,"ad initial ``Qobj`` as the state. (by **Jake Lishman**); - Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by **Drew Parsons**); - Fix ``zspmv_openmp.cpp`` missing from the pip sdist. (by **Christoph Gohlke**); - Fix correlation functions throwing away imaginary components. (by **Asier Galicia Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83405,release,release,83405,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"ad them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minim",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1627,release,releases,1627,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['releases']
Deployability,"ail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:10570,install,installing,10570,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installing']
Deployability,"ained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5729,integrat,integrated,5729,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability,"ake to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6365,update,updated,6365,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['update'],['updated']
Deployability,"amiliar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/quti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35051,update,update,35051,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['update']
Deployability,"an to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4076,integrat,integrated,4076,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability,"at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3826,install,installation,3826,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['installation']
Deployability,"ata; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3201,integrat,integration,3201,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['integrat'],['integration']
Deployability,"ated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5085,integrat,integrated,5085,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability,"ation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Pyt",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74995,install,installed,74995,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"bits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93590,configurat,configuration,93590,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['configurat'],['configuration']
Deployability,"both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note dow",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15146,deploy,deployed,15146,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deployed']
Deployability,"both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: `bloch_decay.mp4 <https://raw.githubusercontent.com/qutip/qutip/master/doc/figures/bloch_decay.mp4>`_; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:13145,install,installing,13145,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,2,['install'],"['install', 'installing']"
Deployability,"bspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57052,release,releases,57052,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['releases']
Deployability,"but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro rele",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16300,release,release,16300,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"c arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42579,integrat,integrator,42579,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6409,release,release,6409,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['release'],['release']
Deployability,"conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Py",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4277,install,installed,4277,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installed']
Deployability,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:3731,integrat,integration,3731,doc/guide/dynamics/dynamics-nmmonte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst,2,['integrat'],['integration']
Deployability,"cts the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8406,install,install,8406,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"d not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10462,install,installation,10462,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['install-from-', 'installation']"
Deployability,"d to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Piet",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34954,update,updated,34954,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"de.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5432,release,release,5432,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest me",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8831,install,install,8831,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"e Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Giguère); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71066,release,release,71066,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"e and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Se",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:94350,install,installed,94350,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"e been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5502,integrat,integrated,5502,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability,"e in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sur",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13877,update,update,13877,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['update'],['update']
Deployability,"e members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyprojec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3069,install,installing,3069,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installing']
Deployability,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10542,patch,patch,10542,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['patch'],['patch']
Deployability,"e must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3620,release,release,3620,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"e_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13410,deploy,deployment,13410,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deployment']
Deployability,"ease from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list be",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13545,install,install,13545,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['install'],['install']
Deployability,"ebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.z",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13257,release,release,13257,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"ed call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78351,install,install,78351,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,3,['install'],"['install', 'installs']"
Deployability,"ed.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34879,update,updated,34879,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"eed to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1520,release,release,1520,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"eels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16095,patch,patch,16095,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,3,"['patch', 'release']","['patch', 'release']"
Deployability,"efficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25480,install,installed,25480,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"efs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18568,release,release,18568,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"emovals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mix",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:32492,install,installed,32492,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"ensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12239,install,install,12239,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['install']
Deployability,"er than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failure",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:8539,update,update,8539,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['update'],['update']
Deployability,"erations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when al",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80742,install,installation,80742,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installation']
Deployability,"ere have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4105,update,update,4105,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['update']
Deployability,"es that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15284,deploy,deploy,15284,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['deploy', 'release']","['deploy', 'release']"
Deployability,"es.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6889,upgrade,upgrades,6889,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['patch', 'upgrade']","['patch', 'upgrades']"
Deployability,"esentation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4008,update,updated,4008,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"ethods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https:/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5279,update,updated,5279,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"ey might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15617,release,release,15617,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"f you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12235,deploy,deploy,12235,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deploy']
Deployability,"form the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12659,release,release,12659,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79257,release,release,79257,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a ne",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3051,update,updated,3051,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['update'],['updated']
Deployability,"g time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; `",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:40105,update,updated,40105,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"g time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders.; - The spline type can take ``bc_type`` to control the boundary conditions.; - QobjEvo can be creating from the multiplication of a Qobj with a coefficient:; ``oper * qutip.coefficient(f, args=args)`` is equivalent to; ``qutip.QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; M",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:12842,update,updated,12842,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12443,install,install,12443,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['install', 'update']","['install', 'update']"
Deployability,"h release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2322,release,release,2322,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"h the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to inst",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8564,install,installed,8564,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['installed']
Deployability,"h to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes aroun",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9854,install,install,9854,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7397,release,release,7397,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"he current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15882,integrat,integrator,15882,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3288,configurat,configurations,3288,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['configurat'],['configurations']
Deployability,"he system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10742,install,installation,10742,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['installation']
Deployability,"heck for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for sav",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114336,install,installed,114336,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2843,integrat,integrator,2843,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _clas,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3322,integrat,integrator,3322,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,"hin this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1319,update,update-,1319,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['update'],['update-']
Deployability,"his document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1266,patch,patch,1266,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['patch', 'release']","['patch', 'release']"
Deployability,"his into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a contr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8384,deploy,deploying,8384,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['deploy'],['deploying']
Deployability,"hon and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8689,install,installations,8689,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['install-on-', 'installations']"
Deployability,"https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4394,install,install,4394,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['install']
Deployability,"ically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8031,install,installation,8031,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['installation']
Deployability,"ices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jak",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78051,release,release,78051,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"ild from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10930,install,install,10930,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"ill be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice y",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5995,release,release,5995,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:55956,release,release,55956,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False). # creating figure; fig, ax = plt.subplots(figsize=(FIGURE_SIZE, FIGURE_SIZE)); patch = PathPatch(path, facecolor=FONT_COLOR, linewidth=0); ax.add_artist(patch); ax.set_xlim(-AXIS_SIZE, AXIS_SIZE), ax.set_xticks([]); ax.set_ylim(-AXIS_SIZE, AXIS_SIZE), ax.set_yticks([]). # add qutip logo; ax.imshow(img, alpha=LOGO_TRANSPARENCY,; extent=[-LOGO_SIZE,LOGO_SIZE, -LOGO_SIZE, LOGO_SIZE]). .. _developers-lead:. Lead Developers; ===============. - `Alex Pitchford <https://github.com/ajgpitch>`_; - `Nathan Shammah <https://nathanshammah.com/>`_; - `Shahnawaz Ahmed <http://sahmed.in/>`_; - `Neill Lambert <https://github.com/nwlambert>`_; - `Eric Giguère <https://github.com/Ericgig>`_; - `Boxi Li <https://github.com/BoxiLi>`_; - `Simon Cross <http://hodgestar.za.net/>`_; - `Asier Galicia <https://github.com/AGaliciaMartinez>`_. Past Lead Developers; ====================. - `Robert Johansson <https://jrjohansson.github.io/research.html>`_ (RIKEN); - `Paul Nation <https://www.korea.ac.kr/>`_ (Korea University); - `Chris Granade <https://www.cgranade.com>`_; - `Arne Grimsmo <https://www",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:2176,patch,patch,2176,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,1,['patch'],['patch']
Deployability,"ing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of u",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84920,install,installation,84920,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installation']
Deployability,"ing the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least invol",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3387,release,release,3387,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore Deprecati",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50813,release,release,50813,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,ip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2940,integrat,integrator,2940,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,"isation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other prope",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100345,configurat,configuration,100345,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['configurat'],['configuration']
Deployability,"it log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10755,release,release,10755,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"ition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Giguère). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have no",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:68693,release,released,68693,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['released']
Deployability,"itional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package man",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4519,install,install,4519,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"l not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6761,upgrade,upgrade,6761,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['upgrade'],['upgrade']
Deployability,"ld look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13379,deploy,deployment,13379,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deployment']
Deployability,"le when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10280,install,installing,10280,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['installing']
Deployability,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18911,update,update,18911,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['update'],['update']
Deployability,"lity.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41990,integrat,integrator,41990,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"llaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53579,release,release,53579,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"llowing command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5743,install,install,5743,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"load Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14660,deploy,deployment,14660,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deployment']
Deployability,"m runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8182,install,installed,8182,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['installed']
Deployability,"m to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary w",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12971,deploy,deployment,12971,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['deploy'],['deployment']
Deployability,"me as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:3256,release,release,3256,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['release'],['release']
Deployability,"mentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85137,release,release,85137,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"mes). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e_ops=num(2)).expect[0]; data2 = sesolve(H, psi0, tlist, e_ops=num(2), options={""max_step"": 0.01}).expect[0]. plt.plot(tlist, data1, label=""no max_step""); plt.plot(tlist, data2, label=""fixed max_step""); plt.fill_between(tlist, [pulse(t) for t in tlist], color=""g"", alpha=0.2, label=""pulse""); plt.ylim([-0.1, 1.1]); plt.legend(loc=""center left""). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16648,integrat,integration,16648,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['integrat'],['integration']
Deployability,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16063,release,release,16063,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,5,['release'],"['release', 'released']"
Deployability,"mplexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvemen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66805,release,release,66805,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"mpsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8055,integrat,integration,8055,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integration']
Deployability,"n 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All us",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13296,install,installed,13296,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installed']
Deployability,"n); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66638,release,release,66638,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"nd inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the G",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:98083,release,released,98083,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['released']
Deployability,"nd them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks*",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17772,release,release,17772,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"nda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentatio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4306,release,release,4306,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['release'],['release']
Deployability,"ng on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the sam",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78828,install,installed,78828,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What wi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4159,install,installed,4159,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['install'],['installed']
Deployability,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11796,install,installed,11796,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,4,['install'],['installed']
Deployability,"nterpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. T",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4686,install,install,4686,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"nx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12284,configurat,configuration,12284,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['configurat'],['configuration']
Deployability,"o(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=Tr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:10895,update,update,10895,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['update'],['update']
Deployability,"oduction/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6943,release,release,6943,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['release'],['release']
Deployability,"oints and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, Asier Galicia and Simon Cross); - Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (`#1837 <https://github.c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57301,release,release,57301,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1607,integrat,integrate,1607,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['integrat'],['integrate']
Deployability,"oken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5059,update,updated,5059,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"olve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Mi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54401,update,updates,54401,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updates']
Deployability,"om the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6146,install,install,6146,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['install']
Deployability,"om`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, A",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57080,release,releases,57080,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['releases']
Deployability,"on is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; S",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12175,configurat,configuration,12175,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['configurat'],['configuration']
Deployability,"onal arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41022,integrat,integrator,41022,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"ope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most lik",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:3440,install,installed,3440,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['install'],['installed']
Deployability,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:118562,release,release,118562,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15636,integrat,integrated,15636,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Deployability,"or providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3906,install,installation,3906,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['installation']
Deployability,"organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4052,release,releases,4052,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['release'],['releases']
Deployability,"orkflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4060,release,release,4060,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['release'],['release']
Deployability,"ort, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9412,install,installed,9412,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installed']
Deployability,"ould contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test cover",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:72474,install,installation,72474,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installation']
Deployability,"ource distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14923,deploy,deployment,14923,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['deploy'],['deployment']
Deployability,"ovariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:112614,install,installation,112614,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installation']
Deployability,"ownload.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18055,release,release,18055,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,4,['release'],"['release', 'releases']"
Deployability,"p ``state_number_enumerate``, ``state_number_index``, ``state_index_number``, and added some error checking. ``enr_state_dictionaries`` now returns a list for ``idx2state``. (`#1604 <https://github.com/qutip/qutip/pull/1604>`_ by Johannes Feist); - Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new ``qutip.QFunc`` class, instead of the ``qutip.qfunc`` function. (`#934 <https://github.com/qutip/qutip/pull/934>`_ and `#1583 <https://github.com/qutip/qutip/pull/1583>`_ by Daniel Weigand and Jake Lishman); - Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (`#1579 <https://github.com/qutip/qutip/pull/1579>`_ by Jake Lishman); - Removed the vendored copy of LaTeX's qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#1580 <https://github.com/qutip/qutip/pull/1580>`_ by Jake Lishman); - The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (`#1509 <https://github.com/qutip/qutip/pull/1509>`_ by Purva Thakre). Bug Fixes; ---------; - Fix circuit index used when plotting circuits with non-reversed states. (`#1847 <https://github.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Giguère); - Ensured that tidyup's default tolerance is read from settings at each call. (`#1830 <https://github.com/qutip/qutip/pul",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:61263,install,installed,61263,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"pe could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4328,install,installed,4328,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['install'],['installed']
Deployability,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111195,continuous,continuous,111195,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['continuous', 'integrat']","['continuous', 'integration']"
Deployability,"plying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15293,integrat,integrator,15293,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6593,install,install,6593,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); - Fixed issue where `extract_states` did not preserve hermiticity.; Fixed issue where `rand_herm` did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); - ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by se",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:52776,release,release,52776,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8739,integrat,integrated,8739,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1892,integrat,integration,1892,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['integrat'],['integration']
Deployability,"r GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7251,install,install,7251,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],['install']
Deployability,"r supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the late",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3935,release,releases,3935,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,2,['release'],['releases']
Deployability,"r the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:4141,release,release,4141,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['release'],['release']
Deployability,"r.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a mess",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11237,install,installation,11237,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['installation']
Deployability,"rds-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<versi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2579,patch,patch,2579,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['patch', 'release']","['patch', 'release']"
Deployability,"re everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3217,install,installation,3217,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['install', 'release']","['installation', 'release']"
Deployability,"red%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3537,install,install,3537,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['install']
Deployability,"releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16857,release,release,16857,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"rement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49799,install,installed,49799,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installed']
Deployability,"repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; ---------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1394,release,release,1394,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['release', 'update']","['release', 'update-']"
Deployability,"rimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False). # creating figure; fig, ax = plt.subplots(figsize=(FIGURE_SIZE, FIGURE_SIZE)); patch = PathPatch(path, facecolor=FONT_COLOR, linewidth=0); ax.add_artist(patch); ax.set_xlim(-AXIS_SIZE, AXIS_SIZE), ax.set_xticks([]); ax.set_ylim(-AXIS_SIZE, AXIS_SIZE), ax.set_yticks([]). # add qutip logo; ax.imshow(img, alpha=LOGO_TRANSPARENCY,; extent=[-LOGO_SIZE,LOGO_SIZE, -LOGO_SIZE, LOGO_SIZE]). .. _developers-lead:. Lead Developers; ===============. - `Alex Pitchford <https://github.com/ajgpitch>`_; - `Nathan Shammah <https://nathanshammah.com/>`_; - `Shahnawaz Ahmed <http://sahmed.in/>`_; - `Neill Lambert <https://github.com/nwlambert>`_; - `Eric Giguère <https://github.com/Ericgig>`_; - `Boxi Li <https://github.com/BoxiLi>`_; - `Simon Cross <http://hodgestar.za.net/>`_; - `Asier Galicia <https://github.com/AGaliciaMartinez>`_. Past Lead Developers; ====================. - `Robert Johansson <https://jrjohansson.github.io/research.html>`_ (RIKEN); - `Paul Nation <https://www.korea.ac.kr/>`_ (Korea University); - `Chris Granade <https://www.cgranade.com>`_; - `Arne Grimsmo <https://www.sydney.edu.au/science/about/our-people/academic-staff/arne-grims",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:2250,patch,patch,2250,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,1,['patch'],['patch']
Deployability,"ription, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17055,update,updated,17055,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,3,"['patch', 'release', 'update']","['patch', 'release', 'updated']"
Deployability,"rise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84640,install,installing,84640,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['install'],"['installation', 'installing']"
Deployability,"rs updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and `",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35870,update,updated,35870,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['update'],['updated']
Deployability,"rt of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugf",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2845,release,released,2845,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['released']
Deployability,"rted PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **J",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80810,install,installations,80810,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installations']
Deployability,"ructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41772,integrat,integrator,41772,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"s already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17916,install,installation,17916,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['install', 'update']","['installation', 'updated']"
Deployability,"s are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qob",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:51246,release,release,51246,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['release'],['release']
Deployability,"s been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12509,release,release,12509,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"s, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1609,release,release,1609,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"s, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2973,update,updated,2973,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['update'],"['update', 'updated']"
Deployability,"s.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Páde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and inspection of the ADOs (auxiliary density operators). QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been renamed to ``stack_columns`` and; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:21560,integrat,integrators,21560,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrators']
Deployability,"s; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; wo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6161,integrat,integrated,6161,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Deployability,"se`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a descri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41303,integrat,integrated,41303,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Deployability,"see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted)",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15535,release,releases,15535,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['releases']
Deployability,"ser-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedoc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17166,release,release,17166,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,"['release', 'update']","['release', 'updated']"
Deployability,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6691,continuous,continuous,6691,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['continuous', 'integrat']","['continuous', 'integration']"
Deployability,"sion: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing informa",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11359,install,installing,11359,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['installation', 'installing']"
Deployability,solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.P,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3132,integrat,integrator,3132,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,"stall>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the gi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4327,install,install,4327,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['install']
Deployability,"sts that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8550,release,release,8550,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"t&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a lis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3585,install,install,3585,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['install']
Deployability,"t/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1132,release,released,1132,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['released']
Deployability,"target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79447,release,release,79447,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,3,"['install', 'release']","['install', 'release', 'releases']"
Deployability,"te the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 mont",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1881,release,release,1881,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"tegrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42333,integrat,integrated,42333,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Deployability,"th no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5747,release,release,5747,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,th; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.s,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3035,integrat,integrator,3035,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,"the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSI",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4519,release,release,4519,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9031,install,install,9031,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder su",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5921,install,install,5921,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],['install']
Deployability,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4648,integrat,integration,4648,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['integrat'],['integration']
Deployability,"ther changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85447,install,installation,85447,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installation']
Deployability,"thon dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41874,integrat,integrator,41874,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Deployability,"through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4311,integrat,integration,4311,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['integrat'],['integration']
Deployability,"tic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3505,integrat,integrator,3505,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Deployability,"tion are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The u",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1277,install,install,1277,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['install'],['install']
Deployability,"tion of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------; - Fixed text alignment issues in AboutBox. - Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module. - Added tidyup function to tensor function output. - Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); +++++++++++++++",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115907,install,installation,115907,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['install'],['installation']
Deployability,"ts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, mak",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6738,release,released,6738,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['released']
Deployability,"ttps://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and de",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3624,install,installation,3624,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['install'],['installation']
Deployability,"u can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *te",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2631,update,update,2631,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['update'],['update']
Deployability,"u prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You act",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4849,install,install,4849,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['install'],['install']
Deployability,"u will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag y",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11489,update,updated,11489,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['update'],['updated']
Deployability,"ut the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5544,release,release,5544,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['release'],['release']
Deployability,"utip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5576,release,release,5576,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['release'],['release']
Deployability,"utip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5433,install,installed,5433,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['install'],"['install', 'installed']"
Deployability,"utip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:5181,release,releases,5181,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['release'],['releases']
Deployability,"utip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install q",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12009,install,install,12009,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['install']
Deployability,"y Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Updat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54162,integrat,integration,54162,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integration']
Deployability,"y not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other `",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13685,install,installation,13685,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['install'],['installation']
Deployability,"you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the rele",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11680,release,release,11680,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['release'],['release']
Deployability,"ze_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Giguère); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fses",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71034,configurat,configuration,71034,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['configurat'],['configuration']
Deployability,"zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17580,release,release,17580,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,3,['release'],"['release', 'releases']"
Energy Efficiency," Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Su",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80142,schedul,scheduler,80142,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['schedul'],['scheduler']
Energy Efficiency," To verify that QuTiP can find the; necessary libraries, one can check for ``INTEL MKL Ext: True`` in the QuTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large sys",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4199,power,power,4199,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['power'],['power']
Energy Efficiency," ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other properties and methods were renamed at the same time. A full list is given here. - All modules; - function: ``set_log_level`` -> property: ``log_level``. - dynamics functions. - ``_init_lists`` now ``_init_evo``; - ``get_num_ctrls`` now property: ``num_ctrls``; - ``get_owd_evo_target`` now property: ``onto_evo_target``; - ``combine_dyn_gen`` now ``_combine_dyn_gen`` (no longer returns a value); - ``get_dyn_gen`` now ``_get_phased_dyn_gen``; - ``get_ctrl_den_gen`` now ``_get_phased_ctrl_dyn_gen``; - ``ensure_decomp_curr`` now ``_ensure_decomp_curr``; - ``spectral_decomp`` now ``_spectral_decomp``. - dynamics properties. - ``evo_init2t`` now ``_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100892,efficient,efficient,100892,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['efficient'],['efficient']
Energy Efficiency," as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:9102,efficient,efficient,9102,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['efficient'],['efficient']
Energy Efficiency," as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114918,efficient,efficient,114918,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['efficient'],['efficient']
Energy Efficiency," for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance comp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:2126,power,power,2126,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['power'],['power']
Energy Efficiency," functions decay on a time-scale fast compared to those of the system. - **Secular approximation** Stipulates that elements in the master equation corresponding; to transition frequencies satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}`,; i.e., all fast rotating terms in the interaction picture can be neglected.; It also ignores terms that lead to a small renormalization of the system energy levels.; This approximation is not strictly necessary for all master-equation formalisms; (e.g., the Block-Redfield master equation), but it is required for arriving; at the Lindblad form :eq:`lindblad_master_equation` which is used in :func:`.mesolve`. For systems with environments satisfying the conditions outlined above, the; Lindblad master equation :eq:`lindblad_master_equation` governs the; time-evolution of the system density matrix, giving an ensemble average of the; system dynamics. In order to ensure that these approximations are not violated,; it is important that the decay rates :math:`\gamma_n` be smaller than the; minimum energy splitting in the system Hamiltonian. Situations that demand; special attention therefore include, for example, systems strongly coupled to; their environment, and systems with degenerate or nearly degenerate energy levels. For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function :func:`.mesolve` is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The :func:`.mesolve`; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:10381,energy,energy,10381,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['energy'],['energy']
Energy Efficiency," in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:1723,efficient,efficient,1723,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['efficient'],['efficient']
Energy Efficiency," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17156,power,power,17156,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['power'],['power']
Energy Efficiency," method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning; is that it is only well defined for Hermitian matrices. Since the Liouvillian; is non-Hermitian, the ability to fin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4880,power,power,4880,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['power'],['power']
Energy Efficiency," that is the solution to :eq:`eq_driven_qubit` at an arbitrary; time :math:`t` using the function :meth:`.FloquetBasis.from_floquet_basis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:10895,efficient,efficiently,10895,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['efficient'],['efficiently']
Energy Efficiency," we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:7762,reduce,reduces,7762,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['reduce'],['reduces']
Energy Efficiency,"***********************; TensorFlow Data Backend; ***********************. .. contents:: Contents; :local:; :depth: 3. .. note::; This project was completed as part of GSoC 2021 [3]_. QuTiP's data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. ``Qobj``, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:871,efficient,efficiently,871,doc/development/ideas/tensorflow-data-backend.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst,1,['efficient'],['efficiently']
Energy Efficiency,", times, c_ops, e_ops=e_ops, ntraj=1); data10 = data1 + mcsolve(H, psi0, times, c_ops, e_ops=e_ops, ntraj=9); data100 = data10 + mcsolve(H, psi0, times, c_ops, e_ops=e_ops, ntraj=90). expt1 = data1.expect; expt10 = data10.expect; expt100 = data100.expect. plt.figure(); plt.plot(times, expt1[0], label=""ntraj=1""); plt.plot(times, expt10[0], label=""ntraj=10""); plt.plot(times, expt100[0], label=""ntraj=100""); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend(); plt.show(). Using the Improved Sampling Algorithm; -------------------------------------. Oftentimes, quantum jumps are rare. This is especially true in the context of; simulating gates for quantum information purposes, where typical gate times are; orders of magnitude smaller than typical timescales for decoherence. In this case,; using the standard monte-carlo sampling algorithm, we often repeatedly sample the; no-jump trajectory. We can thus reduce the number of required runs by only; sampling the no-jump trajectory once. We then extract the no-jump probability; :math:`p`, and for all future runs we only sample random numbers :math:`r_1`; where :math:`r_1>p`, thus ensuring that a jump will occur. When it comes time to; compute expectation values, we weight the no-jump trajectory by :math:`p` and; the jump trajectories by :math:`1-p`. This algorithm is described in [Abd19]_; and can be utilized by setting the option ``""improved_sampling""`` in the call; to ``mcsolve``:. .. plot::; :context: close-figs. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], options={""improved_sampling"": True}). where in this case the first run samples the no-jump trajectory, and the; remaining 499 trajectories are all guaranteed to include (at least) one jump. The power of this algorithm is most obvious when considering systems that rarely; undergo jumps. For instance, consider the following T1 simulation of a qubit with; a lifetime of 10 microseconds (assuming time is in units o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:12165,reduce,reduce,12165,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['reduce'],['reduce']
Energy Efficiency,"------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is interested in only a part of a coupled quantum system.; For open quantum systems, this typically involves tracing over the environment leaving only the system of interest.; In QuTiP the class method :meth:`~qutip.core.qobj.Qobj.ptrace` is used to take partial traces. :meth:`~qutip.core.qobj.Qobj.ptrace` acts on the :class:`~qutip.core.qobj.Qobj` instance for which it is called, and it takes one argument ``sel``, which is a ``list`` of integers that mark the component systems that should be **kept**.; All other components are traced out. For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:. .. doctest:: [tensor]; :options: +NORMALIZE_WHITESPACE. >>> psi = tensor(basis(2, 0), basis(2, 1)). >>> psi.ptrace(0); Quantum object: dims = [[2], [2]], shape = (2, 2), type ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:6849,reduce,reduces,6849,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['reduce'],['reduces']
Energy Efficiency,"---. The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. .. math::. Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>. where :math:`\left|\alpha\right>` is a coherent state and; :math:`\alpha = x + iy`. In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function :func:`.qfunc`, as; demonstrated below. .. plot::; :context: close-figs. Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the :obj:`.QFunc` class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling :obj:`.qfunc` in a loop. .. code-block:: python. xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). .. _visual-oper:. Visualizing operators; =====================. Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements. QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, :func:`qutip.visualization.matrix_histogram` and; as Hinton diagra",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:8142,efficient,efficient,8142,doc/guide/guide-visualization.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst,1,['efficient'],['efficient']
Energy Efficiency,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:474,efficient,efficiently,474,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['efficient'],['efficiently']
Energy Efficiency,".. _functions:. ***************; Functions; ***************. Manipulation and Creation of States and Operators; =================================================. Quantum States; --------------. .. automodule:: qutip.core.states; :members: basis, bell_state, bra, coherent, coherent_dm, fock, fock_dm, ghz_state, maximally_mixed_dm, ket, ket2dm, phase_basis, projection, qutrit_basis, singlet_state, spin_state, spin_coherent, state_number_enumerate, state_number_index, state_index_number, state_number_qobj, thermal_dm, triplet_states, w_state, zero_ket. Quantum Operators; -----------------. .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like. Quantum Gates; -----------------. .. automodule:: qutip.core.gates; :members: rx, ry, rz, sqrtnot, snot, phasegate, qrot, cy_gate, cz_gate, s_gate, t_gate, cs_gate, ct_gate, cphase, cnot, csign, berkeley, swapalpha, swap, iswap, sqrtswap, sqrtiswap, fredkin, molmer_sorensen, toffoli, hadamard_transform, qubit_clifford_group, globalphase; . Energy Restricted Operators; ---------------------------. .. automodule:: qutip.core.energy_restricted; :members: enr_state_dictionaries, enr_thermal_dm, enr_fock, enr_destroy, enr_identity. .. _functions-rand:. Quantum Objects; ---------------. .. automodule:: qutip.core.qobj; :members: ptrace, issuper, isoper, isoperket, isoperbra, isket, isbra, isherm. Random Operators and States; ---------------------------. .. automodule:: qutip.random_objects; :members: rand_dm, rand_herm, rand_ket, rand_stochastic, rand_unitary, rand_super, rand_super_bcsz, rand_kraus_map. Superoperators and Liouvillians; -------------------------------. .. automodule:: qutip.core.superoperator; :members: operator_to_vector, vector_to_operator, li",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:643,charge,charge,643,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['charge'],['charge']
Energy Efficiency,".. _monte:. *******************************************; Monte Carlo Solver; *******************************************. .. _monte-intro:. Introduction; =============. Where as the density matrix formalism describes the ensemble average over many; identical realizations of a quantum system, the Monte Carlo (MC), or; quantum-jump approach to wave function evolution, allows for simulating an; individual realization of the system dynamics. Here, the environment is; continuously monitored, resulting in a series of quantum jumps in the system; wave function, conditioned on the increase in information gained about the; state of the system via the environmental measurements. In general, this; evolution is governed by the Schrödinger equation with a **non-Hermitian**; effective Hamiltonian. .. math::; :label: heff. H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},. where again, the :math:`C_{n}` are collapse operators, each corresponding to a; separate irreversible process with rate :math:`\gamma_{n}`. Here, the strictly; negative non-Hermitian portion of Eq. :eq:`heff` gives rise to a reduction in; the norm of the wave function, that to first-order in a small time; :math:`\delta t`, is given by; :math:`\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p` where. .. math::; :label: jump. \delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,. and :math:`\delta t` is such that :math:`\delta p \ll 1`. With a probability; of remaining in the state :math:`\left|\psi(t+\delta t)\right>` given by; :math:`1-\delta p`, the corresponding quantum jump probability is thus Eq.; :eq:`jump`. If the environmental measurements register a quantum jump, say via; the emission of a photon into the environment, or a change in the spin of a; quantum dot, the wave function undergoes a jump into a state defined by; projecting :math:`\left|\psi(t)\right>` using the collapse operator; :math:`C_{n}` corresponding to the measurement. .. math::; :label: project. \lef",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:481,monitor,monitored,481,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['monitor'],['monitored']
Energy Efficiency,".. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :inc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8132,power,power,8132,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['power'],['power']
Energy Efficiency,".0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80167,schedul,scheduler,80167,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['schedul'],['scheduler']
Energy Efficiency,".expect[1]); >>> ax.set_xlabel('Time'); >>> ax.set_ylabel('Expectation values'); >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")); >>> plt.show(). If an empty list of operators is passed to the ``e_ops`` parameter, the; :func:`.sesolve` and :func:`.mesolve` functions return a :class:`.Result`; instance that contains a list of state vectors for the times specified in; ``times``. .. plot::; :context: close-figs. >>> times = [0.0, 1.0]; >>> result = sesolve(H, psi0, times, []); >>> result.states; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. .. _master-nonunitary:. Non-unitary evolution; =======================. While the evolution of the state vector in a closed quantum system is; deterministic, open quantum systems are stochastic in nature. The effect of an; environment on the system of interest is to induce stochastic transitions; between energy levels, and to introduce uncertainty in the phase difference; between states of the system. The state of an open quantum system is therefore; described in terms of ensemble averaged states using the density matrix; formalism. A density matrix :math:`\rho` describes a probability distribution; of quantum states :math:`\left|\psi_n\right>`, in a matrix representation; :math:`\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|`, where; :math:`p_n` is the classical probability that the system is in the quantum state; :math:`\left|\psi_n\right>`. The time evolution of a density matrix :math:`\rho`; is the topic of the remaining portions of this section. .. _master-master:. The Lindblad Master equation; =============================. The standard approach for deriving the equations of motion for a system; interacting with its environment is to expand the scope of the system to; include the environment. The combined quantum system is then closed, and its; evolution is governed b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:5562,energy,energy,5562,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['energy'],['energy']
Energy Efficiency,".gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change and a positive-valued square for a +1 sign. .. plot::; :context: close-figs. hinton(to_super(sigmaz())). As a couple more examples, we also consider the supermatrix for a Hadamard transform and for :math:`\sigma_z \otimes H`. .. plot::; :context: close-figs. hinton(to_super(hadamard_transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires fr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:2367,reduce,reduced-channels,2367,doc/guide/guide-super.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,1,['reduce'],['reduced-channels']
Energy Efficiency,":`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12831,energy,energy,12831,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['energy'],['energy']
Energy Efficiency,"; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not r",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1360,efficient,efficiently,1360,doc/development/ideas/tensorflow-data-backend.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst,1,['efficient'],['efficiently']
Energy Efficiency,"=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:2545,power,powered,2545,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['power'],['powered']
Energy Efficiency,"=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15050,efficient,efficient,15050,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['efficient'],['efficient']
Energy Efficiency,"A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; &+; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\. where the ""sec"" above the summation symbol indicate summation of the secular terms which satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}`.; This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function :math:`g(\tau)` in terms of the noise-power spectrum of the environment :math:`S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)`:. .. math::; :label: br-nonmarkovian-form-four. \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),. where :math:`\lambda_{ab}(\omega)` is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. .. math::; :label: br-final. \frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},. is the Bloch-Redfield tensor. The Bloch-Redfield master equation in the form Eq. :eq:`br-final` is suitable for numerical implementation. The input parameters are the system Hamiltonian :math:`H`, the system operators through which the environment couples to the system :math:`A_\alpha`, and the noise-power spectrum :math:`S_{\alpha\beta}(\omega)`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:7768,energy,energy,7768,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['energy'],['energy']
Energy Efficiency,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:1794,adapt,adapted,1794,CODE_OF_CONDUCT.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md,1,['adapt'],['adapted']
Energy Efficiency,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:716,adapt,adaptation,716,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,3,['adapt'],"['adaptation', 'adaptations', 'adapted']"
Energy Efficiency,"ad to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introdu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:10627,efficient,efficiently,10627,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['efficient'],['efficiently']
Energy Efficiency,"and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53893,adapt,adaptive,53893,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['adapt'],['adaptive']
Energy Efficiency,"ass:`~qutip.solver.heom.LorentzianPadeBath`. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2074,energy,energy,2074,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['energy'],['energy']
Energy Efficiency,"ate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:5526,reduce,reduce,5526,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['reduce'],['reduce']
Energy Efficiency,"atisfy :math:`|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}`,; i.e., all fast rotating terms in the interaction picture can be neglected.; It also ignores terms that lead to a small renormalization of the system energy levels.; This approximation is not strictly necessary for all master-equation formalisms; (e.g., the Block-Redfield master equation), but it is required for arriving; at the Lindblad form :eq:`lindblad_master_equation` which is used in :func:`.mesolve`. For systems with environments satisfying the conditions outlined above, the; Lindblad master equation :eq:`lindblad_master_equation` governs the; time-evolution of the system density matrix, giving an ensemble average of the; system dynamics. In order to ensure that these approximations are not violated,; it is important that the decay rates :math:`\gamma_n` be smaller than the; minimum energy splitting in the system Hamiltonian. Situations that demand; special attention therefore include, for example, systems strongly coupled to; their environment, and systems with degenerate or nearly degenerate energy levels. For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function :func:`.mesolve` is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The :func:`.mesolve`; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation. What is new in the master equation compared to the Schrödinger equatio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:10596,energy,energy,10596,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['energy'],['energy']
Energy Efficiency,"aw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99514,power,power,99514,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['power'],['power']
Energy Efficiency,"be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LG",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:1717,power,power,1717,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,2,['power'],['power']
Energy Efficiency,"bugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105759,power,power,105759,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['power'],['power']
Energy Efficiency,"ce may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Review X *8*, 031027 (2018). .. [4] Boxi Li's blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. .. [5] Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. .. [6] `Mitiq <https://mitiq.readthedocs.io/>`_; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:3081,schedul,schedule,3081,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['schedul'],['schedule']
Energy Efficiency,"continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Giguère). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/quti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:68463,power,power,68463,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['power'],['power']
Energy Efficiency,"d the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13817,monitor,monitor,13817,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['monitor'],['monitor']
Energy Efficiency,"development notebook <...TODO-Merge 61...>`_. Stochastic Master Equation; ==========================. .. Stochastic Master equation. When the initial state of the system is a density matrix :math:`\rho`, the stochastic master equation solver :func:`qutip.stochastic.smesolve` must be used.; The stochastic master equation is given by (see section 4.4, [Wis09]_). .. math::; :label: stochastic_master. d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t). where. .. math::; :label: dissipator. D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],. and. .. math::; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option `",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:3652,monitor,monitored,3652,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['monitor'],['monitored']
Energy Efficiency,"dvantage of the Monte Carlo method over the master equation approach is that; only the state vector is required to be kept in the computers memory, as opposed; to the entire density matrix. For large quantum system this becomes a significant; advantage, and the Monte Carlo solver is therefore generally recommended for such; systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins; with random parameters and initial states takes almost 7 times longer using the; master equation rather than Monte Carlo approach with the default number of; trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times; the memory as well. However, for small systems, the added overhead of averaging; a large number of stochastic trajectories to obtain the open system dynamics, as; well as starting the multiprocessing functionality, outweighs the benefit of the; minor (in this case) memory saving. Master equation methods are therefore; generally more efficient when Hilbert space sizes are on the order of a couple; of hundred states or smaller. Monte Carlo Solver Result; -------------------------. The Monte Carlo solver returns a :class:`.McResult` object consisting of; expectation values and/or states. The main difference with :func:`.mesolve`'s; :class:`.Result` is that it optionally stores the result of each trajectory; together with their averages. When trajectories are stored, ``result.runs_expect``; is a list over the expectation operators, trajectories and times in that order.; The averages are stored in ``result.average_expect`` and the standard derivation; of the expectation values in ``result.std_expect``. When the states are returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also con",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:6232,efficient,efficient,6232,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['efficient'],['efficient']
Energy Efficiency,"e calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54008,reduce,reduced,54008,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['efficient', 'reduce']","['efficient', 'reduced']"
Energy Efficiency,"ecoherence. In this case,; using the standard monte-carlo sampling algorithm, we often repeatedly sample the; no-jump trajectory. We can thus reduce the number of required runs by only; sampling the no-jump trajectory once. We then extract the no-jump probability; :math:`p`, and for all future runs we only sample random numbers :math:`r_1`; where :math:`r_1>p`, thus ensuring that a jump will occur. When it comes time to; compute expectation values, we weight the no-jump trajectory by :math:`p` and; the jump trajectories by :math:`1-p`. This algorithm is described in [Abd19]_; and can be utilized by setting the option ``""improved_sampling""`` in the call; to ``mcsolve``:. .. plot::; :context: close-figs. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], options={""improved_sampling"": True}). where in this case the first run samples the no-jump trajectory, and the; remaining 499 trajectories are all guaranteed to include (at least) one jump. The power of this algorithm is most obvious when considering systems that rarely; undergo jumps. For instance, consider the following T1 simulation of a qubit with; a lifetime of 10 microseconds (assuming time is in units of nanoseconds). .. plot::; :context: close-figs. times = np.linspace(0.0, 300.0, 100); psi0 = fock(2, 1); sm = fock(2, 0) * fock(2, 1).dag(); omega = 2.0 * np.pi * 1.0; H0 = -0.5 * omega * sigmaz(); gamma = 1/10000; data = mcsolve(; [H0], psi0, times, [np.sqrt(gamma) * sm], [sm.dag() * sm], ntraj=100; ); data_imp = mcsolve(; [H0], psi0, times, [np.sqrt(gamma) * sm], [sm.dag() * sm], ntraj=100,; options={""improved_sampling"": True}; ). plt.figure(); plt.plot(times, data.expect[0], label=""original""); plt.plot(times, data_imp.expect[0], label=""improved sampling""); plt.plot(times, np.exp(-gamma * times), label=r""$\exp(-\gamma t)$""); plt.title('Monte Carlo: improved sampling algorithm'); plt.xlabel(""time [ns]""); plt.ylabel(r""$p_{1}$""); plt.legend(); plt.show(). The original sampling algorithm samples the no-jump traject",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:12980,power,power,12980,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['power'],['power']
Energy Efficiency,"er provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42076,efficient,efficient,42076,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['efficient'],['efficient']
Energy Efficiency,"erm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92132,efficient,efficient,92132,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['efficient'],['efficient']
Energy Efficiency,"full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79323,schedul,scheduler,79323,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['schedul'],['scheduler']
Energy Efficiency,"ga) + i\lambda_{\alpha\beta}(\omega),. where :math:`\lambda_{ab}(\omega)` is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. .. math::; :label: br-final. \frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},. is the Bloch-Redfield tensor. The Bloch-Redfield master equation in the form Eq. :eq:`br-final` is suitable for numerical implementation. The input parameters are the system Hamiltonian :math:`H`, the system operators through which the environment couples to the system :math:`A_\alpha`, and the noise-power spectrum :math:`S_{\alpha\beta}(\omega)` associated with each system-environment interaction term. To simplify the numerical implementation we assume that :math:`A_\alpha` are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. .. math::; :label: br-tensor. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:8719,power,power,8719,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['power'],['power']
Energy Efficiency,"gma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]],",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4447,energy,energy,4447,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['energy'],['energy']
Energy Efficiency,"gner`` and ``plot_wigner_fock_distribution`` now supports 3D views; in addition to contour views. - New API and new functions for working with spin operators and states,; including for example ``spin_Jx``, ``spin_Jy``, ``spin_Jz`` and; ``spin_state``, ``spin_coherent``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qubit states using ``ket`` function. - The module ``qutip.cyQ`` has been renamed to ``qutip.cy`` and the sparse; matrix-vector functions ``spmv`` and ``spmv1d`` has been combined into one; function ``spmv``. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., ``spmv_csr``). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized imp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:109344,power,power,109344,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['power'],['power']
Energy Efficiency,"he class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15379,efficient,efficient,15379,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['efficient'],['efficient']
Energy Efficiency,"he eigenstate :math:`\left|m\right>`, we obtain in matrix form in the Schrödinger picture. .. math::. \frac{d}{dt}\rho_{ab}(t); =&; -i\omega_{ab}\rho_{ab}(t) \nonumber\\; &-\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; &+; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\. where the ""sec"" above the summation symbol indicate summation of the secular terms which satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}`.; This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function :math:`g(\tau)` in terms of the noise-power spectrum of the environment :math:`S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)`:. .. math::; :label: br-nonmarkovian-form-four. \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),. where :math:`\lambda_{ab}(\omega)` is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. .. math::; :label: br-final. \frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\om",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:7441,power,power,7441,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['power'],['power']
Energy Efficiency,"his License will continue; in full force and effect unless terminated as stated above. 8. Miscellaneous. a. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License. b. Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License. c. If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and enforceable. d. No term or provision of this License shall be deemed waived and no breach; consented to unless such waiver or consent shall be in writing and signed; by the party to be charged with such waiver or consent. e. This License constitutes the entire agreement between the parties with; respect to the Work licensed here. There are no understandings,; agreements or representations with respect to the Work not specified; here. Licensor shall not be bound by any additional provisions that may; appear in any communication from You. This License may not be modified; without the mutual written agreement of the Licensor and You. f. The rights granted under, and the subject matter referenced, in this; License were drafted utilizing the terminology of the Berne Convention; for the Protection of Literary and Artistic Works (as amended on; September 28, 1979), the Rome Convention of 1961, the WIPO Copyright; Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and; the Universal Copyright Convention (as revised on July 24, 1971). These; rights and subject matter take effect in the relevan",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:15653,charge,charged,15653,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['charge'],['charged']
Energy Efficiency,"in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16090,efficient,efficient,16090,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['efficient'],['efficient']
Energy Efficiency,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1874,efficient,efficient,1874,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['efficient'],['efficient']
Energy Efficiency,"master equation, so if possible the; solver will fall back on using the Schrödinger equation. What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes. In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (``c_ops``) is passed as the fourth argument to the; :func:`.mesolve` function in order to define the dissipation processes in the master; equation. When the ``c_ops`` isn't empty, the :func:`.mesolve` function will use; the master equation instead of the unitary Schrödinger equation. Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding ``np.sqrt(0.05) * sigmax()`` in the fourth; parameter to the :func:`.mesolve` function. .. plot::; :context: close-figs. >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], e_ops=[sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]); >>> ax.plot(times, result.expect[1]); >>> ax.set_xlabel('Time'); >>> ax.set_ylabel('Expectation values'); >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")); >>> plt.show(). Here, 0.05 is the rate and the operator :math:`\sigma_x` (:func:`.sigmax`); describes the dissipation process. Now a slightly more complex example: Consider a two-level atom coupled to a; leaky single-mode cavity through a dipole-type interaction, which supports a; coherent exchange of quanta between the two systems. If the atom initially is; in its groundstate and the cavity in a 5-photon Fock state, the dynamics is;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:12394,energy,energy,12394,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['energy'],['energy']
Energy Efficiency,"ment. The combined quantum system is then closed, and its; evolution is governed by the von Neumann equation. .. math::; :label: neumann_total. \dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],. the equivalent of the Schrödinger equation :eq:`schrodinger` in the density; matrix formalism. Here, the total Hamiltonian. .. math::. 	H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},. includes the original system Hamiltonian :math:`H_{\rm sys}`, the Hamiltonian; for the environment :math:`H_{\rm env}`, and a term representing the interaction; between the system and its environment :math:`H_{\rm int}`. Since we are only; interested in the dynamics of the system, we can at this point perform a partial; trace over the environmental degrees of freedom in Eq. :eq:`neumann_total`, and; thereby obtain a master equation for the motion of the original system density; matrix. The most general trace-preserving and completely positive form of this; evolution is the Lindblad master equation for the reduced density matrix; :math:`\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]`. .. math::; 	:label: lindblad_master_equation. 	\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]. where the :math:`C_n = \sqrt{\gamma_n} A_n` are collapse operators, and; :math:`A_n` are the operators through which the environment couples to the; system in :math:`H_{\rm int}`, and :math:`\gamma_n` are the corresponding rates.; The derivation of Eq. :eq:`lindblad_master_equation` may be found in several; sources, and will not be reproduced here. Instead, we emphasize the; approximations that are required to arrive at the master equation in the form; of Eq. :eq:`lindblad_master_equation` from physical arguments, and hence; perform a calculation in QuTiP:. - **Separability:** At :math:`t=0` there are no correlations between the system; and its environment such that the total density matrix ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:7503,reduce,reduced,7503,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['reduce'],['reduced']
Energy Efficiency,"mprovements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Cos",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80251,schedul,scheduling,80251,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['schedul'],['scheduling']
Energy Efficiency,"nutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done throug",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14452,monitor,monitor,14452,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['monitor'],['monitor']
Energy Efficiency,"om/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35979,reduce,reduced,35979,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['reduce'],['reduced']
Energy Efficiency,"ons for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4382,monitor,monitored,4382,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['monitor'],['monitored']
Energy Efficiency,"ore easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ========",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1450,efficient,efficiently,1450,doc/development/ideas/tensorflow-data-backend.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst,1,['efficient'],['efficiently']
Energy Efficiency,"ors can be used as an input::. >>> rho_ss = steadystate(L). where ``L`` is the Louvillian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perf",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:7986,power,power,7986,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['power'],['power']
Energy Efficiency,"ov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbe",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:1395,reduce,reduced,1395,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['reduce'],['reduced']
Energy Efficiency,"rix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14480,efficient,efficient,14480,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['efficient'],['efficient']
Energy Efficiency,"s a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.g",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1219,schedul,schedule,1219,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['schedul'],['schedule']
Energy Efficiency,"s corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Out",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4289,energy,energy,4289,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['energy'],['energy']
Energy Efficiency,"s plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense mor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1045,energy,energy,1045,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,2,"['energy', 'power']","['energy', 'power']"
Energy Efficiency,"sis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is interacting with its environment is not necessarily well; described by the standard Lindblad master equation, since its dissipation proc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:11058,efficient,efficiently,11058,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['efficient'],['efficiently']
Energy Efficiency,"sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` funct",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:5195,power,power,5195,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['power'],['power']
Energy Efficiency,"stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limit",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:7472,efficient,efficient,7472,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['efficient'],['efficient']
Energy Efficiency,"system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:3616,efficient,efficiently,3616,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['efficient'],['efficiently']
Energy Efficiency,"t of the interaction with the system;; (2) The system and the environment remain separable throughout the evolution.; These assumptions are justified if the interaction is weak, and if the; environment is much larger than the system. In summary,; :math:`\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}`. - **Markov approximation** The time-scale of decay for the environment; :math:`\tau_{\rm env}` is much shorter than the smallest time-scale of the; system dynamics :math:`\tau_{\rm sys} \gg \tau_{\rm env}`. This approximation; is often deemed a ""short-memory environment"" as it requires that environmental; correlation functions decay on a time-scale fast compared to those of the system. - **Secular approximation** Stipulates that elements in the master equation corresponding; to transition frequencies satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}`,; i.e., all fast rotating terms in the interaction picture can be neglected.; It also ignores terms that lead to a small renormalization of the system energy levels.; This approximation is not strictly necessary for all master-equation formalisms; (e.g., the Block-Redfield master equation), but it is required for arriving; at the Lindblad form :eq:`lindblad_master_equation` which is used in :func:`.mesolve`. For systems with environments satisfying the conditions outlined above, the; Lindblad master equation :eq:`lindblad_master_equation` governs the; time-evolution of the system density matrix, giving an ensemble average of the; system dynamics. In order to ensure that these approximations are not violated,; it is important that the decay rates :math:`\gamma_n` be smaller than the; minimum energy splitting in the system Hamiltonian. Situations that demand; special attention therefore include, for example, systems strongly coupled to; their environment, and systems with degenerate or nearly degenerate energy levels. For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:9730,energy,energy,9730,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['energy'],['energy']
Energy Efficiency,"tal data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5388,reduce,reduced,5388,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['reduce'],['reduced']
Energy Efficiency,"te=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4064,power,power,4064,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['power'],['power']
Energy Efficiency,"tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is interested in only a part of a coupled quantum system.; For open quantum systems, this typically involves tracing over the environment leaving only the system of interest.; In QuTiP the class method :meth:`~qutip.core.qobj.Qobj.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:6188,energy,energy,6188,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['energy'],['energy']
Energy Efficiency,"th with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorent",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:1845,energy,energy,1845,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['energy'],['energy']
Energy Efficiency,"two times. Most importantly, this function accepts alternative solvers such as :func:`.brmesolve`. .. _correlation-steady:. Steadystate correlation function; ================================. The following code demonstrates how to calculate the :math:`\left<x(t)x(0)\right>` correlation for a leaky cavity with three different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:4615,power,power,4615,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['power'],['power']
Energy Efficiency,"uTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4242,power,power,4242,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,2,['power'],['power']
Energy Efficiency,"uch faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99873,charge,charge,99873,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['charge'],['charge']
Energy Efficiency,"variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algori",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8545,reduce,reduces,8545,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['reduce'],['reduces']
Energy Efficiency,"ven target cubits (by **Boxi Li**). Bug Fixes; ---------. - Fixed the pickling but that made solver unable to run in parallel on Windows (Thank **lrunze** for reporting). - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91797,efficient,efficiently,91797,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['efficient'],['efficiently']
Energy Efficiency,"villian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8065,power,power,8065,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['power'],['power']
Energy Efficiency,"y reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the di",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8743,efficient,efficient,8743,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['efficient'],['efficient']
Energy Efficiency,"| | | for requested coherent state |; +--------------------------+----------------------------------+----------------------------------------+; | Coherent density matrix | ``coherent_dm(N,alpha)`` | same as coherent(N,alpha) |; | (outer product) | | |; +--------------------------+----------------------------------+----------------------------------------+; | Thermal density matrix | ``thermal_dm(N,n)`` | n = particle number expectation value |; | (for n particles) | | |; +--------------------------+----------------------------------+----------------------------------------+; | Maximally mixed density | ``maximally_mixed_dm(N)`` | N = number of levels in Hilbert space |; | matrix | | |; +--------------------------+----------------------------------+----------------------------------------+. .. cssclass:: table-striped. +--------------------------+----------------------------+----------------------------------------+; | Operators | Command (# means optional) | Inputs |; +==========================+============================+========================================+; | Charge operator | ``charge(N,M=-N)`` | Diagonal operator with entries |; | | | from M..0..N. |; +--------------------------+----------------------------+----------------------------------------+; | Commutator | ``commutator(A, B, kind)`` | Kind = 'normal' or 'anti'. |; +--------------------------+----------------------------+----------------------------------------+; | Diagonals operator | ``qdiags(N)`` | Quantum object created from arrays of |; | | | diagonals at given offsets. |; +--------------------------+----------------------------+----------------------------------------+; | Displacement operator | ``displace(N,alpha)`` | N=number of levels in Hilbert space, |; | (Single-mode) | | alpha = complex displacement amplitude.|; +--------------------------+----------------------------+----------------------------------------+; | Higher spin operators | ``jmat(j,#s)`` | j = integer or half-integer |; | ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:6172,charge,charge,6172,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['charge'],['charge']
Integrability," - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99919,depend,dependent,99919,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability," Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulatio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113930,rout,routines,113930,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['rout'],['routines']
Integrability," Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ----------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8883,integrat,integrated,8883,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1243,synchroniz,synchronization,1243,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['synchroniz'],['synchronization']
Integrability," The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14549,integrat,integrated,14549,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Integrability," \rho_S(t) \otimes \rho_B`.; This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to wri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4598,depend,dependence,4598,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['dependence']
Integrability," `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Giguère**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step function interpolation for array time-coefficient (by **Boxi Li**). - Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by **Boxi Li**). Bug Fixes; ---------. - Fixed the pickling but that made solver unable to run in parallel on Windows (Thank **lrunze** for reporting). - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficient",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91213,depend,dependant,91213,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependant']
Integrability," added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fse",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:17955,interface,interface,17955,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability," by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exceptio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54513,depend,dependent,54513,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability," creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33707,depend,dependent,33707,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability," dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15177,integrat,integrator,15177,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability," different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:4877,depend,dependent,4877,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['depend'],['dependent']
Integrability," function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator doe",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3482,depend,dependence,3482,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['depend'],['dependence']
Integrability," in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:27650,interface,interface,27650,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability," information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quant",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:6413,interface,interfaces,6413,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['interface'],['interfaces']
Integrability," is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the sol",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95119,depend,dependent,95119,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17056,depend,dependent,17056,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,2,['depend'],['dependent']
Integrability," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14034,message,messages,14034,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,"['depend', 'message']","['dependencies', 'messages']"
Integrability," nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4036,integrat,integrated,4036,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['integrat'],['integrated']
Integrability," qutip.coefficient(f, args=args)`` is equivalent to; ``qutip.QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy ls",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14268,integrat,integrator,14268,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability," same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +----------------+------------------+----------------------------------------+; | Representation | ``Q.superrep``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5976,depend,dependent,5976,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability," solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15927,integrat,integrator,15927,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability," tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20168,integrat,integration,20168,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['integrat'],['integration']
Integrability," the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` v",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42624,integrat,integrator,42624,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability," the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate oper",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:77739,depend,depending,77739,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['depending']
Integrability," the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8401,wrap,wrapper,8401,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['wrap'],['wrapper']
Integrability," the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+-------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5818,depend,dependent,5818,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability," the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34510,interface,interface,34510,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability," to Schrödinger's equation are of the form:. .. math::. \ket{\psi(t)} = U(t)\ket{\psi_0}. where :math:`\psi_0` is the state of the system at :math:`t=0` and :math:`U(t)` is a unitary operator on the Hilbert space containing the states. :math:`U(t)` is a solution to the *Schrödinger operator equation*. .. math::. \tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}. We can use optimal control algorithms to determine a set of :math:`u_j` that will drive our system from :math:`\ket{\psi_0}` to :math:`\ket{\psi_1}`, this is state-to-state transfer, or drive the system from some arbitary state to a given state :math:`\ket{\psi_1}`, which is state preparation, or effect some unitary transformation :math:`U_{target}`, called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm; ===================; The **GR**\ adient **A**\ scent **P**\ ulse **E**\ ngineering was first proposed in [NKanej]_. Solutions to Schrödinger's equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve :math:`T` is split into :math:`M` timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. .. math::. H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad. where :math:`k` is a timeslot index, :math:`j` is the control index, and :math:`N` is the number of controls. Hence :math:`t_k` is the evolution time at the start of the timeslot, and :math:`u_{jk}` is the amplitude of control :math:`j` throughout timeslot :math:`k`. The time evolution operator, or propagator, within the timeslot can then be calculated as:. .. math::. X_k:=e^{-iH(t_k)\Delta t_k}. where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:3602,depend,dependent,3602,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['depend'],['dependent']
Integrability," updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta method",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41116,interface,interface,41116,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability," value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18696,integrat,integrator,18696,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability," will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request aga",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9975,message,message,9975,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['message'],['message']
Integrability,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:632,interface,interface,632,doc/guide/heom/history.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst,1,['interface'],['interface']
Integrability,"#. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, w",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8889,depend,depending,8889,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['depend'],['depending']
Integrability,"*********************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath operators. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the follow",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:1093,depend,dependent,1093,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:794,integrat,integration,794,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['integrat'],['integration']
Integrability,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:249,interface,interface,249,doc/development/ideas/qutip-interactive.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst,1,['interface'],['interface']
Integrability,"******; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:1061,depend,depends,1061,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['depends']
Integrability,", is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4805,rout,routine,4805,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['rout'],['routine']
Integrability,"- Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15075,integrat,integrator,15075,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:3915,interface,interface,3915,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['interface'],['interface']
Integrability,"-------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the opti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:3580,depend,dependencies,3580,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['dependencies']
Integrability,"-----------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix sever",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105299,integrat,integration,105299,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integration']
Integrability,"-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96178,depend,dependence,96178,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependence']
Integrability,"-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12033,depend,dependent,12033,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,". - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Oded",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113469,depend,dependence,113469,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependence']
Integrability,". S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires from 0 to 3, this corresponds to a :func:`.tensor_contract` argument of ``(1, 3)``. .. plot::; :context:; :nofigs:. tensor_contract(to_super(identity([2, 2])), (1, 3)). Meanwhile, the :func:`.super_tensor` function implements the swap on the right, such that we can quickly find the preparation map. .. plot::; :context:; :nofigs:. q = tensor(identity(2), basis(2)); s_prep = sprepost(q, q.dag()). For a :math:`\scriptstyle \rm CNOT` system-environment model, the composition of these maps should give us a completely dephasing channel. The channel on both qubits is just the superunitary :math:`\scriptstyle \rm CNOT` channel:. .. plot::; :context: close-figs. hinton(to_super(cnot())). We now complete by multiplying the superunitary :math:`\scriptstyle \rm CNOT` by the preparation channel above, then applying the partial trace channel by contracting the second and fourth index indices. As expected, this gives us a dephasing map. .. plot::; :context: close-figs. hinton(tensor_contract(to_super(cnot()), (1, 3)) * s_prep). .. plot::; :context: reset; :include-source: false; :nofigs:. # reset the context at the end; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:4213,contract,contracting,4213,doc/guide/guide-super.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,1,['contract'],['contracting']
Integrability,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12187,integrat,integration,12187,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,3,"['integrat', 'interface']","['integration', 'interface']"
Integrability,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:752,depend,dependencies,752,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['dependencies']
Integrability,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:129,depend,dependent,129,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,5,"['depend', 'integrat']","['dependent', 'integration']"
Integrability,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:641,integrat,integration,641,doc/guide/dynamics/dynamics-options.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst,7,"['depend', 'integrat', 'interface']","['depend', 'integration', 'integrator', 'interface']"
Integrability,".. _propagator:. *********************; Computing propagators; *********************. Sometime the evolution of a single state is not sufficient and the full propagator; is desired. QuTiP has the :func:`.propagator` function to compute them:. .. code-block::. >>> H = sigmaz() + np.pi *sigmax(); >>> psi_t = sesolve(H, basis(2, 1), [0, 0.5, 1]).states; >>> prop = propagator(H, [0, 0.5, 1]). >>> print((psi_t[1] - prop[1] @ basis(2, 1)).norm()); 2.455965272327082e-06. >>> print((psi_t[2] - prop[2] @ basis(2, 1)).norm()); 2.0071900004562142e-06. The first argument is the Hamiltonian, any time dependent system format is; accepted. The function also accepts an optional `c_ops` argument for collapse operators.; When used, a propagator for density matrices is computed:; :math:`\rho(t) = U(t)(\rho(0))`:. .. code-block::. >>> rho_t = mesolve(H, fock_dm(2, 1), [0, 0.5, 1], c_ops=[sigmam()]).states; >>> prop = propagator(H, [0, 0.5, 1], c_ops=[sigmam()]). >>> print((rho_t[1] - prop[1](fock_dm(2, 1))).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - prop[2](fock_dm(2, 1))).norm()); 1.2666967766644768e-06. The propagator function is also available as a class:. .. code-block::. >>> U = Propagator(H, c_ops=[sigmam()]). >>> state_0_5 = U(0.5)(fock_dm(2, 1)); >>> state_1 = U(1., t_start=0.5)(state_0_5). >>> print((rho_t[1] - state_0_5).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - state_1).norm()); 8.355518501351504e-07. The :obj:`.Propagator` can take ``options`` and ``args`` as a solver instance. .. _propagator_solver:. Using a solver to compute a propagator; ======================================. Many solvers accept an operator as the initial state. When an identity matrix is; passed as the initial state, the propagator is computed. This can be used to compute; a propagator for Bloch-Redfield or Floquet equations:. .. code-block::. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> gamma1 = 0.5. >>> H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). >>> def ohmic_sp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst:595,depend,dependent,595,doc/guide/dynamics/dynamics-propagator.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst,1,['depend'],['dependent']
Integrability,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:233,interface,interface,233,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,2,['interface'],['interface']
Integrability,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:348,contract,contracts,348,doc/guide/guide-super.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,2,['contract'],"['contracted', 'contracts']"
Integrability,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:89,depend,dependent,89,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,6,['depend'],"['depend', 'dependence', 'dependent']"
Integrability,.. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :member,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3230,integrat,integrator,3230,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,".. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the ret",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:14224,depend,dependent,14224,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,".; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator r",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105410,depend,dependent,105410,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,".to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equiva",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39169,depend,dependent,39169,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74379,depend,dependabot,74379,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependabot']
Integrability,"578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/17",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74531,depend,dependabot,74531,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependabot']
Integrability,:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qut,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3414,integrat,integrator,3414,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,"://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://gi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74229,depend,dependabot,74229,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependabot']
Integrability,"; - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66239,depend,dependabot,66239,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependabot']
Integrability,"; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11810,depend,dependent,11810,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"= tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however wi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4277,depend,dependent,4277,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"==. Schrödinger Equation; --------------------. .. automodule:: qutip.solver.sesolve; :members: sesolve. Master Equation; ---------------. .. automodule:: qutip.solver.mesolve; :members: mesolve. Monte Carlo Evolution; ---------------------. .. automodule:: qutip.solver.mcsolve; :members: mcsolve. .. automodule:: qutip.solver.nm_mcsolve; :members: nm_mcsolve. Krylov Subspace Solver; ----------------------. .. automodule:: qutip.solver.krylovsolve; :members: krylovsolve. Bloch-Redfield Master Equation; ------------------------------. .. automodule:: qutip.solver.brmesolve; :members: brmesolve. Floquet States and Floquet-Markov Master Equation; -------------------------------------------------. .. automodule:: qutip.solver.floquet; :members: fmmesolve, fsesolve, floquet_tensor. Stochastic Schrödinger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:4809,depend,dependent,4809,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['depend'],['dependent']
Integrability,"==========+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +==========================+==============+=====================================================+; | ``matplotlib`` | 1.2.1+ | Needed for all visualisation tasks. |; +--------------------------+--------------+-----------------------------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +---------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:2434,depend,dependent,2434,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['dependent']
Integrability,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7070,depend,dependencies,7070,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['depend'],['dependencies']
Integrability,">`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile ma",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4550,depend,dependencies,4550,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependencies']
Integrability,">`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/quti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:76518,depend,dependent,76518,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3723,depend,dependencies,3723,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['depend'],['dependencies']
Integrability,"Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in p",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93816,depend,dependent,93816,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105038,depend,dependent,105038,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"P 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7624,depend,depend,7624,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['depend']
Integrability,"Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change and a positive-valued square for a +1 sign. .. plot::; :context: close-figs. hinton(to_super(sigmaz())). As a couple more examples, we also consider the supermatrix for a Hadamard transform and for :math:`\sigma_z \otimes H`. .. plot::; :context: close-figs. hinton(to_super(hadamard_transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires from 0 to 3, this corresponds to a :func:`.tensor_contract` argument of ``(1, 3)``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:2446,contract,contraction,2446,doc/guide/guide-super.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,1,['contract'],['contraction']
Integrability,"QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own imple",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14362,interface,interface,14362,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability,"Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad di",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92341,depend,dependant,92341,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependant']
Integrability,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11120,integrat,integration,11120,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['integrat'],['integration']
Integrability,"[random]. >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz([[2, 3], [2, 3]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the random :class:`.Qobj` function in QuTiP support additional parameters as well, namely *density* and *distribution*.; :func:`.rand_dm`, :func:`.rand_herm`, :func:`.rand_unitary` and :func:`.rand_ket` can be created using multiple method controlled by *distribution*.; The :func:`.rand_ket`, :func:`.rand_herm` and :func:`.rand_unitary` functions can return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the ``density`` keyword argument.; By contrast, `rand_super_bcsz` take as an argument the rank of the generated object, such that passing ``rank=1`` returns a random pure state or unitary channel, respectively.; Passing ``rank=None`` specifies that the generated object should be full-rank for the given dimension.; `rand_dm` can support *density* or *rank* depending on the chosen distribution. For example,. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_dm(5, density=0.5, distribution=""herm""); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.298+0.j , 0. +0.j , -0.095+0.1j , 0. +0.j ,-0.105+0.122j],; [ 0. +0.j , 0.088+0.j , 0. +0.j , -0.018-0.001j, 0. +0.j ],; [-0.095-0.1j , 0. +0.j , 0.328+0.j , 0. +0.j ,-0.077-0.033j],; [ 0. +0.j , -0.018+0.001j, 0. +0.j , 0.084+0.j , 0. +0.j ],; [-0.105-0.122j, 0. +0.j , -0.077+0.033j, 0. +0.j , 0.201+0.j ]]. >>> rand_dm_ginibre(5, rank=2); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.307+0.j , -0.258+0.039j, -0.039+0.184j, 0.041-0.054j, 0.016+0.045j],; [-0.258-0.039j, 0.239+0.j , 0.075-0.15j , -0.053+0.008j,-0.057-0.078j],; [-0.039-0.184j, 0.075+0.15j , 0.136+0.j , -0.05 -0.052j,-0.028-0.058j],; [ 0.041+0.054j, -0.053-0.008j, -0.05 +0.052j, 0.083+0.j , 0.101-0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst:4388,depend,depending,4388,doc/guide/guide-random.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst,1,['depend'],['depending']
Integrability,"_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114404,depend,dependent,114404,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"`MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:44477,integrat,integrator,44477,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Páde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20963,interface,interface,20963,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability,"``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:46744,interface,interface,46744,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability,"agonalizing it. In particular this method is useful to find :math:`\Phi_\alpha(0)` by calculating and diagonalize :math:`U(T,0)`. The Floquet modes at arbitrary time :math:`t` can then be found by propagating :math:`\Phi_\alpha(0)` to :math:`\Phi_\alpha(t)` using the wave function propagator :math:`U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)`, which for the Floquet modes yields. .. math::. U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. so that :math:`\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)`. Since :math:`\Phi_\alpha(t)` is periodic we only need to evaluate it for :math:`t \in [0, T]`, and from :math:`\Phi_\alpha(t \in [0,T])` we can directly evaluate :math:`\Phi_\alpha(t)`, :math:`\Psi_\alpha(t)` and :math:`\Psi(t)` for arbitrary large :math:`t`. Floquet formalism in QuTiP; --------------------------. QuTiP provides a family of functions to calculate the Floquet modes and quasi energies,; Floquet state decomposition, etc., given a time-dependent Hamiltonian. Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. .. math::; :label: eq_driven_qubit. H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z. In QuTiP we can define this Hamiltonian as follows:. .. code-block:: python. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The :math:`t=0` Floquet modes corresponding to the Hamiltonian :eq:`eq_driven_qubit`; can then be calculated using the :class:`.FloquetBasis` class, which encapsulates; the Floquet modes and the quasienergies:. .. code-block:: python. >>> T = 2*np.pi / omega; >>> floquet_basis = FloquetBasis(H, T, args); >>> f_energies = floquet_basis.e_quasi; >>> f_energies # doctest: +NORMALIZE_WHITESPACE; array([-2.83131212, 2.831312",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:5810,depend,dependent,5810,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,"ained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5729,integrat,integrated,5729,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability,"al for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6391,depend,dependency,6391,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['dependency']
Integrability,"ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6800,wrap,wrapper,6800,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['wrap'],['wrapper']
Integrability,"amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4946,depend,dependence,4946,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['depend'],['dependence']
Integrability,"an to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4076,integrat,integrated,4076,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability,"ape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +----------------+------------------+----------------------------------------+; | Representation | ``Q.superrep`` | Representation used if `type` is |; | | | 'super'? |; +----------------+------------------+----------------------------------------+; | Is constant | ``Q.isconstant`` | Does the QobjEvo depend on time. |; +----------------+------------------+----------------------------------------+. :obj:`.QobjEvo`'s follow the same mathematical operations rules than :obj:`.Qobj`.; They can be added, subtracted and multiplied with scalar, ``Qobj`` and ``QobjEvo``.; They also support the ``dag`` and ``trans`` and ``conj`` method and can be used; for tensor operations and super operator transformation:. .. code-block:: python. H = tensor(H_t, qeye(2)); c_op = tensor(QobjEvo([destroy(N), lambda t: np.exp(-t)]), sigmax()). L = -1j * (spre(H) - spost(H.dag())); L += spre(c_op) * spost(c_op.dag()) - 0.5 * spre(c_op.dag() * c_op) - 0.5 * spost(c_op.dag() * c_op). Or equivalently:. .. code-block:: python. L = liouvillian(H, [c_op]). Using arguments; ---------------. Until now, the coefficients were only functions of time. In the definition of ``H1_coeff``,; the driving amplitude ``A`` and width ``sigma`` were hardcoded with their numerical values.; This is fine for problems that are ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:7191,depend,depend,7191,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['depend']
Integrability,"ase let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4292,interface,interface,4292,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability,"ata is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:38696,contract,contract,38696,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['contract'],['contract']
Integrability,"ata is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coeffic",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11236,contract,contract,11236,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['contract'],['contract']
Integrability,"ata; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3201,integrat,integration,3201,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['integrat'],['integration']
Integrability,"ated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5085,integrat,integrated,5085,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability,"ation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6327,depend,depends,6327,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['depends']
Integrability,"both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note dow",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15109,message,message,15109,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['message'],['message']
Integrability,"c arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42579,integrat,integrator,42579,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:3731,integrat,integration,3731,doc/guide/dynamics/dynamics-nmmonte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst,2,['integrat'],['integration']
Integrability,"custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approxim",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14856,depend,depends,14856,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41610,depend,depends,41610,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['depends']
Integrability,"cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Vi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95446,depend,dependent,95446,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['depend', 'rout']","['dependent', 'routines']"
Integrability,"d the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these ar",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3548,interface,interface,3548,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability,"d. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Páde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and inspection of the ADOs (auxiliary density operators). QuTiP core; ----------. There have been numer",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:21051,depend,dependent,21051,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"d. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been renamed to ``stack_columns`` and; ``unstack_columns``.; - The function ``liouvillian_ref`` has bee",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:46832,depend,dependent,46832,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"duction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1108,depend,dependent,1108,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,"e been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5502,integrat,integrated,5502,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10548,depend,depends,10548,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['depend'],['depends']
Integrability,"e of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath operators. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the following are equivalent:. .. code-block:: python. result = mesolve(H_t, ...); result = mesolve([num(N), [destroy(N) + create(N), lambda t: np.sin(t)]], ...); result = mesolve(oper, ...). Collapse operator also accept a list of object that could be made into :obj:`.QobjEvo`.; However one needs to be careful about not confusing the list nature of the `c_ops`; parameter with list format quantum system. In the following call:. .. code-block:: python. result = mesolve(H_t, ..., c_ops=[num(N), [destroy(N) + create(N), lambda t: np",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:1628,depend,dependent,1628,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"e(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)}; ).expect. plt.figure(); plt.plot(times, data[0]); plt.plot(times, data[1]); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4690,depend,dependent,4690,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['depend'],['dependent']
Integrability,"ease to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Giguère**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Vers",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:86173,message,messages,86173,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['message'],['messages']
Integrability,"ed call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78456,depend,dependencies,78456,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependencies']
Integrability,"efs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18526,interface,interface,18526,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['interface'],['interface']
Integrability,"egration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct res",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:112196,depend,dependent,112196,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"el Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99410,depend,dependent,99410,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"elated to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing na",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2721,depend,dependences,2721,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['dependences']
Integrability,"er(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11]_.; In particular, the :func:`~qutip.core.tensor.tensor_contract` function allows for; contracting one or more pairs of indices.; This can be used to find superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from :math:`3 \times 3` operators to :math:`2 \times 2`; operators:. .. doctest:: [tensor]. >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. ..; TODO: remake from notebook to tutorials; .. _channel contraction tutorial: github/qutip/qutip-notebooks/blob/master/examples/superop-contract.ipynb; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:11416,contract,contracting,11416,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,3,['contract'],"['contract', 'contracting', 'contraction']"
Integrability,"ersion 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); data2 = solver.run(psi1, times, e_ops=e_ops). plt.figure(); plt.plot(times, data1.expect[0], ""b"", times,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:1107,interface,interface,1107,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['interface'],['interface']
Integrability,"erz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91969,depend,dependant,91969,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependant']
Integrability,"es and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in `qutip.qip.device` and; `qutip.qip.compiler`. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * quantum information processing and quantum computing (quantum circuit formalism). Difficulty; ==========. * Medium. Mentors; =======. * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ====",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:1521,depend,depend,1521,doc/development/ideas/pulse-level-quantum-circuits.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst,1,['depend'],['depend']
Integrability,"es.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6878,depend,dependency,6878,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependency']
Integrability,"formance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrödinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state. - New module `qutip.qip` with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP arc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:106511,depend,dependent,106511,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12451,depend,dependencies,12451,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependencies']
Integrability,"he QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). D",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:77868,depend,dependent,77868,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"he current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15882,integrat,integrator,15882,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"heck for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for sav",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114288,depend,dependent,114288,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"heme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build als",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1641,depend,dependency,1641,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['depend'],['dependency']
Integrability,"hen the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:3199,depend,depend,3199,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['depend'],['depend']
Integrability,heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2843,integrat,integrator,2843,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _clas,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3322,integrat,integrator,3322,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,"his into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a contr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8415,depend,dependent,8415,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['dependent']
Integrability,"iP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (ne",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2793,depend,depend,2793,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['depend']
Integrability,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12346,interface,interface,12346,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['interface'],['interface']
Integrability,"ill fail:. .. code-block:: python. >>> QobjEvo(system); TypeError: H1_coeff() missing 2 required positional arguments: 'A' and 'sigma'. When evaluation the :obj:`.QobjEvo` at a time, new arguments can be passed either; with the ``args`` dictionary positional arguments, or with specific keywords arguments:. .. code-block:: python. >>> print(qevo(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:10635,depend,dependent,10635,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"ime-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to constr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15637,depend,dependent,15637,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['dependent']
Integrability,"interaction Hamiltonian. The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (:math:`\dot\rho = -i\hbar^{-1}[H, \rho]`). In the interaction picture the result is. .. math::; :label: br-nonmarkovian-form-one. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],. where the additional assumption that the total system-bath density matrix can be factorized as :math:`\rho(t) \approx \rho_S(t) \otimes \rho_B`.; This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:3973,depend,depends,3973,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['depends']
Integrability,"ion 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrödinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state. - New module `qutip.qip` with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures. - New module `qutip.distributions` with unified API for working with; distribution functions. - New format for defining time-dependent Hamiltonians and collapse operators,; using a pre-calculated numpy array that specifies the values of the; Qobj-coefficients for each time step. - New functions for working with different superoperator representations,; including Kraus and Chi representation. - New functions for visualizing quantum states using Qubism and Schimdt plots:; ``plot_qubism`` and ``plot_schmidt``. - Dynamics solver now support taking argument ``e_ops`` (expectation value; operators) in dictionary form. - Public plotting functions from the ``qutip.visualization`` module are now; prefixed with ``plot_`` (e.g., ``plot_fock_distribution``). The; ``plot_wigner`` and ``plot_wigner_fock_distribution`` now supports 3D views; in addition to contour views. - New API and new functions for working with spin operators and states,; including for example ``spin_Jx``, ``spin_Jy``, ``spin_Jz`` and; ``spin_state``, ``spin_coherent``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:107687,depend,dependent,107687,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"ion_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj obj",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95914,depend,dependent,95914,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"ious lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Giguère**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Giguère**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Giguère**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step functi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89542,depend,depending,89542,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['depending']
Integrability,ip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2940,integrat,integrator,2940,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,"isation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other prope",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100328,depend,depending,100328,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['depending']
Integrability,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The outpu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4228,depend,dependent,4228,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"itional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package man",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4546,depend,dependences,4546,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['dependences']
Integrability,"iving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions to :eq:`eq_td_schrodinger` of the form. .. math::; :label: eq_floquet_states. \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. where :math:`\Psi_\alpha(t)` are the *Floquet states* (i.e., the set of wave function solutions to the Schrödinger equation), :math:`\Phi_\alpha(t)=\Phi_\alpha(t+T)` are the periodic *Floquet modes*, and :math:`\epsilon_\alpha` are the *quasienergy levels*. The quasienergy levels are constants in time, but only uniquely defined up to multiples of :math:`2\pi/T` (i.e., unique value in the interval :math:`[0, 2\pi/T]`). If we know the Floquet modes (for :math:`t \in [0,T]`) and the quasienergies for a particular :math:`H(t)`, we can easily decompose any initial wavefunction :math:`\Psi(t=0)` in the Floquet states and immediately obtain the solution for arbitrary :math:`t`. .. m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1943,depend,dependence,1943,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependence']
Integrability,"ivity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15141,depend,dependent,15141,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,2,['depend'],['dependent']
Integrability,"kipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation values and states are averaged; over all trajectories, while a list over the runs are given when they are stored.; For a fix output format, ``average_expect`` return the average, while; ``runs_states`` return the list over trajectories. The ``runs_`` output will; return ``None`` when the trajectories are not saved. Standard derivation of the; expectation values is also available:. +-------------------------+----------------------+--------------------------------------------------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4791,depend,depending,4791,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['depend'],['depending']
Integrability,"ks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5655,depend,depend,5655,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['depend'],['depend']
Integrability,"l be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plot(tlist, [H(t).norm() for t in tlist], label=""CubicSpline""). H = QobjEvo([qeye(1), coeff], tlist=times, order=0); plt.plot(tlist, [H(t).norm() for t in tlist], label=""step""). H = QobjEvo([qeye(",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13920,interface,interface,13920,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['interface'],['interface']
Integrability,"l done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They sho",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16500,wrap,wrap,16500,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['wrap'],['wrap']
Integrability,"l free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12574,depend,depending,12574,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['depend'],['depending']
Integrability,"l not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6784,depend,dependency,6784,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependency']
Integrability,"lity.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41990,integrat,integrator,41990,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:2036,depend,dependence,2036,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['depend'],['dependence']
Integrability,"m runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8169,depend,dependencies,8169,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['dependencies']
Integrability,"mes). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e_ops=num(2)).expect[0]; data2 = sesolve(H, psi0, tlist, e_ops=num(2), options={""max_step"": 0.01}).expect[0]. plt.plot(tlist, data1, label=""no max_step""); plt.plot(tlist, data2, label=""fixed max_step""); plt.fill_between(tlist, [pulse(t) for t in tlist], color=""g"", alpha=0.2, label=""pulse""); plt.ylim([-0.1, 1.1]); plt.legend(loc=""center left""). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16648,integrat,integration,16648,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['integrat'],['integration']
Integrability,"meter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equiva",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11906,depend,dependent,11906,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"mic_spectrum]], e_ops=e_ops). where the resulting `output` is an instance of the class :class:`.Result`. .. note::; While the code example simulates the Bloch-Redfield equation in the secular; approximation, QuTiP's implementation allows the user to simulate the non-secular; version of the Bloch-Redfield equation by setting ``sec_cutoff=-1``, as well as; do a partial secular approximation by setting it to a ``float`` , this float; will become the cutoff for the sum in :eq:`br-final` meaning terms with; :math:`|\omega_{ab}-\omega_{cd}|` greater than the cutoff will be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this top",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:14263,depend,dependent,14263,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['dependent']
Integrability,"min lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9625,depend,dependent,9625,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['dependent']
Integrability,"mpsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8055,integrat,integration,8055,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integration']
Integrability,"nctions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that ca",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105662,depend,dependent,105662,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions to :eq:`eq_td_schrodinger` of the form. .. math::; :label: eq_floquet_states. \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. where :math:`\Psi_\alpha(t)` are the *Floquet states* (i.e., the set of wave function solutions to the Schrödinger equation), :math:`\Phi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1414,depend,dependent,1414,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11810,depend,dependencies,11810,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,4,"['depend', 'message']","['dependencies', 'message']"
Integrability,"ntal data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plot(tlist, [H(t).norm() for t in tlist], label=""CubicSpline""). H = QobjEvo([qeye(1), coeff], tlist=times, order=0); plt.plot(tlist, [H(t).norm() for t in tlist], label=""step""). H = QobjEvo([qeye(1), coeff], tlist=times, order=1); plt.plot(tlist, [H(t).norm() for t in tlist], label=""linear""). plt.legend(). When using array coefficients in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:15067,depend,dependent,15067,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"nts you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:10485,depend,depending,10485,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['depending']
Integrability,"o longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114735,depend,dependent,114735,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"o(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=Tr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:10932,depend,dependent,10932,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['dependent']
Integrability,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1607,integrat,integrate,1607,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['integrat'],['integrate']
Integrability,"onal arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41022,integrat,integrator,41022,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15636,integrat,integrated,15636,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Integrability,"ork; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9982,wrap,wrapper,9982,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['wrap'],['wrapper']
Integrability,"ors. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the following are equivalent:. .. code-block:: python. result = mesolve(H_t, ...); result = mesolve([num(N), [destroy(N) + create(N), lambda t: np.sin(t)]], ...); result = mesolve(oper, ...). Collapse operator also accept a list of object that could be made into :obj:`.QobjEvo`.; However one needs to be careful about not confusing the list nature of the `c_ops`; parameter with list format quantum system. In the following call:. .. code-block:: python. result = mesolve(H_t, ..., c_ops=[num(N), [destroy(N) + create(N), lambda t: np.sin(t)]]). :func:`.mesolve` will see 2 collapses operators:; ``num(N)`` and ``[destroy(N) + create(N), lambda t: np.sin(t)]``.; It is therefore preferred to pass each collapse operator as either a :obj:`.Qobj`; or a :obj:`.QobjEvo`. As an example, we will look at a case with a time-dependent Hamiltonian of the form; :math:`H=H_{0}+f(t)H_{1}` where :math:`f(t)` is the time-dependent driving strength; given as :math:`f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]`.; The following code sets up the problem. .. plot::; :context: reset. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); st",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:2939,depend,dependent,2939,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,2,['depend'],['dependent']
Integrability,"ort, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9334,depend,depending,9334,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['depending']
Integrability,"ot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain chec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96646,depend,dependent,96646,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"oved duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Giguère**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Giguère**).",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88605,message,message,88605,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['message'],['message']
Integrability,"ow gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114211,depend,dependent,114211,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"p``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80886,message,message,80886,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['message'],['message']
Integrability,"pe could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4395,depend,dependency,4395,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['depend'],['dependency']
Integrability,"pendent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions to :eq:`eq_td_schrodinger` of the form. .. math::; :label: eq_floquet_states. \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. where :math:`\Psi_\alpha(t)` are the *Floquet states* (i.e., the set of wave function solutions to the Schrödinger equation), :math:`\Phi_\alpha(t)=\Phi_\alpha(t+T)` are the periodic *Floquet modes*, and :math:`\epsilon_\alpha` are the *quasienergy levels*. The quasienergy levels are constants in time, but only uniquely defined up to multiples of :math:`2\pi/T` (i.e., unique value in the interval :math:`[0, 2\pi/T]`). If we know the Floquet modes (for :math:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1701,depend,dependent,1701,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111206,integrat,integration,111206,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integration']
Integrability,"plying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15293,integrat,integrator,15293,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8739,integrat,integrated,8739,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1870,protocol,protocols,1870,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,2,"['integrat', 'protocol']","['integration', 'protocols']"
Integrability,"r. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent S",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97804,depend,dependent,97804,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"rce framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4995,depend,dependent,4995,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['depend'],['dependent']
Integrability,"re the coefficients :math:`c_\alpha` are determined by the initial wavefunction :math:`\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)`. This formalism is useful for finding :math:`\Psi(t)` for a given :math:`H(t)` only if we can obtain the Floquet modes :math:`\Phi_a(t)` and quasienergies :math:`\epsilon_\alpha` more easily than directly solving :eq:`eq_td_schrodinger`. By substituting :eq:`eq_floquet_states` into the Schrödinger equation :eq:`eq_td_schrodinger` we obtain an eigenvalue equation for the Floquet modes and quasienergies. .. math::; :label: eq_floquet_eigen_problem. \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),. where :math:`\mathcal{H}(t) = H(t) - i\hbar\partial_t`. This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation :eq:`eq_td_schrodinger`, which by definition satisfies. .. math::. U(T+t,t)\Psi(t) = \Psi(T+t). Inserting the Floquet states from :eq:`eq_floquet_states` into this expression results in. .. math::; U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),. or, since :math:`\Phi_\alpha(T+t)=\Phi_\alpha(t)`,. .. math::; U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),. which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies :math:`\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T` by numerically calculating :math:`U(T+t,t)` and diagonalizing it. In particular this method is useful to find :math:`\Phi_\alpha(0)` by calculating and diagonalize :math:`U(T,0)`. The Floquet modes at arbitrary time :math:`t` can then be found by propagating :math:`\Phi_\alpha(0)` to :math:`\Phi_\alpha(t)` using the wave functio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:4069,depend,dependent,4069,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,"rix :math:`M` with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP; -----------------------. In QuTiP, the procedure described above is implemented in the function :func:`qutip.tomography.qpt`, which returns the :math:`\chi` matrix given a density matrix propagator.; To illustrate how to use this function, let's consider the SWAP gate for two qubits. In QuTiP the function :func:`.swap` generates the unitary transformation for the state kets:. .. plot::; :context: close-figs. from qutip.core.gates import swap. U_psi = swap(). To be able to use this unitary transformation matrix as input to the function :func:`qutip.tomography.qpt`, we first need to convert it to a transformation matrix for the corresponding density matrix:. .. plot::; :context:. U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis :math:`\{B_i\}` in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the :math:`\chi` matrix. .. plot::; :context:. op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute :math:`\chi` using :func:`qutip.tomography.qpt`, and to plot it using :func:`qutip.tomography.qpt_plot_combined`. .. plot::; :context:. chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function :func:`.propagator`, see notebook ""Time-dependent master equation: Landau-Zener transitions"" on the tutorials section on the QuTiP web site.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:15568,depend,dependent,15568,doc/guide/guide-visualization.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst,1,['depend'],['dependent']
Integrability,"rt degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to QobjEvo (#2111 by lklivingstone); - Improve print(qutip.settings) by make it shorter (#2113 by tamakoshi2001); - Create the `trace_oper_ket` operation (#2126); - Speed up the construction of the RHS of the HEOM solver by a factor of 4x by converting the final step to Cython. (#2128); - Rewrite the stochastic solver to use the v5 solver interface. (#2131); - Add `Qobj.get` to extract underlying data in original format. (#2141); - Add qeye_like and qzero_like (#2153); - Add capacity to dispatch on ``Data`` (#2157); - Added fermionic annihilation and creation operators. (#2166 by khnikhil); - Changed arguments and applied colorblind_safe to functions in visualization.py (#2170 by Yuji Tamakoshi); - Changed arguments and applied colorblind_safe to plot_wigner_sphere and matrix_histogram in visualization.py (#2193 by Yuji Tamakoshi); - Added Dia data layer which represents operators as multi-diagonal matrices. (#2196); - Added support for animated plots. (#2203 by Yuji Tamakoshi); - Improved sampling algorithm for mcsolve (#2218 by Daniel Weiss); - Added support for early termination of map functions. (#2222). Bug Fixes; ---------. - Add missing state transformation to floquet_markov_mesolve (#1952 by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:30138,interface,interface,30138,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['interface'],['interface']
Integrability,"ructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41772,integrat,integrator,41772,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"s, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2942,depend,dependency,2942,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['depend'],['dependency']
Integrability,"s.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Páde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and inspection of the ADOs (auxiliary density operators). QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been renamed to ``stack_columns`` and; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:21560,integrat,integrators,21560,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrators']
Integrability,"s; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; wo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6161,integrat,integrated,6161,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['integrat'],['integrated']
Integrability,"se`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a descri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41303,integrat,integrated,41303,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Integrability,"sed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to g",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11772,depend,dependencies,11772,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependencies']
Integrability,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6702,integrat,integration,6702,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['integrat'],['integration']
Integrability,"smo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Giguère**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Giguère**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88859,depend,dependent,88859,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.P,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3132,integrat,integrator,3132,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,"ster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL so",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95210,depend,dependent,95210,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"strates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is interacting with its environment is not necessarily well; described by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take the driving into account when deriving the master equation. This can be; done in many different ways, but one way common approach is to derive the master; equation in the Floquet basis. That approach results in the so-called Floquet-Markov; master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:12064,depend,dependent,12064,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['depend'],['dependent']
Integrability,subara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedo,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:6776,interface,interface,6776,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['interface'],['interface']
Integrability,"t minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2746,depend,dependent,2746,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"t`` , this float; will become the cutoff for the sum in :eq:`br-final` meaning terms with; :math:`|\omega_{ab}-\omega_{cd}|` greater than the cutoff will be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; I",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:14639,depend,dependent,14639,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['dependent']
Integrability,"te number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, Asier Galicia and Simon Cross); - Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (`#1837 <https://github.com/qutip/qutip/pull/1837>`_ by Xavier Spronken); - Support ``Path`` objects in ``qutip.fileio``. (`#1813 <https://github.com/qutip/qutip/pull/1813>`_ by Adrià Labay); - Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (`#1275 <https://github.com/qutip/qutip/pull/1275>`_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57697,wrap,wrapper,57697,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['wrap'],['wrapper']
Integrability,"tegrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42333,integrat,integrated,42333,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrated']
Integrability,th; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.s,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3035,integrat,integrator,3035,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,"that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10222,interface,interface,10222,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['interface'],['interface']
Integrability,"the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirement",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6503,depend,dependencies,6503,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependencies']
Integrability,"the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79909,depend,dependencies,79909,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependencies']
Integrability,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4648,integrat,integration,4648,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['integrat'],['integration']
Integrability,"ther changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85433,message,messages,85433,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['message'],['messages']
Integrability,"thon dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41874,integrat,integrator,41874,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integrator']
Integrability,"through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4311,integrat,integration,4311,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['integrat'],['integration']
Integrability,"tic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3505,integrat,integrator,3505,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['integrat'],['integrator']
Integrability,"tps://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pul",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74081,depend,dependabot,74081,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependabot']
Integrability,"transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires from 0 to 3, this corresponds to a :func:`.tensor_contract` argument of ``(1, 3)``. .. plot::; :context:; :nofigs:. tensor_contract(to_super(identity([2, 2])), (1, 3)). Meanwhile, the :func:`.super_tensor` function implements the swap on the right, such that we can quickly find the preparation map. .. plot::; :context:; :nofigs:. q = tensor(identity(2), basis(2)); s_prep = sprepost(q, q.dag()). For a :math:`\scriptstyle \rm CNOT` system-environment model, the composition of these maps should give us a completely dephasing channel. The channel on both qubits is just the superunitary :math:`\scriptstyle \rm CNOT` channel:. .. plot::; :context: close-figs. hinton(to_super(cnot())). We now complete by multiplying the superunitary :math:`\scriptstyle \rm CNOT` by the preparation channel above, then applying the partial trace channel by contracting the second and fourth index indices. As expected, this gives",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:3299,contract,contraction,3299,doc/guide/guide-super.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,1,['contract'],['contraction']
Integrability,"tuted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11349,depend,dependencies,11349,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependencies']
Integrability,"ub.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65234,depend,dependabot,65234,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependabot']
Integrability,"uilt circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93659,depend,dependent,93659,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"urce_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block::",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11511,depend,depending,11511,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['depend'],['depending']
Integrability,"utip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install q",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12029,depend,dependencies,12029,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['depend'],['dependencies']
Integrability,"vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110092,depend,dependent,110092,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['depend'],"['depend', 'dependent']"
Integrability,"vers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:16601,depend,dependent,16601,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['dependent']
Integrability,"vo`` as Qobj). - fidcomp properties. - ``uses_evo_t2end`` now ``uses_onwd_evo``; - ``uses_evo_t2targ`` now ``uses_onto_evo``; - ``set_phase_option`` function now property ``phase_option``. - propcomp properties. - ``grad_exact`` (now read only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103031,depend,dependent,103031,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"w-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions e",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5652,rout,routines,5652,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['rout'],['routines']
Integrability,"will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39073,depend,dependent,39073,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`_, or by raising issues in `the main GitHub repository <https://github.com/qutip/qutip>`_ if you find any bugs.; Anyone who contributes code will be duly recognized.; Even sma",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:7486,protocol,protocols,7486,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['protocol'],['protocols']
Integrability,"x cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrödinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:106043,depend,dependent,106043,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['depend'],['dependent']
Integrability,"y Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Updat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54162,integrat,integration,54162,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['integrat'],['integration']
Integrability,"y optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:98860,rout,routine,98860,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['rout'],['routine']
Integrability,"y rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kap",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4574,depend,depends,4574,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['depend'],['depends']
Integrability,"you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15346,depend,dependent,15346,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['depend'],['dependent']
Modifiability," .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is intereste",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:6084,coupling,coupling,6084,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['coupling'],['coupling']
Modifiability," A_n^\dagger A_n - A_n^\dagger A_n \rho(t)\right]. with ""rates"" :math:`\gamma_n(t)` that can take negative values.; This can be done with the :func:`.nm_mcsolve` function.; The function is based on the influence martingale formalism [Donvil22]_ and; formally requires that the collapse operators :math:`A_n` satisfy a completeness; relation of the form. .. math::; :label: nmmcsolve_completeness. \sum_n A_n^\dagger A_n = \alpha \mathbb{I} ,. where :math:`\mathbb{I}` is the identity operator on the system Hilbert space; and :math:`\alpha>0`.; Note that when the collapse operators of a model don't satisfy such a relation,; ``nm_mcsolve`` automatically adds an extra collapse operator such that; :eq:`nmmcsolve_completeness` is satisfied.; The rate corresponding to this extra collapse operator is set to zero. Technically, the influence martingale formalism works as follows.; We introduce an influence martingale :math:`\mu(t)`, which follows the evolution; of the system state. When no jump happens, it evolves as. .. math::; :label: influence_cont. \mu(t) = \exp\left( \alpha\int_0^t K(\tau) d\tau \right). where :math:`K(t)` is for now an arbitrary function.; When a jump corresponding to the collapse operator :math:`A_n` happens, the; influence martingale becomes. .. math::; :label: influence_disc. \mu(t+\delta t) = \mu(t)\left(\frac{K(t)-\gamma_n(t)}{\gamma_n(t)}\right). Assuming that the state :math:`\bar\rho(t)` computed by the Monte Carlo average. .. math::; :label: mc_paired_state. \bar\rho(t) = \frac{1}{N}\sum_{l=1}^N |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and rates; :math:`\Gamma_n(t)`, the state :math:`\rho(t)` defined by. .. math::; :label: mc_martingale_state. \rho(t) = \frac{1}{N}\sum_{l=1}^N \mu_l(t) |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and shifted; rates :math:`\gamma_n(t)-K(t)`. Thus, while :math:`\Gamma_n(t) \geq 0`, the new; """,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:1496,evolve,evolves,1496,doc/guide/dynamics/dynamics-nmmonte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst,1,['evolve'],['evolves']
Modifiability," Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33909,layers,layers,33909,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['layers'],['layers']
Modifiability," Cristian Emiliano Godinez Ramirez (Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver, `#2167 <https://github.com/qutip/qutip/pull/2167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to spe",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:10043,flexible,flexible,10043,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['flexible'],['flexible']
Modifiability," \right)^{2}\right]`.; The following code sets up the problem. .. plot::; :context: reset. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4092,coupling,coupling,4092,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['coupling'],['coupling']
Modifiability, _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. ..,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1165,inherit,inherited-members,1165,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['inherit'],['inherited-members']
Modifiability," adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2446,flexible,flexible,2446,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['flexible'],['flexible']
Modifiability, autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1493,inherit,inherited-members,1493,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,2,['inherit'],"['inheritance', 'inherited-members']"
Modifiability," by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 by Asier Galicia); - Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template. (#2107 by Valan Baptist Mathuranayagam); - Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05. (#2181 by SJUW); - Raise error on insufficient memory. (#2224); - Fixed fallback to fsesolve call in fmmesolve (#2225). Removals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:31958,inherit,inherited,31958,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['inherit'],['inherited']
Modifiability," contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:1159,config,configure,1159,doc/development/ideas/qutip-interactive.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst,1,['config'],['configure']
Modifiability," defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the insta",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:13678,evolve,evolves,13678,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['evolve'],['evolves']
Modifiability," first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:1203,variab,variables,1203,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['variab'],['variables']
Modifiability," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17076,coupling,coupling,17076,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability," isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coeff",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12938,variab,variable,12938,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['variab'],['variable']
Modifiability," likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory requ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:7576,variab,variables,7576,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['variab'],['variables']
Modifiability," multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4359,config,config,4359,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['config'],['config']
Modifiability," new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4421,layers,layers,4421,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['layers'],['layers']
Modifiability," of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5785,plugin,plugin,5785,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,2,"['coupling', 'plugin']","['coupling', 'plugin']"
Modifiability, qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass::,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1346,inherit,inherited-members,1346,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,2,['inherit'],"['inheritance', 'inherited-members']"
Modifiability," runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80073,config,configuration,80073,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['configuration']
Modifiability," string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13572,variab,variables,13572,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['variab'],['variables']
Modifiability," than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::; :context: reset. >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> solver = SESolver(H); >>> result = solver.run(psi0, times, e_ops=[sigmaz()]); >>> result.expect; [array([ 1. , 0.78914057, 0.24548543, -0.40169579, -0.87947417,; -0.98636112, -0.67728018, -0.08257665, 0.54695111, 0.94581862,; 0.94581574, 0.54694361, -0.08258559, -0.67728679, -0.9863626 ,; -0.87946979, -0.40168705, 0.24549517, 0.78914703, 1. ])]. See the next section for examples on evolution with dissipation using; :func:`.mesolve`. The function returns an instance of :class:`.Result`, as described in the; previous section :ref:`solver",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:2249,evolve,evolves,2249,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['evolve'],['evolves']
Modifiability," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:3157,config,configured,3157,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['config'],['configured']
Modifiability,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:848,flexible,flexible,848,doc/guide/heom/history.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst,1,['flexible'],['flexible']
Modifiability,"######################; Fermionic Environments; ######################. Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, :math:`H_{sys}`, and bath spectral density, :math:`J_D`,; are. .. math::. H_{sys} &= c^{\dagger} c. J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state. Since our fermion is coupled to two reservoirs, we will construct two baths --; one for each reservoir or lead -- and call them the left (:math:`L`) and right; (:math:`R`) baths for convenience. Each bath will have a different chemical; potential :math:`\mu` which we will label :math:`\mu_L` and :math:`\mu_R`. First we will do this using the built-in implementations of the bath expansions,; :class:`~qutip.solver.heom.LorentzianBath` and; :class:`~qutip.solver.heom.LorentzianPadeBath`. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. fro",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:574,evolve,evolve,574,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['evolve'],['evolve']
Modifiability,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:570,evolve,evolve,570,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['evolve'],['evolve']
Modifiability,")); axes.plot(result.times, result.e_data[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.e_data[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state; ------------. Using the same solver, we can also determine the steady state of the; combined system and bath using:. .. plot::; :context:; :nofigs:. steady_state, steady_ados = solver.steady_state(). where ``steady_state`` is the steady state of the system and ``steady_ados``; if the steady state of the full hierarchy. The ADO states are; described more fully in :ref:`heom-determining-currents` and; :class:`~qutip.solver.heom.HierarchyADOsState`. Matsubara Terminator; --------------------. When constructing the Drude-Lorentz bath we have truncated the expansion at; ``Nk = 2`` terms and ignore the remaining terms. However, since the coupling to these higher order terms is comparatively weak,; we may consider the interaction with them to be Markovian, and construct an; additional Lindbladian term that captures their interaction with the system and; the lower order terms in the expansion. This additional term is called the ``terminator`` because it terminates the; expansion. The :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` both provide a means of; calculating the terminator for a given expansion:. .. plot::; :context:; :nofigs:. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). # Add terminator to the system Liouvillian:; delta, terminator = bath.terminator(); HL = liouvillian(H_sys) + terminator. # Construct solver:; solver = HEOMSolver(HL, bath, max_depth=max_depth, options=options). This captures the Markovian effect of the remaining terms in the expansion; without having to fully model many more terms. The value ``delta`` is an approximation to the strength of the effect of; the remaini",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:6548,coupling,coupling,6548,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['coupling'],['coupling']
Modifiability,"**********************************************************; GPU implementation of the Hierarchical Equations of Motion; **********************************************************. .. contents:: Contents; :local:; :depth: 3. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in [1]_. The; goal of this project would be to extend QuTiP's HEOM method [2]_ and implement; it on a GPU. Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes; =================. * A version of HEOM which runs on a GPU.; * Performance comparison with the CPU version.; * Implement dynamic scaling. Skills; ======. * Git, python and familiarity with the Python scientific computing stack; * CUDA and OpenCL knowledge. Difficulty; ==========. * Hard. Mentors; =======. * Neill Lambert (nwlambert@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); * Simon Cross (hodgestar@gmail.com). References; ==========. .. [1] https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce; .. [2] https://arxiv.org/abs/2010.10806; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst:574,extend,extend,574,doc/development/ideas/heom-gpu.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst,2,['extend'],"['extend', 'extended']"
Modifiability,"*******************************************; Pulse level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:210,enhance,enhance,210,doc/development/ideas/pulse-level-quantum-circuits.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst,3,['enhance'],"['enhance', 'enhanced']"
Modifiability,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:258,enhance,enhanced,258,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['enhance'],['enhanced']
Modifiability,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:553,flexible,flexible,553,doc/development/ideas/qutip-interactive.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst,1,['flexible'],['flexible']
Modifiability,"********; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error star",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:1046,evolve,evolved,1046,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['evolve'],['evolved']
Modifiability,"++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill La",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:56924,enhance,enhancements,56924,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['enhance'],['enhancements']
Modifiability,", and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111512,variab,variable,111512,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['variab'],['variable']
Modifiability,"- Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65661,config,configuration,65661,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['configuration']
Modifiability,"-------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environmen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4240,enhance,enhanced,4240,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['enhance'],['enhanced']
Modifiability,"---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorWaveFunction; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorProbabilityF",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4579,inherit,inherited-members,4579,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['inherit'],['inherited-members']
Modifiability,"-----; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88222,refactor,refactored,88222,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['refactor'],['refactored']
Modifiability,". .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: q",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4457,inherit,inherited-members,4457,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['inherit'],['inherited-members']
Modifiability,". .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorWaveFunction; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorProbabilityFunction; :members:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4713,inherit,inherited-members,4713,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,2,['inherit'],['inherited-members']
Modifiability,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:568,inherit,inherited-members,568,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,8,['inherit'],"['inheritance', 'inherited-members']"
Modifiability,".. _correlation:. ******************************; Two-time correlation functions; ******************************. With the QuTiP time-evolution functions (for example :func:`.mesolve` and :func:`.mcsolve`), a state vector or density matrix can be evolved from an initial state at :math:`t_0` to an arbitrary time :math:`t`, :math:`\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}`, where :math:`V(t, t_0)` is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of *same-time* operators. To calculate *two-time* correlation functions on the form :math:`\left<A(t+\tau)B(t)\right>`, we can use the quantum regression theorem (see, e.g., [Gar03]_) to write. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]. We therefore first calculate :math:`\rho(t)=V(t, 0)\left\{\rho(0)\right\}` using one of the QuTiP evolution solvers with :math:`\rho(0)` as initial state, and then again use the same solver to calculate :math:`V(t+\tau, t)\left\{B\rho(t)\right\}` using :math:`B\rho(t)` as initial state. Note that if the initial state is the steady state, then :math:`\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}` and. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,. which is independent of :math:`t`, so that we only have one time coordinate :math:`\tau`. QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:247,evolve,evolved,247,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['evolve'],['evolved']
Modifiability,".. _intro:. ************; Introduction; ************. Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time.; QuTiP provides many ways to model dynamics. There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector.; When we are modeling an open system, or an ensemble of systems,; the use of the density matrix is mandatory. The following table lists of the solvers QuTiP provides for dynamic; quantum systems and indicates the type of object returned by the solver:. .. list-table:: QuTiP Solvers; :widths: 50 25 25 25; :header-rows: 1. * - Equation; - Function; - Class; - Returns; * - Unitary evolution, Schrödinger equation.; - :func:`~qutip.solver.sesolve.sesolve`; - :obj:`~qutip.solver.sesolve.SESolver`; - :obj:`~qutip.solver.result.Result`; * - Periodic Schrödinger equation.; - :func:`~qutip.solver.floquet.fsesolve`; - None; - :obj:`~qutip.solver.result.Result`; * - Schrödinger equation using Krylov method; - :func:`~qutip.solver.krylovsolve.krylovsolve`; - None; - :obj:`~qutip.solver.result.Result`; * - Lindblad master eqn. or Von Neuman eqn.; - :func:`~qutip.solver.mesolve.mesolve`; - :obj:`~qutip.solver.mesolve.MESolver`; - :obj:`~qutip.solver.result.Result`; * - Monte Carlo evolution; - :func:`~qutip.solver.mcsolve.mcsolve`; - :obj:`~qutip.solver.mcsolve.MCSolver`; - :obj:`~qutip.solver.result.McResult`; * - Non-Markovian Monte Carlo; - :func:`~qutip.solver.nm_mcsolve.nm_mcsolve`; - :obj:`~qutip.solver.nm_mcsolve.NonMarkovianMCSolver`; - :obj:`~qutip.solver.result.NmmcResult`; * - Bloch-Redfield master equation; - :func:`~qutip.solver.mesolve.brmesolve`; - :obj:`~qutip.solver.mesolve.BRSolver`; - :obj:`~qutip.solver.result.Result`; * - Floquet-Markov master equation; - :func:`~qutip.solver.floqu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-intro.rst:232,evolve,evolves,232,doc/guide/dynamics/dynamics-intro.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-intro.rst,1,['evolve'],['evolves']
Modifiability,".. _krylov:. *******************************************; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:350,evolve,evolves,350,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['evolve'],['evolves']
Modifiability,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:638,evolve,evolve,638,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['evolve'],['evolve']
Modifiability,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:479,coupling,coupling,479,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['coupling'],['coupling']
Modifiability,.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.ito,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2719,inherit,inherited-members,2719,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['inherit'],['inherited-members']
Modifiability,".rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1018,config,configured,1018,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['config'],['configured']
Modifiability,"/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. N",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2474,coupling,coupling,2474,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['coupling'],['coupling']
Modifiability,"/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33407,flexible,flexible,33407,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['flexible'],['flexible']
Modifiability,"1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6393,variab,variable,6393,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['variab'],['variable']
Modifiability,"; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12761,variab,variable,12761,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,2,['variab'],['variable']
Modifiability,"; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11887,extend,extended,11887,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['extend'],['extended']
Modifiability,">`); - lklivingstone (Added __repr__ to QobjEvo, `#2111 <https://github.com/qutip/qutip/pull/2111>`); - Yuji Tamakoshi (Improve print(qutip.settings) by make it shorter, `#2113 <https://github.com/qutip/qutip/pull/2113>`); - khnikhil (Added fermionic annihilation and creation operators, `#2166 <https://github.com/qutip/qutip/pull/2166>`); - Daniel Weiss (Improved sampling algorithm for mcsolve, `#2218 <https://github.com/qutip/qutip/pull/2218>`); - SJUW (Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05, `#2181 <https://github.com/qutip/qutip/pull/2181>`); - Valan Baptist Mathuranayagam (Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template, `#2107 <https://github.com/qutip/qutip/pull/2107>`); - Gerardo Jose Suarez (Added information on sec_cutoff to the documentation, `#2136 <https://github.com/qutip/qutip/pull/2136>`); - Cristian Emiliano Godinez Ramirez (Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver, `#2167 <https://github.com/qutip/qutip/pull/2167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse for",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:9075,inherit,inherited,9075,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['inherit'],['inherited']
Modifiability,"A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as for other solvers) and we can calculate; expectation values using:. .. code-block:: python. output = fmmesolve(H, psi0, tlist, [sigmax()], e_ops=[num(2)],; spectra_cb=[noise_spectrum], T=T, args=args); p_ex = output.expect[0]. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:15338,extend,extends,15338,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['extend'],['extends']
Modifiability,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:1794,adapt,adapted,1794,CODE_OF_CONDUCT.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md,1,['adapt'],['adapted']
Modifiability,"It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:51106,config,config,51106,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['config']
Modifiability,"It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26886,config,config,26886,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['config']
Modifiability,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:716,adapt,adaptation,716,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,3,['adapt'],"['adaptation', 'adaptations', 'adapted']"
Modifiability,"Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the docume",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:56405,flexible,flexible,56405,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['flexible'],['flexible']
Modifiability,"_image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin com",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2854,coupling,coupling,2854,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['coupling'],['coupling']
Modifiability,"a \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as for other solvers) and we can calculate; expectation values using:. .. code-block:: python. output = fmmesolve(H, psi0, tlist, [sigmax()], e_ops=[num(2)],; spectra_cb=[noise_spectrum], T=T, args=args); p_ex = output.expect[0]. .. plot::",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:14859,coupling,coupling,14859,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['coupling'],['coupling']
Modifiability,"aches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11223,layers,layers,11223,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['layers'],['layers']
Modifiability,"and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53893,adapt,adaptive,53893,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['adapt'],['adaptive']
Modifiability,"arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Giguère](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1181,maintainab,maintainability,1181,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['maintainab'],['maintainability']
Modifiability,"aths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2312,coupling,coupling,2312,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['coupling'],['coupling']
Modifiability,"atly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15753,coupling,coupling,15753,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. ..",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2567,extend,extended,2567,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['extend'],['extended']
Modifiability,"baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. .. _heom-bosonic-system-and-bath-dynamics:. System and bath dynamics; ------------------------. Now we are ready to construct a solver:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:2166,coupling,coupling,2166,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['coupling'],['coupling']
Modifiability,"bits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93590,config,configuration,93590,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['configuration']
Modifiability,"containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. .. _heom-bosonic-system-and-bath-dynamics:. System and bath dynamics; ------------------------. Now we are ready to construct a solver:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import HEOMSolver. max_depth = 5 # maximum hierarchy depth to retain; options = {""nsteps"": 15_000}. solver = HEOMSo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:2392,coupling,coupling,2392,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['coupling'],['coupling']
Modifiability,"creases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(),",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:16467,coupling,coupling,16467,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"e found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. Note that we haved labelled each bath with a tag (either ""L"" or ""R"") so that; we can identify the exponents from individual baths later when calculating; the currents b",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2740,coupling,coupling,2740,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['coupling'],['coupling']
Modifiability,"e.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hada",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104846,enhance,enhanced,104846,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['enhance'],['enhanced']
Modifiability,"f memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12577,flexible,flexible,12577,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['flexible'],['flexible']
Modifiability,"fer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0 = U(0) = \mathbb{1}` and the target :math:`X_{targ}=U_{targ}`. A *figure of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5634,variab,variables,5634,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"g/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:7962,variab,variable,7962,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['variab'],['variable']
Modifiability,"github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip. Some developments tasks remain, including providin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:13117,config,configure,13117,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['config'],['configure']
Modifiability,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3288,config,configurations,3288,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['config'],['configurations']
Modifiability,"he requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15818,coupling,coupling,15818,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"he system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10604,variab,variable,10604,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['variab'],['variable']
Modifiability,"iP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35145,layers,layers,35145,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['layers'],['layers']
Modifiability,"isation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other prope",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100345,config,configuration,100345,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['configuration']
Modifiability,"issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Chri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2948,layers,layers,2948,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['layers'],['layers']
Modifiability,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:19536,config,config,19536,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['config'],['config']
Modifiability,"lication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97708,enhance,enhancements,97708,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['enhance'],['enhancements']
Modifiability,"lve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simon Cross.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:1799,rewrite,rewrite,1799,doc/guide/heom/history.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst,1,['rewrite'],['rewrite']
Modifiability,lver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ----------------,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2603,inherit,inherited-members,2603,doc/apidoc/classes.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst,1,['inherit'],['inherited-members']
Modifiability,"me as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:3116,enhance,enhancement,3116,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['enhance'],['enhancement']
Modifiability,"mes). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e_ops=num(2)).expect[0]; data2 = sesolve(H, psi0, tlist, e_ops=num(2), options={""max_step"": 0.01}).expect[0]. plt.plot(tlist, data1, label=""no max_step""); plt.plot(tlist, data2, label=""fixed max_step""); plt.fill_between(tlist, [pulse(t) for t in tlist], color=""g"", alpha=0.2, label=""pulse""); plt.ylim([-0.1, 1.1]); plt.legend(loc=""center left""). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16545,variab,variable,16545,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['variab'],['variable']
Modifiability,"min lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9635,variab,variable,9635,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['variab'],['variable']
Modifiability,"n must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <htt",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12619,flexible,flexible,12619,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['flexible'],['flexible']
Modifiability,"n:. .. code-block:: python. H = tensor(H_t, qeye(2)); c_op = tensor(QobjEvo([destroy(N), lambda t: np.exp(-t)]), sigmax()). L = -1j * (spre(H) - spost(H.dag())); L += spre(c_op) * spost(c_op.dag()) - 0.5 * spre(c_op.dag() * c_op) - 0.5 * spost(c_op.dag() * c_op). Or equivalently:. .. code-block:: python. L = liouvillian(H, [c_op]). Using arguments; ---------------. Until now, the coefficients were only functions of time. In the definition of ``H1_coeff``,; the driving amplitude ``A`` and width ``sigma`` were hardcoded with their numerical values.; This is fine for problems that are specialized, or that we only want to run once.; However, in many cases, we would like study the same problem with a range of parameters and; not have to worry about manually changing the values on each run.; QuTiP allows you to accomplish this using by adding extra arguments to coefficients; function that make the :obj:`.QobjEvo`. For instance, instead of explicitly writing; 9 for the amplitude and 5 for the width of the gaussian driving term, we can add an; `args` positional variable:. .. code-block:: python. >>> def H1_coeff(t, args):; >>> return args['A'] * np.exp(-(t/args['sigma'])**2). or, new from v5, add the extra parameter directly:. .. code-block:: python. >>> def H1_coeff(t, A, sigma):; >>> return A * np.exp(-(t / sigma)**2). When the second positional input of the coefficient function is named ``args``,; the arguments are passed as a Python dictionary of ``key: value`` pairs.; Otherwise the coefficient function is called as ``coeff(t, **args)``.; In the last example, ``args = {'A': a, 'sigma': b}`` where ``a`` and ``b`` are the; two parameters for the amplitude and width, respectively.; This ``args`` dictionary need to be given at creation of the :obj:`.QobjEvo` when; function using then are included:. .. code-block:: python. >>> system = [sigmaz(), [sigmax(), H1_coeff]]; >>> args={'A': 9, 'sigma': 5}; >>> qevo = QobjEvo(system, args=args). But without ``args``, the :obj:`.QobjE",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:8664,variab,variable,8664,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['variab'],['variable']
Modifiability,"nade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Giguère](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1120,maintainab,maintainability,1120,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['maintainab'],['maintainability']
Modifiability,"nx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12284,config,configuration,12284,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['config'],['configuration']
Modifiability,"objEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. M",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9487,variab,variables,9487,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['variab'],['variables']
Modifiability,"oints. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varied according to the number of points and vectors added. But what if you want a different choice of color, or you want your sphere to be purple with different axes labels? Well then you are in luck as the Bloch class has 22 attributes which one can control. Assuming ``b=Bloch()``:. .. tabularcolumns:: | p{3cm} | p{7cm} | p{7cm} |. .. cssclass:: table-striped. +---------------+---------------------------------------------------------+-------------------------------------------------+; | Attribute | Function | Default Setting |; +===============+=========================================================+=================================================+; | b.axes | Matplotlib axes instance for animations. Set by ``axes``| ``None`` |; | | keyword ar",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:5193,config,config,5193,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['config'],['config']
Modifiability,"on is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; S",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12175,config,configuration,12175,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['config'],['configuration']
Modifiability,"ork; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10000,variab,variable,10000,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['variab'],['variable']
Modifiability,"oved mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Giguère**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Giguère**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Giguère**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) whi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92271,variab,variable,92271,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['variab'],['variable']
Modifiability,"pha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:14586,coupling,coupling,14586,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['coupling'],['coupling']
Modifiability,"propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE*",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103328,variab,variables,103328,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['variab'],['variables']
Modifiability,"r the real part, :math:`C_{real}(t)`:. .. math::. \nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}. c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}. and the imaginary part, :math:`C_{imag}(t)`:. .. math::. \nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. And now the same numbers calculated in Python:. .. plot::; :context:; :nofigs:. # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we're done!. The :class:`~qutip.solver.heom.BosonicBath` can be used with the; :class:`~qutip.solver.heom.HEOMSolver` in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths; --------------. The :class:`~qutip.solver.heom.HEOMSolver` supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath. In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fenna–Matth",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:9673,extend,extend,9673,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['extend'],['extend']
Modifiability,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-red",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1657,coupling,coupling,1657,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"ribed by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take the driving into account when deriving the master equation. This can be; done in many different ways, but one way common approach is to derive the master; equation in the Floquet basis. That approach results in the so-called Floquet-Markov; master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:12921,coupling,coupling,12921,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['coupling'],['coupling']
Modifiability,"s. :math:`U(t)` is a solution to the *Schrödinger operator equation*. .. math::. \tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}. We can use optimal control algorithms to determine a set of :math:`u_j` that will drive our system from :math:`\ket{\psi_0}` to :math:`\ket{\psi_1}`, this is state-to-state transfer, or drive the system from some arbitary state to a given state :math:`\ket{\psi_1}`, which is state preparation, or effect some unitary transformation :math:`U_{target}`, called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm; ===================; The **GR**\ adient **A**\ scent **P**\ ulse **E**\ ngineering was first proposed in [NKanej]_. Solutions to Schrödinger's equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve :math:`T` is split into :math:`M` timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. .. math::. H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad. where :math:`k` is a timeslot index, :math:`j` is the control index, and :math:`N` is the number of controls. Hence :math:`t_k` is the evolution time at the start of the timeslot, and :math:`u_{jk}` is the amplitude of control :math:`j` throughout timeslot :math:`k`. The time evolution operator, or propagator, within the timeslot can then be calculated as:. .. math::. X_k:=e^{-iH(t_k)\Delta t_k}. where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution :math:`k=M`) can the be calculated as. .. math::. X(t_k):=X_k X_{k-1}\cdots X_1 X_0. If the objective is state-to-state transfer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:3785,evolve,evolve,3785,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['evolve'],['evolve']
Modifiability,"st(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real numb",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28678,extend,extended,28678,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['extend'],['extended']
Modifiability,"t interaction term. To simplify the numerical implementation we assume that :math:`A_\alpha` are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. .. math::; :label: br-tensor. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:9885,coupling,coupling,9885,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"t=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plot(tlist, [H(t).norm() for t in tlist], label=""CubicSpline""). H = QobjEvo([qeye(1), coeff], tlist=times, order=0); plt.plot(tlist, [H(t).norm() for t in tlist], label=""step""). H = QobjEvo([qeye(1), coeff], tlist=times, order=1); plt.plot(tlist, [H(t).norm() for t in tlist], label=""linear""). plt.legend(). When using array coefficients in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:15321,extend,extended,15321,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['extend'],['extended']
Modifiability,"tered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} *",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:16107,coupling,coupling,16107,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4634,extend,extending,4634,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['extend'],['extending']
Modifiability,"tian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to spe",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:37503,flexible,flexible,37503,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['flexible'],['flexible']
Modifiability,"tps://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quan",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2716,coupling,coupling,2716,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['coupling'],['coupling']
Modifiability,"ts. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6014,variab,variables,6014,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algori",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8616,variab,variable,8616,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['variab'],['variable']
Modifiability,"will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39150,extend,extended,39150,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['extend'],['extended']
Modifiability,"x code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4915,config,config,4915,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['config'],['config']
Modifiability,"you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15361,coupling,coupling,15361,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['coupling'],['coupling']
Modifiability,"ystem coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. .. _heom-bosonic-system-and-bath-dynamics:. System and bath dynamics; ------------------------. Now we are ready to construct a solver:. .. plot::; :context:; :nofigs:. from qutip.solver.he",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:2222,coupling,coupling,2222,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['coupling'],['coupling']
Modifiability,"ze_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Giguère); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fses",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71034,config,configuration,71034,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['config'],['configuration']
Modifiability,"{# Import the theme's layout. #}; {% extends ""!layout.html"" %}. {# Custom CSS overrides #}; {% set bootswatch_css_custom = ['_static/site.css'] %}",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/templates/layout.html:37,extend,extends,37,doc/templates/layout.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/templates/layout.html,1,['extend'],['extends']
Modifiability,"{- \nu_{k,imag} t}. In the specific case of Matsubara expansion for the Drude-Lorentz bath, the; coefficients of this expansion are, for the real part, :math:`C_{real}(t)`:. .. math::. \nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}. c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}. and the imaginary part, :math:`C_{imag}(t)`:. .. math::. \nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. And now the same numbers calculated in Python:. .. plot::; :context:; :nofigs:. # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we're done!. The :class:`~qutip.solver.heom.BosonicBath` can be used with the; :class:`~qutip.solver.heom.HEOMSolver` in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths; --------------. The :class:`~qutip.solver.heom.HEOMSolver` supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath. In the example below we calculate the evolution of a small s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:9527,extend,extend,9527,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['extend'],['extend']
Performance," Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulatio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113852,perform,performance,113852,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1213,perform,performance,1213,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['perform'],['performance']
Performance," Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:37630,perform,performance,37630,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance," different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:4904,perform,performs,4904,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['perform'],['performs']
Performance," documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80003,load,loading,80003,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['load'],['loading']
Performance," from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map :math:`\Lambda(\rho) = \rho^{\mathrm{T}}` is a positive map. We run into; problems, however, if we tensor :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:41676,perform,perform,41676,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['perform'],['perform']
Performance," function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95636,optimiz,optimization,95636,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['optimiz'],['optimization']
Performance," thereby obtain a master equation for the motion of the original system density; matrix. The most general trace-preserving and completely positive form of this; evolution is the Lindblad master equation for the reduced density matrix; :math:`\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]`. .. math::; 	:label: lindblad_master_equation. 	\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]. where the :math:`C_n = \sqrt{\gamma_n} A_n` are collapse operators, and; :math:`A_n` are the operators through which the environment couples to the; system in :math:`H_{\rm int}`, and :math:`\gamma_n` are the corresponding rates.; The derivation of Eq. :eq:`lindblad_master_equation` may be found in several; sources, and will not be reproduced here. Instead, we emphasize the; approximations that are required to arrive at the master equation in the form; of Eq. :eq:`lindblad_master_equation` from physical arguments, and hence; perform a calculation in QuTiP:. - **Separability:** At :math:`t=0` there are no correlations between the system; and its environment such that the total density matrix can be written as a; tensor product :math:`\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)`. - **Born approximation:** Requires: (1) that the state of the environment does; not significantly change as a result of the interaction with the system;; (2) The system and the environment remain separable throughout the evolution.; These assumptions are justified if the interaction is weak, and if the; environment is much larger than the system. In summary,; :math:`\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}`. - **Markov approximation** The time-scale of decay for the environment; :math:`\tau_{\rm env}` is much shorter than the smallest time-scale of the; system dynamics :math:`\tau_{\rm sys} \gg \tau_{\rm env}`. This approximation; is often deemed a ""short-memory environment"" as it requ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:8310,perform,perform,8310,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['perform'],['perform']
Performance," vector_to_operator, liouvillian, spost, spre, sprepost, lindblad_dissipator. Superoperator Representations; -----------------------------. .. automodule:: qutip.core.superop_reps; :members: kraus_to_choi, kraus_to_super, to_choi, to_chi, to_super, to_kraus, to_stinespring; :undoc-members:. Operators and Superoperator Dimensions; --------------------------------------. .. automodule:: qutip.core.dimensions; :members: to_tensor_rep, from_tensor_rep. Functions acting on states and operators; ========================================. Expectation Values; ------------------. .. automodule:: qutip.core.expect; :members: expect, variance. Tensor; ------. .. automodule:: qutip.core.tensor; :members: tensor, super_tensor, composite, tensor_contract. Partial Transpose; -----------------. .. automodule:: qutip.partial_transpose; :members: partial_transpose. .. _functions-entropy:. Entropy Functions; -----------------. .. automodule:: qutip.entropy; :members: concurrence, entropy_conditional, entropy_linear, entropy_mutual, entropy_relative, entropy_vn. Density Matrix Metrics; ----------------------. .. automodule:: qutip.core.metrics; :members: fidelity, tracedist, bures_dist, bures_angle, hellinger_dist, hilbert_dist, average_gate_fidelity, process_fidelity, unitarity, dnorm. Continuous Variables; --------------------. .. automodule:: qutip.continuous_variables; :members: correlation_matrix, covariance_matrix, correlation_matrix_field, correlation_matrix_quadrature, wigner_covariance_matrix, logarithmic_negativity. Measurement; ===========. Measurement of quantum states; -----------------------------. .. automodule:: qutip.measurement; :members: measure, measure_povm, measure_observable, measurement_statistics, measurement_statistics_observable, measurement_statistics_povm. Dynamics and Time-Evolution; ===========================. Schrödinger Equation; --------------------. .. automodule:: qutip.solver.sesolve; :members: sesolve. Master Equation; ---------------. .. automodul",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:2940,concurren,concurrence,2940,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['concurren'],['concurrence']
Performance,"). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions :func:`qutip.fileio.file_data_store` and :func:`qutip.fileio.file_data_read` we can store and load **numpy** arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format. The :func:`qutip.fileio.file_data_store` takes two mandatory and three optional arguments:. >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") # doctest: +SKIP. where `filename` is the name of the file, `data` is the data to be written to the file (must be a *numpy* array), `numtype` (optional) is a flag indicating numerical type that can take values ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:3142,load,loading,3142,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['loading']
Performance,"------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.molmer_sorensen` | Molmer Sorensen gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.toffoli` | Toffoli gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.hadamard_transform` | Hadamard gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.qubit_clifford_group` | Generates the Clifford group on a single qubit |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). n",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:22278,load,load,22278,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['load'],['load']
Performance,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12281,optimiz,optimization,12281,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['optimiz'],['optimization']
Performance,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:249,load,load,249,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,3,['load'],"['load', 'loaded']"
Performance,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:646,load,load,646,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['load'],['load']
Performance,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:745,load,load,745,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,2,['load'],"['load', 'loads']"
Performance,".. _measurement:. ******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:569,perform,perform,569,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['perform'],['perform']
Performance,".. _saving:. **********************************; Saving QuTiP Objects and Data Sets; **********************************. With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]]",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:608,perform,performed,608,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,3,"['load', 'perform']","['load', 'loading', 'performed']"
Performance,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:350,perform,performing,350,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['perform'],['performing']
Performance,".. _visual:. .. plot::; :include-source: False. import numpy as np. from qutip import *. import pylab as plt. from warnings import warn. plt.close(""all""). *********************************************; Visualization of quantum states and processes; *********************************************. Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. .. _visual-fock:. Fock-basis probability distribution; ===================================. In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian :math:`H = \hbar\omega a^\dagger a`, which is; in a state described by its density matrix :math:`\rho`, and which on average; is occupied by two photons, :math:`\mathrm{Tr}[\rho a^\dagger a] = 2`. Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained. One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribution, which can be obtained from the diagonal of the density matrix,; for a few possible oscilla",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:824,perform,perform,824,doc/guide/guide-visualization.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst,1,['perform'],['perform']
Performance,".toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9190,load,load,9190,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['load'],['load']
Performance,"00000j,1.7435892209+0.0000000000j,-0.1126550232+0.0000000000j,0.2497182058+0.0000000000j; 5.0505050505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn't really need to store both the real and imaginary parts, so instead we could use the ``numtype=""real""`` option. .. plot::; :context:. >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the ``numformat=""exp""`` option. .. plot::; :context:. >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using :func:`qutip.fileio.file_data_store` (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the :func:`qutip.fileio.file_data_read`, which only takes the filename as mandatory argument. .. plot::; :context:. input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example ``sep=""_""`` if ``_`` is the deliminator).; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:7402,load,loaded,7402,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['loaded']
Performance,"167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:10170,perform,performance,10170,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. .. math::; :label: schrodinger. 	i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,. where :math:`\Psi` is the wave function, :math:`\hat H` the Hamiltonian, and; :math:`\hbar` is Planck's constant. In general, the Schrödinger equation is a; partial differential equation (PDE) where both :math:`\Psi` and :math:`\hat H`; are functions of space and time. For computational purposes it is useful to; expand the PDE in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:1142,perform,perform,1142,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['perform'],['perform']
Performance,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:837,perform,performance,837,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['perform'],['performance']
Performance,"_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10063,optimiz,optimize,10063,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['optimiz'],['optimize']
Performance,"_image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin com",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2809,perform,performed,2809,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['perform'],['performed']
Performance,"`1111.6950`. .. [dAless08]; D. d’Alessandro, *Introduction to Quantum Control and Dynamics*, (Chapman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Müller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296–305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and autom",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst:2709,optimiz,optimization,2709,doc/biblio.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst,1,['optimiz'],['optimization']
Performance,"``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:1409,perform,performed,1409,doc/guide/heom/history.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst,1,['perform'],['performed']
Performance,"a: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load ag",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:1313,load,loads,1313,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['loads']
Performance,"ad to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introdu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:10639,optimiz,optimize,10639,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['optimiz'],['optimize']
Performance,"apman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Müller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296–305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and automatic differentiation*, Phys. Rev. A **99**, 052327 (2019). :doi:`10.1103/PhysRevA.99.052327`.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst:2897,optimiz,optimization,2897,doc/biblio.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst,1,['optimiz'],['optimization']
Performance,"ate. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6824,perform,perform,6824,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['perform'],['perform']
Performance,"bitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115374,optimiz,optimized,115374,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['optimiz'],['optimized']
Performance,"creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculptur",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:2623,perform,performance,2623,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,3,['perform'],"['perform', 'performance']"
Performance,"ction for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110320,optimiz,optimized,110320,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['optimiz'],['optimized']
Performance,"d a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; =",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1684,perform,performance,1684,doc/development/ideas/tensorflow-data-backend.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst,1,['perform'],['performance']
Performance,"e first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Outpu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6437,perform,perform,6437,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['perform'],['perform']
Performance,"e stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions :func:`qutip.fileio.file_data_store` and :func:`qutip.fileio.file_data_read` we can store and load **numpy** arrays and matrices to files on disk using a deliminator-separated value format (for example c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:2677,load,loaded,2677,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['loaded']
Performance,"e; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2815,optimiz,optimize,2815,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['optimiz'],['optimize']
Performance,"ed.; Use ``rand_dm(distribution=""hs"")`` and ``rand_dm(distribution=""ginibre"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``.; - Dimensions use a class instead of layered lists.; - Allow measurement functions to support degenerate operators.; - Add ``qeye_like`` and ``qzero_like``.; - Added fermionic annihilation and creation operators. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:24317,load,load,24317,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['load'],['load']
Performance,"ed; using the isomorphism; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}` [Hav03]_, [Wat13]_.; To represent superoperators acting on :math:`\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)` thus takes some tensor rearrangement to get the desired ordering; :math:`\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2`. In particular, this means that :func:`.tensor` does not act as; one might expect on the results of :func:`.to_super`:. .. doctest:: [tensor]. >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representati",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:10289,perform,performs,10289,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['perform'],['performs']
Performance,"ew; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1712,perform,perform,1712,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['perform'],['perform']
Performance,"explicit dimensions are required.; - The function ``rand_unitary_haar`` has been removed. Use; ``rand_unitary(distribution=""haar"")`` instead.; - The functions ``rand_dm_hs`` and ``rand_dm_ginibre`` have been removed.; Use ``rand_dm(distribution=""hs"")`` and ``rand_dm(distribution=""ginibre"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49335,load,load,49335,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['load'],['load']
Performance,"f version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latte",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5178,load,load,5178,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['load'],['load']
Performance,"h:`\left<A(t)B(t+\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | | :math:`\left<A(\tau)B(0)\right>` or |; | :func:`qutip.correlation_2op_1t` | :math:`\left<A(0)B(\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_1t` | :math:`\left<A(0)B(\tau)C(0)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_2t` | :math:`\left<A(t)B(t+\tau)C(t)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op` | :math:`\left<A(t)B(t+\tau)C(t)\right>`. |; +----------------------------------+--------------------------------------------------+. The most common use-case is to calculate the two time correlation function :math:`\left<A(\tau)B(0)\right>`. :func:`.correlation_2op_1t` performs this task with sensible default values, but only allows using the :func:`.mesolve` solver. From QuTiP 5.0 we added :func:`.correlation_3op`. This function can also calculate correlation functions with two or three operators and with one or two times. Most importantly, this function accepts alternative solvers such as :func:`.brmesolve`. .. _correlation-steady:. Steadystate correlation function; ================================. The following code demonstrates how to calculate the :math:`\left<x(t)x(0)\right>` correlation for a leaky cavity with three different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3))",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:3327,perform,performs,3327,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['perform'],['performs']
Performance,"have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7385,perform,perform,7385,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['perform'],['perform']
Performance,"hod need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance compared with; the standard SuperLU method used by SciPy. To verify that QuTiP can find the; necessary libraries, one can check for ``INTEL MKL Ext: True`` in the QuTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:3123,perform,performance,3123,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['perform'],['performance']
Performance,"https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made signi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66922,perform,performance,66922,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"ion_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj obj",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95937,load,loading,95937,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['load'],['loading']
Performance,"ks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------; - Fixed text alignment issues in AboutBox. - Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module. - Added tidyup function to tensor function output. - Removed openmp flags from setup.py as new ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115602,concurren,concurrence,115602,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['concurren'],['concurrence']
Performance,"ld look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13357,perform,perform,13357,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['perform'],['perform']
Performance,"lication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97696,perform,performance,97696,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"ll be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:14895,scalab,scalability,14895,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['scalab'],['scalability']
Performance,"lude-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:1080,load,load,1080,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,1,['load'],['load']
Performance,"me steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 20",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54926,load,loaded,54926,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['load'],['loaded']
Performance,"nction. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user de",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:112007,perform,performance,112007,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"of the remaining portions of this section. .. _master-master:. The Lindblad Master equation; =============================. The standard approach for deriving the equations of motion for a system; interacting with its environment is to expand the scope of the system to; include the environment. The combined quantum system is then closed, and its; evolution is governed by the von Neumann equation. .. math::; :label: neumann_total. \dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],. the equivalent of the Schrödinger equation :eq:`schrodinger` in the density; matrix formalism. Here, the total Hamiltonian. .. math::. 	H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},. includes the original system Hamiltonian :math:`H_{\rm sys}`, the Hamiltonian; for the environment :math:`H_{\rm env}`, and a term representing the interaction; between the system and its environment :math:`H_{\rm int}`. Since we are only; interested in the dynamics of the system, we can at this point perform a partial; trace over the environmental degrees of freedom in Eq. :eq:`neumann_total`, and; thereby obtain a master equation for the motion of the original system density; matrix. The most general trace-preserving and completely positive form of this; evolution is the Lindblad master equation for the reduced density matrix; :math:`\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]`. .. math::; 	:label: lindblad_master_equation. 	\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]. where the :math:`C_n = \sqrt{\gamma_n} A_n` are collapse operators, and; :math:`A_n` are the operators through which the environment couples to the; system in :math:`H_{\rm int}`, and :math:`\gamma_n` are the corresponding rates.; The derivation of Eq. :eq:`lindblad_master_equation` may be found in several; sources, and will not be reproduced here. Instead, we emphasize the; approximations that are require",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:7193,perform,perform,7193,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['perform'],['perform']
Performance,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:117702,concurren,concurrence,117702,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,"['concurren', 'load']","['concurrence', 'loading']"
Performance,"ory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file for",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:2299,load,load,2299,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['load']
Performance,"penQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Giguère**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80411,perform,performance,80411,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1499,perform,performances,1499,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['perform'],['performances']
Performance,"rce framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5084,perform,performance,5084,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['perform'],['performance']
Performance,"re Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimens",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:9585,perform,performing,9585,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['perform'],['performing']
Performance,"refixed with ``plot_`` (e.g., ``plot_fock_distribution``). The; ``plot_wigner`` and ``plot_wigner_fock_distribution`` now supports 3D views; in addition to contour views. - New API and new functions for working with spin operators and states,; including for example ``spin_Jx``, ``spin_Jy``, ``spin_Jz`` and; ``spin_state``, ``spin_coherent``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qubit states using ``ket`` function. - The module ``qutip.cyQ`` has been renamed to ``qutip.cy`` and the sparse; matrix-vector functions ``spmv`` and ``spmv1d`` has been combined into one; function ``spmv``. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., ``spmv_csr``). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:109233,concurren,concurrence,109233,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['concurren'],['concurrence']
Performance,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4560,perform,perform,4560,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,5,['perform'],"['perform', 'performance', 'performances']"
Performance,"s the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39472,cache,cached,39472,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['cache'],['cached']
Performance,"s:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :include-source:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8954,perform,perform,8954,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['perform'],['perform']
Performance,"show(). Stepping through the run; ------------------------. The solver class also allows to run through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4241,perform,performance,4241,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['perform'],['performance']
Performance,"singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public r",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:3995,perform,performance,3995,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,3,['perform'],"['performance', 'performed', 'performer']"
Performance,"sts. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:56561,load,loading,56561,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['load'],['loading']
Performance,"te this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8310,perform,performance,8310,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['perform'],['performance']
Performance,"tochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105546,perform,performance,105546,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"tor :math:`C_{n}` is chosen such that :math:`n` is the smallest; integer satisfying:. .. math::; :label: mc3. \sum_{i=1}^{n} P_{n}(\tau) \ge r_2. where the individual :math:`P_{n}` are given by Eq. :eq:`pcn`. Note that the; left hand side of Eq. :eq:`mc3` is, by definition, normalized to unity. - **IV:** Using the renormalized state from step III as the new initial; condition at time :math:`\tau`, draw a new random number, and repeat the; above procedure until the final simulation time is reached. .. _monte-qutip:. Monte Carlo in QuTiP; ====================. In QuTiP, Monte Carlo evolution is implemented with the :func:`.mcsolve`; function. It takes nearly the same arguments as the :func:`.mesolve`; function for master-equation evolution, except that the initial state must be a; ket vector, as oppose to a density matrix, and there is an optional keyword; parameter ``ntraj`` that defines the number of stochastic trajectories to be; simulated. By default, ``ntraj=500`` indicating that 500 Monte Carlo; trajectories will be performed. To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,; let's again consider the case of a two-level atom coupled to a leaky cavity.; The only differences to the master-equation treatment is that in this case we; invoke the :func:`.mcsolve` function instead of :func:`.mesolve`. .. plot::; :context: reset. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). .. guide-dynamics-mc1:. The advantage of the Monte Carlo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:4313,perform,performed,4313,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['perform'],['performed']
Performance,"uct.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders.; - The spline type can take ``bc_type`` to control the boundar",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:12209,cache,cached,12209,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['cache'],['cached']
Performance,"upport for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for high",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111039,perform,performance,111039,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performance']
Performance,"urement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues # doctest: +NORMALIZE_WHITESPACE; array([-1., 1.]). >>> eigenstates # doctest: +NORMALIZE_WHITESPACE; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [-0.70710678]],; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]]], dtype=object). >>> probabilities # doctest: +NORMALIZE_WHITESPACE; [0.5000000000000001, 0.4999999999999999]. The :func:`~qutip.measurement.measurement_statistics` function then returns three values; when called with a single observable:. - `eigenvalues` is an array of eigenvalues of the measurement operator, i.e.; a list of the possible measurement results. In our example; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7930,perform,perform,7930,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['perform'],['perform']
Performance,"vers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip. Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. .. _qmain-reorg:. qutip main reorganization; -------------------------. :tag: qmain-reorg; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Reorganise qutip main components to the structure :ref:`described above <qmain>`. .. _qmain-docs:. qutip user docs migration; -------------------------. :tag: qmain-docs; :status: completed; :admin lead: `Jake Lishman <https://github.com/jakelishman>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:14065,perform,performance,14065,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['perform'],['performance']
Performance,"who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:5393,perform,performance,5393,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['perform'],['performance']
Performance,"y QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:1852,load,loaded,1852,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['loaded']
Performance,"y optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:98873,perform,performs,98873,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['perform'],['performs']
Performance,"y_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions :func:`qutip.fileio.file_data_store` and :func:`qutip.fileio.file_data_read` we can store and load **numpy** arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format. The :func:`qutip.fileio.file_data_store` takes two mandatory and three optional arguments:. >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") # doctest: +SKIP. where `filename` is the name of the file, `data` is the data to be written to the file (must be a *numpy* array), `numtype` (optional) is a flag indicating numerical type that can take values `complex` or `real`, `numformat` (optional) specifies the numerical format that can take the values `exp` for the format `1.0e1` and `decimal` for the format `10.0`, and `sep` (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.). A common use for the :func:`qutip.fileio.file_data_store` function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the :func:`.mesolve` funct",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:3587,load,load,3587,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['load'],['load']
Performance,"you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the rele",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11668,perform,perform,11668,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['perform'],['perform']
Safety," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1158,avoid,avoidance,1158,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['avoid'],['avoidance']
Safety," import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj]. def measure_2folds_4modes_squashing(N,psi,proj,proj2):; 	""""""; 	Determines the 2-fold count rate on the joint state ; 	outputs for an array of double count probabilities.; 	; 	Parameters; 	----------; 	N : int; 	 The Fock Space dimension.; 	psi : qobj; 	 The entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the C",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:1381,detect,detection,1381,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detection']
Safety," to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for altern",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12902,avoid,avoid,12902,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['avoid'],['avoid']
Safety,"- tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumP",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103453,avoid,avoid,103453,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avoid'],['avoid']
Safety,"-------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environmen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4142,detect,detect,4142,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['detect'],['detect']
Safety,"------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8444,timeout,timeout,8444,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['timeout'],['timeout']
Safety,"-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96113,safe,safety,96113,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['safe'],['safety']
Safety,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:539,detect,detector,539,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,2,['detect'],['detector']
Safety,". - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97605,avoid,avoid,97605,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avoid'],['avoid']
Safety,".. _stochastic:. *******************************************; Stochastic Solver; *******************************************. .. _stochastic-intro:. When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations.; The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record. In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. .. math::; :label: general_form. d \rho (t) = d_1 \rho \, dt + \sum_n d_{2,n} \rho \, dW_n,. where :math:`dW_n` is a Wiener increment, which has the expectation values :math:`E[dW] = 0` and :math:`E[dW^2] = dt`. Stochastic Schrodinger Equation; ===============================. .. _sse-solver:. The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]_). .. math::; :label: jump_ssesolve. d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,. where :math:`H` is the Hamiltonian, :math:`S_n` are the stochastic collapse operators, and :math:`e_n` is. .. math::; :label: jump_matrix_element. e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic opera",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:228,detect,detection,228,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['detect'],['detection']
Safety,"/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Giguère). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wikståhl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:69031,sanity check,sanity checks,69031,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['sanity check'],['sanity checks']
Safety,"0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4576,detect,detection,4576,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detection']
Safety,"4-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28327,timeout,timeouts,28327,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['timeout'],['timeouts']
Safety,": [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14558,avoid,avoided,14558,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['avoid'],['avoided']
Safety,"; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). st",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4235,detect,detection,4235,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['detect'],['detection']
Safety,"Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj]. def measure_2folds_4modes_squashing(N,psi,proj,proj2):; 	""""""; 	Determines the 2-fold count rate on the joint state ; 	outp",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:1136,detect,detectors,1136,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detectors']
Safety,"ady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floque",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18069,timeout,timeout,18069,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['timeout'],['timeout']
Safety,"any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Giguère**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Giguère**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Giguère**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**);",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85937,unsafe,unsafe,85937,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['unsafe'],['unsafe']
Safety,"ction for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110413,avoid,avoiding,110413,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avoid'],['avoiding']
Safety,"e :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _N",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5926,detect,detect,5926,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['detect'],['detect']
Safety,"ectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8968,timeout,timeout,8968,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['timeout'],['timeout']
Safety,"ent detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4297,detect,detection,4297,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detection']
Safety,"fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. openmcsolve:. Open Systems; ------------. ``mcsolve`` can be used to study systems which have measurement and dissipative; interactions with their environment. This is done by passing a Liouvillian including the; dissipative interaction to the solver instead of a Hamiltonian.; In this case the effective Liouvillian becomes:. .. math::; :label: Leff. L_{\rm eff}\rho = L_{\rm sys}\rho -\frac{1}{2}\sum_{i}\left( C^{+}_{n}C_{n}\rho + \rho C^{+}_{n}C_{n}\right),. With the collapse probability becoming:. .. math::; :label: L_jump. \delta p =\delta t \sum_{n}\mathrm{tr}\left(\rho(t)C^{+}_{n}C_{n}\right),. And a jump with the collapse operator ``n`` changing the state as:. .. math::; :label: L_project. \rho(t+\delta t) = C_{n} \rho(t) C^{+}_{n} / \mathrm{tr}\left( C_{n} \rho(t) C^{+}_{n} \right),. We can redo the previous example for a situation where only half the emitted photons are detected. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); L = liouvillian(H, [np.sqrt(0.05) * a]); data = mcsolve(L, psi0, times, [np.sqrt(0.05) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:18105,detect,detected,18105,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,2,['detect'],"['detected', 'detections']"
Safety,"fy; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad an",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11660,avoid,avoided,11660,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['avoid'],['avoided']
Safety,"hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6069,detect,detection,6069,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detection']
Safety,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3100,detect,detector,3100,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,3,['detect'],['detector']
Safety,"ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj]. def measure_2folds_4modes_squashing(N,psi,proj,proj2):; 	""""""; 	Determines the 2-fold count rate on the joint state ; 	outputs for an array of double count probabilities.; 	; 	Parameters; 	----------; 	N : int; 	 The Fock Space dimension.; 	psi : qobj; 	 The entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement veric",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:1607,detect,detection,1607,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detection']
Safety,"nnes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other properties and methods were renamed at the same time. A full list is given here. - All modules; - function: ``set_log_level`` -> property: ``log_level``. - dynamics functions. - ``_init_lists`` now ``_init_evo``; - ``get_num_ctrls`` now property: ``num_ctrls``; - ``get_owd_evo_target`` now property: ``onto_evo_target``; - ``combine_dyn_gen`` now ``_combine_dyn_gen`` (no longer returns a value); - ``get_dyn_gen`` now ``_get_phased_d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100717,avoid,avoided,100717,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['avoid'],['avoided']
Safety,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` par",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:43186,timeout,timeout,43186,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['timeout'],['timeout']
Safety,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:16489,timeout,timeout,16489,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['timeout'],['timeout']
Safety,"of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8808,timeout,timeout,8808,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['timeout'],['timeout']
Safety,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1667,avoid,avoid,1667,doc/development/ideas/quantum-error-mitigation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst,1,['avoid'],['avoid']
Safety,"ons for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4408,detect,detection,4408,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['detect'],['detection']
Safety,"ossibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28811,redund,redundant,28811,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['redund'],['redundant']
Safety,"pect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4358,detect,detection,4358,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['detect'],['detection']
Safety,"plification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:5681,detect,detectors,5681,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,2,['detect'],"['detection', 'detectors']"
Safety,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:5988,detect,detection,5988,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,2,['detect'],['detection']
Safety,"r applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,. d. to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. i. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;. ii. Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; right to collect such royalties for any exercise by You of the; rights granted under this License; and,. iii. Voluntary License Schemes. The Licensor waives the right to collect; royalties, whether individually or, in the event that the Licensor; is a member of a collecting society that administers voluntary; licensing schemes, via that society, from any exercise by You of; the rights granted under this License. The above rights may be exercised in all me",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:6722,avoid,avoidance,6722,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['avoid'],['avoidance']
Safety,"right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic operator list (``sc_ops``). As with the :func:`~qutip.solver.mcsolve.mcsolve`,; the number of trajectories and the seed for the noise realisation can be fixed using; the arguments: ``ntraj`` and ``seeds``, respectively. If the user also requires the; measurement output, the options entry ``{""store_measurement"": True}`` should be included. Per default, homodyne is used. Heterodyne detections can be easily simulated by passing; the arguments ``'heterodyne=True'`` to :func:`~qutip.solver.stochastic.ssesolve`. ..; Examples of how to solve the stochastic Schrodinger equation using QuTiP; can be found in this `development notebook <...TODO-Merge 61...>`_. Stochastic Master Equation; ==========================. .. Stochastic Master equation. When the initial state of the system is a density matrix :math:`\rho`, the stochastic master equation solver :func:`qutip.stochastic.smesolve` must be used.; The stochastic master equation is given by (see section 4.4, [Wis09]_). .. math::; :label: stochastic_master. d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t). where. .. math::; :label: dissipator. D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],. and. .. math::; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:2379,detect,detections,2379,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['detect'],['detections']
Safety,"rpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6194,detect,detection,6194,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['detect'],['detection']
Safety,"te Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are co",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8661,timeout,timeout,8661,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['timeout'],['timeout']
Safety,"tories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9530,timeout,timeout,9530,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['timeout'],['timeout']
Safety,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., ""French translation of the Work by Original; Author,"" or ""Screenplay based on original Work by Original Author""). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:11180,avoid,avoidance,11180,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['avoid'],['avoidance']
Safety,"wn_key=(1,),),; SeedSequence(entropy=1,spawn_key=(0,),),; SeedSequence(entropy=1,spawn_key=(2,),)]. >>> print(res_ser.seeds[:3]); [SeedSequence(entropy=1,spawn_key=(0,),),; SeedSequence(entropy=1,spawn_key=(1,),),; SeedSequence(entropy=1,spawn_key=(2,),)]. Photocurrent; ------------. The photocurrent, previously computed using the ``photocurrent_sesolve`` and; ``photocurrent_sesolve`` functions, are now included in the output of; :func:`.mcsolve` as ``result.photocurrent``. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. openmcsolve:. Open Systems; ------------. ``mcsolve`` can be used to study systems which have measurement and dissipative; interactions with their environment. This is done by passing a Liouvillian including the; dissipative interaction to the solver instead of a Hamiltonian.; In this case the effective Liouvillian becomes:. .. math::; :label: Leff. L_{\rm eff}\rho = L_{\rm sys}\rho -\frac{1}{2}\sum_{i}\left( C^{+}_{n}C_{n}\rho + \rho C^{+}_{n}C_{n}\right),. With the collapse probability becoming:. .. math::; :label: L_jump. \delta p =\delta t \sum_{n}\mathrm{tr}\left(\rho(t)C^{+}_{n}C_{n}\right),. And a jump with the collapse operator ``n`` changing the state as:. .. math::; :label: L_project. \rho(t+\delta t) = C_{n} \rho(t) C^{+}_{n} / \mathrm{tr}\left( C_{n} \rho(t) C^{+}_{n} \right),. We can redo the previous example for a situation where only half the emitted photons are detected. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:17186,detect,detections,17186,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['detect'],['detections']
Security," Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50317,access,accessible,50317,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['access'],['accessible']
Security," in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:1737,access,accessible,1737,doc/guide/dynamics/dynamics-master.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst,1,['access'],['accessible']
Security," of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6355,secur,security,6355,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['secur'],['security']
Security," the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the option",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13125,access,accessible,13125,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['access'],['accessible']
Security," will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request aga",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9999,hash,hashes,9999,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hashes']
Security," |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we h",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2291,access,access,2291,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['access'],['access']
Security,"# Contributor Covenant Code of Conduct. As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:740,attack,attacks,740,CODE_OF_CONDUCT.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md,1,['attack'],['attacks']
Security,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:317,access,accessible,317,doc/development/ideas/qutip-interactive.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst,1,['access'],['accessible']
Security,"-----------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +---------------+---------------+----------------------------------------+. .. figure:: quide-basics-qobj-box.png; :align: center; :width: 3.5in. The ``Qobj`` Class viewed as a container for the properties needed to characterize a quantum operator or state vector. For the destruction operator above:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; Dia(shape=(4, 4), num_diag=1). The ``data`` attribute returns a Qutip diagonal matrix.; ``Qobj`` instances store their data in Qutip matrix format.; In the core qutip module, the ``Dense``, ``CSR`` and ``Dia`` formats are available, but other packages can add other formats.; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:13499,access,access,13499,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['access'],['access']
Security,"----------------------------------------------------------------+; | ``result.expect`` | List/array of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2214,access,access,2214,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['access'],['access']
Security,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:27,secur,secure,27,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['secur'],['secure']
Security,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:1153,access,accessible,1153,doc/guide/guide-overview.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst,1,['access'],['accessible']
Security,"0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. .. _basics-qobj-props:. Qobj attributes; ---------------. We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a ``Qobj`` object (or any Python object) can be retrieved using the `Q.attribute` notation.; In addition to the those shown with the ``print`` function, an instance of the ``Qobj`` class also has the following attributes:. .. cssclass:: table-striped. +---------------+---------------+----------------------------------------+; | Property | Attribute | Description |; +===============+===============+========================================+; | Data | ``Q.data`` | Matrix representing state or operator |; +---------------+---------------+----------------------------------------+; | Dimensions | ``Q.dims`` | List keeping track of shapes for |; | | | individual components of a |; | | | multipartite system (for tensor |; | | | products and partial traces). |; +---------------+---------------+-----------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:11214,access,accessed,11214,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['access'],['accessed']
Security,"0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4712,secur,secure,4712,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['secur'],['secure']
Security,"H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28393,expose,exposed,28393,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['expose'],['exposed']
Security,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6649,secur,secure,6649,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['secur'],['secure']
Security,"[1.1, -1.1]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.ylabel | Labels for y-axis | ``['$y$', '']`` +y and -y (labels use LaTeX) |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.ylpos | Position of y-axis labels | ``[1.2, -1.2]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.zlabel | Labels for z-axis | ``['$\left|0\right>$', '$\left|1\right>$']`` |; | | | +z and -z (labels use LaTeX) |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.zlpos | Position of z-axis labels | ``[1.2, -1.2]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+. These properties can also be accessed via the print command:. .. doctest::. >>> b = qutip.Bloch(). >>> print(b) # doctest: +NORMALIZE_WHITESPACE; Bloch data:; -----------; Number of points: 0; Number of vectors: 0; <BLANKLINE>; Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]; <BLANKLINE>. .. _bloch-animate:. Animating with the Bloch sphere; ===============================. The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:10551,access,accessed,10551,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['access'],['accessed']
Security,"``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26097,access,accessible,26097,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['access'],['accessible']
Security,"apman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Müller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296–305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and automatic differentiation*, Phys. Rev. A **99**, 052327 (2019). :doi:`10.1103/PhysRevA.99.052327`.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst:2931,access,access,2931,doc/biblio.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst,1,['access'],['access']
Security,"ause it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manua",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9458,hash,hash,9458,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hash']
Security,"e branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9175,hash,hash,9175,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hash']
Security,"e example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9412,hash,hash,9412,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hash']
Security,"efs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18481,checksum,checksum,18481,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['checksum'],['checksum']
Security,"en the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. .. _heom-determining-currents:. Determining currents; --------------------. The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath. The contribution to the current into a given bath from each exponent in that; bath is:. .. math::. \mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A). where the :math:`\pm` sign is the sign of the exponent (see the; description later in :ref:`heom-fermionic-pade-expansion-coefficients`) and; :math:`Q^\pm` is :math:`Q` for ``+`` exponents and :math:`Q^{\dagger}` for; ``-`` exponents. The first-level exponents for the left bath are retrieved by calling; ``.filter(tags=[""L""])`` on ``ado_state`` which is an instance of; :class:`~qutip.solver.heom.HierarchyADOsState` and also provides access to; the methods of :class:`~qutip.solver.heom.HierarchyADOs` which describes the; structure of the hierarchy for a given problem. Here the tag ""L"" matches the tag passed when constructing ``bath_L`` earlier; in this example. Similarly, we may calculate the current to the right bath from the exponents; tagged with ""R"". .. plot::; :context:; :nofigs:. def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_curr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:6388,access,access,6388,doc/guide/heom/fermionic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst,1,['access'],['access']
Security,"he number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4233,access,accessed,4233,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['access'],['accessed']
Security,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12414,access,accessible,12414,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['access'],['accessible']
Security,"ider a process that is described by quantum map :math:`\epsilon(\rho_{\rm in}) = \rho_{\rm out}`, which can be written. .. math::; :label: qpt-quantum-map. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,. where :math:`N` is the number of states of the system (that is, :math:`\rho` is represented by an :math:`[N\times N]` matrix). Given an orthogonal operator basis of our choice :math:`\{B_i\}_i^{N^2}`, which satisfies :math:`{\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}`, we can write the map as. .. math::; :label: qpt-quantum-map-transformed. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger. where :math:`\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*` and :math:`A_i = \sum_{m} b_{im}B_{m}`. Here, matrix :math:`\chi` is the transformation matrix we are after, since it describes how much :math:`B_m \rho_{\rm in} B_n^\dagger` contributes to :math:`\rho_{\rm out}`. In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. :eq:`qpt-quantum-map`. Instead, what we usually can do is to calculate the propagator :math:`U` for the density matrix in superoperator form, using for example the QuTiP function :func:`qutip.propagator.propagator`. We can then write. .. math::. \epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}. where :math:`\tilde{\rho}` is the vector representation of the density matrix :math:`\rho`. If we write Eq. :eq:`qpt-quantum-map-transformed` in superoperator form as well we obtain. .. math::. \tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}. so we can identify. .. math::. U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger. Now this is a linear equation systems for the :math:`N^2 \times N^2` elements in :math:`\chi`. We can solve it by writing :math:`\chi` and the superoperator propagator as :math:`[N^4]` vectors, and likewis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:12393,access,access,12393,doc/guide/guide-visualization.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst,1,['access'],['access']
Security,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18929,checksum,checksum,18929,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['checksum'],['checksum']
Security,"ll request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10128,hash,hashes,10128,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hashes']
Security,"out a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9234,hash,hash,9234,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hash']
Security,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4838,access,access,4838,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['access'],['access']
Security,"s the operator Hermitian or not? |; +---------------+---------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +---------------+---------------+----------------------------------------+. .. figure:: quide-basics-qobj-box.png; :align: center; :width: 3.5in. The ``Qobj`` Class viewed as a container for the properties needed to characterize a quantum operator or state vector. For the destruction operator above:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; Dia(shape=(4, 4), num_diag=1). The ``data`` attribute returns a Qutip diagonal matrix.; ``Qobj`` instances store their data in Qutip matrix format.; In the core qutip module, the ``Dense``, ``CSR`` and ``Dia`` formats are available, but other packages can add other formats.; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:13403,access,access,13403,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['access'],['access']
Security,"s, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s resu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3420,access,access,3420,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['access'],['access']
Security,"ter``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9768,hash,hash,9768,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['hash'],['hash']
Security,"xp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)}; ).expect. plt.figure(); plt.plot(times, data[0]); plt.plot(times, data[1]); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavit",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4528,access,accessible,4528,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['access'],['accessible']
Testability," **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.0132685",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6621,test,testcode,6621,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``de",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9446,test,tests,9446,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability," .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27896,test,testing,27896,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability," 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The differ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12003,test,testcode,12003,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic osci",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:11412,test,testcode,11412,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32706,test,testoutput,32706,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output*",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13581,test,testcode,13581,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]]",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34333,test,testcode,34333,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:75029,test,tests,75029,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability," = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32645,test,testcode,32645,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability, Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wikståhl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Giguère); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the c,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:70531,test,tests,70531,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability," Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83671,test,tests,83671,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['test'],"['testing', 'tests']"
Testability," Obtaining measurement statistics(Projective); --------------------------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_povm`. The :func:`~qutip.measurement.measurement_statistics` function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; :func:`~qut",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10834,test,testcode,10834,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability," We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12660,test,testcode,12660,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," X = sigmax(); S = spre(X) * spost(X.dag()). hinton(S). Choi, Kraus, Stinespring and :math:`\chi` Representations; =========================================================. In addition to the superoperator representation of quantum maps, QuTiP; supports several other useful representations. First, the Choi matrix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, si",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31513,test,testoutput,31513,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15265,test,testoutput,15265,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3172,test,testcode,3172,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1991,test,testcode,1991,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2857,test,testcode,2857,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testcode']
Testability," are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [state",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25109,test,testing,25109,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability," block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when rendering to LaTeX or HTML. The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.050315",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:3552,test,tested,3552,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['tested']
Testability," breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35107,benchmark,benchmark,35107,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmark']
Testability," dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use the :func:`print` function to view the Qobj attributes. .. _basics-qobj-states:. States and operators; ---------------------. Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2784,test,testoutput,2784,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testoutput']
Testability," guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block wi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2525,test,testoutput,2525,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testoutput']
Testability," is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14833,test,testoutput,14833,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:39482,test,testcode,39482,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2491,test,testcode,2491,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. te",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:1628,test,testoutput,1628,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testoutput']
Testability," mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1452,test,testcode,1452,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability," must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and dat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20562,log,logging,20562,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logging']
Testability," must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:46343,log,logging,46343,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logging']
Testability," new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3959,benchmark,benchmarks,3959,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmarks']
Testability," new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40219,test,testoutput,40219,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(ope",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26096,test,testcode,26096,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:32957,test,test,32957,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['test'],"['test', 'tests']"
Testability," of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5956,test,testcode,5956,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40744,test,testing,40744,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability," solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4583,test,test,4583,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['test']
Testability," string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13725,log,log,13725,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['log'],['log']
Testability," task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.08546",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9644,test,testoutput,9644,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obt",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4202,test,testoutput,4202,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map :math:`\Lambda(\rho) = \rho^{\mathrm{T}}` is a positive map. We run into; problems, however, if we tensor :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:42069,test,testcode,42069,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(n",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25838,test,testcode,25838,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability," the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). p",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13998,test,testoutput,13998,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigma",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14208,test,testoutput,14208,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5647,test,testoutput,5647,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38974,test,testoutput,38974,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability," wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressB",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10994,log,logging,10994,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['log'],['logging']
Testability," |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34409,test,testcode,34409,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"'s m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Giguère**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère*",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87528,test,testing,87528,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['testing']
Testability,"(February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:67787,test,testing,67787,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['testing']
Testability,") = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32191,test,testcode,32191,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,") == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've als",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:5864,test,testcode,5864,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"* vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` stat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14598,test,testoutput,14598,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"* vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3867,test,testcode,3867,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Giguère**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nath",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87591,test,testing,87591,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['test'],"['test', 'testing']"
Testability,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md:478,test,tests,478,.github/pull_request_template.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md,1,['test'],['tests']
Testability,"*:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14982,test,testcode,14982,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATU",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97346,test,tests,97346,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,", P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one mus",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2324,log,logo,2324,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['log'],['logo']
Testability,", [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\up",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15054,test,testoutput,15054,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,", and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111622,log,logarithmic,111622,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logarithmic']
Testability,", dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23610,test,testcode,23610,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,", functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:1576,test,testcode,1576,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testcode']
Testability,"-----+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23087,test,testcode,23087,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +==========================+==============+=====================================================+; | ``matplotlib`` | 1.2.1+ | Needed for all visualisation tasks. |; +--------------------------+--------------+-----------------------------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a mor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:2840,test,test,2840,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['test'],['test']
Testability,"------------------------+; | :func:`~qutip.core.gates.toffoli` | Toffoli gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.hadamard_transform` | Hadamard gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.qubit_clifford_group` | Generates the Clifford group on a single qubit |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts l",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:22505,test,testoutput,22505,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23176,test,testing,23176,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"-----------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or n",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23227,test,testing,23227,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_povm`. The :func:`~qutip.measurement.measurement_statistics` function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; :func:`~qutip.measurement.measurement_statistics_observable`; and :func:`~qutip",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10884,test,testoutput,10884,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testoutput']
Testability,"-------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2565,test,testcode,2565,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testcode']
Testability,"-------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Giguère**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87068,test,testing,87068,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['testing']
Testability,"-; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169j; 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.24514517+0.j ]]. Note that it is also possible to add Lindblad dissipation superoperators in the; Bloch-Refield tensor by passing the operators via the ``c_ops`` keyword argument; like you would in the :func:`.mesolve` or :func:`.mcsolve` functions.; For convenience, the function :func:`.bloch",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:10222,test,testcode,10222,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['test'],['testcode']
Testability,"-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8696,log,log,8696,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['log'],['log']
Testability,". .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6995,test,testcode,6995,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,". 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +N",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38592,test,testcode,38592,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,". 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27076,test,testcode,27076,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,". Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25050,test,testing,25050,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,". Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a fil",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9248,test,test,9248,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['test']
Testability,". Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6674,test,testoutput,6674,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,". ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag()",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:37226,test,testoutput,37226,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:551,log,logo,551,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,2,['log'],"['login', 'logo']"
Testability,".. _development-contributing:. *********************************; Contributing to QuTiP Development; *********************************. Quick Start; ===========. QuTiP is developed through wide collaboration using the ``git`` version-control system, with the main repositories hosted in the `qutip organisation on GitHub <https://github.com/qutip>`_.; You will need to be familiar with ``git`` as a tool, and the `GitHub Flow <https://docs.github.com/en/get-started/quickstart/github-flow>`_ workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. #. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; #. (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (``git remote add qutip https://github.com/qutip/<repo>``); #. Begin on the ``master`` branch (``git checkout master``), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (``git pull qutip master``).; #. Switch to a new ``git`` branch (``git checkout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:601,test,testing,601,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['testing']
Testability,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:153,test,testsetup,153,doc/guide/dynamics/dynamics-options.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst,5,['test'],"['testcode', 'testsetup']"
Testability,".. _random:. ********************************************; Generating Random Quantum States & Operators; ********************************************. .. testsetup:: [random]. from qutip import rand_herm, rand_dm, rand_super_bcsz, rand_dm_ginibre. QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions. For example, a random Hermitian operator can be sampled by calling :func:`.rand_herm` function:. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_herm(5) # doctest: +NORMALIZE_WHITESPACE; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. .. tabularcolumns:: | p{2cm} | p{3cm} | c |. .. cssclass:: table-striped. +-------------------------------+-----------------------------------------------+------------------------------------------+; | Random Variable Type | Sampling Functions | Dimensions |; +===============================+===============================================+==========================================+; | State vector (``ket``) | :func:`.rand_ket` | :math:`N \times 1` |; +-------------------------------+-----------------------------------------------+------------------------------------------+; | Hermitian operator (``oper``) | :func:`.rand_herm` | :math:`N \times N` |; +-------------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst:154,test,testsetup,154,doc/guide/guide-random.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst,2,['test'],"['testing', 'testsetup']"
Testability,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:801,test,testcode,801,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,2,['test'],"['testcode', 'testoutput']"
Testability,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:20,log,logo,20,doc/index.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst,1,['log'],['logo']
Testability,".]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32991,test,testoutput,32991,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,".]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4766,test,testoutput,4766,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2334,test,testcode,2334,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testcode']
Testability,"1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------------------------------------+; | Gate function | Description |; +===========",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16167,test,testoutput,16167,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use the :func:`print` function to view the Qobj attributes. .. _basics-qobj-states:. States and operators; ---------------------. Manually specifying the data for each quantum object is inefficie",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2705,test,testcode,2705,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testcode']
Testability,"2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:7128,test,testoutput,7128,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. ..",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32934,test,testcode,32934,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"47+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8342,test,testcode,8342,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:11599,test,testing,11599,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35667,test,testcode,35667,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector correspond",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:11548,test,testing,11548,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#17",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74699,test,tests,74699,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :opt",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:7422,test,testoutput,7422,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMA",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5325,test,testoutput,5325,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,":math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quant",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40720,test,testcode,40720,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"; - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65285,test,tests,65285,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"; - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66260,test,tests,66260,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43202,test,testoutput,43202,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40153,test,testcode,40153,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10239,test,testoutput,10239,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.935",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38184,test,testcode,38184,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"= sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2485,test,testcode,2485,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"==. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3896,test,test,3896,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['test']
Testability,"======. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23740,test,testoutput,23740,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"=============. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2228,log,logo,2228,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['log'],['logo']
Testability,">`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13185,test,testing,13185,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['test'],['testing']
Testability,">`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copyi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1645,test,tests,1645,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['tests']
Testability,"ACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3601,test,testcode,3601,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1551,log,logo,1551,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['log'],['logo']
Testability,"ALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use the :func:`print` function to view the Qobj attributes. .. _basics-qobj-states:. States and operators; ---------------------. Manually specifyi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2653,test,testcode,2653,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testcode']
Testability,"API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); =======================",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9974,test,tests,9974,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; trans",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40857,test,testoutput,40857,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloc",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:76130,test,tests,76130,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"ITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10681,test,testcode,10681,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:2151,assert,assert,2151,doc/guide/guide-settings.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst,1,['assert'],['assert']
Testability,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:7401,log,log,7401,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html,1,['log'],['log']
Testability,"Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2],",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27143,test,testoutput,27143,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"P support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); - Fixed issue where `extract_states` did not preserve hermiticity.; Fixed issue where `rand_herm` did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); - ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:51822,test,tests,51822,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attribute:. .. testcode:: [states]. print(J.istp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true. .. doctest:: [states]. >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43886,test,testcode,43886,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,4,['test'],"['testcode', 'testoutput']"
Testability,"QuTiP: Quantum Toolbox in Python; ================================. [A. Pitchford](https://github.com/ajgpitch),; [C. Granade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Giguère](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or coll",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:821,test,tests,821,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,2,['test'],['tests']
Testability,"Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], sh",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:36533,test,testcode,36533,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:988,test,tested,988,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['test'],['tested']
Testability,"TiP: Quantum Toolbox in Python; ================================. [A. Pitchford](https://github.com/ajgpitch),; [C. Granade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Giguère](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collap",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:987,log,logo,987,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['log'],['logo']
Testability,"True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10746,test,testoutput,10746,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4693,test,testcode,4693,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"[0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38357,test,testoutput,38357,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"[[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we rais",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14772,test,testcode,14772,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4672,test,testoutput,4672,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:. .. doctest:: [basics]; :options: +SKIP. >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators ""is equal"" `==` and ""is not equal"" `!=` are also supported. .. _basics-functions:. Functions operating on Qobj class; =================================. Like attributes, the quantum object class has defined functions (methods) that operate on ``Qobj`` class instances. For a general quantum object ``Q``:. .. cssclass:: table-striped. +-----------------+-------------------------------+----------------------------------------+; | Function | Command | Description |; +=================+===============================+========================================+; | Check Hermicity | ``Q.check_herm()`` | Check if quantum object is Hermitian |; +-----------------+-------------------------------+----------------------------------------+; | Conjugate | ``Q.conj()`` | Conjugate of quantum object. |; +-----------------+-------------------------------+----------------------------------------+; | Cosine | ``Q.cosm()`` | Cosine of quantum object. |; +-----------------+-------------------------------+----------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:16125,log,logic,16125,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['log'],['logic']
Testability,"_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_ope",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28437,test,tests,28437,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,_dyn_gen`` (no longer returns a value); - ``get_dyn_gen`` now ``_get_phased_dyn_gen``; - ``get_ctrl_den_gen`` now ``_get_phased_ctrl_dyn_gen``; - ``ensure_decomp_curr`` now ``_ensure_decomp_curr``; - ``spectral_decomp`` now ``_spectral_decomp``. - dynamics properties. - ``evo_init2t`` now ``_fwd_evo`` (``fwd_evo`` as Qobj); - ``evo_t2end`` now ``_onwd_evo`` (``onwd_evo`` as Qobj); - ``evo_t2targ`` now ``_onto_evo`` (``onto_evo`` as Qobj). - fidcomp properties. - ``uses_evo_t2end`` now ``uses_onwd_evo``; - ``uses_evo_t2targ`` now ``uses_onto_evo``; - ``set_phase_option`` function now property ``phase_option``. - propcomp properties. - ``grad_exact`` (now read only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johann,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:102583,test,tests,102583,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directiv",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2946,test,testcode,2946,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testcode']
Testability,"` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1657,test,testoutput,1657,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://git",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73756,test,tests,73756,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['test'],"['test', 'tests']"
Testability,"`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14147,test,testcode,14147,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3461,test,testcode,3461,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"amiliar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/quti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35062,benchmark,benchmarks,35062,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmarks']
Testability,"antum maps, QuTiP; supports several other useful representations. First, the Choi matrix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31758,test,testcode,31758,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"antum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:37148,test,testcode,37148,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:2077,test,testing,2077,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['test'],['testing']
Testability,"ated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169j; 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.24514517+0.j ]]. Note that it is also possible to add Lindblad dissipation superoperators in the; Bloch-Refield tensor by passing the operators via the ``c_ops`` keyword argument; like you would in the :func:`.mesolve` or :func:`.mcsolve` functions.; For convenience, the function :func:`.bloch_redfield_tensor` also returns the basis; transformation operator, the eigen vector matrix, since they are calculated in the; process of calculating the Bloch-Redfield tensor `R`, and the `ekets` are usually; needed again later when transforming operators between the laboratory basis and the eigen basis.; The tensor can be obtained in the laboratory basis by setting ``fock_basis=True``,; in that ca",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:10622,test,testoutput,10622,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['test'],['testoutput']
Testability,"ates is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2167,test,testoutput,2167,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"ates`` | State vectors or density matrices calculated at each times of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_final_state`` | ``runs_final_state`` | State vectors or density matrices calculated at the last time of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_expect`` | ``runs_expect`` | List/array of expectation values, if requested. |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``std_expect`` | | List/array of standard derivation of the expectation values. |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_e_data`` | ``runs_e_data`` | Dictionary of expectation values, if requested. |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``std_e_data`` | | Dictionary of standard derivation of the expectation values. |; +-------------------------+----------------------+------------------------------------------------------------------------+. Multiple trajectories results also keep the trajectories ``seeds`` to allows; recomputing the results. .. testcode::; :skipif: True. seeds = result.seeds. One last feature specific to multi-trajectories results is the addition operation; that can be used to merge sets of trajectories. .. code-block::. >>> run1 = smesolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = smesolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. This allows one to improve statistics while keeping previous computations.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:7391,test,testcode,7391,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['test'],['testcode']
Testability,"ath::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states];",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34743,test,testcode,34743,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Pyt",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74973,test,tests,74973,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"bb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35058,test,testcode,35058,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"bility is `probabilities[0]`, and so on. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_observable`. Obtaining measurement statistics(Projective); --------------------------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being a list of projectors, it acts as an alia",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10566,test,testoutput,10566,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testoutput']
Testability,"bj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:36599,test,testoutput,36599,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"bj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14544,test,testcode,14544,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"bj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28494,test,testcode,28494,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ce, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when rendering to LaTeX or HTML. The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the ``NORMALIZE_WHITESPACE`` option to ensure that the; multiline output matches. **Render:**. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +SKIP; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. - A useful argument to specify in plot blocks is that of ``context`` whic",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:4176,test,tests,4176,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['tests']
Testability,"chmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12220,assert,assert,12220,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['assert'],['assert']
Testability,"ct was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(resul",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4019,test,testcode,4019,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['test'],['testcode']
Testability,"ct: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real number for all Hermitian-preserving superoperators; :math:`S`,; allowing us to plot the elements of :math:`S` as a `Hinton diagram <https://matplotlib.org/examples/specialty_plots/hinton_demo.html>`_. In such diagrams, positive elements are indicated by white squares, and negative elements; by black squares. The size of each element is indicated by the size of the corresponding square. For instance,; let :math:`S[\rho] = \sigma_x \rho \si",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:29114,test,testoutput,29114,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ctions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26817,test,testcode,26817,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real number for all Hermitian-preserving superoperators; :math:`S`,; allowing us to plot the elements of :math:`S` as a `Hinton diagram <https://matplotlib.org/examples/specialty_plots/hinton_demo.html>`_. In such diagrams, positive elements are indicated by white squares, and negative elements; by ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28984,test,testcode,28984,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operato",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4837,test,testcode,4837,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"drey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); =================",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:1391,test,tests,1391,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"e RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and ad",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3079,test,tests,3079,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['test'],['tests']
Testability,"e not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2444,test,tests,2444,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['test'],['tests']
Testability,"e relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3592,test,tests,3592,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"e systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, whic",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:5058,test,testcode,5058,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"e we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1623,test,testoutput,1623,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"e; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9545,test,testcode,9545,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"eadless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Giguère); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74849,test,test,74849,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['test']
Testability,"eckout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions fo",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2273,test,tests,2273,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,3,['test'],['tests']
Testability,"ector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2843,test,testcode,2843,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ed to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1288,test,testcode,1288,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"ed.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34905,benchmark,benchmarks,34905,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmarks']
Testability,"ed:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4522,test,testcode,4522,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"ee lists are in the same order -- i.e. the first eigenvalue is; `eigenvalues[0]`, its corresponding eigenstate is `eigenstates[0]`, and; its probability is `probabilities[0]`, and so on. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_observable`. Obtaining measurement statistics(Projective); --------------------------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10437,test,testcode,10437,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"efore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23967,test,testoutput,23967,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"end`` now ``_onwd_evo`` (``onwd_evo`` as Qobj); - ``evo_t2targ`` now ``_onto_evo`` (``onto_evo`` as Qobj). - fidcomp properties. - ``uses_evo_t2end`` now ``uses_onwd_evo``; - ``uses_evo_t2targ`` now ``uses_onto_evo``; - ``set_phase_option`` function now property ``phase_option``. - propcomp properties. - ``grad_exact`` (now read only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:102966,test,tests,102966,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"erations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9063,test,testcode,9063,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ere have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; f",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4116,benchmark,benchmarks,4116,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmarks']
Testability,"erlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and `",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:38793,log,logm,38793,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['log'],"['logarithm', 'logm']"
Testability,"erlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were adde",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11333,log,logm,11333,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['log'],"['logarithm', 'logm']"
Testability,"ermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represent",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26421,test,testing,26421,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"es = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24626,test,testcode,24626,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"es and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Giguère**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Giguère**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Giguère**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:86966,test,tests,86966,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"es. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code pr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4161,benchmark,benchmark,4161,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmark']
Testability,"es\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:5342,test,testoutput,5342,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"es]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vecto",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2559,test,testoutput,2559,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"es]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims =",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13649,test,testoutput,13649,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"estcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23423,test,testing,23423,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"esting on Mac and Linux. (by **Simon Cross** and **Eric Giguère**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88060,test,tests,88060,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,3,['test'],"['testing', 'tests']"
Testability,"et/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2412,test,testcode,2412,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testcode']
Testability,"etric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:75971,test,test,75971,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['test']
Testability,"ever, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Severa",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4623,test,tested,4623,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['test'],['tested']
Testability,"except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9208,test,test,9208,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['test']
Testability,"g as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13948,test,testcode,13948,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"hape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse opera",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27854,test,testcode,27854,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"he state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3230,test,testoutput,3230,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14953,test,tests,14953,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,['test'],"['test', 'tests']"
Testability,"iP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11993,log,logging,11993,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['log'],['logging']
Testability,"idelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12199,test,testcode,12199,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"inespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map :math:`\Lambda(\rho) = \rho^{\mathrm{T}}` is a positive map. We run into; problems, however, if we tensor :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:42208,test,testoutput,42208,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ing identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34806,test,testoutput,34806,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ing operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2900,test,testoutput,2900,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2172,test,testcode,2172,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testcode']
Testability,"ion. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2498,test,testoutput,2498,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testoutput']
Testability,"ions for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3716,test,testing,3716,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,['test'],"['testing', 'tests']"
Testability,"ions: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8422,test,testoutput,8422,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ious lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Giguère**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Giguère**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Giguère**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step functi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89578,test,tests,89578,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"ip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; =========================================",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2925,test,testoutput,2925,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagona",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53783,log,logger,53783,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logger']
Testability,"ix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = Tru",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31826,test,testoutput,31826,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7257,test,testcode,7257,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"l Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: sol",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:7128,test,tests,7128,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['test'],['tests']
Testability,"le returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3483,test,testcode,3483,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['test'],['testcode']
Testability,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:19294,test,tests,19294,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,3,['test'],"['test', 'tests']"
Testability,"left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2050,test,testoutput,2050,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"lize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24688,test,testing,24688,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"ll just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9120,test,testoutput,9120,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"llow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the change",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9856,test,tests,9856,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"lobal phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3789,test,testcode,3789,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"lse; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28026,test,testcode,28026,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"lude-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:1095,log,logo,1095,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,1,['log'],['logo']
Testability,"luding the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, opt",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4118,test,testcode,4118,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['test'],['testcode']
Testability,"ly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26361,test,testcode,26361,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"m object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace dista",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10173,test,testcode,10173,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"m systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23817,test,testcode,23817,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65418,test,tests,65418,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to QobjEvo (#2111 by lklivingstone); - Improve print(qutip.settings) by make it shorter (#2113 by tamakoshi2001); - Create the `trace_oper_ket` operation (#2126); - Speed up the construction of the RHS of the HEOM solver by a factor of 4x by converting the final step to Cython. (#2128); - Rewrite the stochastic solver to use the v5 solver interface. (#2131); - Add `Qobj.get` to extract underlying data in original format. (#2141); - Add qeye_like and qzero_like (#2153); - Add capacity to di",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:29338,log,logger,29338,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logger']
Testability,"master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2294,test,test,2294,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['test']
Testability,"matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8820,test,testoutput,8820,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ment of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famou",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1052,test,testcode,1052,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [g",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2399,test,testcode,2399,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testcode']
Testability,"more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2853,test,testcode,2853,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16547,test,test,16547,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,3,['test'],"['test', 'tested', 'testing']"
Testability,"multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28564,test,testoutput,28564,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"n overview, the steps to contribute are:. #. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; #. (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (``git remote add qutip https://github.com/qutip/<repo>``); #. Begin on the ``master`` branch (``git checkout master``), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (``git pull qutip master``).; #. Switch to a new ``git`` branch (``git checkout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The res",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:1646,test,tests,1646,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"n the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6222,test,testcode,6222,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"nc:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_s",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7214,test,testcode,7214,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"ng map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34509,test,testoutput,34509,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ngle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32247,test,testoutput,32247,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"nit time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the St",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3741,test,testcode,3741,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['test'],['testcode']
Testability,"nsity matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues # doctest: +NORMALIZE_WHITESPACE; array([-1., 1.]). >>> eigenstates # doctest: +NORMALIZE_WHITESPACE; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7458,test,testoutput,7458,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testoutput']
Testability,"nstallation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73476,test,test,73476,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['test']
Testability,"nt(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28073,test,testoutput,28073,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11556,test,testing,11556,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,5,['test'],"['testing', 'tests']"
Testability,"o choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argume",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:5283,test,testcode,5283,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + bas",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5257,test,testcode,5257,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ocstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself)",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83934,test,testing,83934,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['testing']
Testability,"om/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:36011,log,logger,36011,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logger']
Testability,"orensen gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.toffoli` | Toffoli gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.hadamard_transform` | Hadamard gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.qubit_clifford_group` | Generates the Clifford group on a single qubit |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.asser",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:22426,test,testcode,22426,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ors that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = te",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:3539,test,testcode,3539,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"ors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1570,test,testcode,1570,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ossibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28847,test,tests,28847,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"ould have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6009,test,testoutput,6009,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"output:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WH",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15203,test,testcode,15203,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] https://www.tensorflow.org/; .. [2] https://github.com/tehruhn/bofin; .. [3] https://github.com/qutip/qutip-tensorflow/; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1915,benchmark,benchmark,1915,doc/development/ideas/tensorflow-data-backend.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst,3,['benchmark'],['benchmark']
Testability,"p.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False). # creating figure; fig, ax = plt.subplots(figsize=(FIGURE_SIZE, FIGURE_SIZE)); patch = PathPatch(path, facecolor=FONT_COLOR, linewidth=0); ax.add_artist(patch); ax.set_xlim(-AXIS_SIZE, AXIS_SIZE), ax.set_xticks([]); ax.set_ylim(-AXIS_SIZE, AXIS_SIZE), ax.set_yticks([]). # add qutip logo; ax.imshow(img, alpha=LOGO_TRANSPARENCY,; extent=[-LOGO_SIZE,LOGO_SIZE, -LOGO_SIZE, LOGO_SIZE]). .. _developers-lead:. Lead Developers; ===============. - `Alex Pitchford <https://github.com/ajgpitch>`_; - `Nathan Shammah <https://nathanshammah.com/>`_; - `Shahnawaz Ahmed <http://sahmed.in/>`_; - `Neill Lambert <https://github.com/nwlambert>`_; - `Eric Giguère <https://github.com/Ericgig>`_; - `Boxi Li <https://github.com/BoxiLi>`_; - `Simon Cross <http://hodgestar.za.net/>`_; - `Asier Galicia <https://github.com/AGaliciaMartinez>`_. Past Lead Developers; ====================. - `Robert Johansson <https://jrjohansson.github.io/research.html>`_ (RIKEN); - `Paul Nation <https://www.korea.ac.kr/>`_ (Korea University); - `Chris Granade <https://www.cgranade.com>`_; - `Arne Grimsmo <https://www.sydney.edu.au/science/about/our-people/academic-staff/arne-grimsmo.html>`_; - `Jake Lishman <https://binhbar.com>`_. .. _developers-contributors:. Contributors; ============. .. note::. 	Anyon",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:2380,log,logo,2380,doc/contributors.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst,1,['log'],['logo']
Testability,"perators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:3614,test,testoutput,3614,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"pins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHIT",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25925,test,testoutput,25925,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111218,test,tests,111218,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"ply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will waive or not assert, as appropriate, this Section, to the; fullest extent permitted by the applicable national law, to enable You to; reasonably exercise Your right under Section 3(b) of this License (right; to make Adaptations) but not otherwise. 5. Representations, Warranties and Disclaimer. UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR; OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND; CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING,; WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A; PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER; DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT; DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED; WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU. 6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN; NO EVENT WILL LICENSOR BE LIABLE TO Y",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:12447,assert,assert,12447,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['assert'],['assert']
Testability,"ponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when rendering to LaTeX or HTML. The plot directive can also be used in the doctest format. In this case,; wh",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:3061,test,testcode,3061,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testcode']
Testability,"ported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; ----------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:7444,test,test,7444,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['test']
Testability,"pt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2682,test,tests,2682,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['tests']
Testability,"ptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11410,log,logging,11410,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['log'],['logging']
Testability,"qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9009,log,log,9009,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,2,['log'],['log']
Testability,"r.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a mess",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11206,test,test,11206,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['test'],['test']
Testability,"rated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8761,test,testcode,8761,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"re up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9726,test,tests,9726,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"re**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Giguère**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Giguère**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Giguère**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Giguère**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Giguère**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Giguère**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `Poly",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88125,benchmark,benchmarking,88125,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['benchmark'],['benchmarking']
Testability,"rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :mat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43081,test,testcode,43081,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"robably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packag",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2938,test,testing,2938,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['test'],['testing']
Testability,"rom the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34260,test,testcode,34260,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"rs, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the st",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1235,test,testoutput,1235,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"rsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/q",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9933,test,tests,9933,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"rt *; settings.colorblind_safe = True. import matplotlib.pyplot as plt; plt.rcParams['savefig.transparent'] = True. X = sigmax(); S = spre(X) * spost(X.dag()). hinton(S). Choi, Kraus, Stinespring and :math:`\chi` Representations; =========================================================. In addition to the superoperator representation of quantum maps, QuTiP; supports several other useful representations. First, the Choi matrix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =;",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31416,test,testcode,31416,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"rties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2245,test,testoutput,2245,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['test'],['testoutput']
Testability,"rue; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator repre",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38665,test,testoutput,38665,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"s as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), ty",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2030,test,testcode,2030,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"s ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3261,log,logo,3261,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['log'],['logo']
Testability,"s is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34699,test,testing,34699,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['testing']
Testability,"s must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when renderi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2978,test,testoutput,2978,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testoutput']
Testability,"s representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35122,test,testoutput,35122,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"s that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13383,test,testcode,13383,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6680,test,testing,6680,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['testing']
Testability,"sn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Giguère). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wikståhl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); -",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:69596,test,tested,69596,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['test'],"['test', 'tested']"
Testability,"ss is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorf",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3737,test,testing,3737,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['testing']
Testability,"st to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look li",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11334,test,tests,11334,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['test'],['tests']
Testability,"stcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matr",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:39567,test,testoutput,39567,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"t QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical ge",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27651,test,testcode,27651,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"t the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ======",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11287,test,tests,11287,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,2,['test'],"['testing', 'tests']"
Testability,"t to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12745,test,test,12745,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['test']
Testability,"t, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13432,test,testoutput,13432,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"t:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24745,test,testing,24745,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"ta =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector fir",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3658,test,testoutput,3658,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"tal data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5420,log,logger,5420,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logger']
Testability,"tates :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12850,test,testcode,12850,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"tates]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j];",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6313,test,testoutput,6313,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert spa",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1577,test,testcode,1577,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testcode']
Testability,"ter``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9708,log,log,9708,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,3,['log'],['log']
Testability,"tes]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.707106",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35731,test,testoutput,35731,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:5625,test,testcode,5625,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1172,test,testcode,1172,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1366,test,testoutput,1366,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['test'],['testoutput']
Testability,"tice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9287,test,tests,9287,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['test'],['tests']
Testability,"tion of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------; - Fixed text alignment issues in AboutBox. - Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module. - Added tidyup function to tensor function output. - Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); +++++++++++++++",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115883,test,tests,115883,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"ton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects wh",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:55572,test,tests,55572,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"tors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, iden",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4679,test,testcode,4679,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['test'],['testcode']
Testability,"tps://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://i",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1400,log,logo,1400,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['log'],['logo']
Testability,"tps://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3380,log,logo,3380,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['log'],['logo']
Testability,"tput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26904,test,testoutput,26904,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"u have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23306,test,testing,23306,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"uTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floque",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35306,test,test,35306,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['test']
Testability,"uTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12027,test,testing,12027,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testing']
Testability,"uantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demon",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3930,test,testoutput,3930,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,ub.com/qutip/qutip/pull/1562>`_ by Eric Giguère). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 w,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64944,test,test,64944,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['test']
Testability,"ubit gates and controlled gates. (by **Mateo Laguna** and **Martín Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martín Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()``. (by **pschindler**); - Fix invalid string literals in docstrings and some unclosed files. (by **Élie Gouzien**); - Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by **Jake Lishman**); - Fix the trace norm being incorrectly reported as 0 for small matrices. (by **Jake Lishman**); - Fix issues with ``dnorm`` when using CVXPy 1.1 with sparse matrices. (by **Felipe Bivort Haiek**); - Fix segfaults in ``mesolve`` when passed a bad initial ``Qobj`` as the state. (by **Jake Lishman**); - Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by **Drew Parsons**); - Fix ``zspmv_openmp.cpp`` missing from the pip sdist. (by **Christoph Gohlke**); - Fix correlation functions throwing away imaginary components. (by **Asier Galicia Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:82025,test,tests,82025,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['test'],['tests']
Testability,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., ""French translation of the Work by Original; Author,"" or ""Screenplay based on original Work by Original Author""). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:11403,assert,assert,11403,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['assert'],['assert']
Testability,"um object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16106,test,testcode,16106,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"um object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:7365,test,testcode,7365,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"unning doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the ``NORMALIZE_WHITESPACE`` option to ensure that the; multiline output matches. **Render:**. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +SKIP; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. - A useful argument to specify in plot blocks is that of ``context`` which ensures; that the code is being run in the namespace of the previous plot block within the; same file. - By default, each rendered figure in one plot block (when using ``:context:``); is carried over to the next block. - When the ``context`` argument is specified with the ``reset`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. - When the ``context`` argument is specified with the ``close-figs`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:5926,test,testing,5926,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testing']
Testability,"ursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104767,log,logging,104767,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logging']
Testability,"vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104731,log,logging,104731,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['log'],['logging']
Testability,"w the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your sys",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11462,test,tests,11462,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['test'],['tests']
Testability,"we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2496,test,testoutput,2496,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['test'],['testoutput']
Testability,"with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`_, or by raising issues in `the main GitHub repository <https://github.com/qutip/qutip>`_ if you find any bugs.; Anyone who contributes code will be duly recognized.; Even sma",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:7481,test,test,7481,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['test'],['test']
Testability,"x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24884,test,testcode,24884,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"x.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6373,test,tests,6373,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['test'],['tests']
Testability,"zed Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum obje",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26184,test,testoutput,26184,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testoutput']
Testability,"| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the numb",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5588,test,testcode,5588,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4136,test,testcode,4136,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Testability,"}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acti",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38927,test,testcode,38927,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['test'],['testcode']
Usability," # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4436,simpl,simply,4436,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['simpl'],['simply']
Usability," .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is intereste",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:5940,simpl,simplest,5940,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['simpl'],['simplest']
Usability," >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12730,simpl,simple,12730,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['simpl'],['simple']
Usability," Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Giguère**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83798,simpl,simplify,83798,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['simpl'],['simplify']
Usability," a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The adv",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1532,guid,guidelines,1532,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,2,['guid'],"['guide', 'guidelines']"
Usability," and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:67895,simpl,simple,67895,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['simpl'],['simple']
Usability," another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the ini",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:2308,clear,clear,2308,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability," before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3394,guid,guide,3394,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['guid'],['guide']
Usability," both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be man",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2245,progress bar,progress bars,2245,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['progress bar'],['progress bars']
Usability," depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentatio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11475,simpl,simply,11475,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['simpl'],['simply']
Usability," guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73231,guid,guide,73231,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability," in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:27526,feedback,feedback,27526,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['feedback'],['feedback']
Usability," matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = de",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:1414,simpl,simple,1414,doc/guide/guide-saving.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,1,['simpl'],['simple']
Usability," of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) file",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1341,simpl,simply,1341,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['simpl'],['simply']
Usability," original problem :eq:`eq_driven_qubit` given some initial state :math:`\left|\psi_0\right>`.; To do that, we first need to decompose the initial state in the Floquet states,; using the function :meth:`.FloquetBasis.to_floquet_basis`. .. plot::; :context: close-figs. >>> psi0 = rand_ket(2); >>> f_coeff = floquet_basis.to_floquet_basis(psi0); >>> f_coeff # doctest: +SKIP; [(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily; evaluate the wavefunction that is the solution to :eq:`eq_driven_qubit` at an arbitrary; time :math:`t` using the function :meth:`.FloquetBasis.from_floquet_basis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the differen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:10327,guid,guide,10327,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['guid'],['guide']
Usability," removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110979,simpl,simplified,110979,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['simpl'],['simplified']
Usability," returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also contain a; list of times at which the collapse occurred, and which collapse operators did; the collapse. These can be obtained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:7940,simpl,simply,7940,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['simpl'],['simply']
Usability," solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15946,usab,usable,15946,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['usab'],['usable']
Usability," the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` v",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42643,usab,usable,42643,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['usab'],['usable']
Usability," the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+-------------------------",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5730,simpl,simple,5730,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['simpl'],['simple']
Usability," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:2505,learn,learn,2505,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,3,"['guid', 'learn']","['guide', 'guidelines', 'learn']"
Usability," |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we h",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2355,guid,guide,2355,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['guid'],['guide']
Usability,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:96,simpl,simple,96,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,2,['simpl'],"['simple', 'simplest']"
Usability,"************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j));",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:991,simpl,simpler,991,doc/guide/dynamics/dynamics-class.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst,1,['simpl'],['simpler']
Usability,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:117,simpl,simple,117,doc/development/ideas/qutip-interactive.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst,2,"['learn', 'simpl']","['learners', 'simple']"
Usability,"+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8214,simpl,simplest,8214,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['simpl'],['simplest']
Usability,", e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:`system`.; We give two basic examples on the use of *PIQS*.; In the first example the incoherent emission of N driven TLSs is considered. .. code-block:: python. from qutip import piqs; N = 10; system = piqs.Dicke(N, emission = 1, pumping = 2); L = system.liouvillian(); steady = steadystate(L). For more example of use, see the ""Permutational Invariant Lindblad Dynamics"" section in the tutorials section of the website, `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_. .. list-table:: Useful PIQS functions.; :widths: 25 25 50; :header-rows: 1. * - Operators; - Command; - Description; * - Collective spin algebra :math:`J_x,\ J_y,\ J_z`; - ``jspin(N)``; - The collective spin algebra :math:`J_x,\ J_y,\ J_z` for :math:`N` TLSs; * - Collective spin :math:`J_x`; - ``jspin(N, ""x"")``; - The collective spin operator :math:`Jx`. Requires :math:`N` number of TLSs; * - Collective spin :math:`J_y`; - ``jspin(N, ""y"")``; - The collective spin opera",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst:3113,simpl,simply,3113,doc/guide/guide-piqs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst,1,['simpl'],['simply']
Usability,", for example, the construction of qutrit circuits. (`#1807 <https://github.com/qutip/qutip/pull/1807>`_ by Boxi Li); - Fixed the checking of ``method`` and ``offset`` parameters in ``coherent`` and ``coherent_dm``. (`#1469 <https://github.com/qutip/qutip/pull/1469>`_ and `#1741 <https://github.com/qutip/qutip/pull/1741>`_ by Joseph Fox-Rabinovitz and Simon Cross); - Removed the Hamiltonian saved in the ``sesolve`` solver results. (`#1689 <https://github.com/qutip/qutip/pull/1689>`_ by Eric Giguère); - Fixed a bug in rand_herm with ``pos_def=True`` and ``density>0.5`` where the diagonal was incorrectly filled. (`#1562 <https://github.com/qutip/qutip/pull/1562>`_ by Eric Giguère). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` test",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64332,guid,guide,64332,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,- Removed the Hamiltonian saved in the ``sesolve`` solver results. (`#1689 <https://github.com/qutip/qutip/pull/1689>`_ by Eric Giguère); - Fixed a bug in rand_herm with ``pos_def=True`` and ``density>0.5`` where the diagonal was incorrectly filled. (`#1562 <https://github.com/qutip/qutip/pull/1562>`_ by Eric Giguère). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeCli,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64701,guid,guide,64701,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,"-----------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:3390,progress bar,progress bars,3390,doc/installation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst,1,['progress bar'],['progress bars']
Usability,"--------------------------------. .. automodule:: qutip.solver.floquet; :members: fmmesolve, fsesolve, floquet_tensor. Stochastic Schrödinger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:5525,undo,undoc-members,5525,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['undo'],['undoc-members']
Usability,"------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histogram, plot_energy_levels, plot_fock_distribution, plot_wigner, sphereplot, plot_schmidt, plot_qubism, plot_expectation_values, plot_wigner_sphere, plot_spin_distribution; :undoc-members:. .. automodule:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:5874,undo,undoc-members,5874,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['undo'],['undoc-members']
Usability,"------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8463,simpl,simple,8463,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['simpl'],['simple']
Usability,"-------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the re",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2606,simpl,simpler,2606,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['simpl'],['simpler']
Usability,"-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10610,simpl,simplify,10610,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['simpl'],['simplify']
Usability,". 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4102,simpl,simple,4102,doc/guide/guide-tensor.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,1,['simpl'],['simple']
Usability,". conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes ru",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12945,guid,guide,12945,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['guid'],['guide']
Usability,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:763,simpl,simply,763,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['simpl'],['simply']
Usability,".. _bloch_redfield:. ******************************; Bloch-Redfield master equation; ******************************. .. plot::; :context: reset; :include-source: False. import pylab as plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative metho",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:836,clear,clear,836,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['clear'],['clear']
Usability,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:751,guid,guide-states,751,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide-states']
Usability,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:162,guid,guide,162,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['guid'],['guide']
Usability,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:95,guid,guide-overview,95,doc/guide/guide.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst,17,['guid'],"['guide-basics', 'guide-bloch', 'guide-control', 'guide-correlation', 'guide-dynamics', 'guide-heom', 'guide-measurement', 'guide-overview', 'guide-piqs', 'guide-random', 'guide-saving', 'guide-settings', 'guide-states', 'guide-steady', 'guide-super', 'guide-tensor', 'guide-visualization']"
Usability,".. _krylov:. *******************************************; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control o",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:796,simpl,simplest,796,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['simpl'],['simplest']
Usability,".. _measurement:. ******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:577,simpl,simple,577,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['simpl'],['simple']
Usability,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:88,guid,guide,88,doc/guide/guide-overview.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst,3,['guid'],['guide']
Usability,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:194,guid,guide,194,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,2,['guid'],['guide']
Usability,".. _steady:. *************************************; Solving for Steady-State Solutions; *************************************. .. _steady-intro:. Introduction; ============. For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as :math:`t\rightarrow\infty` that satisfies the equation. .. math::; \frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0. Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix :math:`\hat{\rho}_{ss}` can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Li",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:886,simpl,simple,886,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,1,['simpl'],['simple']
Usability,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:276,guid,guide,276,doc/guide/guide-super.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,1,['guid'],['guide']
Usability,".. _user_guide.rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specifi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:144,guid,guide,144,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,4,"['guid', 'learn']","['guide', 'learn']"
Usability,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:162,guid,guide,162,doc/index.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst,3,['guid'],['guide']
Usability,"19>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://g",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:72028,guid,guide,72028,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,"1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6336,clear,clearly,6336,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['clear'],['clearly']
Usability,"2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` function, if we pass the density matrix at time :math:`t_1` as second argument, a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:5221,guid,guide,5221,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['guid'],['guide']
Usability,"752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Giguère); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Giguère). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/q",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:72178,guid,guide,72178,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,": [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices,",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14589,clear,clear,14589,doc/guide/guide-basics.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,1,['clear'],['clear']
Usability,": [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermici",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32538,simpl,simply,32538,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['simpl'],['simply']
Usability,"; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+===",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5476,simpl,simple,5476,doc/guide/dynamics/dynamics-time.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst,1,['simpl'],['simple']
Usability,"A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as for other solvers) and we can calculate; expectation values using:. .. code-block:: python. output = fmmesolve(H, psi0, tlist, [sigmax()], e_ops=[num(2)],; spectra_cb=[noise_spectrum], T=T, args=args); p_ex = output.expect[0]. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:15459,guid,guide,15459,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['guid'],['guide']
Usability,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1996,simpl,simple,1996,doc/guide/guide-settings.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst,1,['simpl'],['simple']
Usability,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:822,simpl,simplest,822,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['simpl'],['simplest']
Usability,"The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new da",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:7267,simpl,simplifcation,7267,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['simpl'],['simplifcation']
Usability,"The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versio",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1918,guid,guide,1918,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['guid'],['guide']
Usability,"\sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},. is the Bloch-Redfield tensor. The Bloch-Redfield master equation in the form Eq. :eq:`br-final` is suitable for numerical implementation. The input parameters are the system Hamiltonian :math:`H`, the system operators through which the environment couples to the system :math:`A_\alpha`, and the noise-power spectrum :math:`S_{\alpha\beta}(\omega)` associated with each system-environment interaction term. To simplify the numerical implementation we assume that :math:`A_\alpha` are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. .. math::; :label: br-tensor. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:8827,simpl,simplify,8827,doc/guide/dynamics/dynamics-bloch-redfield.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst,1,['simpl'],['simplify']
Usability,"]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right). where :math:`J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}` are SU(2) Pauli spin operators, with :math:`{\alpha=x,y,z}` and :math:`J_{\pm,n}=\sigma_{\pm,n}`. The collective spin operators are :math:`J_{\alpha} = \sum_{n}J_{\alpha,n}` . The Lindblad super-operators are :math:`\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A`. The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension :math:`4^N`. By exploiting the permutational invariance of identical particles [2-8], the Liouvillian :math:`\mathcal{D}_\text{TLS}(\rho)` can be built as a block-diagonal matrix in the basis of Dicke states :math:`|j, m \rangle`. The system under study is defined by creating an object of the; :class:`~qutip.piqs.piqs.Dicke` class, e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:`system`.; We give two basic examples on the use of *PIQS*.; In the first example the incoherent emission of N driven TLSs is ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst:2276,simpl,simply,2276,doc/guide/guide-piqs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst,1,['simpl'],['simply']
Usability,"_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10160,learn,learning,10160,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['learn'],['learning']
Usability,"`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files t",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5052,guid,guide,5052,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['guid'],['guide']
Usability,"``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Giguère); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's c",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66382,guid,guidelines,66382,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,2,['guid'],['guidelines']
Usability,"agger(\tau)a(0)\right>}{\sqrt{\left<a^\dagger(\tau)a(\tau)\right>\left<a^\dagger(0)a(0)\right>}}`. For a coherent state :math:`|g^{(1)}(\tau)| = 1`, and for a completely incoherent (thermal) state :math:`g^{(1)}(\tau) = 0`. The following code calculates and plots :math:`g^{(1)}(\tau)` as a function of :math:`\tau`. .. plot:: guide/scripts/correlation_ex3.py; :width: 5.0in; :include-source:. For convenience, the steps for calculating the first-order coherence function have been collected in the function :func:`.coherence_function_g1`. Example: second-order optical coherence function; ------------------------------------------------. The second-order optical coherence function, with time-delay :math:`\tau`, is defined as. .. math::. \displaystyle g^{(2)}(\tau) = \frac{\langle a^\dagger(0)a^\dagger(\tau)a(\tau)a(0)\rangle}{\langle a^\dagger(0)a(0)\rangle^2}. For a coherent state :math:`g^{(2)}(\tau) = 1`, for a thermal state :math:`g^{(2)}(\tau=0) = 2` and it decreases as a function of time (bunched photons, they tend to appear together), and for a Fock state with :math:`n` photons :math:`g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1` and it increases with time (anti-bunched photons, more likely to arrive separated in time). To calculate this type of correlation function with QuTiP, we can use :func:`.correlation_3op_1t`, which computes a correlation function on the form :math:`\left<A(0)B(\tau)C(0)\right>` (three operators, one delay-time vector).; We first have to combine the central two operators into one single one as they are evaluated at the same time, e.g. here we do :math:`a^\dagger(\tau)a(\tau) = (a^\dagger a)(\tau)`. The following code calculates and plots :math:`g^{(2)}(\tau)` as a function of :math:`\tau` for a coherent, thermal and Fock state. .. plot:: guide/scripts/correlation_ex4.py; :width: 5.0in; :include-source:. For convenience, the steps for calculating the second-order coherence function have been collected in the function :func:`.coherence_function_g2`.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:8750,guid,guide,8750,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['guid'],['guide']
Usability,"all `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :m",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4574,simpl,simply,4574,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,1,['simpl'],['simply']
Usability,"all to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gra",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114538,simpl,simplifying,114538,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['simpl'],['simplifying']
Usability,"at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documen",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:3839,guid,guide,3839,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['guid'],['guide']
Usability,"ate the system state at; result = solver.run(rho0, tlist). The ``max_depth`` parameter determines how many levels of the hierarchy to; retain. As a first approximation hierarchy depth may be thought of as similar; to the order of Feynman Diagrams (both classify terms by increasing number; of interactions). The ``result`` is a standard QuTiP results object with the attributes:. - ``times``: the times at which the state was evaluated (i.e. ``tlist``); - ``states``: the system states at each time; - ``expect``: a list with the values of each ``e_ops`` at each time; - ``e_data``: a dictionary with the values of each ``e_op`` at each time; - ``ado_states``: see below (an instance of; :class:`~qutip.solver.heom.HierarchyADOsState`). If ``ado_return=True`` is passed to ``.run(...)`` the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as ``.ado_states``. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see :ref:`heom-determining-currents`). If one has a full set of ADOs from a previous call of ``.run(...)`` you may; supply it as the initial state of the solver by calling; ``.run(result.ado_states[-1], tlist, ado_init=True)``. As with other QuTiP solvers, if expectation operators or functions are supplied; using ``.run(..., e_ops=[...])`` the expectation values are available in; ``result.expect`` and ``result.e_data``. Below we run the solver again, but use ``e_ops`` to store the expectation; values of the population of the system states and the coherence:. .. plot::; :context:. # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:4565,guid,guide,4565,doc/guide/heom/bosonic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst,1,['guid'],['guide']
Usability,"ate. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the d",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6809,learn,learned,6809,doc/guide/guide-measurement.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,2,['learn'],['learned']
Usability,"aw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99564,simpl,simplified,99564,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['simpl'],['simplified']
Usability,"b.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Giguère); - Ensured that tidyup's default tolerance is read from settings at each call. (`#1830 <https://github.com/qutip/qutip/pull/1830>`_ by Eric Giguère); - Fixed ``scipy.sparse`` deprecation warnings raised by ``qutip.fast_csr_matrix``. (`#1827 <https://github.com/qutip/qutip/pull/1827>`_ by Simon Cross); - Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (`#1818 <https://github.com/qutip/qutip/pull/1818>`_ by Simon Cross); - Fixed the displaying of ``Lattice1d`` instances and their unit cells. Previously calling them raised exceptions in simple cases. (`#1819 <https://github.com/qutip/qutip/pull/1819>`_, `#1697 <https://github.com/qutip/qutip/pull/1697>`_ and `#1702 <https://github.com/qutip/qutip/pull/1702>`_ by Simon Cross and Saumya Biswas); - Fixed the displaying of the title for ``hinton`` and ``matrix_histogram`` plots when a title is given. Previously the supplied title was not displayed. (`#1707 <https://github.com/qutip/qutip/pull/1707>`_ by Vladimir Vargas-Calderón); - Removed an incorrect check on the initial state dimensions in the ``QubitCircuit`` constructor. This allows, for example, the construction of qutrit circuits. (`#1807 <https://github.com/qutip/qutip/pull/1807>`_ by Boxi Li); - Fixed the checking of ``method`` and ``offset`` parameters in ``coherent`` and ``coherent_dm``. (`#1469 <https://github.com/qutip/qutip/pull/1469>`_ and `#1741 <https://github.com/qutip/qutip/pull/1741>`_ by Joseph Fox-Rabinovitz and Simon Cross); - Removed the Hamiltonian saved in the ``sesolve`` solver r",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:62731,simpl,simple,62731,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['simpl'],['simple']
Usability,"both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: `bloch_decay.mp4 <https://raw.githubusercontent.com/qutip/qutip/master/doc/figures/bloch_decay.mp4>`_; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:13589,clear,clear,13589,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"cke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histogram, plot_energy_levels, plot_fock_distribution, plot_wigner, sphereplot, plot_schmidt, plot_qubism, plot_expectation_values, plot_wigner_sphere, plot_spin_distribution; :undoc-members:. .. automodule:: qutip.animation; :members: anim_hinton, anim_matrix_histogram, anim_fock_distribution, anim_wigner, anim_sphereplot, anim_schmidt, anim_qubism, anim_wigner_sphere, anim_spin_distribution. .. automodule:: qutip.matplotlib_utilities; :members: wigner_cmap, complex_phase_cmap. Quantum Process Tomography; --------------------------. .. automodule:: qutip.tomography; :members: qpt, qpt_plot, qpt_plot_combined; :undoc-members:. .. _functions-non_markov:. Non-Markovian Solvers; =====================. .. automodule:: qutip.solver.nonmarkov.transfertensor; :members: ttmsolve. Utility Functions; =================. .. _functions-utilities:. Utility Functions; -----------------. .. automodule:: qutip.utilities; :members: n_thermal, clebsch, convert_unit. .. _functions-fileio:. File I/O Functions; ------------------. .. automodule:: qutip.fileio; :members: file_data_read, file_data_store, qload, qsave. .. _functions-parallel:. Parallelization; ---------------. .. automodule:: qutip.solver.parallel; :members: parallel_map, serial_map, loky_pmap, mpi_pmap. .. _functions-ipython:. IPython Notebook Tools; ----------------------. .. automodule:: qutip.ipynbtools; :members: version_table. .. _functions-misc:. Miscellaneous; -------------. .. automodule:: qutip; :members: about, simdiag; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:7246,undo,undoc-members,7246,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['undo'],['undoc-members']
Usability,"ctor:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_poi",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:2170,clear,clear,2170,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"cumentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to in",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:2345,guid,guide,2345,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['guid'],['guide']
Usability,"d or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,. d. to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. i. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;. ii. Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; ri",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:6295,clear,clearly,6295,doc/LICENSE_cc-by-3.0.txt,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt,1,['clear'],['clearly']
Usability,"e ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may st",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18219,feedback,feedback,18219,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['feedback'],['feedback']
Usability,"e guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of exampl",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1239,guid,guide,1239,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['guid'],['guide']
Usability,"e members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyprojec",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3062,simpl,simply,3062,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['simpl'],['simply']
Usability,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10474,simpl,simple,10474,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['simpl'],['simple']
Usability,"e of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidel",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5886,simpl,simplest,5886,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['simpl'],['simplest']
Usability,"ectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2537,simpl,simply,2537,doc/guide/dynamics/dynamics-data.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst,1,['simpl'],['simply']
Usability,"en returns a vector with the correlation values corresponding to the times in `taulist` (the fourth argument). Example: first-order optical coherence function; -----------------------------------------------. This example demonstrates how to calculate a correlation function on the form :math:`\left<A(\tau)B(0)\right>` for a non-steady initial state. Consider an oscillator that is interacting with a thermal environment. If the oscillator initially is in a coherent state, it will gradually decay to a thermal (incoherent) state. The amount of coherence can be quantified using the first-order optical coherence function :math:`g^{(1)}(\tau) = \frac{\left<a^\dagger(\tau)a(0)\right>}{\sqrt{\left<a^\dagger(\tau)a(\tau)\right>\left<a^\dagger(0)a(0)\right>}}`. For a coherent state :math:`|g^{(1)}(\tau)| = 1`, and for a completely incoherent (thermal) state :math:`g^{(1)}(\tau) = 0`. The following code calculates and plots :math:`g^{(1)}(\tau)` as a function of :math:`\tau`. .. plot:: guide/scripts/correlation_ex3.py; :width: 5.0in; :include-source:. For convenience, the steps for calculating the first-order coherence function have been collected in the function :func:`.coherence_function_g1`. Example: second-order optical coherence function; ------------------------------------------------. The second-order optical coherence function, with time-delay :math:`\tau`, is defined as. .. math::. \displaystyle g^{(2)}(\tau) = \frac{\langle a^\dagger(0)a^\dagger(\tau)a(\tau)a(0)\rangle}{\langle a^\dagger(0)a(0)\rangle^2}. For a coherent state :math:`g^{(2)}(\tau) = 1`, for a thermal state :math:`g^{(2)}(\tau=0) = 2` and it decreases as a function of time (bunched photons, they tend to appear together), and for a Fock state with :math:`n` photons :math:`g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1` and it increases with time (anti-bunched photons, more likely to arrive separated in time). To calculate this type of correlation function with QuTiP, we can use :func:`.correlation_3op_1t`, which ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:7292,guid,guide,7292,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['guid'],['guide']
Usability,"er/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this di",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1686,simpl,simplest,1686,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['simpl'],['simplest']
Usability,"ffoli, hadamard_transform, qubit_clifford_group, globalphase; . Energy Restricted Operators; ---------------------------. .. automodule:: qutip.core.energy_restricted; :members: enr_state_dictionaries, enr_thermal_dm, enr_fock, enr_destroy, enr_identity. .. _functions-rand:. Quantum Objects; ---------------. .. automodule:: qutip.core.qobj; :members: ptrace, issuper, isoper, isoperket, isoperbra, isket, isbra, isherm. Random Operators and States; ---------------------------. .. automodule:: qutip.random_objects; :members: rand_dm, rand_herm, rand_ket, rand_stochastic, rand_unitary, rand_super, rand_super_bcsz, rand_kraus_map. Superoperators and Liouvillians; -------------------------------. .. automodule:: qutip.core.superoperator; :members: operator_to_vector, vector_to_operator, liouvillian, spost, spre, sprepost, lindblad_dissipator. Superoperator Representations; -----------------------------. .. automodule:: qutip.core.superop_reps; :members: kraus_to_choi, kraus_to_super, to_choi, to_chi, to_super, to_kraus, to_stinespring; :undoc-members:. Operators and Superoperator Dimensions; --------------------------------------. .. automodule:: qutip.core.dimensions; :members: to_tensor_rep, from_tensor_rep. Functions acting on states and operators; ========================================. Expectation Values; ------------------. .. automodule:: qutip.core.expect; :members: expect, variance. Tensor; ------. .. automodule:: qutip.core.tensor; :members: tensor, super_tensor, composite, tensor_contract. Partial Transpose; -----------------. .. automodule:: qutip.partial_transpose; :members: partial_transpose. .. _functions-entropy:. Entropy Functions; -----------------. .. automodule:: qutip.entropy; :members: concurrence, entropy_conditional, entropy_linear, entropy_mutual, entropy_relative, entropy_vn. Density Matrix Metrics; ----------------------. .. automodule:: qutip.core.metrics; :members: fidelity, tracedist, bures_dist, bures_angle, hellinger_dist, hilbert_dist, a",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:2254,undo,undoc-members,2254,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['undo'],['undoc-members']
Usability,"fic contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`); - Rochisha Agarwal (Add dtype to printed ouput of qobj, `#2352 <https://github.com/qutip/qutip/pull/2352>`); - Kosuke Mizuno (Add arguments of plot_wigner() and plot_wigner",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:6208,guid,guide,6208,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,"g/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:8049,guid,guidelines,8049,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['guid'],['guidelines']
Usability,"ger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histog",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:5655,undo,undoc-members,5655,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['undo'],['undoc-members']
Usability,"he cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the le",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11231,clear,clear,11231,doc/development/release_distribution.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst,1,['clear'],['clear']
Usability,"hen the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:3446,simpl,simple,3446,doc/guide/dynamics/dynamics-krylov.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst,1,['simpl'],['simple']
Usability,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14323,guid,guide,14323,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,2,['guid'],['guide']
Usability,"ist antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `g",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104992,progress bar,progress bars,104992,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['progress bar'],['progress bars']
Usability,"it commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools sect",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2488,feedback,feedback,2488,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['feedback'],['feedback']
Usability,"l the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite contro",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8828,simpl,simple,8828,doc/guide/guide-control.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,1,['simpl'],['simple']
Usability,"l., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:13405,simpl,simplified,13405,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['simpl'],['simplified']
Usability,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/README.md:1856,user-friendly,user-friendly,1856,README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md,1,['user-friendly'],['user-friendly']
Usability,"ly reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-indep",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14673,progress bar,progress bar,14673,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['progress bar'],['progress bar']
Usability,"ly reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagona",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41427,progress bar,progress bar,41427,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['progress bar'],['progress bar']
Usability,"mber the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the ``save()`` method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:12671,clear,clear,12671,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"n 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All us",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13359,simpl,simply,13359,doc/development/contributing.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst,1,['simpl'],['simply']
Usability,"n the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:2288,guid,guide,2288,doc/README.md,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md,1,['guid'],['guide']
Usability,"nds. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data.",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:3027,clear,clear,3027,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"ng list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:3074,clear,clear,3074,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"oints`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the dat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4389,clear,clear,4389,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"on using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` function, if we pass the density matrix at time :math:`t_1` as second argument, and `None` as third argument. The :func:`.correlation_2op_2t` function then returns a vector with the correlation values corresponding to the times in `taulist` (the fourth argument). Example: first-order optical coherence function; -----------------------------------------------. This example demonstrates how to calculate a correlation function on the form :math:`\left<A(\tau)B(0)\right>` for a non-steady initial state. Consider an oscillator that is interacting with a thermal environment. If the oscillator initially is in a coherent state, it will gradually decay to a thermal (incoherent) state. The amount of coh",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:5841,guid,guide,5841,doc/guide/guide-correlation.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,1,['guid'],['guide']
Usability,"opic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in `qutip.qip.device` and; `qutip.qip.compiler`. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * quantum information processing and quantum computing (quantum circuit formalism). Difficulty; ==========. * Medium. Mentors; =======. * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. .. [2] Häffner H, Roos C F, Blatt R, **Quantum computing with trapped ions**, Physics reports, 2008, 469(4): 155-203. .. [3] Krantz P, Kjaergaard M, Yan F, et al. **A quantum engineer's guide to superconducting qubits**, Applied Physics Reviews, 2019, 6(2): 021318.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:2873,guid,guide,2873,doc/development/ideas/pulse-level-quantum-circuits.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst,1,['guid'],['guide']
Usability,"or :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Tru",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:42920,simpl,simply,42920,doc/guide/guide-states.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,1,['simpl'],['simply']
Usability,"oviding the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the p",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5248,learn,learning,5248,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['learn'],['learning']
Usability,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:6046,feedback,feedback,6046,doc/guide/dynamics/dynamics-stochastic.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst,1,['feedback'],['feedback']
Usability,"pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wikståhl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Giguère); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Giguère); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73086,guid,guide,73086,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,"put looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; =======",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12493,learn,learners,12493,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['learn'],['learners']
Usability,"quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`_, or by raising issues in `the main GitHub repository <https://github.com/qutip/qutip>`_ if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See :ref:`developers-contributors` for a list of people who have helped in one way or another.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:8153,guid,guide,8153,doc/frontmatter.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst,1,['guid'],['guide']
Usability,"quet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is interacting with its environment is not necessarily well; described by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take th",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:11140,guid,guide,11140,doc/guide/dynamics/dynamics-floquet.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst,1,['guid'],['guide']
Usability,"rough the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galán); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implement",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28630,guid,guide,28630,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,"s initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view sta",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12214,simpl,simple,12214,doc/development/roadmap.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst,1,['simpl'],['simple']
Usability,"s:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :include-source:; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8469,simpl,simple,8469,doc/guide/guide-steady.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"sampling algorithm for mcsolve (#2218 by Daniel Weiss); - Added support for early termination of map functions. (#2222). Bug Fixes; ---------. - Add missing state transformation to floquet_markov_mesolve (#1952 by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 by Asier Galicia); - Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template. (#2107 by Valan Baptist Mathuranayagam); - Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05. (#2181 by SJUW); - Raise error on insufficient memory. (#2224); - Fixed fallback to fsesolve call in fmmesolve (#2225). Removals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - O",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:31776,guid,guide,31776,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['guid'],['guide']
Usability,"se level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:1004,simpl,simple,1004,doc/development/ideas/pulse-level-quantum-circuits.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst,1,['simpl'],['simple']
Usability,"spond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varie",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4436,clear,clear,4436,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"stems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histogram, plot_energy_levels, plot_fock_distribution, plot_wigner, sphereplot, plot_schmidt, plot_qubism, plot_expectation_values, plot_wigner_sphere, plot_spin_distribution; :undoc-members:. .. automodule:: qutip.animation; :members: anim_hinton, anim_matrix_histogram, anim_fock_distribution, anim_wigner, anim_sphereplot, anim_schmidt, anim_qubism, anim_wigner_sphere, anim_spin_distribution. .. automodule:: qutip.matplotlib_utilities; :members: wigner_cmap, complex_phase_cmap. Quantum Process Tomography; --------------------------. .. automodule:: qutip.tomography; :members: qpt, qpt_plot, qpt_plot_combined; :undoc-members:. .. _functions-non_markov:. Non-Markovian Solvers; =====================. .. automodule:: qutip.solver.nonmarkov.transfertensor; :members: ttmsolve. Utility Functions; =================. .. _functions-utilities:. Utility Functions; -----------------. .. automodule:: qutip.utilities; :members: n_thermal, clebsch, convert_unit. .. _functions-fileio:. File I/O Functions; ------------------. .. automodule:: qutip.fileio; :members: file_data_r",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:6804,undo,undoc-members,6804,doc/apidoc/functions.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst,1,['undo'],['undoc-members']
Usability,"t = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th)",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:2759,clear,clear,2759,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"tate :math:`\rho(t)` defined by. .. math::; :label: mc_martingale_state. \rho(t) = \frac{1}{N}\sum_{l=1}^N \mu_l(t) |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and shifted; rates :math:`\gamma_n(t)-K(t)`. Thus, while :math:`\Gamma_n(t) \geq 0`, the new; ""rates"" :math:`\gamma_n(t) = \Gamma_n(t) - K(t)` satisfy no positivity requirement. The input of :func:`.nm_mcsolve` is almost the same as for :func:`.mcsolve`.; The only difference is how the collapse operators and rate functions should be; defined. ``nm_mcsolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:3146,simpl,simple,3146,doc/guide/dynamics/dynamics-nmmonte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst,1,['simpl'],['simple']
Usability,"the print command:. .. doctest::. >>> b = qutip.Bloch(). >>> print(b) # doctest: +NORMALIZE_WHITESPACE; Bloch data:; -----------; Number of points: 0; Number of vectors: 0; <BLANKLINE>; Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]; <BLANKLINE>. .. _bloch-animate:. Animating with the Bloch sphere; ===============================. The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the ``save()`` method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. impor",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:11600,clear,clear,11600,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['clear'],['clear']
Usability,"to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie ma",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:12921,simpl,simple,12921,doc/guide/guide-bloch.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,1,['simpl'],['simple']
Usability,"tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian dat",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113677,progress bar,progress bar,113677,doc/changelog.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst,1,['progress bar'],['progress bar']
Usability,"um_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right). where :math:`J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}` are SU(2) Pauli spin operators, with :math:`{\alpha=x,y,z}` and :math:`J_{\pm,n}=\sigma_{\pm,n}`. The collective spin operators are :math:`J_{\alpha} = \sum_{n}J_{\alpha,n}` . The Lindblad super-operators are :math:`\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A`. The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension :math:`4^N`. By exploiting the permutational invariance of identical particles [2-8], the Liouvillian :math:`\mathcal{D}_\text{TLS}(\rho)` can be built as a block-diagonal matrix in the basis of Dicke states :math:`|j, m \rangle`. The system under study is defined by creating an object of the; :class:`~qutip.piqs.piqs.Dicke` class, e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst:2107,simpl,simply,2107,doc/guide/guide-piqs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst,1,['simpl'],['simply']
Usability,"unning doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the ``NORMALIZE_WHITESPACE`` option to ensure that the; multiline output matches. **Render:**. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +SKIP; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. - A useful argument to specify in plot blocks is that of ``context`` which ensures; that the code is being run in the namespace of the previous plot block within the; same file. - By default, each rendered figure in one plot block (when using ``:context:``); is carried over to the next block. - When the ``context`` argument is specified with the ``reset`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. - When the ``context`` argument is specified with the ``close-figs`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages.; ",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:6001,learn,learn,6001,doc/development/docs.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst,1,['learn'],['learn']
Usability,"y default, ``ntraj=500`` indicating that 500 Monte Carlo; trajectories will be performed. To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,; let's again consider the case of a two-level atom coupled to a leaky cavity.; The only differences to the master-equation treatment is that in this case we; invoke the :func:`.mcsolve` function instead of :func:`.mesolve`. .. plot::; :context: reset. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). .. guide-dynamics-mc1:. The advantage of the Monte Carlo method over the master equation approach is that; only the state vector is required to be kept in the computers memory, as opposed; to the entire density matrix. For large quantum system this becomes a significant; advantage, and the Monte Carlo solver is therefore generally recommended for such; systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins; with random parameters and initial states takes almost 7 times longer using the; master equation rather than Monte Carlo approach with the default number of; trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times; the memory as well. However, for small systems, the added overhead of averaging; a large number of stochastic trajectories to obtain the open system dynamics, as; well as starting the multiprocessing functionality, outweighs the benefit of the; minor (in this case) memory saving. Master equation methods are therefore; generally more eff",MatchSource.DOCS,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:5225,guid,guide-dynamics-,5225,doc/guide/dynamics/dynamics-monte.rst,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst,1,['guid'],['guide-dynamics-']
