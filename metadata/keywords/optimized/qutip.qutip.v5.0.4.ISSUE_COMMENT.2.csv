quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"s tests on all platforms. They pass for all besides Mac OS (similar error as for other PR). With `python setup.py install`, with `install` instead of `develop`, things seem to work. What it is unclear to me is why it reads that the QuTiP Version is `4.4.0.dev0+1a639d7a`, when I could not find this hash in here (or maybe I am confused). Now, after some tries with install and develop, I am on that version of qutip-dev. . To begin with, I am running the contents of the [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). Some comments below are relevant to the PR of the notebooks, https://github.com/qutip/qutip-notebooks/pull/71. * `development-qobjevo.ipynb`: Runs fine. ; * `development-qobjevo-adv.ipynb`: Runs fine. ; * `development-qobjevo-timing.ipynb`: Runs fine. * The notebook [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb) could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:1048,depend,dependent,1048,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['depend'],['dependent']
Integrability,"site may help for future reference. On Wed, 13 May 2020 at 23:38, Eric Giguère <notifications@github.com> wrote:. > I did some tests and; > 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian; > matrices) (c's version Ok); > 2 - It happen when installing the scipy stack with pip but not when; > installing it with conda.; > 3 - It depend on the problem size, 64 seems particularly bad, usually it; > fails on the second call.; > 4 - I only got it in zheevr which is only used in brmesolve. But Nathan; > got it in other tests which use scipy's eigh.; > 4 - It happen in scipy in the fortan version of lapack:; >; > import numpy as np; > from scipy.linalg import eigh; > H = random_hermitian(64); > eigh(H) # Work fine; > eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; >; > Possible solutions (for zheevr):; >; > - Installing scipy with conda, the easiest solution, but not in our; > control.; > - Finding a way to link clapack from cython. Linking scipy's one would; > require good knowledge of scipy internals since only one cython interface; > is provided. Linking to another installation of lapack, but it would; > require the user to install lapack or install it with qutip. Both seems; > wrong to me.; > - For mac user, call scipy's eigh from cython i zheevr, slower but; > better than risking segfault.; > - Have the code directly in qutip. We can adapt it from OpenBlas:; > https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1197#issuecomment-628259492>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67AJF3WTZBCU4YWFY23RRMHMHANCNFSM4LCKXE6A>; > .; >; -- ; Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264:1341,interface,interface,1341,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264,1,['interface'],['interface']
Integrability,"sounds good to me. On 10 Jan 2017 07:30, ""Paul Nation"" <notifications@github.com> wrote:. > A faster isherm function. 3-5x faster if operator is Hermitian, 100x+; > faster if not. Essentially does a modified adjoint calculation. This; > requires having a csr matrix in canonical format, which is not guaranteed; > under sparse multiplication. Since canonical format is important for; > time-dependent dynamics as well, fast_csr_matrix now does the indices and; > data sorting for canonical format after multiplication. This gives a slight; > performance hit, but having all Qobj in canonical format outweighs this.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/qutip/qutip/pull/629; > Commit Summary; >; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - ENH: Faster isherm; >; > File Changes; >; > - *M* qutip/cy/spmath.pyx; > <https://github.com/qutip/qutip/pull/629/files#diff-0> (82); >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/629#issuecomment-271928375:391,depend,dependent,391,https://qutip.org,https://github.com/qutip/qutip/pull/629#issuecomment-271928375,1,['depend'],['dependent']
Integrability,"ssues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inputs, that would be virtually impossible (or very close to that) to occur in practical scenarios. In any case, I'd strongly recommend performing a time-boxed experiment on a small subset of tests, which are more suited to property-based testing, and examining how that affects the test-run-completion time(s) and whether it introduces more failures than what would be desired/cost-efficient.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:2780,depend,depending,2780,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,1,['depend'],['depending']
Integrability,"stalled.; > > > Graph: Reverse Cuthill-McKee Ordering (simple) ... ok; > > > Graph: Reverse Cuthill-McKee Ordering (Bucky) ... ok; > > > Graph: Reverse Cuthill-McKee Ordering (boost) ... ok; > > > Monte-carlo: Constant H with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H (str format) with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H (func format) with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H (str format) with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H (func format) with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H with constant collapse ... ok; > > > Monte-carlo: Constant H with single collapse operator ... ok; > > > Monte-carlo: Constant H with single expect operator ... ok; > > > Monte-carlo: Collapse terms constant (func format) ... ok; > > > Monte-carlo: Collapse terms constant (str format) ... ok; > > > Monte-carlo: Time-dependent H (func format) ... ok; > > > Monte-carlo: Time-dependent H (str format) ... ok; > > > Monte-carlo: check for correct dtypes (average_states=True) ... ok; > > > Monte-carlo: check for correct dtypes (average_states=False) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (average_states=True) ... ok; > > > mcsolve_f90: check for correct dtypes (average_states=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as fu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:4400,depend,dependent,4400,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['depend'],['dependent']
Integrability,"t I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33 PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you can point me at the latest versions, I can think about; > how to convert them into unit tests and add them to the new PR.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AU2Z2WLCVH7BFC2QLXOW6QNANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:2516,Message,Message,2516,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036,1,['Message'],['Message']
Integrability,"t handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to allow easy conversion of objects to qutip objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:3536,interface,interface,3536,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,1,['interface'],['interface']
Integrability,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1147,integrat,integrator,1147,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199,1,['integrat'],['integrator']
Integrability,"te0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1671,rout,routine,1671,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,1,['rout'],['routine']
Integrability,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13066,integrat,integrate,13066,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['integrat'],"['integrate', 'integrator']"
Integrability,"tents/lib/python2.7/distutils/dist.py"", line 953, in run_commands; > self.run_command(cmd); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > cmd_obj.run(); > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > _build_ext.build_ext.run(self); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > self.build_extensions(); > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > self.build_extension(ext); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > depends=ext.depends); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > raise CompileError, msg; > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > import numpy as np; > ; > from qutip import *; > Traceback (most recent call last):; > File """", line 1, in ; > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/init.py"", line 62, in ; > qutip.settings.ipython = False; > AttributeError: 'module' object has no attribute 'settings'; > ; > ######################; > ; > This seems similar to the build error in Installation on OS X with Homebrew script error #348.; > ; > Is this a bug in quti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/382#issuecomment-148179436:4204,depend,depends,4204,https://qutip.org,https://github.com/qutip/qutip/issues/382#issuecomment-148179436,1,['depend'],['depends']
Integrability,"thanks Dani, I think if you encode the problem in a more standard qutip structure the dependence on the small frequencies disappears;; ```; d = destroy(2).dag(); L_s = liouvillian(0*d.dag()*d, [np.sqrt(Gamma_l) *d, np.sqrt(Gamma_r) *d.dag()]); rho_ss = steadystate(L_s); I_s = Gamma_r * sprepost(d.dag(),d); current, noise, skw = third_cumulant(L_s, rhoss=rho_ss, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""); ```. So I would prefer to revert the pseudo_inverse change (which is there originally to catch a different issue with the noise exploding). But nice example! this would make a great test I think. For the third_cumulant itself, maybe better to combine with the existing countstat_current_noise function, and provide the third cumulant, and support J_ops!=I_ops, as options?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607:86,depend,dependence,86,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607,1,['depend'],['dependence']
Integrability,"thanks for the comment, I didn't know about `qutip.propagator`. > Lots of people have successfully used QuTiP already as part of reinforcement learning protocols - I've worked with at least a couple. cool, can i learn more about this from you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1323#issuecomment-660472157:152,protocol,protocols,152,https://qutip.org,https://github.com/qutip/qutip/issues/1323#issuecomment-660472157,1,['protocol'],['protocols']
Integrability,thanks. can you also please run:; ```; import qutip; qutip.about(); ```; and copy here the message?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1374#issuecomment-717351448:91,message,message,91,https://qutip.org,https://github.com/qutip/qutip/issues/1374#issuecomment-717351448,1,['message'],['message']
Integrability,"the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inp",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:2007,depend,depend,2007,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,1,['depend'],['depend']
Integrability,the structure of the states returned are different. A subtle difference is mcsolve returns a representation of state wrapped with one more square bracket.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/330#issuecomment-90325080:117,wrap,wrapped,117,https://qutip.org,https://github.com/qutip/qutip/issues/330#issuecomment-90325080,1,['wrap'],['wrapped']
Integrability,"tip.qeye(2))); array([[0.84147098+0.j, 0. +0.j],; [0. +0.j, 0.84147098+0.j]]); ```; Alternatively, if people _really_ want to be able to use ufuncs on `Qobj`, it is possible to define `__array_ufunc__` in such a way that we allow only some `ufuncs` to operate. Doing this leaves us susceptible to problems interacting with other libraries that implement this, though, beacuse whichever class has the highest `__array_priority__` gets to dictate what makes sense. Unless there's a really clear _need_ for this, I don't think it's a good idea. For completeness, the rest of this comment is stuff I find out while researching. ## The `__array__()` and `__array_wrap__()` methods. These have been special methods understood by numpy since at least 1.3 (2009 - the oldest docs still on scipy.org), and I imagine long before then too. `__array__` is mentioned (and still is) in the documentation of `np.array`, which is unchanged since 2009 and says that its argument should be; > An array, any object exposing the array interface, an object whose `__array__` method returns an array, or any (nested) sequence. and `__array_wrap__` is like the reverse - it's for coercing numpy arrays back into this class. If we were to keep `__array__` in `Qobj`, we should also implement `__array_wrap__` for coercion back (something that isn't currently implemented). At the time and up to inclusively 1.19, the presence of `__array__` caused otherwise scalar types passed alone to `np.array` to return the output of `input.__array__(*args, **kwargs)`, instead of becoming a 0D numpy array (like `np.array(1)` does). Taken purely alone, that could make sense as something we implement. However, this also implies that `Qobj` should fulfil the numpy ufunc interface; `Qobj` would be a container for data such that operations like `np.sin` is the elementwise sin, or (most notably) `np.multiply` is the *elementwise* multiplication. Our `Qobj` _does not_ fulfil the ufunc interface:; 1. elementwise operations don't make s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:3198,interface,interface,3198,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,1,['interface'],['interface']
Integrability,"tructure of dimensions objects are going to change in 5.0 (though the list structure will still work). This should even give you more freedom, if you need it - I've got some plans for vastly improved handling of restricted-entry Hilbert spaces (basically spaces that are small embeddings into a larger space that's all 0).; - I am very strongly against accepting this (like I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_function__` and other additional methods on top to start to make it work, and it's still not perfect - even `scipy.sparse` have/had problems implementing them. While it might work in your particular case, making sure that nothing funny happens in the abstract across _all_ possible implementors of the interface while still having it do something useful is a very tricky problem, as evidenced by Numpy. Any conversion is going to be lossy for some people (perhaps not you, but it will be for others), and that means the behaviour for users will be surprising in some cases. In my opinion, if we're going to have a `__qutip_qobj__` interface, the interface should be defined for one operation only, and should never be called implicitly. I'm not entirely close-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:2301,interface,interface,2301,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['interface'],['interface']
Integrability,"umerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6118,integrat,integrators,6118,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['integrat'],['integrators']
Integrability,"updated OS from High Sierra to Mojave, plus some other updates in scipy and numpy, and reinstalled conda, so I am curious to see if these speedups are machine independent, which would be great. My specs; ```; Software	Version; QuTiP	4.4.0.dev0+e1639f73; Numpy	1.16.4; SciPy	1.2.1; matplotlib	3.1.0; Cython	0.29.8; Number of CPUs	2; BLAS Info	INTEL MKL; IPython	7.5.0; Python	3.7.3 (default, Mar 27 2019, 16:54:48) [Clang 4.0.1 (tags/RELEASE_401/final)]; OS	posix [darwin]; Mon Jun 10 21:16:02 2019 JST; ```; Some details:; In cell 6 of development-ssesolver-new-methods, the running time went from over 160 seconds to 6 seconds (x25 speedup). Total run time in cell 21 is now down to 14.22s from 79.46s, cell 24/25 of is now 1.4 seconds down from 14.22s in `smesolve`. `ssesolve` in cell 4 is down from 164.50s to 11.06s. Cell 6 is down to 11.48s from 250s. The next cell checking all solver methods in `ssesolve` is down from 80s to 24s. In the notebook with new smesolve methods, cell 11 with multiple time dependence in sc_ops now runs in 69s instead of 171s. . Also, the benchmarking of the different methods now reads; ```; {'solver': 'euler-maruyama'}; Total run time: 0.21s; Total run time: 0.25s; Total run time: 0.30s; Total run time: 0.38s; Total run time: 0.45s; Total run time: 0.55s; Total run time: 0.67s; Total run time: 0.81s; {'solver': 'platen'}; Total run time: 0.70s; Total run time: 0.90s; Total run time: 1.13s; Total run time: 1.15s; Total run time: 1.41s; Total run time: 1.66s; Total run time: 2.03s; Total run time: 2.47s; {'solver': 'pc-euler'}; Total run time: 0.38s; Total run time: 0.46s; Total run time: 0.58s; Total run time: 0.70s; Total run time: 0.84s; Total run time: 1.00s; Total run time: 1.26s; Total run time: 1.49s; {'solver': 'milstein'}; Total run time: 0.31s; Total run time: 0.39s; Total run time: 0.46s; Total run time: 0.56s; Total run time: 0.70s; Total run time: 0.84s; Total run time: 1.05s; Total run time: 1.24s; {'solver': 'milstein-imp'}; Total r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990#issuecomment-500396003:1618,depend,dependence,1618,https://qutip.org,https://github.com/qutip/qutip/pull/990#issuecomment-500396003,1,['depend'],['dependence']
Integrability,"ve to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamilt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1436,integrat,integrator,1436,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,1,['integrat'],['integrator']
Integrability,"ver-package=qutip qutip; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... ok; BR Tools : dense operator to eigenbasis ... ok; BR Tools : vector to eigenbasis ... ok; BR Tools : eigvector to fockbasis ... ok; BR Tools : vector roundtrip transform ... ok; BR Tools : Diagonal liouvillian mult ... ok; BR Tools : cop_super_mult ... ok; BR Tools : br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear in",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576:1209,depend,dependent,1209,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576,1,['depend'],['dependent']
Integrability,"will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4959,interface,interface,4959,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['interface'],['interface']
Modifiability," > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would have to become nested too (at least conceptually)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:1321,flexible,flexible,1321,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005,1,['flexible'],['flexible']
Modifiability," br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (tau) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (Qobj) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (OO) ... ok; control.pulseoptim: Hadamard gate gradient check ... ok; control.pulseoptim: QFT gate with linear initial pulses ... ok; control.pulseoptim: QFT gate with linear initial pulses (bounds) ... ok; control: data dumping ... ok; control: unitarity checking (via dump) ... ok; control.pulseoptim: state-to-state transfer ... ok; control.pulseoptim: state-to-state transfer (Qobj) ... ok; control.pulseoptim: amplitude damping channel ... ok; control.pulseoptim: coupled oscillators (symplectic dynamics) ... ok; control.pulseoptim: Hadamard gate using CRAB algorithm ... ok; control.pulseoptim: Hadamard gate (loading config from file) ... ok; control.pulsegen: Check periodic control functions ... ok; control.pulseoptim: Hadamard gate with fixed and time varying drift ... ok; control.pulseoptim: Hadamard gate with fixed and time varying ctrls ... ok; correlation: legacy me and es for oscillator in coherent initial state ... ok; correlation: comparing me and es for oscillator in coherent initial state ... ok; correlation: comparing me and mc for driven oscillator in fock state ... ok; correlation: legacy me and es for oscillator in steady-state ... ok; correlation: comparing me and es for oscillator in steady-state ... ok; correlation: legacy spectrum from es and pi methods ... ok; correlation: comparing spectrum from es and fft methods ... ok; correlation: comparing spectrum from es and pi methods ... ok; correlation: comparing TLS emission corr., H td (str-list td format) ... ok; correlation: comparing TLS emission corr., H td (np-list td format) ... ok; correlation: comparing TLS emission ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:4447,config,config,4447,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['config'],['config']
Modifiability," compare the expectation value at the end of the simulation which is at time t = 1. . #First code:. import qutip; import numpy as np; options = qutip.Options(); options.nsteps = 100000; args = {'omega':1000}; time_grid = 1000; timelist = np.linspace(0, 1, time_grid); omegatlist = np.cos(args['omega']*timelist); H = qutip.QobjEvo([qutip.sigmax(),omegatlist], tlist= np.array(np.linspace(0, 1, time_grid), dtype=np.float64)); state = qutip.basis(2, 0).proj(); times = np.linspace(0, 1, 2); result = qutip.mesolve(H,state,times,[],qutip.sigmaz(),args=args,options=options); print(result.expect[0][1]). #Second code: ; import qutip; import numpy as np; options = qutip.Options(); options.nsteps = 100000; args = {'omega':1000}; time_grid = 1000; tlist = np.linspace(0, 1, time_grid); omegatlist = np.cos(args['omega']*tlist); H = [qutip.sigmax(),omegatlist]; state = qutip.basis(2, 0).proj(); times = tlist; result = qutip.mesolve(H,state,times,[],qutip.sigmaz(),args=args,options=options); print(result.expect[0][999]). The first code gives a value of 0.9999989185418086 and the second one returns a value of 0.9999989289570258. So, the two results are not exactly the same. For the above analytic Hamiltonian, the result seems to differ by a small decimal number. However for the non-analytic Hamiltonian that I am actually using, the result can differ by six orders of magnitude. May I know why there is a difference in the results obtained from the two methods above? Is it because when QobjEvo is used, the mesolve routine actually does not sample enough time grid points when it evolves the Hamiltonian (i.e., it does not sample all the time_grid points which is time_grid = 1000 as provided above)? If so, may you kindly tell me how to rectify this problem?. As per my original question, I would like the first code to give the same the expectation value of the operator at the final time as is in the second code but without having to evaluate the expectation value of the operator at all time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-808726734:1924,evolve,evolves,1924,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-808726734,1,['evolve'],['evolves']
Modifiability," module is small and very focussed. 2. Exactly - it's more of an internal type. Currently `Qobj` converts the underlying data object to dense `ndarray` and prints it for its `repr` method - I don't have any plans to change that, so `Qobj` will still be full and user-facing. My `CSR` repr actually just tells you the same information that `scipy.sparse.csr_matrix` does, just in a slightly more Python-looking form. 3. Yes, in some form or another. Perhaps we could talk about the best way to do that in a future meeting?. 4. `PyDataMem_NEW` isn't actually a Python routine, it's a numpy one, but that's largely irrelevant. The Python equivalent is `cpython.mem.PyMem_Malloc` and family. The reason I don't use the latter in general is because sometimes `PyMem_Malloc` allocates into Python-reserved stack-space, and if we subsequently pass the pointer to numpy, it will try to free it and cause a segfault. The reason for using `malloc` and `free` here is mostly just because there was a comment in the code I copied it from saying that raw `malloc` and `free` were slightly faster for allocating heap space to be released within the same function, so I just did what they did. I can change it - it's not important. When allocating space that _may_ be passed to numpy, I always use `PyDataMem_NEW` (or friends). 5. That's a mistake - I meant to take out that ability in `matmul_csr` because it's just asking for trouble (the user won't know how much space to allocate, and we're basically just asking for a segfault). I did `matmul_csr` first, and I hadn't decided yet exactly what I was doing. 6. Yeah, I'm going to add additional `imul`, `ineg` and `idiv` routines as dispatched operations. 7. LAPACK/BLAS as far as we can. I've no pretense to being able to write faster code than hardware-specific optimised stuff for matrices. I haven't actually written most of the numerical code in this PR either - it's just ported from current `qutip`, with the variable names changed to be more descriptive.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648270004:2803,variab,variable,2803,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648270004,1,['variab'],['variable']
Modifiability," since it there are so many different dispatch functions from mesolve depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions.; > ; > Please let me know what you think about implementing this in qutip.; > ; > Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?; > ; > import scipy; > ; > from qutip.mesolve import _generic_ode_solve; > from qutip.superoperator import liouvillian, mat2vec; > from qutip.settings import debug; > ; > if debug:; > import inspect; > ; > def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; > progress_bar):; > """"""; > Evolve the super-operator `E0` using an ODE solver, for constant ; > Liouvillian; > """"""; > ; > ```; > if debug:; > print(inspect.stack()[0][3]); > ; > """"""; > #; > # check initial state; > #; > if isket(rho0):; > # if initial state is a ket and no collapse operator where given,; > # fall back on the unitary schrodinger equation solver; > if len(c_op_list) == 0 and isoper(H):; > return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; > progress_bar); > ; > # Got a wave function as initial state: convert to density matrix.; > rho0 = ket2dm(rho0); > """"""; > ; > #; > # check initial value; > #; > if not E0.issuper:; > raise TypeError(""Argument 'E0' should be a super-operator""); > ; > #; > # construct liouvillian; > #; > if opt.tidy:; > H = H.tidyup(opt.atol); > ; > L = liouvillian(H, c_op_list); > ; > #; > # setup integrator; > #; > initial_vector = mat2vec(E0.full()).ravel(); > # r = scipy.integrate.ode(cy_ode_rhs); > r = scipy.integrate.ode(_rhs); > # r.set_f_params(L.data.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/384#issuecomment-150751174:3247,Evolve,Evolve,3247,https://qutip.org,https://github.com/qutip/qutip/issues/384#issuecomment-150751174,1,['Evolve'],['Evolve']
Modifiability,"#1249 should be reviewed and merged before this (because if it needs changed, then this PR has to be rebased on top of it), but also I'm going to change the Clifford group tests a little, and rebase the typo fix commit into the general refactor before this one should be merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626315063:236,refactor,refactor,236,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626315063,1,['refactor'],['refactor']
Modifiability,"'t access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6497,refactor,refactoring,6497,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['refactor'],['refactoring']
Modifiability,"(target). numpy_fidelity = np.abs(np.vdot(final_state.full(), target_state.full())); qutip_good_fidelity = np.abs((final_state.dag() * target_state)[0, 0]); qutip_bad_fidelity = qutip.fidelity(final_state, target_state); print('Correct: {}'.format(numpy_fidelity)); print('Still correct: {}'.format(qutip_good_fidelity)); print('Wrong: {}'.format(qutip_bad_fidelity)). # Correct: 0.9999999999849929; # Still correct: 0.9999999999849929; # Wrong: 1.0000000026189553; ```. The problem is clearly in the fact that you compute the fidelity of ket states by converting them into density matrices and using the general formula:; https://github.com/qutip/qutip/blob/564c987bdca385ae179730d0aad7b0d1e624e14d/qutip/metrics.py#L88-L113. This is fine in general, but can be very inefficient for large states, and is less numerically stable. An easy solution is to just compute the fidelity as the inner product when both states are kets. Moreover, the general formula might also be improvable: consider the following example (which uses the variables defined in the previous snippet):. ```; final_dm = qutip.ket2dm(final_state); target_dm = qutip.ket2dm(target_state); sqrt_final_dm = final_dm.sqrtm(); sqrt_target_dm = target_dm.sqrtm(); eig_vals = (sqrt_final_dm * target_dm * sqrt_final_dm).eigenenergies(); bad_fid = np.sqrt(eig_vals[eig_vals > 0]).sum(). prod_sqrt = (sqrt_final_dm * sqrt_target_dm); better_fid = scipy.linalg.svdvals(prod_sqrt.full()).sum(). print('bad fid: {}'.format(bad_fid)); print('better fid: {}'.format(better_fid)). # bad fid: 1.000000072436338; # better fid: 0.9999999999849937; ```; Here, I'm proceeding similarly to what qutip currently does, by converting to dms and then applying the general formula. However, I compute the general fidelity by summing the singular values of $\sqrt\rho \sqrt\sigma$, instead of summing the square roots of the eigenvalues of $\sqrt\sigma \rho \sqrt\sigma$. Mathematically, this is equivalent, and in this particular case does at least give a ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/925#issuecomment-542318121:1439,variab,variables,1439,https://qutip.org,https://github.com/qutip/qutip/issues/925#issuecomment-542318121,1,['variab'],['variables']
Modifiability,"* imports first except. ```from qutip.qobj import *```. then we can remove the numpy and scipy checks but numpy is still used to setup pyximport in . ```; # Setup pyximport ; import pyximport; os.environ['CFLAGS'] = '-O2 -w -ffast-math'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}); del pyximport; ```. Then we can move the section regarding multiprocessing to some appropiate place. Currently it is used in the following files. Can we put the multiprocessing stuff in a file called `multiprocessing_config.py` and run it to get the settings in `__init__` at all the places where we need multiprocessing.; ```; /Users/shahnawaz/dev/qutip/qutip/__init__.py:; 33 from __future__ import division, print_function, absolute_import; 34 import os; 35: # Fix the multiprocessing issue with NumPy compiled against OPENBLAS; 36 if 'OPENBLAS_MAIN_FREE' not in os.environ:; 37 os.environ['OPENBLAS_MAIN_FREE'] = '1'; ..; 149 # cpu/process configuration; 150 #; 151: import multiprocessing; 152 ; 153 # Check if environ flag for qutip processes is set; ...; 164 qutip.settings.num_cpus = info['cpus']; 165 else:; 166: qutip.settings.num_cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:1003,config,configuration,1003,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,1,['config'],['configuration']
Modifiability,"**Summary of what was done:**. - Changes in floquet_master_equation_rates to make it faster.; - Corrected transposition errors in _floquet_master_equation_tensor_ and changes to make it faster. I also removed a line so that the ME is solved in the interaction picture, this implies a different basis change in the _floquet_markov_mesolve_ function.; - Correction in _floquet_markov_mesolve_. As explained in the point above, the Floquet-Markov ME was not being solved in the interaction picture, therefore I modified _floquet_master_equation_tensor_ and modified the basis change in _floquet_markov_mesolve_. This modification requires an additional variable in the entry of _floquet_markov_mesolve_ which can not be chosen by default. For the moment, if this variable is not given and _floquet_basis=False_, then the density matrix or expectation values are returned in the interaction picture, in the computational basis, and a warning message is sent. ; - Added integration options in: _floquet_modes, floquet_modes_t, floquet_modes_table, floquet_states_t, floquet_modes_t, floquet_wavefunction_t, fsesolve, floquet_master_equation_rates, fmmesolve_; - Added test functions to verify the dissipative dynamics:; a) Compare _fmmesolve_ and _mesolve_ for the cases: (NO drive but dissipation) and (Drive but NO dissipation); b) Compare numerical and analytical matrix elements for a driven-dissipative TLS with RWA. There are some places where the code could be modified to optimize the running time, especially in the basis change in _floquet_markov_mesolve_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949:650,variab,variable,650,https://qutip.org,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949,2,['variab'],['variable']
Modifiability,", build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifing config_fc, config, build_clib, build_ext, build commands; > --fcompiler options; > running build_src; > build_src; > building py_modules sources; > building extension ""qutip.cy.spmatfuncs"" sources; > building extension ""qutip.cy.stochastic"" sources; > building extension ""qutip.cy.sparse_utils"" sources; > building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_ext; > customize UnixCCompiler; > customize UnixCCompiler using build_ext; > building 'qutip.cy.spmatfuncs' extension; > compiling C sources; > C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2; > -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; >; > compile options:; > '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c'; > extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; > gcc: qutip/cy/src/zspmv.c; > qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:4185,config,config,4185,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['config'],['config']
Modifiability,", especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactoring much of QuTiP to be more object-oriented will be a positive change to the framework. However, consider that: (1) properly rewriting this as a class-based module without losing functionality will take some time, (2) there are many other modules (for example, most solvers) which would benefit from being refactored into classes, and (3) rewriting these modules would be a breaking API change. . These reasons make me think it would be best to merge the current module now, including it in version 4.3 of QuTiP, and to refactor this (among many other modules) in version 5.0 of QuTiP. This option would make this module available quickly, would be most consistent with semantic versioning, and would keep this module's structure consistent with QuTiP in both pre-refactor v4.X and post-ref",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:2687,refactor,refactorings,2687,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactorings']
Modifiability,", multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using the builtin Python module multiprocessing.; 36 """"""; 37 __all__ = ['parfor', 'parallel_map', 'serial_map']; 38 ; 39 from scipy import array; 40: from multiprocessing import Pool; 41 from functools import partial; 42 import os. /Users/shahnawaz/dev/qutip/qutip/settings.py:; 32 ###############################################################################; 33 """"""; 34: This module contains settings for the QuTiP graphics, multiprocessing, and; 35 tidyup functionality, etc.; 36 """"""; ```. Can the `pyximport` be dealt in a similar way by having a pyximport_config.py and running it from all the places which needs C compilation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:2497,config,config,2497,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,1,['config'],['config']
Modifiability,"- I agree that renaming the _inner_point_color variable is a good idea. - The case you mention of black point_color with style 'l' also occurs in V4 and is solved by defining the variable as a list, e.g., ['black'] (which also works with the changes I proposed). So basically I assumed it was an expected use case. - I asked this question about style 's' plotting two colors in issue #1974, since we are given the same colors for style 's' and 'm', and Neil suggested leaving it as is. The docstring in the add_points function already tells you to give a single color for style 's' and a list of colors for style 'm'. - The error you get using style 'm' with two colors is that you need to specify a color for each point (you have to pass to the function a list of colors of the same length as the length of the points). In view of this, I don't know which approach you prefer to apply, as it depends on the expected use case. Given that the code works, perhaps the priority would be to specify the expected use while defining as part of issue #1913 the modifications you consider appropriate (although maybe someone will catch it earlier if you define it as a new issue).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672:47,variab,variable,47,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672,2,['variab'],['variable']
Modifiability,". **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are not physics-related:; - 6 are related to plotting or visualization utilities ; - 6 are `Distribution` classes or subclasses, which seem to be only used for visualization; - 6 are related to solver options or results; - 3 are low-level classes that users typically wouldn't interact with; - This leaves only 4 physics-related occurrences: ; - `Evolver` (in this module), which is not exported and which I might rename to `_Evolver` (this is necessary to be a class for cacheing purposes); - `Cubic_Spline`, which only has __init__ and __call__ methods, and thus could (should?) be refactored into a function (this class also doesn't interact with `QObj`s, so one could argue that it is not physics-related); - `eseries`, which represents an exponential expansion of `QObj`s and thus refers to something at least loosely physical; - `QObj`, which is the basic representation of a physical object; - This would mean that the proposed `PhotonScatterer` class would be the **only** exported occurrence of using a class to represent computations related to a `QObj`. I think there are points to be made for both sides, but I'm not sure that having a few extra helper functions or requiring slightly shorter function calls would be worth introducing what seems to me to be a big inconsistency in the use of functions vs. classes in QuTiP. Once again, thank you @sahmed95 for your suggestions to this module and I look forward to hearing everyone's thoughts on the main issue of c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:4421,Evolve,Evolver,4421,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,2,"['Evolve', 'refactor']","['Evolver', 'refactored']"
Modifiability,"5 seems also fine for me. We default to the dense solver when all the eigenvalues are required, even if `sparse=True` and we then raise a Warning explaining why we do this and how to stop the warning. IIf I understood it correctly, 3 would be raising an Error instead of a warning, which may be a little bit more annoying for someone that just wants the code to work (?). I am fine with both though and I think they could be suitable issues for a ""medium"" level ""good_first_issue"" (if that makes sense 😅 ). 1 and 4 seem indeed too much work right now (but perhaps they can be tackled in the future). 2 may actually be separate an enhacement, that could be useful for some specific scenarios (?). But maybe it is best to wait for when this scenario is present to actually motivate the enhancement (?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858:784,enhance,enhancement,784,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858,1,['enhance'],['enhancement']
Modifiability,"739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/83c8cac0-f12e-4af4-96df-4be972b485d4 width=30% height=30%>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1904,variab,variables,1904,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617,2,['variab'],"['variable', 'variables']"
Modifiability,":thought_balloon: Can you follow [the rationale of the Python enhancement proposal 203](https://www.python.org/dev/peps/pep-0203/#rationale ""Proposal for augmented assignments"") (from 2000-07-13)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972611843:62,enhance,enhancement,62,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972611843,1,['enhance'],['enhancement']
Modifiability,"; Using cached qutip-3.1.0.tar.gz; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File ""<frozen importlib._bootstrap>"", line 693, in _load; File ""<frozen importlib._boot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:1099,config,config,1099,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,1,['config'],['config']
Modifiability,"> ; > ; > @thangleiter can you try with the dependencies (cython numpy scipy nose matplotlib)? What Python are you using and what OS?. I am building (and running) the Docker image from Windows 10 1803 Education. The image itself is based on Alpine Linux (see [https://github.com/ContinuumIO/docker-images/tree/master/miniconda3](url)) and runs Python 3.7.1 (or lower, depending on the qutip version's requirements). Explicitly installing the dependencies also results in an `Illegal Instruction`. The dockerfile for reference:; ```dockerfile; FROM continuumio/miniconda3. RUN conda config --append channels conda-forge && conda update -y --quiet conda && conda install -y --quiet qutip cython numpy scipy nose matplotlib; ```. Edit: Some further investigation revealed that the crash also happens in the WSL Ubuntu shell with miniconda manually installed and Python 3.6 and 3.7. It doesn't crash with the same setup and Python 3.5, however. Edit 2: Installing via pip or from source works with Python 3.7 and qutip 4.3.1, so the problem is definitely the conda package.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-480771908:582,config,config,582,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-480771908,1,['config'],['config']
Modifiability,"> ; > ; > Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems.; > ; > Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook.; > ; > Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See [qutip/qutip-notebooks#100](https://github.com/qutip/qutip-notebooks/issues/100); > ; > One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in #1092, using [loky](https://loky.readthedocs.io).; > ; > In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence.; > ; > If the freeze is indeed caused by spawn-multiprocessing, the problem _should_ also show up on Windows. Is anyone running Windows able to reproduce this?. Windows doesn't have 'fork' at all, if we want to make parallel_map work under windows, we have to find ways to 'spawn' efficiently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416:212,inherit,inheriting,212,https://qutip.org,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416,2,"['inherit', 'variab']","['inheriting', 'variables']"
Modifiability,"> @arnelg What if we add a variable `shape` also to the `_super_tofrom_choi`, `choi_to_kraus`, and `kraus_to_choi` functions?; > In that way, if `shape=None` the function uses the old code, while if `shape=""rectangular""` it implements the new version of the code. I don't think this is a good idea. The ""square"" case is really just a special case of ""rectangular"", and there is no reason the user should need to specify that it is square or not through an additional argument; this information is already there by looking at the `Qobj` in question. The code as submitted already correctly handles a square input (as before), so why create a separate code path? Also by sticking to one code path we ensure that if there is an error, it only needs to be fixed once. > Moreover, for the sake of completeness, I think this option should be implemented also in the Stinespring and $\chi$ representation.; > Commenting the docstring on this issue could help the user, even if these are private functions.; > I have been reviewing this with @nathanshammah. Yeah good point. I will have a look at this together with @joshcombes. (It is fine to accept the current pull request, and we can open another one for further improvements, however.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-565329722:27,variab,variable,27,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-565329722,1,['variab'],['variable']
Modifiability,"> @hodgestar I gave it a first read. Thank you!. > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would ha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:711,Flexible,Flexible,711,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005,1,['Flexible'],['Flexible']
Modifiability,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:128,inherit,inheritance,128,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661,2,['inherit'],['inheritance']
Modifiability,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:216,adapt,adaptive,216,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248,1,['adapt'],['adaptive']
Modifiability,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:506,extend,extend,506,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214,1,['extend'],['extend']
Modifiability,"> General comment about plotting on the Bloch sphere:; > ; > QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are _not_ required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix.; > ; > There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested.; > ; > I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now.; > ; > I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling.; > ; > My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though. Thanks a lot, Simon (@hodgestar). My modification to the bloch.py follows what you have suggested. ; Also, the code can plot arcs inside and outside the bloch sphere too, and the line segment can be drawn between any two points. And the inputs have to be in cartesian coordinates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018:985,flexible,flexible,985,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018,1,['flexible'],['flexible']
Modifiability,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:1456,layers,layers,1456,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192,1,['layers'],['layers']
Modifiability,"> I added ipython to the testing workflow. Let me know if it should have been included somewhere else. Hmm. I don't like adding random dependencies into the workflow config. On the other hand, this is specific to IPython. Maybe we can add an ""ipython"" section in `setup.cfg` and add that to `full`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238:166,config,config,166,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238,1,['config'],['config']
Modifiability,"> I solved this by adding C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\ to the PATH variable. I don't know why, but setting the PATH variable does not work for me :(; I was using VS2017 before installing qutip. It was recommended that qutip should work with VS2015 on windows. So I uninstalled VS2017 and reinstalled VS2015. I guess something went wrong in this process, but I haven't figured out what it is.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1026#issuecomment-506745768:98,variab,variable,98,https://qutip.org,https://github.com/qutip/qutip/issues/1026#issuecomment-506745768,2,['variab'],['variable']
Modifiability,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1146,evolve,evolver,1146,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667,1,['evolve'],['evolver']
Modifiability,"> I'm going to change the Clifford group tests a little, and rebase the typo fix commit into the general refactor before this one should be merged. Sure",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626315402:105,refactor,refactor,105,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626315402,1,['refactor'],['refactor']
Modifiability,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:199,variab,variable,199,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390,1,['variab'],['variable']
Modifiability,"> Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?. That sounds great, but I don't think it's required if it turns into a rabbit hole.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1513#issuecomment-829623558:143,rewrite,rewrite,143,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829623558,1,['rewrite'],['rewrite']
Modifiability,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:606,enhance,enhancement,606,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845,1,['enhance'],['enhancement']
Modifiability,"> Seems to me that the whole thing should first decide the kind of gate, then loop over only the necessary qubits - that'd be both more efficient and easier to read. I feel the same. Indeed it is just something I encountered when writing the doc. I guess this structure to make use of similarity among those gates. Many have one control and one target. Those gates work well. SWAP just happens to not be one of this... Also, ISWAP doesn't work very well if it acts on qubits not next to each other. The gates need to be classified better. Maybe completely rewrite it at some point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-781976727:556,rewrite,rewrite,556,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-781976727,1,['rewrite'],['rewrite']
Modifiability,"> There is no agreement on how this should be handled yet. It's been removed from `dev.major` with the plan to restore it before the release, but the exact interface is not fixed. It certainly will not be some special keyword in args. It could be a special value, or a special parameter / method for the solver class. Actually having a method in the solver class seems better, I suppose this is why we are going towards Solvers from the simple `mesolve` function. I am going to try and rewrite my example using the Solver class. We can probably get away with having this functionality only in the new Solver class --- benefit of a major release I guess.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/947#issuecomment-1142213362:486,rewrite,rewrite,486,https://qutip.org,https://github.com/qutip/qutip/issues/947#issuecomment-1142213362,1,['rewrite'],['rewrite']
Modifiability,"> This randomly failing test appears again. It is really getting annoying. I copied the error message from Travis bellow:; > ; > ```; > =================================== FAILURES ===================================; > ___________________________ test_MCSimpleConstStates ___________________________; > @pytest.mark.slow; > def test_MCSimpleConstStates():; > ""Monte-carlo: Constant H with constant collapse (states)""; > N = 10 # number of basis states to consider; > a = destroy(N); > H = a.dag() * a; > psi0 = basis(N, 9) # initial state; > kappa = 0.2 # coupling to oscillator; > c_op_list = [np.sqrt(kappa) * a]; > tlist = np.linspace(0, 10, 100); > mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; > options=Options(average_states=True)); > assert_(len(mcdata.states) == len(tlist)); > assert_(isinstance(mcdata.states[0], Qobj)); > expt = expect(a.dag() * a, mcdata.states); > actual_answer = 9.0 * np.exp(-kappa * tlist); > avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > > assert_equal(avg_diff < mc_error, True); > E AssertionError: ; > E Items are not equal:; > E ACTUAL: False; > E DESIRED: True; > ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; > ----------------------------- Captured stdout call -----------------------------; > 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; > 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; > 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; > 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; > 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; > 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; > 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; > 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; > 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; > 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; > Total run time: 20.34s; > ---------- covera",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896:557,coupling,coupling,557,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896,1,['coupling'],['coupling']
Modifiability,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:441,extend,extend,441,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207,1,['extend'],['extend']
Modifiability,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:67,config,config,67,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649,5,"['Config', 'config', 'variab']","['ConfigLocation', 'config', 'variable']"
Modifiability,"> also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; > Expected outcomes; >; > - More devices defined in the qutip.qip.device module. At the moment,; > we have two models: spin chain and cavity QED. We would like to include; > some other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in qutip.qip.device and; > qutip.qip.compiler; > - Refactoring the circuit compiler to allow simple pulse scheduling,; > e.g. Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages; > or commonly used language e.g. through quantum assembly language (qasm); >; > ------------------------------; >; > Also, the last outcomes have some overlap with the last project. Although; > I also find this circuit importation very important, I guess two projects; > should not have overlap if they are both selected.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67E",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:2576,Refactor,Refactoring,2576,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,1,['Refactor'],['Refactoring']
Modifiability,"> by calculating the `qutip.propagator` we are actually solving `qutip.sesolve` for `N` basis states. Yes, propagator returns the unitary matrix of the evolution. For large system, this will be much slower than `sesolve`. Roughly speaking, `sesolve` evolves only the given initial state while propagator all the `N` basis. From a very inaccurate estimation, if you want to evolve more than `N` initial states with the same Hamiltonian, `propagator` will be a better choice. However, you might also need a bigger memory to save the unitary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1323#issuecomment-660506344:250,evolve,evolves,250,https://qutip.org,https://github.com/qutip/qutip/issues/1323#issuecomment-660506344,2,['evolve'],"['evolve', 'evolves']"
Modifiability,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:53,plugin,plugins,53,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005,2,['plugin'],['plugins']
Modifiability,"> thanks for the comment, I didn't know about `qutip.propagator`; > ; > > Lots of people have successfully used QuTiP already as part of reinforcement learning protocols - I've worked with at least a couple; > ; > cool, can i learn more about this from you?. Sorry, I don't have much experience in it myself - you'll be reading about the methods in papers/lecture note by people smarter than me. We have some tutorial notebooks about optimal control using the QuTiP optimal control package here: http://qutip.org/tutorials.html#optimal-control, which you may be able to adapt to your use case. I believe there are components in there that you can subclass so that the optimiser is RL-based rather than using standard BFGS or something else.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1323#issuecomment-660475258:570,adapt,adapt,570,https://qutip.org,https://github.com/qutip/qutip/issues/1323#issuecomment-660475258,1,['adapt'],['adapt']
Modifiability,>… are part of why `a = a + 5` is not equivalent to `a += 5` …. Different development views are involved here for the interpretation of “equivalence”.; How will the design goals evolve further for selected software areas? :thinking:,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972782553:178,evolve,evolve,178,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972782553,1,['evolve'],['evolve']
Modifiability,"@BOBO1997 Sorry I forgot about your proposal above. - What is the proposed behaviour of gate insertion? I guess you mean that, in the current code, if one inserts more than one gates, the length of the list is modified during the loop. This makes the definition of `position` tricky. Is this what you mean?. - About the syntax sugar, this sounds nice indeed. However, there might be a rather big refactor in `QubiCircuit` in the near future. I had a proposed refactor of `QubiCircuit` https://github.com/qutip/qutip-qip/discussions/15 (This is a separate repo in qutip org. Big new features in qip will most likely happen there). Although no one is working on that yet. I feel like this change will be much easier to implement after that refactor?. In any case, they should be in a different PR as they don't relate to this topic of FREDKIN.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1489#issuecomment-817748955:396,refactor,refactor,396,https://qutip.org,https://github.com/qutip/qutip/pull/1489#issuecomment-817748955,3,['refactor'],['refactor']
Modifiability,@BassemSafieldeen thank you for addressing this enhancement. It would be nice to find out what's broken with pytest.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/972#issuecomment-482167982:48,enhance,enhancement,48,https://qutip.org,https://github.com/qutip/qutip/pull/972#issuecomment-482167982,1,['enhance'],['enhancement']
Modifiability,"@Chasmiccoder I agree with @BoxiLi that we don't want to do a big refactor, especially of the older 4.6 and 4.7 releases. I would like to add some code style checkers like `pyflakes` , `black` (or `blue`) and `isort` to our CI system on the `dev.major` branch, initially excluding all the files and then slowly including more and more files in the checks as we fix them. I'm going to close this issue for now, but if you would like to tackle adding, e.g., `pyflakes` to `dev.major` that would be awesome.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729#issuecomment-982600604:66,refactor,refactor,66,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982600604,1,['refactor'],['refactor']
Modifiability,"@Darshil9120 I actually don't know what the ""correct"" fix should be. The links are actually correct in the documentation source, but Jekyll, which is used to generate qutip.org, ignore folders with leading underscores, so they underscores need to be removed from the folders and the links to them. There is a script https://github.com/qutip/qutip.github.io/ called `docs/remove_leading_underscore.py` that does this. I'm inclined to close this issue for now unless since we have a solution, but I'm happy to reopen it if someone has a good concrete suggestion (I think change the Sphinx defaults is a bit of a mess, but maybe we could configure Jekyll to not ignore some specific folders -- e.g. all folders with leading underscores that are under the docs folder).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1531#issuecomment-1100139852:635,config,configure,635,https://qutip.org,https://github.com/qutip/qutip/issues/1531#issuecomment-1100139852,1,['config'],['configure']
Modifiability,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:78,Config,ConfigParser,78,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169,1,['Config'],['ConfigParser']
Modifiability,"@Ericgig Do you think it's a good idea to add the br_solver as an option for the correlation functions? If so, there a plan to make selecting a solver more flexible in QuTiP v5? I found https://github.com/qutip/qutip/projects/6#card-72925447 which suggest there might be, but I don't know the full plan.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/884#issuecomment-983858798:156,flexible,flexible,156,https://qutip.org,https://github.com/qutip/qutip/pull/884#issuecomment-983858798,1,['flexible'],['flexible']
Modifiability,"@Ericgig I am now trying to use pytest's parametrize feature which allows us to parametrize input to test functions variable by variable. I was able to successfully rewrite some tests which use `yield`, but this one (`test_trunc_neg`) in particular throws an error. Could you please run the following self sufficient snippet locally and inform me if there is anything wrong with the values in this example?? Thanks for the tip about yield, that might indeed be what is wrong. ```; from qutip import *; import numpy as np; import pytest; from numpy.testing import (assert_equal, assert_, assert_almost_equal,; run_module_suite). @pytest.mark.parametrize(""method"", ['clip', 'sgs']); @pytest.mark.parametrize(""qobj"", [rand_dm(5), Qobj(np.diag([1.1, -0.1])),; rand_unitary(3)*Qobj(np.diag([1.1, 0, -0.1]))*rand_unitary(3).dag()]); @pytest.mark.parametrize(""expected"", [None, Qobj(np.diag([1.0, 0.0])),; rand_unitary(3)*Qobj(np.diag([1.0, 0.0, 0.0]))*rand_unitary(3).dag()]); def test_trunc_neg(method, qobj, expected):; ""Checks trunc_neg in several different cases.""; pos_qobj = qobj.trunc_neg(method=method); assert(all([energy > -1e-8 for energy in pos_qobj.eigenenergies()])); assert_almost_equal(pos_qobj.tr(), 1); if expected is not None:; assert_almost_equal(pos_qobj.data.todense(), expected.data.todense()); ```. Also, I would like to rewrite all the tests which use `yield` in this format, would that be okay?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-571008013:116,variab,variable,116,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-571008013,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"@Ericgig I changed the variable names. In the example file one small change has to be made. For changing the b.point_color after points are added, we will have to set b.point_color = [colors] instead of b.point_colors = list(colors). b.point_color is a list of list of points. https://github.com/rajathshetty20/misc/blob/master/bloch_sphere_with_colorbar.ipynb",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1315#issuecomment-667491189:23,variab,variable,23,https://qutip.org,https://github.com/qutip/qutip/pull/1315#issuecomment-667491189,1,['variab'],['variable']
Modifiability,@Ericgig I have implemented the enhancement required please have a look.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1722#issuecomment-1415691098:32,enhance,enhancement,32,https://qutip.org,https://github.com/qutip/qutip/issues/1722#issuecomment-1415691098,1,['enhance'],['enhancement']
Modifiability,"@Ericgig I've kept the WIP label, but this is ready for a first review. I think I'm made the HEOM look as much like the base solver as I can without having to modify the base solver a bit. Perhaps we can meet up tomorrow on Discord to discuss options. I'm also happy to merge this as is and adapt the solver more in another PR (assuming tests still pass and documentation still builds with my latest commits).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887:291,adapt,adapt,291,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887,1,['adapt'],['adapt']
Modifiability,"@Ericgig any tips how to locally run `pycodestyle` linter so that it follows same settings as `codeclimate`? When I run it locally it show way more warnings than `codeclimate`, seems a lot more restrictive. I'm sure some sort of configuration is missing. I checked the [contribution guide](https://qutip.org/docs/latest/development/contributing.html) but this particular matter is not detailed. If you explain how to run linter locally I would be happy to also update the docs and document it for the future contributors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661:229,config,configuration,229,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661,1,['config'],['configuration']
Modifiability,"@Ericgig, I see. Thank you so much! I had the impression that v5 would change something related to the calculation of density matrices being more flexible. But all in order now. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2167#issuecomment-1584158549:146,flexible,flexible,146,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1584158549,1,['flexible'],['flexible']
Modifiability,"@Krastanov I don't quite understand. Are you use the **nested-list method**? If so, can you tell me how you expanding and rewriting/reordering by hand of the c_ops so that you can list them one by one in the nested-list method? If you can rewriting/reordering them, why cannot you do the same thing for `mcsolve`?. @jrjohansson In the first reply you mentioned that. > Yes, it is not the same thing. You need to rewrite it manually so that each collapse operator contribute on standard lindblad form. . May I ask how to rewrite it manually so that each collapse operator contribute on standard lindblad form so that I can implement complicated time-dependent collapse operator in the **nested-list method**?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/223#issuecomment-223872353:412,rewrite,rewrite,412,https://qutip.org,https://github.com/qutip/qutip/issues/223#issuecomment-223872353,2,['rewrite'],['rewrite']
Modifiability,"@Lala5th Thank you for reporting this. It looks like the issue is just hat `mesolve` calculates the `size` variable incorrectly for a flat array and the following diff removes the segfault for me:. ```diff; diff --git a/qutip/mesolve.py b/qutip/mesolve.py; index f6527299..25e9f3cd 100644; --- a/qutip/mesolve.py; +++ b/qutip/mesolve.py; @@ -435,6 +435,8 @@ def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]; + if rho0.shape[1] == 1:; + size = int(np.sqrt(size)); ; initial_vector = rho0.full().ravel('F'); ```. I agree that we should not segfault. Probably the minimal patch is to raise an exception if `rho0.shape[0] != rho0.shape[1]`. If you agree, I can open a small PR (or you can if you would like to).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291:107,variab,variable,107,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291,1,['variab'],['variable']
Modifiability,"@MartinSandeCosta, free feel to complete the tests in the way you want. However, maybe it is good to discuss a bit with @jakelishman? Since there is a refactoring of `qutip/tests/test_gates.py` in #1181. A lot of change in this test might make it hard to resolve two PRs later. Besides, it is better to leave a more detailed description in the PR. As the template indicated:; ```; **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607803156:151,refactor,refactoring,151,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607803156,1,['refactor'],['refactoring']
Modifiability,"@OliverLunt, ; The problem lies in the adaptative step of the ode solver. Since nothing happen at first, the step become so long that it jump over the change in the on_off signal...; You can do:; ```; opt = qt.Options(); opt.max_step = 0.5; output = mesolve(H, psi0, tlist, c_ops=c_ops, e_ops=e_ops, options=opt); ```; To limit the step size and it will work as expected. . I am not sure why sesolve (used when no c_ops are given) have smaller step size. It seems to be something in the scipy solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/898#issuecomment-430306233:39,adapt,adaptative,39,https://qutip.org,https://github.com/qutip/qutip/issues/898#issuecomment-430306233,1,['adapt'],['adaptative']
Modifiability,"@ajgpitch Thanks for your thoughts on the classes vs. functions matter. I generally agree with @sahmed95 that refactoring this (and many other QuTiP modules) into a more object-oriented class-based structure would be healthy for the ongoing development of QuTiP. . I began rewriting this module into a class this morning, but as I started coding, I realized that this does introduce one major complication which could limit usefulness, which is that class methods do not play well with Python multithreading/multiprocessing. If you look in the example notebook in [my `qutip-notebooks` PR](https://github.com/qutip/qutip-notebooks/pull/58), there are several instances where I create a 1- or 2-line helper function to multiprocess a parameter search of `scattering_probability` using `multiprocessing.pool.starmap`. . In my experience, implementing a parallelized parameter search will be much more difficult to do if `scattering_probability` is changed to become a class method. There are some [hacky workarounds to this](https://stackoverflow.com/questions/27318290/why-can-i-pass-an-instance-method-to-multiprocessing-process-but-not-a-multipro), but these add extra overhead to implementing multiprocessing and don't work with methods that are not functionally static. . Given that these scattering calculations are among the most computationally expensive in QuTiP, I don't think that making parallelism more difficult to work with is a direction we should go in. I am confident that, with significant effort, I can make a clean and parallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more diffi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:110,refactor,refactoring,110,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactoring']
Modifiability,"@alipedram01 It looks like we've understood the cause of the issue -- i.e. your RK45 solver just doesn't converge for this problem. That's probably not unexpected -- I see to remember reading on Wikipedia that the implicit Runga-Kutta methods have small regions of convergence relative to explicit or adaptive methods. Closing this for now, but thank you for taking a look and please feel free to continue the discussion if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164:301,adapt,adaptive,301,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164,1,['adapt'],['adaptive']
Modifiability,"@arnelg What if we add a variable `shape` also to the `_super_tofrom_choi`, `choi_to_kraus`, and `kraus_to_choi` functions?; In that way, if `shape=None` the function uses the old code, while if `shape=""rectangular""` it implements the new version of the code.; Moreover, for the sake of completeness, I think this option should be implemented also in the Stinespring and $\chi$ representation.; Commenting the docstring on this issue could help the user, even if these are private functions.; I have been reviewing this with @nathanshammah.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-547716872:25,variab,variable,25,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-547716872,1,['variab'],['variable']
Modifiability,"@arnelg and @cgranade, you are both raising good points here. I'm not exactly sure what the best solution for this particular issue is, but do tend to agree with @arnelg that we do not want functions that perform unexpected actions, if possible, and that explicit is better than implicit. However, ultimately, it has to be the docstrings that should resolve any ambiguities, because not all functions can be intuitive to everyone, since we all have different backgrounds and expectations. So if the current behaviour is clearly described in the docstring, it should also be an acceptable solution I think. But one important thing that @arnelg also alluded to is that if at some point we expect that we might want to use `composite(S, O)` to mean something different than `composite(S, to_super(O))`, then we should better not implement the operator-to-superoperator promotion implicitly in `composite` now. Since the `composite` function is brand new it might be a good idea at this point to avoid doing these implicit assumptions on how it will be used until various use-cases has been explored in more details. I absolutely agree that it is great to have discussions about these kind of design issues, and it's great that you both have taken an interest in this particular issue. I also agree that Qobj.dims is a bit obscure and not that flexible, and maybe insufficient for complex cases with mixes of operators, kets, superoperators along different subsystems. This would not be an easy thing to change, but having a discussion about the short-comings and possible solutions would be great. I've created a new page on the wiki for listing various issues and design short-comings in qutip:. https://github.com/qutip/qutip/wiki/Future-Design-Changes. Feel free to add to this page and edit what's already on it (and of course, propose solutions!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58190164:1340,flexible,flexible,1340,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58190164,1,['flexible'],['flexible']
Modifiability,"@cgranade Thank you for the detailed write-up. I have some questions below. I have my own ideas of answers to some of these questions, but I'd like to hear yours. * What do you see as the primary drivers for this new feature?; * What is the advantage of this over using the existing superoperator representations?; * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?; * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?; * How do you see the various mathematical operations working?. Given that currently `dims` describe the dimension of the Hilbert space and that the dimension isn't changing, I feel `dims` is perhaps an odd place to put the number of elements in the sum, but that doesn't prevent this becoming a feature of Qobj in some other way. Either way, QobjEvo would need to support this too (probably not a giant amount of work, but some careful checking would be needed) & some other parts of the code might be surprised. @jakelishman had some ideas for revamping dims support in QuTiP. I don't think it's the same idea, but the two definitely overlap in terms of which parts of QuTiP they'd evolve. Jake, would you mind posting the link to your dims proposal here if you have it handy (apologies, I seem to have lost it). Even if dims isn't the right place for this, it would be good for me to reread it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1673#issuecomment-927694147:1191,evolve,evolve,1191,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927694147,1,['evolve'],['evolve']
Modifiability,@drew-parsons I'll leave #1875 open until we've sorted out why the `--config-setting=--global-option=--with-openmp` isn't working in some cases.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1978#issuecomment-1219947340:70,config,config-setting,70,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219947340,1,['config'],['config-setting']
Modifiability,"@elfring The first line of the PEP `There are two main reasons for adding this feature to Python: simplicity of expression, and support for in-place operations` and the `in-place operations` mentioned are part of why `a = a + 5` is not equivalent to `a += 5` (as Jake took the time to demonstrate). I'm closing the issue, but feel free to continue the discussion here & thank you for suggesting an enhancement to QuTiP and please feel free to suggest others.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972730767:398,enhance,enhancement,398,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972730767,1,['enhance'],['enhancement']
Modifiability,"@gautierronan Thanks Ronan for this useful contribution. It looks good to me. I was discussing something similar with a colleague back in October, so I am going to see if I can get them to test it too.; On the subject of testing... this will need tests to be added before it can be merged. Please see https://github.com/qutip/qutip/blob/master/qutip/tests/test_control_pulseoptim.py; Ideally it would also have an example notebook. See https://github.com/qutip/qutip-notebooks/blob/master/examples/control-pulseoptim-Hadamard.ipynb for example. It could either have new notebook, or one could be extended to show this feature.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1369#issuecomment-754707095:596,extend,extended,596,https://qutip.org,https://github.com/qutip/qutip/pull/1369#issuecomment-754707095,1,['extend'],['extended']
Modifiability,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:336,coupling,coupling,336,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548,2,['coupling'],['coupling']
Modifiability,"@hodgestar any updates on merging this, I'm hoping to extend some of this functionality!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-626381159:54,extend,extend,54,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-626381159,1,['extend'],['extend']
Modifiability,"@hodgestar, ; I adapted the `MultiTrajResult` to the new `Result` format, and I have some changes to the `Result` class that I want to do:; - I changed the `Result.__init__` to move setting the `e_ops` in `_post_init`: `MultiTrajResult` can't use them and needed to remove the related state processors.; - `add` was overwritten, but we could use it if we add a `_early_finish_check`: a processor that return the estimated quantity of work remaining. Parallel map will stop computing trajectories when it get under 0. I think we could have it in `Result`: it could be interesting to have with `mesolve` with the options to stop when the steady state is reached, etc. Then if times when added in a state processor, I could use `add` without overloading. Are you Ok with me going for it or do you prefer to keep `Result` as is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173:16,adapt,adapted,16,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173,1,['adapt'],['adapted']
Modifiability,"@hodgestar, to make it work with HEOM, I had to change `step` to return `rho` directly, (controlled by the `store_ados` options). Could you take a look and tell me if you are fine with this approach. Also, do you know a `Bath` configuration that would result in evolution similar to `mesolve` so we could use it in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120:227,config,configuration,227,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120,1,['config'],['configuration']
Modifiability,"@jakelishman , I think it is ready for a review. . There a lot of `TODOs` in the code from the before times, and a general refactor is probably needed since most of the representations are working on the assumption that the channels admit equal right and left tensors:; ![formula](https://render.githubusercontent.com/render/math?math=A_{\alpha}%20=%20B_{\alpha}) . ; This PR at least allows for different left and right tensor in the Stinespring representation, thus completing the `FIXME` in the original tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-831514046:123,refactor,refactor,123,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-831514046,1,['refactor'],['refactor']
Modifiability,"@jakelishman, Equivalent change but with different implementation have been made in `dev.,major`. Here setting variable are directly in the module, but in v5 they are in a `Settings` object. Adding the object was a big change for major.; Maybe cherry-picky commits from master to `dev-major` would be easier.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1289#issuecomment-779252394:111,variab,variable,111,https://qutip.org,https://github.com/qutip/qutip/pull/1289#issuecomment-779252394,1,['variab'],['variable']
Modifiability,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:516,variab,variables,516,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325,1,['variab'],['variables']
Modifiability,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:180,adapt,adapted,180,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939,1,['adapt'],['adapted']
Modifiability,"@nathanshammah @ajgpitch @Ericgig @quantshah ; Thanks a lot for the feedback and patience. I have fixed the variable names issue, hopefully. I can make time these days. Please advise the next steps.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-568178589:108,variab,variable,108,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-568178589,1,['variab'],['variable']
Modifiability,"@nathanshammah I've merged in master, waiting for builds to complete. The code climate error is seems largely unrelated to this PR (the PR adds a tiny snippet of code that is similar to 4 other existing pieces of code). I'm happy to refactor this a bit if someone makes a suggestion, but the code climate error seems overly zealous to me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-581037319:233,refactor,refactor,233,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-581037319,1,['refactor'],['refactor']
Modifiability,"@nathanshammah: Sure. An assumption had previously been hard-coded into various conversion functions between super-operator representations that the input and output Hilbert spaces for the superoperator have the same dimension. An example is `_super_tofrom_choi` which converts between Liouville and Choi matrix representations, for example the line:. ``sqrt_shape = int(sqrt(data.shape[0]))``. This enhancement removes these assumptions and instead looks at the input and ouput dimensions of the `Qobj`s, which is stored in the `dims` attribute, to correctly convert in the case when the input and output dims are different. It's needed in all sorts of applications. Since the failing tests are unrelated to this pull request, it is merge ready.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-541953594:400,enhance,enhancement,400,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-541953594,1,['enhance'],['enhancement']
Modifiability,"@nonhermitian mentioned something about being able to move the pyximport bit to somewhere in the dynamic C building workflow. Now that would be a real bonus. Say we have some (probably Windows) users who have not managed to configure a working C compiler, but have installed from a conda package or some other wheel like thing, then they would be able to use everything except the string format time-dependent stuff. ; This is also discussed in #448",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-269725490:224,config,configure,224,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-269725490,1,['config'],['configure']
Modifiability,"@paulsbrookes Thanks very much for the fix. We have PR #815 that has been awaiting merge for a long time, which also has other enhancements. Please feel free to comment on #815",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/915#issuecomment-434060283:127,enhance,enhancements,127,https://qutip.org,https://github.com/qutip/qutip/pull/915#issuecomment-434060283,1,['enhance'],['enhancements']
Modifiability,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:753,extend,extended,753,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428,2,"['evolve', 'extend']","['evolve', 'extended']"
Modifiability,"@sahmed95 thank you very much. 2018-02-21 11:53 GMT+09:00 Shahnawaz Ahmed <notifications@github.com>:. > This is ready for a review. I incorporated the changes and the pep8 fixes.; > We still might go for a change in the name for the module as piqs and the; > class as Dicke to follow the naming in the paper. There are some more; > tests that we would like to add today.; >; > However, for the rest of it, things remain the same. Since the is_diagonal; > feature is more general, I could open a PR to include that as a Qobj; > property. Otherwise, this function will only be used once we add the; > enhancement diagonal_solver which can solve for some special classes of; > Hamiltonians. But that is for later.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/753#issuecomment-367197236>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AN5ffJy5kuOEnKCIxLH-GjbhKdmP8mHsks5tW4UrgaJpZM4PgbIo>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-367222920:600,enhance,enhancement,600,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-367222920,1,['enhance'],['enhancement']
Modifiability,"@sbisw002 All contributions to QuTiP must follow the pep8 standard. You should read https://www.python.org/dev/peps/pep-0008/, especially the section on naming conventions. I see @nathanshammah has made some specific comments along these lines, but there are too many examples to begin to comment on them. But in general, we like descriptive names for variables. One exception we have to pep8 is that we allow some use of capital letters in variable names, but only at the start, as this relates well to the corresponding mathematics. We reserve these for operators and matrices (in the mathematical sense), so for instance `H` is ok for a Hamiltonian, but `N` is not okay for an integer. `H_cell` is also fine, but `cellH` or `cell_H` is not. All caps are not to be used for anything. If you wish to abbreviate 'periodic boundary condition', then `pbc` would be ok as a local variable, but not as an attribute name, `period_bnd_cond` would be good. I am sorry if this seems a little late in the day, but this is covered in https://github.com/qutip/qutip/wiki/QuTiP-Development-Guidelines and this document https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md was linked in our GSoC page. Coding standards are *very* important, it where quality begins.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-533771943:352,variab,variables,352,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-533771943,3,['variab'],"['variable', 'variables']"
Modifiability,"A few comments and questions. 1. Why are file separated by function and not by datatype? So adding a new datatype will result in modification im a lot of file making support (PR evaluation) harder.; 2. `__repr__` return a very clean output in `Qobj`. `CSR`'s is quite simple. This is because data layers are never meant to be printed directly?; 3. For solver states, we mostly use Fortran ordered array, not C ordered. Will you support both?; 4. In matmul, you use `malloc`, `calloc`, `free`. It is better to use the python PyDataMem_NEW. I never had any issue, but there can be some on windows: https://github.com/numpy/numpy/issues/8253; 5. `mat_mul` can be used inplace, but no `add_csr`. ; 6. It would be good to have inplace multiplication with a scalar instead of always making a copy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648255315:297,layers,layers,297,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648255315,1,['layers'],['layers']
Modifiability,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:118,inherit,inheritance,118,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542,2,['inherit'],['inheritance']
Modifiability,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Giguère ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; > ⬇️ Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:443,variab,variable,443,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839,1,['variab'],['variable']
Modifiability,"Ah great! Thanks! So I probably used parameterization with the circuit in a non-recommended way. The source code is correct, there is just something wrong with the test. I'll try coming up with a solution for that test later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880:37,parameteriz,parameterization,37,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880,1,['parameteriz'],['parameterization']
Modifiability,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:125,variab,variable,125,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042,2,['variab'],['variable']
Modifiability,"Also, instead of adding a third entry to the nested list characterizing the time-dependence, I think the real and imag parts should be in the [1] list entry as a tuple. That way, all of the time-dependence is in a single list item. We may in the future want to add additional items to the list (e.g. on-off times for the time-dependent terms.). I also think that we should get some feedback from @ajgpitch and @cgranade. Chris has some experience with opencl, and he probably is bette suited for feedback than myself. . Another question would be the issue of maintainability. If, for some reason, you are unable to address bug issues or incompatibilities with future QuTiP versions, then can we support this large code submission without having authored it ourselves. For instance, the mcsolve_f90 routine has largely been non-maintained since Arne added it years ago.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-259879928:559,maintainab,maintainability,559,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-259879928,1,['maintainab'],['maintainability']
Modifiability,"Also, we can ""solve"" the testing issue by forcing the environment variable `QUTIP_NUM_PROCESSES=2` before importing QuTiP, I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1470#issuecomment-808299865:66,variab,variable,66,https://qutip.org,https://github.com/qutip/qutip/issues/1470#issuecomment-808299865,1,['variab'],['variable']
Modifiability,"Also: I don't think CodeClimate actually supports skipping the tests when we call it as an action like this. We'd have to set it up to run on CI runner under our control (e.g. on GitHub Actions), and then configure a method of skipping tests within that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927:205,config,configure,205,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927,1,['config'],['configure']
Modifiability,"As I mentioned in the discussion of #90, I think it would make more sense to add this information in Qobj.superrep rather than allowing Qobj.type to have more values, because for some purposes it is sufficient to know if Qobj is a superoperator or not, and it would be a lot easier and more maintainable to add new types of superoperator represenations if we don't have to make changes in many places in the code (which check if Qobj.type is a superoperator)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/88#issuecomment-37779597:291,maintainab,maintainable,291,https://qutip.org,https://github.com/qutip/qutip/issues/88#issuecomment-37779597,1,['maintainab'],['maintainable']
Modifiability,"As mentioned in the previous post I also played with rtol value, but it didn't help. Concerning your question, yes when the pulse is off, I have a zero Hamiltonian and the system stays in the initial state, which is fine, the weird thing however is that apparently the system stays in the initial state even when the pulse is on. Basically, I get as a result that the system stays in the initial state for all times. Did you try to run the code on your machine? Maybe it's the issue of my packages configuration?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/771#issuecomment-338260622:498,config,configuration,498,https://qutip.org,https://github.com/qutip/qutip/issues/771#issuecomment-338260622,1,['config'],['configuration']
Modifiability,"As the Cognitive Complexity exceeds the allowed limit, codeclimate is suggesting for code refactoring. Should I proceed accordingly? @nathanshammah @quantshah",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/979#issuecomment-487313175:90,refactor,refactoring,90,https://qutip.org,https://github.com/qutip/qutip/pull/979#issuecomment-487313175,1,['refactor'],['refactoring']
Modifiability,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:214,adapt,adaptive,214,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136,1,['adapt'],['adaptive']
Modifiability,"At least on my macbook, the 'CFLAGS' environ variable is not set until we do so manually in init. Is this not true on other platforms? If not, then we can easily append.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/570#issuecomment-265069220:45,variab,variable,45,https://qutip.org,https://github.com/qutip/qutip/pull/570#issuecomment-265069220,1,['variab'],['variable']
Modifiability,Build succeeded. Should we merge this? Or should I extend this to perhaps do more builds on 3.8 and reduce 3.7 to just the basic build? Should 3.6 be dropped or kept?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1170#issuecomment-581046004:51,extend,extend,51,https://qutip.org,https://github.com/qutip/qutip/pull/1170#issuecomment-581046004,1,['extend'],['extend']
Modifiability,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:431,enhance,enhancement,431,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466,1,['enhance'],['enhancement']
Modifiability,Checking if this got already solved by @Ericgig refactoring of stochastic solvers and `sesolve`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/867#issuecomment-532607531:48,refactor,refactoring,48,https://qutip.org,https://github.com/qutip/qutip/issues/867#issuecomment-532607531,1,['refactor'],['refactoring']
Modifiability,"Commit #bea29a1 breaks some tests since it refactors some attribute names to follow PEP8 snake_case standard (i.e., qubit.qit.circuit.N ->qubit.qit.circuit.n_qubits )",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603441970:43,refactor,refactors,43,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603441970,1,['refactor'],['refactors']
Modifiability,"Congratulations, you have rediscovered the quantum Zeno effect :-) There is nothing wrong with qutip here, I think. You don't write what your system is exactly, but I assume something like $H=\sigma_x$ and jump operator $\sigma_-$. The effect of the environment can be thought of as measuring the system continuously, with a strength proportional to the coupling rate, which you call jump rate. Jump rate is indeed a slightly misleading (but commonly used) name. Its meaning is the reciprocal of the expected time until a jump, if the system is in the excited state. However, due to the continuous measurement and the quantum Zeno effect, the system rarely makes it to the excited state in the first place. Mathematically, where it comes from is that the deterministic trajectory evolution (between the jumps) is given not by the system Hamiltonian, but by an effective (non hermitian) Hamiltonian. In the limit of large coupling rates, this effective Hamiltonian becomes approximately diagonal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920:354,coupling,coupling,354,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920,2,['coupling'],['coupling']
Modifiability,"Could you make 2 changes:; `verbosity=1`, it looks a lot cleaner.; The tests that ""XFAIL"" use `yield` and are skipped as it is not supported by pytest. Could you rewrite them without it. (4 in `test_qobj`, not sure if there are more.) I will be looking at the failing tests in more detail next week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-570710549:162,rewrite,rewrite,162,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-570710549,1,['rewrite'],['rewrite']
Modifiability,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:644,variab,variable,644,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847,1,['variab'],['variable']
Modifiability,"Dear qutip admin,. If I wrote the Hamiltonian in terms of analytic function (Hanalytic and Hanayticevo as shown below), I got different answers from using the discretized Hamiltonian obtained by providing the list of Hamiltonian values at discrete times (the variable H) as used previously. May I know how to rectify this problem? Below is the code. ```; import qutip; import numpy as np. fast_ts = np.linspace(0, 1, 1001); omegalist = 2.91e2*fast_ts ; fast_xs = 2.9e3*np.pi * np.cos(2*np.pi * omegalist * fast_ts); bad_interpolation_xs = np.array([fast_xs[0], fast_xs[-1]]); Hanalytic = [[qutip.sigmax(),'2.9e3*pi*cos(2*pi*2.91e2*t**2)']] # New line; Hanalyticevo = qutip.QobjEvo([[qutip.sigmax(),'2.9e3*pi*cos(2*pi*2.91e2*t**2)']],tlist=fast_ts) # New line; H = qutip.QobjEvo([[qutip.sigmax(), fast_xs]], tlist=fast_ts); H_bad = [[qutip.sigmax(), bad_interpolation_xs]]; rho = qutip.basis(2, 0).proj(); times = np.array([0., 1]); e_ops = [qutip.sigmay()]; options = qutip.Options(nsteps=10_000_000, atol=1e-14, rtol=1e-12). two_times = qutip.mesolve(H, rho, times, e_ops=e_ops, options=options); many_times = qutip.mesolve(H, rho, fast_ts, e_ops=e_ops, options=options); bad_times = qutip.mesolve(H_bad, rho, times, e_ops=e_ops, options=options); analytics = qutip.mesolve(Hanalytic, rho, fast_ts, e_ops=e_ops, options=options) # New line; analyticsevo = qutip.mesolve(Hanalyticevo, rho, times, e_ops=e_ops, options=options) # New line; assert len(two_times.expect[0]) == 2; assert len(many_times.expect[0]) == 1001. print(two_times.expect[0][-1]) # -0.59736575; print(many_times.expect[0][-1]) # -0.59736575; print(bad_times.expect[0][-1]) # -4.5466086e-08; print(analytics.expect[0][-1]) # 0.00022501347976357222; print(analyticsevo.expect[0][-1]) # 0.0002250044242251665. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-819524720:259,variab,variable,259,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-819524720,1,['variab'],['variable']
Modifiability,"Directly in VS code. My launch.json looks like; ```json; 	""version"": ""0.2.0"",; 	""configurations"": [; 		{; 			""name"": ""Python: Current File"",; 			""type"": ""python"",; 			""request"": ""launch"",; 			""program"": ""${file}"",; 			""console"": ""integratedTerminal""; 		}; 	]; }; ```; When using the plt.show() command, the second window only appears after a b.render() command, but thats also necessary for any vectors I want to draw to appear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011:81,config,configurations,81,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011,1,['config'],['configurations']
Modifiability,"Don't worry about the tests - progress on merging the refactor is slow (though if you want to review #1249 it'll help!). Besides, these tests would probably go in `test_qubitcircuit.py` which I haven't touched yet. Add the tests here, and I'll rebase #1251 onto `master` after this is merged if it's necessary to add them to the new style. Hopefully this will be the last time!. About the merge oddness: it comes about because this PR is built on a false version of the upstream (our) `master`. As long as you apply this merge as a squash, it will actually be ok and the history will be clean. Don't apply the merge as a history-preserving merge (i.e. a regular one), because it will make the commit history confusing (and defeats the purpose of having merged #1242 as a squash). ## Unnecessary detail. The exact reason is that this commit is build on top of #1242, but this is inconsistent with the upstream `master`; because #1242 was merged as a squash, `qutip/master` and `Canoming/master` diverged at fd13ae0 (i.e. before #1242), so `git` sees commits ea1c129 to b4f75cf as ""new"" (the first three commits of this PR). However, when those commits are taken together, they make the same changes as commit 4102b99 (the one which merged #1242) in `qutip/master`. The Github ""Files changed"" dialog is a pretty-printed version of the `git` command `git diff qutip/master...Canoming/master`, which means ""show all changes on either branch since `qutip/master` and `Canoming/master` diverged"". Because they diverged before #1242 was merged, it includes those changes. The merge completes without conflict, however, because `git` is clever and recognises that the changes introduced in the two branches `qutip/master` and `Canoming/master` are identical, even though the commits are different. As a consequence, however, merging this PR without squashing it would cause commits ea1c129 to b4f75cf to suddenly appear in our commit history, which we don't want. ### If Canoming wanted to fix this (not neces",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269:54,refactor,refactor,54,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269,1,['refactor'],['refactor']
Modifiability,"Every routine that uses multiple processes has a kwarg to change the number and if this is not set then it falls back on qutip.settings.num_cpus which is set in **init**.py. On May 2, 2014, at 1:04 PM, Robert Johansson notifications@github.com wrote:. > You can use it to select number of processes to use, right? I think it is useful if you don't want to use all processors for a calculation, although I usually use the .qutiprc configuration file for this rather than environment variables. I guess it is not really necessary but could be useful I guess.; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41985338:430,config,configuration,430,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41985338,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"Everyone: (@ajgpitch, @BoxiLi, @Ericgig, @nathanshammah). Apologies for bumping this again. It would be good to get a strategy in place to handle a review for this. Would it be easier if I close this PR and then make a whole series of new PRs with (say) 5 files in at a time?. I'm particularly keen to get the `test_gates.py` refactor merged in, because there's seemingly quite a lot of movement in the `qip` module. If I do split the PR, then I'll rebase onto `master` so that the new tests added in #1224 are included without a merge resolution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-609702252:326,refactor,refactor,326,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-609702252,1,['refactor'],['refactor']
Modifiability,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:1798,flexible,flexible,1798,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732,1,['flexible'],['flexible']
Modifiability,"First of all I'm glad you could get it to run under OSX. Which OpenCL environment are you using?; - Is the failure of `test_mcsolve_cl_time_dep_h` reproducible?; - You can probably ignore the compiler warning. I assume it is related to the pragma statement. Some OpenCL implementations refuse to work without it, others give you a warning that it is unnecessary. Maybe we can omit the statement based on the platform version and hide some warning, but that would require more testing (on different platforms). At the moment there is a lot of debug information to ease testing.; - The AttributeError you get is something I have not encountered yet. If you do consider merging this branch, it is a good idea to get more people involved in testing. The code has not been reviewed and probably contains some bugs. The questions you raised concerning the maintainability are all valid. On top of that setting up OpenCL is somewhat troublesome, which makes `mcsolve_cl` a kind of experimental feature. Ultimately it is up to the maintainers of qutip to decide whether such a feature should be included. The advantage `mcsolve_cl` has over `mcsolve_f90` is that it supports some time-dependence and introduces no build dependencies. If, for some reason `mcsolve_cl` does not work, the user can always fall back to `mcsolve`. By the way, is it wise to rebase this branch all the time or only when necessary?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-260134503:850,maintainab,maintainability,850,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-260134503,1,['maintainab'],['maintainability']
Modifiability,"Firstly, just to underline @jakelishman comment. We *cannot* change the public interface unless we make a new major release. I also don't like the `.N` property, but it snuck in before my time. We could look to change this in v.5, but not before. . It seems this PR does contain some enhancements that are not part of #1209. However, @mlaguna10 did seem to make quite clear that they were already working on the issue. I believe #1209 is ready to merge, but we'll wait for @BoxiLi to confirm. . So what I suggest is that we merge #1209. @MartinSandeCosta can then merge the master into this PR and see what is left that adds to enhancement request outlined #1208. Assuming (with good reason) that there are valuable additions, then we will merge this too. Thanks everyone for contributing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-605881345:284,enhance,enhancements,284,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-605881345,2,['enhance'],"['enhancement', 'enhancements']"
Modifiability,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:85,layers,layers,85,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360,1,['layers'],['layers']
Modifiability,"For Windows 10, I solved this issue by adding path to the folder that contains gswin32c.exe (e.g. C:\texlive\2019\tlpkg\tlgs\bin) to system variables. [See https://www.architectryan.com/2018/03/17/add-to-the-path-on-windows-10/]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/702#issuecomment-573384624:140,variab,variables,140,https://qutip.org,https://github.com/qutip/qutip/issues/702#issuecomment-573384624,1,['variab'],['variables']
Modifiability,"For me there are three main points here:; 1. The `site.cfg` should be a global numpy configuration (or local qutip configuration); 2. I see no reason for using the `DeprecationWarning` if you change the code to read the info from the `site.cfg`, perhaps there is something I am missing? If I do `sed -i -e '/extra_/d' qutip/fortran/setup.py` it compiles fine and seems to be using the `extra_link_args`.; 3. To dynamically control the `mcf90` module you could equally do this in the `site.cfg`:. ```; [qutip]; mcf90 = False / True; ```. and just default it to `False`. I have no comments on whether this should be preferred or not, or whether you _will_ split it up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-154987547:85,config,configuration,85,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-154987547,2,['config'],['configuration']
Modifiability,"For people finding this later, this is not just because of the macOS version, but also because of your _Xcode_ version. As Xcode increases, Apple are making it harder and harder to have a sensible dev environment for command-line tools when all you care about is building for your local machine. You may find that a system include like `_ctermid.h` is missing in the future - it won't always be `limits.h` - especially with Xcode 11+. Since M1 Macs (I assume - I don't have one) ship entirely with Xcode 12, they will likely need this too. I believe even `xcode-select --install` will not always reinstate `/usr/include` any more, and the `*_headers_*.pkg` seems to not work with Xcode 11. `/usr/include` is gone, but Xcode has the correct set of includes for all platforms, so you can set your compiler's `sysroot` to the relevant SDK directory to get correct lookups. By default, the one you want will be at; ```; /Applications/Xcode.app/Contents/Developer/Platforms/MaxOSX.platform/Developer/SDKs/MacOSX.sdk; ```; The system `clang` will likely find this correctly, but if not or if you're using a separate compiler, for either `gcc` or `clang` you should pass the flag; ```bash; gcc -isysroot '/path/to/sdk' ...; ```; to find the correct includes. To automate this procedure, you may want to add that flag to your `CFLAGS` and `CPPFLAGS` environment variables. For example, you could put in your `.bashrc`; ```bash; export CFLAGS=""-isysroot '/path/to/sdk' ${CFLAGS}""; ```; to have it automatically added to all C compilations (after that file has been sourced).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1030#issuecomment-760084316:1354,variab,variables,1354,https://qutip.org,https://github.com/qutip/qutip/issues/1030#issuecomment-760084316,1,['variab'],['variables']
Modifiability,"General comment about plotting on the Bloch sphere:. QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are *not* required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix. There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested. I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now. I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling. My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552:956,flexible,flexible,956,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552,1,['flexible'],['flexible']
Modifiability,"Good point, sorry to cause that problem, then. Is it worth keeping it at a debug or info severity instead, then? Also, should the warning after a failed import of configobj also be removed or downgraded (https://github.com/qutip/qutip/blob/4fc89ce6804324f20e84039d961ac765105a7a2e/qutip/settings.py#L98)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/465#issuecomment-210294305:163,config,configobj,163,https://qutip.org,https://github.com/qutip/qutip/pull/465#issuecomment-210294305,1,['config'],['configobj']
Modifiability,"Good point. Lets do that for the next version. On 05/01/2014 04:10 PM, Robert Johansson wrote:. > Two suggestions:; > ; > 1.; > ; > ```; > QuTiP uses an environment variable |NUM_THREADS|. We should; > probably name-space this variable, calling it |QUTIP_NUM_THREADS|; > (consistent with how other packages name their variables, like; > |MKL_NUM_THREADS| and |OPENBLAS_NUM_THREADS|. The upcoming 3.0; > release would be a good time to make this change.; > ```; > ; > 2.; > ; > ```; > Considering that QuTiP does not use thread but processes, it would; > be even better to call the variable |QUTIP_NUM_PROCESSES|.; > ```; > ; > —; > Reply to this email directly or view it on GitHub ; > https://github.com/qutip/qutip/issues/119.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41887009:165,variab,variable,165,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41887009,4,['variab'],"['variable', 'variables']"
Modifiability,"Got it to work as expected after a few changes:. * First, it seems there is an error in [Gri98] and `A` should be transposed. This can be seen as equation 251 from [Gri98] differs from equation 52 from [PRA44]. There might be another issue with a `k` factor instead of a `-k` factor, but it should not matter as long as thermal population is 0. For some unknown reason, using `A` or its transpose does not change anything on qubits systems.; * Second, `c_ops` should not be dissipation operators but operators coupling to the environment bath. Then, one should not use `a` but `a + a.dag()`. This seems to be different than the standard `mesolve` and might deserve an emphasis in the doc. [Gri98] | Grifoni, P. Hänggi, Driven quantum tunneling, Physics Reports 304, 299 (1998). doi:10.1016/S0370-1573(98)00022-2.; [PRA44] | R. Blümel, A. Buchleitner, R. Graham, L. Sirko, U. Smilansky, H. Walther, Phys. Rev. A 44 (1991) 4521.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/772#issuecomment-339472230:510,coupling,coupling,510,https://qutip.org,https://github.com/qutip/qutip/issues/772#issuecomment-339472230,1,['coupling'],['coupling']
Modifiability,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:1193,Variab,Variable,1193,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027,2,"['Variab', 'config']","['Variable', 'configure']"
Modifiability,"Having looked at the description of the function, that is it specifically refers to density matrices, then I would say that it does what it promises to do, and that the changes mean that it does it much better. So (now) personally I don't think we need to adapt for a pure vs pure state in this method.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134933420:256,adapt,adapt,256,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134933420,1,['adapt'],['adapt']
Modifiability,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:577,variab,variable,577,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,1,['variab'],['variable']
Modifiability,"Hello! As @jakelishman described, you can help debug this issue by trying:. ```python; from qutip.cy.openmp.parfuncs import spmv_csr_openmp; ```. and reading the exception produced. I suspect that the `qutip.cy.openmp.*` packages will simply not have been compiled -- they're only built by QuTiP when ""--with-openmp"" is passed to `setup.py` and I think `conda install ... qutip` will not do that even when OpenMP is already installed. To correct this you will need to install QuTiP from source and pass `--with-openmp` yourself as described in https://qutip.org/docs/latest/installation.html?highlight=openmp#direct-setuptools-source-builds. We probably could make ""openmpi"" and ""no-openmpi"" builds for conda-forge by adapting the pattern in https://conda-forge.org/docs/maintainer/knowledge_base.html#openmp but that would require some work (and be a feature enhancement :).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1378#issuecomment-916822166:718,adapt,adapting,718,https://qutip.org,https://github.com/qutip/qutip/issues/1378#issuecomment-916822166,2,"['adapt', 'enhance']","['adapting', 'enhancement']"
Modifiability,"Hello, . I am trying to work on this enhancement. Do you think it's also a good idea to add the controlled version of the above gates? This can be done by defining a custom gate as well as given in the example (for rx) in the docs. Also, is it better if we name the gates ""X"" or ""XGATE"". I am not sure what convention the naming follows, if any. I can issue a pull request as soon as this is clarified. . Best, ; Sidhant.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1208#issuecomment-601552795:37,enhance,enhancement,37,https://qutip.org,https://github.com/qutip/qutip/issues/1208#issuecomment-601552795,1,['enhance'],['enhancement']
Modifiability,"Hey guys, thanks for the feedback (this is the first time I have logged in to github in about a year!).. Just some replies to Paul's comments. The method is basically general, under certain assumptions about the bath spectrum density and bath temperature, so the 'system' can, in principle, be anything. I will also do so minor tweaking so it can deal with multiple baths and correlated baths. We will add some notebooks showing different examples and explaining when its valid later. . > Why is it not possible to directly calculate expectation values other than the coupling term?. Yeah there was a list of expectation values at some point, but it disappeared while we were making edits. Thanks for the reminder. Thanks for the other points, we will fix the various issues.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-103750029:568,coupling,coupling,568,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-103750029,1,['coupling'],['coupling']
Modifiability,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1101,config,configuration,1101,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565,2,['config'],['configuration']
Modifiability,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:319,refactor,refactoring,319,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393,2,"['maintainab', 'refactor']","['maintainability', 'refactoring']"
Modifiability,"Hi @Ericgig ; Thanks for investigating this so thoroughly. ; I guess it makes sense that unpacking a dict at each call is inefficient, so I think we should drop this idea. As you have suggested previously, users can always use module variables if they wish to avoid passing vars in `args`. So I think we should aim to keep it simple. I think adding `f(t)` as a signature option will be sufficient for what @goerz wanted and would be sufficient for using a Numba jit. So, my suggestion for the next major release (v5) would be that we have only two call sigs:; - `f(t, args)` (default); - `f(t)`. For now we will have to have the three (although I don't think the `rhs_with_state` is not widely used, if at all).; - `f(t, args)` (default); - `f(t)`; - `f(t, state, args)`; The default needs to remain as it is, because it is widely used. I think it makes sense to use introspection to decide which has been specified by the user, as the sig is clearly distinguishable by the number of args. So effectively we can ignore the `rhs_with_state` option, but I think we should give a deprecation warning that the `f(t, state, args)` signature will be removed in the next version. So, I think this means we can keep the new method of passing the state in the args dict. I would suggest we make it a bit more simple though. I notice that the processing of the option is a bit involved. So I suggest that any element of the `args` dict where the key is of the form `name:special_value_kind` be considered some kind of special value. If `special_value_kind` is not recognised then it should throw a `ValueError`. For now we will have the `special_value_kind` of:; - `state`: Qobj of the state at time `t`, with the correct dimensions; - `state_vec`: ndarray of state as a vector; - `expect`: I can't remember exactly what you did here. The `state_vec` will clearly be much more efficient, as this is what the ODE solver maintains. However, for completeness I think we should have the `state` option. The initial ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162:234,variab,variables,234,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162,1,['variab'],['variables']
Modifiability,"Hi @Ericgig, @jakelishman,. Thanks very much for the very helpful replies! I will try these suggestions in my application Eric!. Jake, when you say the following:; > Oh of course, I had `mcsolve` in mind as to why that couldn't be done (and in that case, my interpolation wouldn't work either because of the separation of the decay channels)... Is it that, this:; ```; def L(t, args):; H = H(t, ...); c_op = C(H, t, ...); return qutip.liouvillian(H, [c_op]). mcsolve(L, ..., c_ops=[]); ```. won't work due to `_funcrhs` treating `h_func` as a Hamiltonian always? If this is the only factor (as far as I can see), then I think I can further hack this to make callbacks work for me locally. I'm not yet sure if the numpy arrays method will work here but this is what I will strive for. Some details of my plans: I am doing dynamics simulations of quantum annealing processes. We use a certain number of qubits (between 4 and 8) biased and coupled in certain ways to produce examples of 'difficult' problems for adiabatic quantum computation, where the instantaneous energy gaps can have very small minima during evolution. The resulting ODEs appear to be 'stiff' and long evolution times are required to observe high probabilities of being in the ground state. The combination of these things appears to make solving for long evolution times very time consuming. I observed a massive speedup using `mcsolve` however. What I wish to do is include various decay channels, which in the physical systems we use, we understand to be in the 'weak coupling limit' defined by T. Albash here:; https://arxiv.org/pdf/1503.08767.pdf. Another note: A number of colleagues have found most useful the RK45 method implemented in what I understand to be 'new' ode solver scipy code `scipy.integrate.solve_ivp`. I notice that the 'dopri5' option for `scipy.integrate.ode` is likely the same thing. This is something I will play with also.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-630067552:1539,coupling,coupling,1539,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-630067552,1,['coupling'],['coupling']
Modifiability,"Hi @MartinSandeCosta, I have merged the PR of @mlaguna10. You can see now there is a few conflicts. Could you make a fresh PR including your changes based on the current master branch? . It could include:; - The controlled version of the gates; - Changes in QubitCircuit.propagator(); - Tests; and another enhancement you have related to #1208 . We shouldn't include the change of the attribution name `N` and `U_list` in this PR, as @jakelishman and @ajgpitch explained.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-607489616:306,enhance,enhancement,306,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-607489616,1,['enhance'],['enhancement']
Modifiability,"Hi @TejasAvinashShetty, I had a try at the conda install on my machine. I had no issue:; ```; conda create -n qutip-env; conda activate qutip-env; (qutip-env): conda install cython numpy scipy nose matplotlib; (qutip-env): conda install qutip; (qutip-env): python; ""Python 3.7.3 (default, Mar 27 2019, 16:54:48); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin""; >>> from qutip import *; >>> qutip.about(); QuTiP Version: 4.3.1; Numpy Version: 1.16.3; Scipy Version: 1.2.1; Cython Version: 0.29.7; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/miniconda3/envs/qutip-env/lib/python3.7/site-packages/qutip; >>> quit(); (qutip-env): conda deactivate; conda update -n qutip-env --all; ""Collecting package metadata: done; Solving environment: done; # All requested packages already installed.""; ```; Can you please specify your machine configuration and what did you do to update the environment?. I guess I am unable to reproduce the issue unless I go back to qutip 4.2. ; Googling ""np113py36_2"", I ended up on this QuTiP Google Group thread, https://groups.google.com/forum/#!topic/qutip/BwtoyhW60jo; maybe making sure you are not in the QuTiP folder resolves the issue. . You can also activate your environment, uninstall qutip, update all the rest and then install qutip ; ```; conda activate qutip-env ; (qutip-env): conda uninstall qutip; conda update -n qutip-env --all; conda activate qutip-env ; (qutip-env): conda install qutip; ```; Another practical suggestion, not really assessing the issue, would be to create a new environment and do a fresh install.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/988#issuecomment-489419006:1013,config,configuration,1013,https://qutip.org,https://github.com/qutip/qutip/issues/988#issuecomment-489419006,1,['config'],['configuration']
Modifiability,"Hi @jakelishman you were right about the contraction, I changed the indexes as in http://qutip.org/docs/latest/guide/guide-tensor.html so that it represents a trace-like channel. On the other hand I find that mixed dimensions operator `[[m,n], [m,n ]]` appear in some of the tests that were already in place, I will try to write my thoughts on their meaning later. I am still going to refactor this a little bit more, and tell you when it is ready for review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-831049708:385,refactor,refactor,385,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-831049708,1,['refactor'],['refactor']
Modifiability,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:1250,flexible,flexible,1250,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386,1,['flexible'],['flexible']
Modifiability,"Hi @nonhermitian, I spent some time struggling with this as I recently shifted to macOS. This problem affects other Python installations too. I found a solution to this and if you could update it in the docs instead of the default macOS installation script, then it would be very helpful for new users. I will post the solution first and explain it below. . 1. Install a manual Python version which overrides the default Python supplied by Apple in the `usr/bin/python` path. You can check this using ```which python```. Installing using brew - . ```brew install python```. 2. Change the default Python interpreter from the one supplied by macOS in `usr/bin/python` to the user installed version in `/usr/local/bin/python`. This is explained in this [post](http://blog.manbolo.com/2014/09/27/use-python-effectively-on-os-x#p1). Edit the file `/etc/paths` using ```sudo vi etc/paths``` and move the line `/usr/local/bin` to the top. This makes the user installed Python default and the packages installed by pip or brew are imported instead of the ones supplied by apple. Restart the terminal. You may need to update numpy and scipy using ```pip install numpy``` or ```pip install numpy -U```. 3. Install qutip using ```python setup.py install```. Apple has its own Python version and a few modules such as numpy and scipy come along with it which are at `/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/include/python2.7`. These modules are difficult to manage and update due to issues with permission. Hence, even if you update numpy or scipy using `pip` or `brew`, it is not detected by Python. ~~This also raises an issue later `error: could not create 'build/src.macosx-10.12-x86_64-2.7': Permission denied`~~. This solution seems better since it does not mess with the system default. Edit 1 : sudo -H is needed to install using ```sudo -H python setup.py install```. The -H tag sets the home directory as the default for installing configuration files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-263745214:1963,config,configuration,1963,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-263745214,1,['config'],['configuration']
Modifiability,"Hi @pschindler, thanks for reporting this! Although the eigenenstates are different for both cases (`sparse=True` and `sparse=False`) I believe that they are both equally valid since the operator has degenerated eigenvalues. The approach for the computation of the eigenstates for both `sparse=True ` and `sparse=False` is different so that may explain why you see different results. For the case that @Ericgig presented though, the eigenvalues are non-degenerated. I tracked down the issue and it is related to how we compute these eigenvalues. When we ask for all the eigenvalues what we actually do is to compute the smallest half in with one method (`scipy.sparse.linalg(which='LR')`) and the largest half with a different method (`scipy.sparse.linalg(which='SR')`). Smallest half and largest half here means relative to the _real_ part of the eigenvalue. This makes complete sense for the cases where the eigenvalues are real but unfortunately not so much sense when we only care about the imaginary part. This is what the `which` is doing, is selecting the values with smallest/largest real part. If we include a small real component the bug completely disappears:; ```; In [56]: (qutip.num(4)*(1j+0.00001)).eigenenergies(sparse=True); Out[56]:; array([1.23048985e-16-2.21177095e-16j, 1.00000000e-05+1.00000000e+00j,; 2.00000000e-05+2.00000000e+00j, 3.00000000e-05+3.00000000e+00j]); ```; Because now there is a real part to use in the ordering. The behavior of `eigenstates` is definitely wrong and one way of solving it would be to not use both `LR` and `SR` options when all the eigenvalues are required and instead chose internally just one. This would still return results ordered by their real part but at least all the eigenvalues would be present (only once). We may want to extend the behavior of `eigenstates` to not only accept `sort=low` and `sort=high` and instead have a similar behavior to the one provided by scipy and allow sorting by imaginary part or absolute value.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009:1789,extend,extend,1789,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009,1,['extend'],['extend']
Modifiability,"Hi @saiyagami , your errors seem to be centered around OpenMP and parallelization stuff. It seems from the red underlined error that you do not have OpenMP installed, which shouldn't be the case since it is bundled with the Visual C/C++ compiler by default. I'd recommend you try the following, in this order:; 1. Try running the install again using the cloned repository's `setup.py` file, but this time run it as `python setup.py install --with-openmp`. Hopefully this configures things properly, and you don't see any more OpenMP related errors.; 2. If the above doesn't work, that suggests a more pathological error, in which case you probably should try using another compiler such as MinGW. Should you do so, please find more detailed instructions here : [https://stackoverflow.com/questions/11079586/getting-started-with-openmp-install-on-windows](url).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1079#issuecomment-539862401:471,config,configures,471,https://qutip.org,https://github.com/qutip/qutip/issues/1079#issuecomment-539862401,1,['config'],['configures']
Modifiability,"Hi @sarsid! I'd like to recommend that we land #1090 separately. It's a stand alone piece of work and coupling PRs together into big PRs where it can be avoided generally makes things harder to review and land. I can show you how to merge that branch into this one if you need to it make progress before #1090 lands. I would also recommend making the formatting changes you have made (I assume using black or your editor?) in a separate PR to this one. Lumping them into one PR also makes reviewing harder since one doesn't know which changes are intentional or meaningful. I'm also happy to help with this if you need!. I've started work on the docs for #1090, so hopefully it can land this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691:102,coupling,coupling,102,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691,1,['coupling'],['coupling']
Modifiability,"Hi Alex and Nathan, thanks for the suggestions, I have resolved the confliction. @ajgpitch Regarding the function `adjacent_gates`. It was there before, I just moved it around. I'm also not happy with it, but refactoring this function needs some careful analysis.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1065#issuecomment-545613325:209,refactor,refactoring,209,https://qutip.org,https://github.com/qutip/qutip/pull/1065#issuecomment-545613325,1,['refactor'],['refactoring']
Modifiability,"Hi Arne. Thanks a lot for the bug report. I'll go through the code fix it so that the qutip_gui = NONE flag is handled consistently. In the long run I think we need to refactor the code a little bit, so that GUI dependent module aren't imported at all if qutip_gui = NONE, rather that having a lot of if-else statements scattered around, but for now I'll try to make a quick fix by adding more if statements.. Rob",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/24#issuecomment-18720853:168,refactor,refactor,168,https://qutip.org,https://github.com/qutip/qutip/issues/24#issuecomment-18720853,1,['refactor'],['refactor']
Modifiability,"Hi Ben. Thanks a lot for your contribution. It's looking great!. A couple of small things:; - We try to make qutip python3 compatible, so please use python3 compatible print(...) function calls instead of print ... statements.; - Functions super_to_choi and choi_to_super seems to do the same thing, while the function names suggest complementary conversion. Is this intentional?; - I think it would be better if you move the test code from within the if **name** == '**main**' to a separate file in the examples directory, or even better as unit tests in qutip/tests/; - Avoid global import of qutip ""from qutip import *"" by only selectively importing the functions that you need (we try to do this internally in qutip to avoid circular module dependencies).; - Make relative import of qutip functions (for example from qutip.super_to_choi import super_to_choi). This is also required for python3 compatibility.; - Add an import of the main functions (for example subsystem_apply) to qutip/**init**.py ; - I would probably prefer the super_to_choi.py module be called something more general, like choi_decomposition,py (or something like that), which would reflect that it does not only contain the super_to_choi function but other related functions as well.; - Avoid printouts in choi_to_kraus function. If you want to enable debugging or diagnostic info, consider adding an optional function argument debug=False or verbose=False and print the vals and vecs variables only if the user explicitly asks for it. Otherwise, one could get an excessive amount of printouts if your code is used in a loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/22#issuecomment-18592742:1461,variab,variables,1461,https://qutip.org,https://github.com/qutip/qutip/pull/22#issuecomment-18592742,1,['variab'],['variables']
Modifiability,"Hi Boxi,. Can you please modify the projects of the Wiki page as you deem best?; All: we can also think of changing the order of them. It may be that; project #3 is deemed the most important. Best wishes,. Nathan. Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com. On Sun, Feb 23, 2020 at 5:42 AM Boxi Li <notifications@github.com> wrote:. > I have some detail information for the GSoC 2020 project ""Error mitigation; > in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub; > Wiki page. I post it here so if anyone finds it nice could copy it to the; > Wiki page.; >; > I add some details based on the original description:; > ------------------------------; > 1. Error mitigation in QuTiP; >; > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > quantum circuit simulator (which was a GSoC project) providing enhanced; > features for a pulse-level description of quantum circuits and noise; > models. A new class Processor and several subclasses are added to; > represent different platforms for quantum computing. They can transfer a; > quantum circuit into the corresponding control sequence and simulate the; > dynamics with QuTiP solvers. Different noise models can be added to; > qutip.qip.noise to simulate noise in a quantum device.; >; > This module is still young and many features can be improved, including; > new device models, new noise models and integration with the existing; > general framework for quantum circuits (qutip.qip.circuit). There are; > also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Request",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:949,enhance,enhanced,949,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,1,['enhance'],['enhanced']
Modifiability,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:274,Config,Configuration,274,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488,3,"['Config', 'config']","['Configuration', 'config', 'configuration']"
Modifiability,Hi Jake no problem. I was just asking about that particular line because I faced the same issue of readability versus properly scoping and could not get to a satisfactory solution. I was geting the variables from a global function that created a dictionary and it was not clean at all.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815068400:198,variab,variables,198,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815068400,1,['variab'],['variables']
Modifiability,"Hi Jake okey will re align and pull then and focus the other modules. Let's see if I am getting this right, is it correct style to add parameter to fixtures when they are used all along the test module, but in very specific special cases just leave the variable assignment before the test definition, like here https://github.com/jakelishman/qutip/blob/862d0de844d9d5b39f0301d0ea4c47c37d995499/qutip/tests/test_metrics.py#L126 ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815030359:253,variab,variable,253,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815030359,1,['variab'],['variable']
Modifiability,"Hi Kevin. Thanks for your efforts on this. However, I am not in favor of merging this PR in this form. It is way too intrusive on the old API, it would break backwarks compatibility for no good reason as I see it. Personally I don't think that the _2t and _1t names are that confusing. As you point out, _1t is still a two-time correlation function (a one-time correlation function would not be a correlation function, just a simple expectation value), but the _1t and _2t is intended to refer to the number of free time variables. Perhaps this should be explained more clearly in the docstrings, but I don't think it is worth changing the API for this reason. I would prefer if you added the new mc solvers using the current API conventions, and preferably without changing the me and es based solvers. If you want to propose a new API the correct way to do it would be:; 1. First discuss the idea, so that everyone interested could weight in on the naming of the functions, the style of parameters and arguments etc.; 2. Implement the new API without disrupting the previous API; 3. Deprecate the previous API, so that using it gives a warning (but still works!). ; 4. Then finally after a few release cycles we may drop the old API. This would not happen until qutip 4.0 (see http://semver.org/), which we do not plan to release anytime soon. Therefore, we cannot accept any PRs that with backwarks breaking API changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/218#issuecomment-53827562:521,variab,variables,521,https://qutip.org,https://github.com/qutip/qutip/pull/218#issuecomment-53827562,1,['variab'],['variables']
Modifiability,"Hi Nathan,. I can't modify the Wiki page because I'm not a maintainer of QuTiP. And it seems that there is no way to make a PR to Wiki. I can also send you the markdown source code per email like this, but I’m not sure if it works as I expected. The following is the markdown source code:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940:495,enhance,enhanced,495,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940,1,['enhance'],['enhanced']
Modifiability,"Hi Vutshi. Thanks a lot for this contribution! It's looking very interesting indeed. I'll be looking into the details of your code, notebook and your paper in the coming days, but from a first look it's looking great! I've been working a lot on the stochastic solvers the last few months, but it is still very much under development. The milstein method has been on my todo list for a long time, but I've not gotten around to work on it yet, so your contribution is very timely and most welcome!. I have tried to design the API in the most general way I could think of while still keeping the complexity from growing too much. Defining an SME with its RHS function, D1 and D2 functions has worked for most problems I considered so far, but I'd be happy to discuss further if this could be changed to something more flexible, like a function for calculating rho_{n+1} like you suggest. We hope to have the stochastic solver API ready and mature enough to include in the next qutip release sometime this fall, so it would be good to have these things tested and thoroughly discussed before then. But until the stochastic module is officially in the QuTiP API we still have a lot of freedom to shake things up if necessary. Also, to keep complexity and code duplication down I wanted to follow the pattern. smesolve (choose solver by argument) -> smesolve_generic -> specific method and SDE by rhs, d1, d2 selection. So it would be good if smesolve_mil and smesolve_impl in your code could be combined with smesolve, and if smesolve_implicit and smesolve_milstein could be combined with smesolve_generic, etc. That would reduce a lot of code duplication I think. Of course, if smesolve_generic needs to be changed to accommodate this that would be totally fine with me. It would be great if you could do a pull request of this to the qutip master, then we could discuss details in the PR. You'd need to rebase your branch to the current master tip though, because things already changed a bit since the v",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22011953:815,flexible,flexible,815,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22011953,1,['flexible'],['flexible']
Modifiability,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:556,variab,variables,556,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['variab'],['variables']
Modifiability,"Hi, . Here's the output I get. While I've installed the BLAS libraries on my machine, I haven't 'connected' it with numpy, so maybe this is what's leading to the issue?. ```; >>> import numpy as np; >>> config = np.__config__; >>> config.show(); openblas_lapack_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_info:; NOT AVAILABLE; atlas_blas_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; atlas_3_10_threads_info:; NOT AVAILABLE; blas_opt_info:; extra_link_args = ['-Wl,-framework', '-Wl,Accelerate']; define_macros = [('NO_ATLAS_INFO', 3), ('HAVE_CBLAS', None)]; extra_compile_args = ['-msse3', '-I/System/Library/Frameworks/vecLib.framework/Headers']; lapack_opt_info:; extra_link_args = ['-Wl,-framework', '-Wl,Accelerate']; define_macros = [('NO_ATLAS_INFO', 3), ('HAVE_CBLAS', None)]; extra_compile_args = ['-msse3']; atlas_3_10_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE; atlas_threads_info:; NOT AVAILABLE; lapack_mkl_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/552#issuecomment-259646175:203,config,config,203,https://qutip.org,https://github.com/qutip/qutip/issues/552#issuecomment-259646175,2,['config'],['config']
Modifiability,"Hi, @Ericgig! I would like to work on this issue. We cannot adopt the 3rd option in the master branch due to backwards compatibility, right? I'd rather avoid any single character variable wherever possible. That said, I believe the second option you gave is the best one to adopt in the master branch. Once I finish, I can work on dev.major implementing the third option.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087:179,variab,variable,179,https://qutip.org,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087,1,['variab'],['variable']
Modifiability,"Hi, I have an implementation of the ICM model now and as a bonus, I got an introduction to topological quantum computing as well as a nice topological quantum computing circuit viewer. I have it all in this repo - https://github.com/sahmed95/icm. It needs major refactoring, testing and there is a lot of brute code in there so please ignore it for now. I had to finish this in the span of a few days to start work on something related to the same and hence the code isn't pretty. I will work on this after finishing up my winter internship and push the commits here. An example can be found in https://github.com/sahmed95/icm/blob/master/tqc_icm/icm_example.ipynb. If this code has to go into qip, I guess I need someone with experience in this for review. How about https://github.com/alexandrupaler. The ICM paper is by him and he has implemented it in C++ in https://github.com/alexandrupaler/tqec.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-273579746:262,refactor,refactoring,262,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-273579746,1,['refactor'],['refactoring']
Modifiability,"Hi, I think it might either be an issue with your conda version or a conflict due to mixing things from the conda-forge and the default conda channel. . There are two options which you can try:. 1. Update all packages and conda by running. ```; conda update --all; ```; and then trying to reinstall qutip from the default conda repo (and not conda-forge) with. ```; conda install qutip; ```. 2. Add the conda-forge channel as priority with . ```; conda config --add channels conda-forge; ```; and then update all with; ```; conda update --all; ```; and finally installing qutip with. ```; conda install -c conda-forge qutip; ```. The last option would be to uninstall conda, install the latest Miniconda which does not install any package by default and then installing qutip from the conda-forge version with; ```; conda install -c conda-forge qutip; ```. All three suggestions should just take a couple of minutes. If you could tell me the Anaconda version, it would be very helpful (```conda --version```)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/860#issuecomment-387719222:453,config,config,453,https://qutip.org,https://github.com/qutip/qutip/issues/860#issuecomment-387719222,1,['config'],['config']
Modifiability,"Hi, This is not ready for review so I added a new tag `WIP`. The tests etc are not proper and I just wanted to get a basic version out. The latest commits are @nwlambert's code to construct the Liouvillian for the Heom. I will start refactoring things now and update the tag to `review in progress` when this is ready.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962#issuecomment-472547191:233,refactor,refactoring,233,https://qutip.org,https://github.com/qutip/qutip/pull/962#issuecomment-472547191,1,['refactor'],['refactoring']
Modifiability,"Hi, the first part for this is ready for review. A typical use case would be to generate the matrix M.; @nathanshammah I made some small changes in the names of functions.; @ajgpitch Please suggest any changes if necessary for pep8, function naming, testing or the API in general. We have the examples and ipynb notebooks that @nathanshammah wrote. Where do they go ? . Once, this is merged, there are additional helper functions to calculate operator expectations, thermal states etc which can be added. However, this forms the core of the module.; ```; from qutip.pim.dicke import *; import numpy as np; from scipy.integrate import odeint. # system parameters. N = 10; gS, gL, gD, gP, gCP = .1, .1, .1, .1, .1. # define the model; model = Pim(N, emission=gS, loss=gL, dephasing=gD, pumping=gP, collective_pumping=gCP). M = model.generate_M(). # Evolve the system according to dp/dt = M.p. rho0 = initial_dicke_state(N, (5, 5)); t = np.linspace(0, 10, 100). def generate_rhs(rho, M):; return M.dot(rho). p = odeint(generate_rhs, rho0, t, args=(M,)); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-332110217:847,Evolve,Evolve,847,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-332110217,1,['Evolve'],['Evolve']
Modifiability,"Hi, this is ready for review. It probably needs a lot of refactoring but I have documented all functions and provided unit tests. I made a simple script for my lab where you can specify a circuit in a text file and the outputs will be generated. You can check it out here: https://github.com/sahmed95/icm. I have an example describing the use of this module. Where do the examples go ? @ajgpitch @nonhermitian . As I mentioned, @alexandrupaler should be the right person for review. Dr. Devitt also mentioned Damian from ProjectQ (?) who could help perhaps.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-275668058:57,refactor,refactoring,57,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-275668058,1,['refactor'],['refactoring']
Modifiability,"Hi,. I think your new implementation of API should be flexible enough to incorporate any explicit scheme. The reason I think it is useful to calculate \rho_{n+1} is to apply a semi implicit method. This is what is done by Lsparse. I tried two ways of doing it. First, one can calculate (1 - (L+d1)_dt)^(-1) and apply it to to the stochastic part of the equation. Another way is to calculate the deterministic evolution expm[(L+d1)_dt] and also apply it to the stochastic part. Both of these methods work for linear deterministic part like in the homodyne detection. I've got good results with these semi-implicit methods on a problem with a few qubits. Due to a big nonlinearity for some parameters regime it really helps to apply the true deterministic evolution (or its approximation). For another regime it is better to use explicit method. In principle it should be good to adjust degree of implicitness. Anyway I'm still looking into the problem and comparing different possibilities. I hope to produce a new notebook with tests soon. This Milstein realisation is compatible in principle with the heterodyne detection. I'm not sure it is possible to express everything in terms of d1 and d2 only. The point is that I need to use derivatives of d2. I don't really see a problem to have separate RHSs for homodyne, heterodyne and photocurrent detections. I'll think a bit more about unification of homodyne and heterodyne and then I'll submit a pull request. Regarding expm for large systems. We need to calculate it only once, it works for small systems so I think it is a good option to have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22116628:54,flexible,flexible,54,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22116628,1,['flexible'],['flexible']
Modifiability,"Hi. I don't quite understand what you are proposing to implement, but enhancements and extensions are of course very welcome!. Edit. OK, thinking about it a bit more I think I understand what you want to accomplish. Instead of giving a single wavefunction as initial state, you want to pass a list of wavefunctions that will ack at different initial states for each trajectory? That would be a very welcome improvement.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/120#issuecomment-41975397:70,enhance,enhancements,70,https://qutip.org,https://github.com/qutip/qutip/issues/120#issuecomment-41975397,1,['enhance'],['enhancements']
Modifiability,"Hmm, it still seems to use the old travis ci configuration, where I tried to install numpy/scipy with pip without wheels. But took too long to install the dependencies that way, and the tests will probably timeout and get cancelled. In the current travis ci configuration uses pip with wheels to install numpy/scipy much faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36083480:45,config,configuration,45,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36083480,2,['config'],['configuration']
Modifiability,"Hmm, yes, that only works if you set the qutip.settings.debug to True via the configuration file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/261#issuecomment-63601247:78,config,configuration,78,https://qutip.org,https://github.com/qutip/qutip/pull/261#issuecomment-63601247,1,['config'],['configuration']
Modifiability,"I agree on leaving this PR as it is. @hodgestar, I committed your suggestions and removed the `user_color` temporary variable (was not really necessary).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1909#issuecomment-1142282073:117,variab,variable,117,https://qutip.org,https://github.com/qutip/qutip/pull/1909#issuecomment-1142282073,1,['variab'],['variable']
Modifiability,"I agree that is is getting a bit unwieldy with all the options to the steadystate function, many of which only have meaning for specific solvers. We should do something about that. I wouldn't favor getting rid of the steadystate function though.. It might break a lot of old code and I think it is nice to have a high-level API that is decoupled from the specific implementation (direct, interative, or something else). Currently steadystate is only dispatching to other functions, and I think that is how it is supposed to be. To solve the problem with diverging options requirements for different solvers I would suggest changing the function signature to. ```; def steadystate(A, c_ops=[], method='direct', **kwargs):; ...; if method == 'direct'; steadystate_direct(A, c_ops, **kwargs); ```. and defer all the specifics about kwargs to specific solvers (including docstrings). That would bring the default values of those options closer to where they are used and reduce duplication. It would also allow us more flexibility in maintaining a backwards compatible api, and future maintainability. It's fine with me to make _steadystate_direct and _steadystate_iterative publicly accessible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/108#issuecomment-41362284:1081,maintainab,maintainability,1081,https://qutip.org,https://github.com/qutip/qutip/issues/108#issuecomment-41362284,1,['maintainab'],['maintainability']
Modifiability,"I agree we need to be consistent, but I would also go with `matrix * Qobj` to be right and change `Qobj * array` to raise an error.; `Qobj * Qobj` can be understood as `Qobj @ Qobj` but everything else could use `mul`. If `mul` raise a `TypeError`, we can catch it and return `NotImplemented`. With this, we probably won't need to touch the `Dense` and `CSR` `mul` function and `Variable` will be passed to the `TfTensor` specialization.; The only issue I see is that sometime `Variable * Qobj` will work, other time it will not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814:379,Variab,Variable,379,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814,2,['Variab'],['Variable']
Modifiability,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:605,layers,layers,605,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874,1,['layers'],['layers']
Modifiability,"I am getting a variety of errors when running the test scripts under OSX:; - For `test_mcsolve_cl_time_dep_h` I get ""atol could not be reached for 1 trajectories"". I am also seeing:. ""CompilerWarning: Non-empty compiler output encountered. Set the environment variable PYOPENCL_COMPILER_OUTPUT=1 to see more.; ""to see more."", CompilerWarning)"". ""AttributeError: 'NoneType' object has no attribute 'clobj__delete'; Exception ignored in: <object repr() failed>""",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-259602577:260,variab,variable,260,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-259602577,1,['variab'],['variable']
Modifiability,I am guessing that there is some issue removing td files in config. The test that you do should not be looking for a RHS file as the test is time-independent. Why this only happens on Win is an interesting question. I put up a fork that may work here:. https://github.com/nonhermitian/qutip/tree/config_reset_test. Let me know how it goes. It seemed to work on my Win7 VM. It basically removes the old td files from config every time it is not needed anymore. I am not sure why we did not do this before. It still needs to be checked that the rhs_reuse setting in the Options class still works.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/728#issuecomment-317316149:60,config,config,60,https://qutip.org,https://github.com/qutip/qutip/issues/728#issuecomment-317316149,2,['config'],['config']
Modifiability,I am not sure what you mean by too large. The dimensions are not really the issue. It is the number of nonzero elements that matter. I am also puzzled by evolution using only collapse operators. Anytime you evolve a system you need the Hamiltonian. The Liouvillian has both coherent and dissipative terms in a single operator.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/531#issuecomment-244249449:207,evolve,evolve,207,https://qutip.org,https://github.com/qutip/qutip/issues/531#issuecomment-244249449,1,['evolve'],['evolve']
Modifiability,I am now also encountering this issue when installing qutip 4.3.1 on a docker image (built from Windows). qutip 4.3.0 works without problems. Minimal docker file where qutip fails to import:. ```dockerfile; FROM continuumio/miniconda3. RUN conda config --append channels conda-forge && conda update -y --quiet conda && conda install -y --quiet qutip=4.3.1; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-480764079:246,config,config,246,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-480764079,1,['config'],['config']
Modifiability,"I am now trying to setup a developement environment using ```python setup.py develop``` and ```python setup.py build_ext --inplace``` but getting the error . ```; cy/stochastic.pyx: cannot find cimported module 'qutip.cy.spmatfuncs'; Appending qutip.cy configuration to qutip; Ignoring attempt to set 'name' (from 'qutip' to 'qutip.cy'); Appending qutip.control configuration to qutip; Ignoring attempt to set 'name' (from 'qutip' to 'qutip.control'); Traceback (most recent call last):; File ""setup.py"", line 18, in <module>; setup(**configuration(top_path='').todict()); File ""setup.py"", line 10, in configuration; if os.environ['FORTRAN_LIBS'] == 'TRUE':; File ""/usr/local/Cellar/python/2.7.12_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/UserDict.py"", line 40, in __getitem__; raise KeyError(key); KeyError: 'FORTRAN_LIBS'; ```; I have gcc and gfortran installed and I suspect this might also be due to some issue with the file paths. I will try to get a workaround and post soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-263750245:253,config,configuration,253,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-263750245,4,['config'],['configuration']
Modifiability,"I am trying to add some `.qasm` files to the folder `qutip/qutip/tests/qasm_files/` to use during test time. I thought it would be enough to add them to the `PACKAGE_DATA` variable in `setup.py` but that does not seem to work. Any ideas on how to make sure this folder is available during testing time? Beside this part, the PR is ready for review. @nathanshammah @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-655893373:172,variab,variable,172,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-655893373,1,['variab'],['variable']
Modifiability,"I completely agree with you that random tests really aren't the right way to go in general, but right now our problem is that basically QuTiP's entire testing suite is based on randomised tests, and that's an awful lot of technical debt to overcome any time soon :(. . The `dnorm` tests have historically been a huge problem, even though basically nobody's worked on `dnorm` for a long long time now (for context, see in particular #880 and #874). We don't actually even know if the failures in `dnorm` are deterministic and reproducible, although it turns out that I had a brief look into this when I joined as a GSoC student about a year ago... I don't remember doing it at all!. I know this is super inelegant and not the perfect method, but it's kind of a nasty trade-off - I don't have time to really dig into `dnorm` (a topic I know almost nothing about) to work out an appropriate solution to temperamental errors, we do want `dnorm` to be tested since we're shipping it, and the slight flakiness keeps causing us test suite failures about 1 in 10 times. I'm somewhat opposed to fixing the random seed because having the variance over several test runs does actually help us cover more ground (eventually) - fixing it to a ""known good"" seed actually seems to me to be more of a mask of potential problems than this. Of note: the pytest plugin I'm using reports the number of reruns it performed in the analysis at the bottom - they show up in a yellow alongside the ""skips"" and ""xfails"" - so it's not completely hidden. I'd love to have a property-based testing suite like hypothesis up and running - that definitely seems like the proper solution to this in the end. In the meantime, I'm open to swapping to a fixed random seed if you think that's much better - testing is one place where I'm really aware of my lack of formal experience in software engineering, so I'm basically just learning as I go.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227:1343,plugin,plugin,1343,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227,1,['plugin'],['plugin']
Modifiability,"I did some tests and ; 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian matrices) (c's version Ok); 2 - It happen when installing the scipy stack with pip but not when installing it with conda.; 3 - It depend on the problem size, 64 seems particularly bad, usually it fails on the second call.; 4 - I only got it in zheevr which is only used in `brmesolve`. But Nathan got it in other tests which use scipy's `eigh`.; 4 - It happen in scipy in the fortan version of lapack:. ```; import numpy as np; from scipy.linalg import eigh; H = random_hermitian(64); eigh(H) # Work fine; eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; ```. Possible solutions (for zheevr):. - Installing scipy with conda, the easiest solution, but not in our control.; - Finding a way to link clapack from cython. Linking scipy's one would require good knowledge of scipy internals since only one cython interface is provided. Linking to another installation of lapack, but it would require the user to install lapack or install it with qutip. Both seems wrong to me.; - For mac user, call scipy's eigh from cython i zheevr, slower but better than risking segfault.; - Have the code directly in qutip. We can adapt it from OpenBlas: https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492:1238,adapt,adapt,1238,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492,1,['adapt'],['adapt']
Modifiability,"I did that and it fixed the issue, but wouldn't it make more sense to have nnz be a directly retrievable variable of a dtype = ""CSR"" Qobj?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2481#issuecomment-2208274271:105,variab,variable,105,https://qutip.org,https://github.com/qutip/qutip/issues/2481#issuecomment-2208274271,1,['variab'],['variable']
Modifiability,"I discovered that we were missing a small bit of towncrier configuration, so I added this test that does a trial run of generating the changelog. In addition to checking that the changelog can be generated, it also outputs the draft so that reviewers can look at it if they like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480:59,config,configuration,59,https://qutip.org,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480,1,['config'],['configuration']
Modifiability,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:905,plugin,plugins,905,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791,2,['plugin'],['plugins']
Modifiability,"I don't know if there was a macOS update or something, but my configuration has gone funny as well. I find now that using `gcc --sysroot=...` rather than `gcc -isysroot=...` (note the missing `i` and the doubled `--`) works. I'm not 100% sure why this is the case - as far as I'm aware, the only difference between `--sysroot` and `-isysroot` is just that the latter only applies to includes and the former is both libraries and includes - but it works for me right now. I must be wrong in some way about the difference. Hopefully that works for you on a temporary basis. I'm sure Apple will be along shortly to change everything else up for us again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1030#issuecomment-769204657:62,config,configuration,62,https://qutip.org,https://github.com/qutip/qutip/issues/1030#issuecomment-769204657,1,['config'],['configuration']
Modifiability,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:88,plugin,plugins,88,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422,1,['plugin'],['plugins']
Modifiability,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:834,Variab,Variable,834,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515,1,['Variab'],['Variable']
Modifiability,"I get the same issue on a [Travis CI build](https://travis-ci.org/github/qutech/filter_functions/jobs/757061484) with; ```; Distributor ID:	Ubuntu; Description:	Ubuntu 16.04.6 LTS; Release:	16.04; Codename:	xenial; ```; running on `amd64` with `qutip-4.5.2` installed via `pip`. The same test config runs fine on Python 3.6 and 3.7, though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-777523352:293,config,config,293,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-777523352,1,['config'],['config']
Modifiability,"I guess it is my turn then :) ; I looked at the `orbital` function and compared it to the scipy implementation of `sph_harm` and the results don't seem to agree. There is one detail I need for clarification: The `orbital` function uses `ket`states as input. Which component of the `ket` state should refer to which configuration of `m`? . For example, if I pass `basis(3,0)` as argument is the corresponding setting `l = 1, m = -1` or `l = 1, m = 0` or `l = 1, m = 1`? ; I am not sure what the desired assignment is. For me it makes sense to start with the smallest `m` (in the example `m=-1`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700:315,config,configuration,315,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700,1,['config'],['configuration']
Modifiability,I guess the purpose is to reduce complexity and increase maintainability. I'm not sure how should I reduce this. Separate the input check and use another private method?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1028#issuecomment-505083482:57,maintainab,maintainability,57,https://qutip.org,https://github.com/qutip/qutip/pull/1028#issuecomment-505083482,1,['maintainab'],['maintainability']
Modifiability,"I had also the idea that showing from which base classes these solvers inherit would be enough, but since the issue asks to show `property` and `run` explicitly on each of the solver docs, then I opted do to it this way. Also, from my implementation, also other methods are now documented (e.g. add_integrator). Which I believe since these are public methods, they should be documented as well (?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2167#issuecomment-1566246459:71,inherit,inherit,71,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1566246459,1,['inherit'],['inherit']
Modifiability,"I have come across the same problem. If you set g=2 you will have a different normalization for the Wigner function. W(0,0)=-0.63661977 is the 0,0 point of the single photon, which usually should be -1/pi so here we multiplied it by two. Same goes for g=1 where you divide it by 2 as far as I see. This does not change the normalization of the marginal distributions so all of those Wigner functions with different g are valid phase-space quasi-probabilities. What does change in fact with the factor g is the commutator relation [x,p]=a*i, where if g!=sqrt(2) a!=1. This will in fact change how we connect annihilation, creation, position and momentum operators together. ; In the case g=sqrt(2) we have the definition x=1/sqrt(2)(a^\dagger + a) and p = i/sqrt(2)(a^\dagger - a).; If we now consider the question at hand concerning the coherent state amplitude we easily understand what is happening. A coherent state is defined by the displacement operator D(\alpha) which is defined as D(\alpha)=Exp[\alpha a^\dagger - Conj[\alpha]a], where we can rewrite the exponential argument as Re(\alpha)(a^\dagger - a) + i Im(\alpha) (a^\dagger + a) which is Re(\alpha) p sqrt(2) + Im(\alpha) x sqrt(2). You can see that with this definition there is a scaling factor alpha/sqrt(2) if we want to plot it in x,p phase space. So all you need to do is rescale your amplitude.; If you instead want to have g=2 then there is no rescaling needed, but your commutator relation and therefore your Heisenberg uncertainty minimum will change.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1112#issuecomment-1970976650:1051,rewrite,rewrite,1051,https://qutip.org,https://github.com/qutip/qutip/issues/1112#issuecomment-1970976650,1,['rewrite'],['rewrite']
Modifiability,"I have found out how to use this after reading the source:; ```; python -m build -n -x --wheel --config-setting=""--global-option=--with-openmp""; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219669702:97,config,config-setting,97,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219669702,1,['config'],['config-setting']
Modifiability,I have just successfully installed qutip using pip into a fresh conda env (python=3.6) on Linux Mint. I believe this Mint is pretty much identical to Ubuntu.; All dependencies were installed automatically. qutip tests run fine.; So I don't think that there is anything wrong with our setup configuration.; Note we do not recommend installing qutip into a system python env - especially on Linux.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/739#issuecomment-323319515:290,config,configuration,290,https://qutip.org,https://github.com/qutip/qutip/issues/739#issuecomment-323319515,1,['config'],['configuration']
Modifiability,"I have not put any tests in for this, because it seems like a lot of effort for something that is used as a kind of testing tool anyway. When I make my PR for the hsolve enhancements, including tests, this file will get pretty reasonable coverage.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454#issuecomment-193176693:170,enhance,enhancements,170,https://qutip.org,https://github.com/qutip/qutip/pull/454#issuecomment-193176693,1,['enhance'],['enhancements']
Modifiability,I have started this enhancement.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/101#issuecomment-39626760:20,enhance,enhancement,20,https://qutip.org,https://github.com/qutip/qutip/issues/101#issuecomment-39626760,1,['enhance'],['enhancement']
Modifiability,I just checked the Intel distro. Their numpy config does not point to the correct location for the libraries. They point toward to compiler folders just like Anaconda did in the past. Will stick to Anaconda support for now.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204802167:45,config,config,45,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204802167,1,['config'],['config']
Modifiability,"I just noticed that this PR treats the dims keywords differently than the existing `rand_*` functions, and does not accept a list. I will extend this PR to include that functionality soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/316#issuecomment-74428511:138,extend,extend,138,https://qutip.org,https://github.com/qutip/qutip/pull/316#issuecomment-74428511,1,['extend'],['extend']
Modifiability,"I looked at the failures and they seem to be in parts that are completely disconnected from logging. I have no idea why they aren't also in the main branch, but I'll investigate. Anyway, I agree with you, @jrjohansson, that the current implementation is not in keeping with the design of Python's logging package. At the time, it was a bit of a hack to try and make it fit as well as possible, but I think in retrospect that may have been misguided. Do you think the refactoring to more appropriately use Python logging would be a good 3.2.0 feature, or would you suggest that for ≥ 3.3? Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/379#issuecomment-147493646:467,refactor,refactoring,467,https://qutip.org,https://github.com/qutip/qutip/pull/379#issuecomment-147493646,1,['refactor'],['refactoring']
Modifiability,I made this pull request as part of my bachelor thesis and to give something back to qutip. But this branch has not been touched for 5 years. Turns out @nonhermitian had it right from the start with his concerns about the maintainability. : ); I think you should close it. Keep up the good work!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-986276625:222,maintainab,maintainability,222,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-986276625,1,['maintainab'],['maintainability']
Modifiability,"I noticed it because I have a code doing spinor lattice physics; the spinor piece is parameterized by the total angular momentum `F`. All of the operators are written as `tensor(spin_part, lattice_part)`. As part of a Brillouin zone unfolding code, I have reason to accumulate increasing powers of an operator in a loop, like. ```; original_state = tensor(basis(2*F+1, 0), basis(N, 0)); op = tensor(qeye(2*F+1), some_lattice_op); while True:; # ...; if occasionally_do_this:; op = base_op * op; transformed_state = op * original_state; ```. This code works fine, except for `F=0`. Since the `original_state` is a 1xN tensor state with `original_state.dims = [[1, N], [1, 1]]`, the `op * original_state` multiplication fails because `op = base_op * op` has deleted the `1` part of of `op`, leaving `op.dims = [[N],[N]]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/222#issuecomment-53928646:85,parameteriz,parameterized,85,https://qutip.org,https://github.com/qutip/qutip/issues/222#issuecomment-53928646,1,['parameteriz'],['parameterized']
Modifiability,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:449,config,config,449,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725,2,['config'],['config']
Modifiability,"I realised I never replied to this. I suggested `2*rtol` in this case because the error propagation in this case would guarantee that this is always sufficient. For other tests, we can always design the test so that it's calculable what the error term should be. I'd say it's generally a good idea to have the tests be as tight as we can possibly make them without risking false-negatives on the results, because otherwise we're not properly testing that the parameters do what they say. Regardless, that test failure isn't due to any of my PRs - it's a pre-existing problem that we happened to get unlucky on this time round. It'll get fixed when I modify `test_mesolve.py`. Can we review this PR to get the ball rolling on getting all of the test refactoring considered?. Possible reviewers: @Ericgig, @BoxiLi, @nathanshammah",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133:749,refactor,refactoring,749,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133,1,['refactor'],['refactoring']
Modifiability,I solved this by adding C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\ to the PATH variable,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1026#issuecomment-506732671:101,variab,variable,101,https://qutip.org,https://github.com/qutip/qutip/issues/1026#issuecomment-506732671,1,['variab'],['variable']
Modifiability,I think I am pretty happy now with all my functions and variable names (for now). I would say we should leave the variable name changing and moving gates and measurement to separate files for a different PR (it can just be a restructuring one !). I was wondering how to check if it passes current tests (I am not sure what changes were there on Travis).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-637291687:56,variab,variable,56,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-637291687,2,['variab'],['variable']
Modifiability,"I think `hypothesis` is the best method here in the long term, but it will most likely have to be a long-term goal. I think the main pro in favour of it is that it actually is making an attempt to remove randomness; it's attempting to comprehensively test a spanning set of input parameters, rather than just Monte-Carlo'ing our way through and hoping. There's a couple of points which make it difficult to implement:. 1. QuTiP can be quite fragile with respect to unexpected input formats, particularly in older parts of the code.; 2. Various components are only accurate up to some tolerance, and the error propagation to work out how that corresponds to useful measurable quantities can be rather tricky. Those are certainly both solvable problems, and point 1 in particular is just general improvement of usability. The second point is about designing the tests well, which again is certainly doable, but will take a while (it takes long enough just to refactor them, let alone a total rewrite of large chunks of them!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-629272663:957,refactor,refactor,957,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-629272663,2,"['refactor', 'rewrite']","['refactor', 'rewrite']"
Modifiability,"I think that @Ericgig makes a good point though. I think we should make the default install from source compile with `-march=native`. I think in the majority of cases this will be the best option for users. However, we need someway to turn it off, so that the conda-forge build will be more portable, and for the use-case illustrated in #920. Ok, I am going to merge this now, while we think of a more complete solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/949#issuecomment-463692072:291,portab,portable,291,https://qutip.org,https://github.com/qutip/qutip/pull/949#issuecomment-463692072,1,['portab'],['portable']
Modifiability,I think the priority order should be. *. Default value from `qutip.hardware_info`; *. Value from configuration file if exists; *. Environment variable if set,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41985674:97,config,configuration,97,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41985674,2,"['config', 'variab']","['configuration', 'variable']"
Modifiability,"I think there are two separate issues here. . As for the fortran module, it's true that the it adds a lot of build complexity, but most users do not need it and can easily install qutip without it. There is a case for removing it from qutip and put it in a separate module, but think this should be low priority, since it would require non-negligible amount work, would break backwards compatibility (it should bump next release to 4.0), and does not really provide any new features (other than a less complex code base). There might users who rely on it and for them it might be annoying if we remove it. So I would vote for postponing it until there are very strong arguments for removing it. As for the topic of this issue, I think that qutip should follow the lead of NumPy, even if it breaks backwards compatibility in the configuration methods, so that users that are familiar with NumPy and related projects does not have any surprises when using qutip. Also, if I understand correctly, this would mostly change how one configure and build against blas libraries such as openblas? Then I guess it would not effect the typical user that just download and install the package with standard configuration (no site.cfg file), and it should be safe the follow the advice of the OP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-155058653:828,config,configuration,828,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-155058653,3,['config'],"['configuration', 'configure']"
Modifiability,"I tried running the same test with pytest and it fails.; ```; ============================= test session starts ==============================; platform darwin -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0; rootdir: /Users/shahnawaz/Dropbox/dev/qutip, inifile:; plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3; collected 13 items. test_superop_reps.py ..Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458572211:270,plugin,plugins,270,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458572211,1,['plugin'],['plugins']
Modifiability,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:646,inherit,inherit,646,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437,2,['inherit'],['inherit']
Modifiability,"I was surprised to see that the color argument was added long time ago for the point methods. These were not ported to master. These changes break backwards compatibility as code that used `point_colors` will not work anymore. I wonder if this change of variable name is something we want to keep as it should be possible to keep the behavior backwards compatible AND include the new colors argument (which I think is a very necessary feature that motivated me to clean the code in master in the first place, I later realized that this was already added in dev.major).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1909#issuecomment-1141357026:254,variab,variable,254,https://qutip.org,https://github.com/qutip/qutip/pull/1909#issuecomment-1141357026,1,['variab'],['variable']
Modifiability,"I worked around this by doing; ```py; import qutip; import the_library # this sets the log level to DEBUG; import logging; logging.getLogger().setLevel(logging.WARNING); ```; I supposes that it's a bit weird/wrong that the library sets the log level like that, and maybe it's understandable that qutip has somewhat automatic logging for IPython. The real issue is that the config for `log_handler` is broken. I could possibly submit a PR for that at some point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1156#issuecomment-578627722:373,config,config,373,https://qutip.org,https://github.com/qutip/qutip/issues/1156#issuecomment-578627722,1,['config'],['config']
Modifiability,"I would not worry too much about codeclimate, but:; - some of the errors are arising due to trailing whitespaces. This is an easy fix; - in some cases, the ""cognitive complexity"" is very high. For example here:; ```; __init__ has a Cognitive Complexity of 68 (exceeds 5 allowed).; ```; Maybe it is worth considering some code refactoring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-575498581:326,refactor,refactoring,326,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-575498581,1,['refactor'],['refactoring']
Modifiability,"I would rather have the styling checks part of CI than pre-commit. Pre-commit hooks are a nice way to automate repetitive tasks, but for coding conventions, each developer tends to have their own setup (e.g. I would run black or pyflakes as a plugin in my editor, so that I get immediate feedback or fixes long before making a commit). Pre-commit hooks are also a poor choice for checking that coding style is followed, because developers will have different operating systems, difference versions of Python, black, pyflakes, etc, etc and so there are certain to be differences between what is considered correct by the scripts run by different developers. Finally, there are many valid reasons to commit broken code into branches, and I would not want to prevent that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467:243,plugin,plugin,243,https://qutip.org,https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467,1,['plugin'],['plugin']
Modifiability,"I would still prefer `qutip.extensions`, `qutip.ext` or maybe `qutip.extra` rather than `qutip.services` because although picloud and tskmon can properly be called services, I think that if we pursue the idea of having extra utitlities like this in the qutip project we should take a broader approach and call it extensions, which may or may not be services. These would have to be completely isolated from the rest of the qutip code base (including the configuration file parser).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/255#issuecomment-63908501:454,config,configuration,454,https://qutip.org,https://github.com/qutip/qutip/pull/255#issuecomment-63908501,1,['config'],['configuration']
Modifiability,"I'd be interested in providing these changes. I have a few points to ask/consider:; 1. which function is meant by `zero_oper()`? I can't find any reference to it in the code, and judging by the name, I'd guess it's equivalent to `qzero()`, which already supports this.; 2. should we extend the automatic tensoring to other operators, e.g. `create()`, `destroy()`, and so forth? I can't necessarily think of any particular use-case, but _not_ having it causes an odd inconsistency with `qeye()`.; 3. for `projection()` and `basis()` in particular: should the interface allow only scalar `m` and `n`, which must be the same for all dimensions, or should there be broadcasting rules? The latter seems like a more useful choice to me, with the rules for all arguments being:; - if `m` is a list, then `max_len == len(m)`; - if `m` is a scalar, then `m = [m] * max_len`. For example, this would provide `tensor(basis(2, 0), basis(2, 1)) == basis(2, [0, 1]) == basis([2,2], [0, 1])`, which seems the ""least surprising"" to me.; 4. should there be error-checking that supplied scalars/lists are the correct format? For lists in particular, the current behaviour is to silently flatten nested lists, though this is presumably a user error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/363#issuecomment-575273170:283,extend,extend,283,https://qutip.org,https://github.com/qutip/qutip/issues/363#issuecomment-575273170,1,['extend'],['extend']
Modifiability,"I'll have to trust you mostly on actual operation of the code, but it looks like you've covered everything I could see as particular problems. I don't use this part of QuTiP, so I'm really not the best placed person to talk about how natural the APIs seem or anything like that. I'm still a fan of fixing the issues CodeClimate is complaining about because I think the cognitive complexity tests are a semi-decent indicator of maintainability, but at the end of the day, you're the code owner and that's your call. The other seemingly major potential headache is the dependence on that internal `_EvoElement` API in `QobjEvo` - I know for sure that that's going to go to hell in 5.0 - but I get that this PR didn't really cause this, so that's maybe a problem for another time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1444#issuecomment-815033004:427,maintainab,maintainability,427,https://qutip.org,https://github.com/qutip/qutip/pull/1444#issuecomment-815033004,1,['maintainab'],['maintainability']
Modifiability,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Giguère ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; > ⬇️ Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:451,variab,variable,451,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847,1,['variab'],['variable']
Modifiability,I'm +1 on having auto tidy up being a feature of the individual data layers. Could the auto tidy up setting perhaps be passed down to the data layers and then each layer can handle it in a way that seems sensible to the data layer?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259:69,layers,layers,69,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259,2,['layers'],['layers']
Modifiability,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:151,coupling,coupling,151,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355,1,['coupling'],['coupling']
Modifiability,"I'm not entirely sure what's being asked here. `mcsolve` evolves the state `psi0` by the given Hamiltonian for the given times, and returns a `qutip.solver.Result` object that contains various quantities, such as how the state evolved for each of the trajectories at a given time, and values of expectation operators at those times if `e_ops` is given. This looks like a question that's best answered by [reading the user guide on solving system dynamics](http://qutip.org/docs/latest/guide/dynamics/dynamics-monte.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1189#issuecomment-809405566:57,evolve,evolves,57,https://qutip.org,https://github.com/qutip/qutip/issues/1189#issuecomment-809405566,2,['evolve'],"['evolved', 'evolves']"
Modifiability,"I'm seeing the same segfault when trying to run the tests on MacOS. I'm using the following script `run_tests.sh` in the qutip root folder for running the tests:; ~~~; #!/usr/bin/env bash; python3 -m venv venv; ./venv/bin/pip install -r requirements.txt; ./venv/bin/pip install pytest matplotlib ipython; ./venv/bin/python setup.py install; ./venv/bin/pip freeze > test.log; ./venv/bin/python -c 'import scipy; print(""Scipy config:""); scipy.__config__.show()' >> test.log; ./venv/bin/python -c 'import numpy; print(""Numpy config:""); numpy.__config__.show()' >> test.log; (cd venv && ./bin/python -c 'from qutip.testing import run; run()' 2>&1 | tee -a ../test.log); ~~~; This results in the attached [`test.log`](https://github.com/qutip/qutip/files/4307785/test.log). This is for the 4.5.1 release candidate, but I'm getting the same segfault on the current `master` (01132789581821517986fad1a14ab3feec7d2de2)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596633885:424,config,config,424,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596633885,2,['config'],['config']
Modifiability,"I'm trying it now on a Windows without ImageMagick installed. However, it finds a wrong executable `convert`, which is a default command on Windows...... Is there a way to identify if the `convert` is the one we want? Otherwise, we can also just catch the CalledProcessError at line 148 and add an instruction. ```; 147 in_file = file_stem + "".pdf""; 148 out_file = file_stem + ""."" + configuration.file_type; --> 149 _run_command((which, *configuration.arguments, in_file, out_file)); 150 with open(out_file, mode) as file:; 151 return file.read(). ~\Miniconda3\envs\qutip-dev-py3\lib\subprocess.py in run(input, capture_output, timeout, check, *popenargs, **kwargs); 485 if check and retcode:; 486 raise CalledProcessError(retcode, process.args,; --> 487 output=stdout, stderr=stderr); 488 return CompletedProcess(process.args, retcode, stdout, stderr); 489 . CalledProcessError: Command '('convert', '-density', '100', 'qcirc.pdf', 'qcirc.png')' returned non-zero exit status 4.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125:383,config,configuration,383,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125,2,['config'],['configuration']
Modifiability,"I'm using. My configuration information is as follows:. Software	Version; QuTiP	4.5.2; Numpy	1.18.5; SciPy	1.5.0; matplotlib	3.2.2; Cython	0.29.21; Number of CPUs	6; BLAS Info	INTEL MKL; IPython	7.16.1; Python	3.8.3 (default, Jul 2 2020, 11:26:31) [Clang 10.0.0 ]; OS	posix [darwin]; Fri Sep 18 02:42:59 2020 MSK. For Mac OS: FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'.\. When I try to generate a circuit diagram as follows:. %matplotlib inline; from IPython.display import Image; from numpy import pi; import numpy as np; from qutip import *; from qutip.qip.operations import *; from qutip.qip.circuit import QubitCircuit, Gate. cphase(pi/2); q = QubitCircuit(2, reverse_states=False); q.add_gate(""CSIGN"", controls=[0], targets=[1]); q.png. Log Error:. ---------------------------------------------------------------------------; FileNotFoundError Traceback (most recent call last); <ipython-input-14-a760fe8d2360> in <module>; 1 q = QubitCircuit(2, reverse_states=False); 2 q.add_gate(""CSIGN"", controls=[0], targets=[1]); ----> 3 q.png. ~/opt/anaconda3/lib/python3.8/site-packages/qutip/qip/circuit.py in png(self); 1122 def png(self):; 1123 from IPython.display import Image; -> 1124 return Image(self._repr_png_(), embed=True); 1125 ; 1126 @property. ~/opt/anaconda3/lib/python3.8/site-packages/qutip/qip/circuit.py in _repr_png_(self); 1114 ; 1115 def _repr_png_(self):; -> 1116 return _latex_compile(self.latex_code(), format=""png""); 1117 ; 1118 def _repr_svg_(self):. ~/opt/anaconda3/lib/python3.8/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; 61 filename)); ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; 63 result = f.read(); 64 else:. FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'. How do I fix this error on Mac?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/702#issuecomment-694558061:14,config,configuration,14,https://qutip.org,https://github.com/qutip/qutip/issues/702#issuecomment-694558061,1,['config'],['configuration']
Modifiability,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:198,parameteriz,parameterization,198,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078,3,['parameteriz'],['parameterization']
Modifiability,"I've also thought of making these ENH proposals I made as sort of QuTiP Enhancement Proposals (QEP), similarly to PEP and NEP. So far, keeping them as ENH and Q&A github issues may be fine. Or one could possibly use the Projects section of Github, too, but there is no possibility for others to chip in there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1188#issuecomment-593255331:72,Enhance,Enhancement,72,https://qutip.org,https://github.com/qutip/qutip/pull/1188#issuecomment-593255331,1,['Enhance'],['Enhancement']
Modifiability,"I've bumped this to QuTiP 5, since that seems a more polite time to change the default configuration directory than 4.7.1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744:87,config,configuration,87,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744,1,['config'],['configuration']
Modifiability,"I've found `pytest` to be extremely nice to work with. One advantage is that `pytest` will also pick up and run `nose` tests, so there is no need to rewrite all of the existing tests. At the same time, new tests will be easier to write, as `pytest` has much less boilerplate code than `nose`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/958#issuecomment-488824031:149,rewrite,rewrite,149,https://qutip.org,https://github.com/qutip/qutip/issues/958#issuecomment-488824031,1,['rewrite'],['rewrite']
Modifiability,"If it helps in the future, you can use `pycodestyle` (available in `pip` and `conda`) to check pep8 compliance on your end before pushing a commit. As to the actual command, we might not actually want to remove the usage of `convert` - it's quite possible that a lot of people are still using ImageMagick 6, since for most people it's just a dependency that got installed by something else, and isn't frequently updated. `qutip` doesn't list it as an official dependency, so it wouldn't get updated on our behalf. We could catch which version of `ImageMagick` to use with something like; ```python; def _magick_comamnd():; for command in ['magick', 'convert']:; try:; subprocess.run((command, '--version'), capture_output=True); return command; except OSError:; pass; raise FileNotFoundError(""Couldn't locate system ImageMagick""); ```; and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; ```python; subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); ```; or something like that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473:883,variab,variable,883,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473,1,['variab'],['variable']
Modifiability,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:60,rewrite,rewrite,60,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075,1,['rewrite'],['rewrite']
Modifiability,"If those editors claim to provide terminal emulation it should be reported as bugs to them. However, even if it is fixed there it will take a long time before such a fix would reach end-users. I think in the interest of avoiding regressions I think we should restore the previous TextProgressBar and rename the current one to EnhancedTextProgressBar or something like that. Then this new progress bar would not disrupt peoples workflow and users who wants to use it can do so by creating an instance of it and pass it to progress-bar enabled functions using the progress_bar keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63267628:326,Enhance,EnhancedTextProgressBar,326,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63267628,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"If we look at https://github.com/cython/cython/issues/4310, they plan to deprecate the compilation time `IF` in a future release.; They suggest using cmacro or code generation to replace this. I suggest to take more time thinking about this and use those method instead. As it is, we would have to set a compilation environment variable each time something want to `cimport Data`, even from outside qutip...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990:328,variab,variable,328,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990,1,['variab'],['variable']
Modifiability,"If you have extra_link_args in the site.cfg, then a double keyword argument; happens when reading the options for the blas library. If you use openblas, add this to your site.cfg; [openblas]; extra_link_args = ... whatever ... and the error will happen.; The error is this. TypeError: config.add_extension() got multiple values for keyword argument; 'extra_link_args'. 2015-11-08 21:12 GMT+01:00 Paul Nation notifications@github.com:. > I do not get a build failure under NumPy 1.10.1. What was the particular; > error message? Any changes would also have to be backward compatible with; > earlier NumPy versions.; > ; > —; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/392#issuecomment-154863591. ## . Kind regards Nick",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-154867711:285,config,config,285,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-154867711,1,['config'],['config']
Modifiability,"If you install from source from the master branch with the environment variable `CI_QUTIP_WITH_IDXINT_64=1` set, you should be able to use matrix with size up to `2**63-1`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/853#issuecomment-1785174200:71,variab,variable,71,https://qutip.org,https://github.com/qutip/qutip/issues/853#issuecomment-1785174200,1,['variab'],['variable']
Modifiability,"ImageMagick is only mentioned in our tutorial page and not listed elsewhere. So we didn't specify a required version for it. . > We could catch which version of `ImageMagick` to use with something like; > ; > ```python; > def _magick_comamnd():; > for command in ['magick', 'convert']:; > try:; > subprocess.run((command, '--version'), capture_output=True); > return command; > except OSError:; > pass; > raise FileNotFoundError(""Couldn't locate system ImageMagick""); > ```; > ; > and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; > ; > ```python; > subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); > ```. This solution looks neat. One minor thing is that maybe we should use `check=True` instead of `capture_output=True` since the latter one is only available from Python 3.7+. Despite those has already been discussed above, the plot sill does not work for me. I find the following lines also wrong on Windows; ``` python; os.system(""rm -f %s.aux %s.log"" % (filename, filename)). os.system(""mv %s-tmp.pdf %s.pdf"" % (filename, filename)); ```; because `rm` and `mv` are not Windows command. We should probably replace it by python script `os.remove` and `os.replace` to make it system independent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793:528,variab,variable,528,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793,1,['variab'],['variable']
Modifiability,"In addition to cherry picking from #246, I think that gets rid of the suprious warnings when either `configobj` or `~/.qutiprc` is missing. Is there any other outstanding issue that I can address to make this more useful?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-63155472:101,config,configobj,101,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-63155472,1,['config'],['configobj']
Modifiability,"In doctest, we can add an option which runs specific commands only conditionally. This is already the case right now for parfor. It can be configured before building in conf.py.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1534#issuecomment-675696166:139,config,configured,139,https://qutip.org,https://github.com/qutip/qutip/issues/1534#issuecomment-675696166,1,['config'],['configured']
Modifiability,"In the latest commit I refactored the `entropy_vn_dicke` and `purity_dicke` functions in terms of a more general function, `dicke_trace`, which accounts for adding with the correct weight the blocks of a density matrix in the Dicke basis. The `dicke_trace` function can be used by other similarly nonlinear functions that involve taking the trace of a Taylor-expandable function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1046#issuecomment-514997016:23,refactor,refactored,23,https://qutip.org,https://github.com/qutip/qutip/pull/1046#issuecomment-514997016,1,['refactor'],['refactored']
Modifiability,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:124,parameteriz,parameterization,124,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135,1,['parameteriz'],['parameterization']
Modifiability,"It appears that the coefficients in your Hamiltonian are large, and the time-dependent part of the Hamiltonian oscillates very rapidly, The result is that the solver does not by default take small enough time steps when evolving the state. You can fix this by specifying a `max_step` to the `Options`:; ```python; max_step = 1. / (100 * gamma); options = Options(max_step=max_step, nsteps=10000); ```; With this max_step the solver correctly evolves the system for me. Closing this for now, but please feel free to continue the discussion here as needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677:442,evolve,evolves,442,https://qutip.org,https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677,1,['evolve'],['evolves']
Modifiability,"It is actually basically the same thing. However, there are several technicalities that need to be addressed in the implementation. For example, one does not know the collapse times a priori, so one has to evolve pass this time and then take a step back. Can also see:. Monte Carlo simulation of the atomic master equation for spontaneous emission; R. Dum, P. Zoller, and H. Ritsch; Phys. Rev. A 45, 4879 – Published 1 April 1992",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/344#issuecomment-105088915:206,evolve,evolve,206,https://qutip.org,https://github.com/qutip/qutip/issues/344#issuecomment-105088915,1,['evolve'],['evolve']
Modifiability,"It is not discouraging at all, quite the contrary. Thank you very much for; looking at it and taking the time to let me know your thoughts. I will take; peek on #1181 and provide any help I can. Regarding the PEP changes: I am extremely inexperienced with this project; and contrasted my ideas with others such as Qskit and projectQ before; proceeding. I also find that this refactoring can be excessively thorough; and not needed since it breaks backwards compatibility.; On the other side, I knew these changes would not go through to master but; they can serve some purpose as to help me get a better understanding of the; library as well as get in touch with the community. It also helped me on; how to approach potential improvements for the tool.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603579386:375,refactor,refactoring,375,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603579386,1,['refactor'],['refactoring']
Modifiability,"It looks as though NumPy keeps some metadata on MKL if it was compiled with MKL support. The `numpy.__config__` module in particular gives a path to the directory that NumPy loads its MKL libraries from. On my Linux box, for instance:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_intel_lp64', 'mkl_intel_thread', 'mkl_core', 'iomp5', 'pthread']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['/home/cgranade/anaconda/lib']; ```. The case seems to be worse for Anaconda on Windows (naturally), with `C:\aroot\stage\` taking the place of the actual Anaconda root:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_core_dll', 'mkl_intel_lp64_dll', 'mkl_intel_thread_dll']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['C:\\aroot\\stage\\Library\\lib']; ```. In the case that NumPy is compiled without MKL support, it seems to just omit the `mkl_info` dict entirely:. ``` bash; cgranade@berith:~$ source activate py27-nomkl; discarding /home/cgranade/anaconda/bin from PATH; prepending /home/cgranade/anaconda/envs/py27-nomkl/bin to PATH; cgranade@berith:~$ ipython; Python 2.7.11 |Anaconda custom (64-bit)| (default, Dec 6 2015, 18:08:32); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 4.0.3 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); <ipython-input-2-ebe4f6e784e1> in <module>(); ----> 1 print(numpy.__config__.mkl_info['libraries']). AttributeError: 'module' object has no attribute 'mkl_info'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204251671:1366,enhance,enhanced,1366,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204251671,1,['enhance'],['enhanced']
Modifiability,"It looks like the loop on line 64 https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/qobjevo_codegen.py#L64 completes on the first try, but doesn't manage to import any objects, so the import_list remains empty. Could you use pdb to access local variables?. ---; P.S. You can use Markdown to format the traceback in a user-friendly way:; e.g. ; \`\`\`python-traceback; /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext; \`\`\`. Renders to:; ```python-traceback; /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196#issuecomment-595050108:278,variab,variables,278,https://qutip.org,https://github.com/qutip/qutip/issues/1196#issuecomment-595050108,1,['variab'],['variables']
Modifiability,"It refers to the system's Liouvillian, I'd say. I think all the `C_n` there are stochastic jumps, `sc_ops `, while the system Liouvillian is the constant part, `c_ops`. But I am not 100% sure. . The user guide is partly out of date there, @Ericgig and others have considerably extended the functionalities of the stochastic solvers. Looking at the [API documentation](http://qutip.org/docs/latest/apidoc/functions.html#module-qutip.stochastic) is safer, and the [source code](http://qutip.org/docs/latest/modules/qutip/stochastic.html) is even more complete. . Meanwhile, you can also have a look at these development notebooks [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-milstein-speed-test.ipynb), [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb), and [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb) with regards to the new methods (you can find them all, a bit hidden, at the bottom of the http://qutip.org/tutorials.html list). Technically this issue could be transferred under [`qutip/qutip-doc`](https://github.com/qutip/qutip-doc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702:277,extend,extended,277,https://qutip.org,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702,1,['extend'],['extended']
Modifiability,"It seems like this routine is geared toward a specific problem, rather than a general input. Regardless, I think a notebook explaining this method is required, including better examples on the usage. This can be added to the documentation once it is converted to IPython notebooks. A few things I noticed are given below:; - The output is not a list, but a Result class object.; - Why is it not possible to directly calculate expectation values other than the coupling term?; - Why are the default input values what they are?; - The print statement at the end should be optional depending on the setting of the debugger.; - The call to Odeoptions in mesolve needs to be user accessible.; - tlist should not be the last input argument and should probably not be a kwarg.; - The call to eigenstates should also have an optional argument to call the sparse eigenstates solver if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-103712771:460,coupling,coupling,460,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-103712771,1,['coupling'],['coupling']
Modifiability,"It would be (for now):; ```; options = qt.solver.options.SolverOptions(store_states=True); solver = MeSolver(H, options=options); ```; `SolverResultsOptions` is not used directly but is contained in `SolverOptions`. While I expect verner method to work with tensorflow, there is still no way to pass a tensorflow variable as a coefficient in a QobjEvo yet, so autodiff will not work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1804#issuecomment-1041471668:313,variab,variable,313,https://qutip.org,https://github.com/qutip/qutip/issues/1804#issuecomment-1041471668,1,['variab'],['variable']
Modifiability,"It's very clean, I really like the `set & set` and reusing the classes. But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. Also what should; ```; def f(t, w, a=1):; return a. coeff = coefficient(f, args={'w':1}); coeff.replace_arguments(a=2)(0); ```; give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481:186,variab,variable,186,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481,1,['variab'],['variable']
Modifiability,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:1026,variab,variable,1026,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230,1,['variab'],['variable']
Modifiability,"Just to get the ball rolling, I will go ahead and ask my question here and migrate it if necessary. . My code performs quantum annealing on a transverse-field Ising Hamiltonian as inspired by D-Wave Systems devices which is explained briefly [here](https://docs.dwavesys.com/docs/latest/c_gs_2.html), but the essential equation is; ![D-Wave-hamiltonian](https://user-images.githubusercontent.com/29308150/61193322-bdb48c00-a688-11e9-94ac-22c5d093b47a.png).; The A(s) and B(s) factors dictate the time-evolution from the initial Hamiltonian to the final Hamiltonian where s is a linear function of time, i.e. s(t) is linear with slope between 0 and some max and 0 <= s <= 1. In my code, my sesolve command looks like 'results = qt.sesolve(listH, init_state, discretized_times_list)' where 'listH = [[Hx, A(s(t))], [Hz, B(s(t))]]' and A(s(t)) and B(s(t)) and created by using QuTiP's interpolate.Cubic_Spline function that dictates what the A and B parameters should be at each point in time. . When I make successive calls, it is to do several different things. For example, I may change coupling (h and J) values to create a new spin-glass, adjust number of qubits (larger or smaller H), or anneal for a longer or shorter time. I am not sure how to directly relate this to what has been posted so far, but perhaps I am not fully understanding the point made in https://github.com/qutip/qutip/issues/966#issuecomment-474569011.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-511266095:1087,coupling,coupling,1087,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-511266095,1,['coupling'],['coupling']
Modifiability,"Looks good to me as well, looks like a great enhancement!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/464#issuecomment-210293697:45,enhance,enhancement,45,https://qutip.org,https://github.com/qutip/qutip/pull/464#issuecomment-210293697,1,['enhance'],['enhancement']
Modifiability,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:205,config,config-setting,205,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726,3,['config'],['config-setting']
Modifiability,"Looks ok to me, but also prefaced with ""not an expert"" :) Also the ICM stuff looks very nice. . Robert and Anubhav did this QIP module. There were various plans to extend it, vaguely summarized here https://github.com/qutip/qutip/issues/441",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/614#issuecomment-270594647:164,extend,extend,164,https://qutip.org,https://github.com/qutip/qutip/issues/614#issuecomment-270594647,1,['extend'],['extend']
Modifiability,"Made another quick change. We know from Prop. 3.44 of (Watrous, 2018) that the diamond norm of CPTP channel is 1. So I added a quick `if` statement that checks this. Also refactored `dnorm` so there's only one return statement to make code climate happy. Looks like it's unhappy with something else and maybe made the logic harder to follow. Please advise if you have a preference. Again, can't really run tests locally, so approving the CI pipeline would be fantastic.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691:171,refactor,refactored,171,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691,1,['refactor'],['refactored']
Modifiability,"Many thanks! I solved it!; Now I have this WARNING:matplotlib.animation:MovieWriter avconv; unavailable. Trying to use pillow instead.; *Many thanks*. *P**arfait Atchadé*. *Tel Spain: 0034661205543*; *Tel Deutsch: 00491706659017*. On Wed, 9 Dec 2020 at 15:45, Jake Lishman <notifications@github.com> wrote:. > You'll find it easier installing from conda-forge, since we distribute; > binary releases there: see the installation guide; > <http://qutip.org/docs/latest/installation.html> here.; >; > If you want to install from source using pip, you need to configure your; > C++ development environment correctly - you'll probably need to enable the; > XCode command-line tools (see e.g. this; > <https://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/>).; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1404#issuecomment-742038577>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AGKQN3YYS6ZYMTV4HEHFTELST7OW3ANCNFSM4UT7TWQQ>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404#issuecomment-742050650:556,config,configure,556,https://qutip.org,https://github.com/qutip/qutip/issues/1404#issuecomment-742050650,1,['config'],['configure']
Modifiability,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:528,variab,variable,528,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561,1,['variab'],['variable']
Modifiability,"NUM_THREADS actually does not do anything as far as I can tell. We store the number of CPUs to use in qutip.settings.num_cpus. We can of course replace this with and environ variable, but is it needed?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41984812:174,variab,variable,174,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41984812,1,['variab'],['variable']
Modifiability,"Nah, don't disparage yourself - your code is good and you've done well to copy the style of the rest of the files. Typically consistency is better than having ""the one true style""; code's read more than it's written, and having a module which is clearly written by four different people makes the logic very very difficult to follow, which in turns makes it much harder to spot bugs. If it were up to me (which is isn't, really), I would say that your changes are good as they are. I didn't mean for the comments to be changes you _had_ to make. You can't reduce the number of merge conflicts that are going to happen with #1181 anyway, because that PR is a massive refactor of large swathes of the testing suite. You've done a good job to keep your work consistent with the rest of the file, so it will be very easy to merge in your logical changes. Merge conflicts are pretty much just par for the course; just the fact that we're discussing this here shows that logically, there _is_ a conflict between two pieces of work being done at the same time. I'd suggest merging this as-is. We'll handle the problems caused by the refactor elsewhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607971891:666,refactor,refactor,666,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607971891,2,['refactor'],['refactor']
Modifiability,"No problem, but to create an example, I need extra time to unwrap the self-defined gate sequence and refactor my test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1038#issuecomment-608335014:101,refactor,refactor,101,https://qutip.org,https://github.com/qutip/qutip/issues/1038#issuecomment-608335014,1,['refactor'],['refactor']
Modifiability,"No, `--config-setting=--global-option=--with-openmp` is still not working with git head. This is with ; * python 3.10.6-1; * python3-build 0.7.0-3; * python3-setuptools 59.6.0-1.2; * python3-wheel 0.37.1-2; * gcc 12.1.0-7",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1978#issuecomment-1220036080:7,config,config-setting,7,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1220036080,1,['config'],['config-setting']
Modifiability,"No, it's mostly here on qutip and direct email. There is only a few of us. We have a qutip-dev google group on invitation managed by @nathanshammah. agarwal1998 is not a maintainer but cgranade was. Last year, we took time to review old issues and let some less pressing with ""help wanted"". We would be happy if you can propose a solution that would close the issue and help with Qutip in general. The only use I personally see from this would be case like:; ```; out = qzero(dims); for i in range(N):; out += f(i, dims); ```; Cases were the qobj is more of a dummy variable than a physical operator. `coherent` and `create` have a physical meaning and I would not know what `coherent([2,10])` is supposed to be, but I understand what `tensor(coherent(2), coherent(10))` is. For `projector`, it could be added, it's meaning is clear. To make it consistent, removing the list support from `qeye`, etc. and fixing the few case that it is used, might be a better option. The dimension can easily be corrected after the creation of the object.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/363#issuecomment-575811864:566,variab,variable,566,https://qutip.org,https://github.com/qutip/qutip/issues/363#issuecomment-575811864,1,['variab'],['variable']
Modifiability,"No, this is not included in my project. The commit above seems to be lost so I can't see the original proposal. It is easy to add a new option to let some gates remain as they are (and I think this is what was proposed). To resolve other multiqubit gates into TOFFOLI basis needs, however, much more work :). If resolving gate becomes a high demand, it might be a good idea to refactor the current `resolve_gate` method as it is quite long and hard to maintain. An optimized gate resolving method needs more complex logic such as merging single-qubit gate.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/614#issuecomment-532940297:377,refactor,refactor,377,https://qutip.org,https://github.com/qutip/qutip/issues/614#issuecomment-532940297,1,['refactor'],['refactor']
Modifiability,"Not sure if I can answer your specific question but I have used QUTIP GRAPE before. I would first suggest opening a pull request or linking to your fork, so it's easier to compare your modifications to the original code.; I have briefly looked at your code and I would suggest dropping numba as qutip doesn't currently have numba as a dependency. I am confused about why you choose the cnot notebook as your example? There is an example of quantum optimal control using open quantum systems, control-pulseoptim-Lindbladian.ipynb .; Nonetheless, I believe grape.py is definitely not the place to place your additional support for open quantum systems. Grape is an optimization method, you should be looking extending support for open quantum systems in the pulseoptim class.; If you are interested you can also take a look at the quantum optimal control tool I built, QUTIP's quantum optimal control didn't satisfy my needs. ; https://github.com/lifeishard/PADQOC",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845:706,extend,extending,706,https://qutip.org,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845,1,['extend'],['extending']
Modifiability,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:38,config,config-setting,38,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152,2,['config'],['config-setting']
Modifiability,"Not to discourage you from contributing, but there's already been some movement on #1208 in #1209. About tests: `qutip` uses `pytest` now, so the preferred method is actually just a bare `assert`, because `pytest` does introspection on the variables on an assertion failure. But yes, any changes to that should be in a new PR, because it's a different logical unit of work. There's some movement on that too (e.g. #1181). About pep8 changes: I'm not a maintainer, but it might be a good idea to be conservative about changing actual public APIs in the name of pep8. Changing public APIs that work fine means the users, who are the reason we're writing the code in the first place, have to adjust, and the pep8 spec explicitly warns against breaking backwards compatibility to match the pep. `N` is fairly consistent within `qutip` for the number of qubits, and the `U` in `U_list` refers to unitary matrices, which are conventionally a capital `U` in mathematical writing. You could argue that `U_list` should perhaps be called `unitaries`, but again, there's a degree of backwards-compatibility that should be maintained.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603560557:240,variab,variables,240,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603560557,1,['variab'],['variables']
Modifiability,"Note that the same holds for Cython:. ``` zsh; % pip install qutip; Collecting qutip; Using cached qutip-3.1.0.tar.gz; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:319,config,configuration,319,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,6,['config'],"['config', 'configuration']"
Modifiability,"Note: in theory you can install QuTiP from the test PyPI server right now by doing; ```; pip install -i https://test.pypi.org/simple qutip-jakelishman; ```; (that's just the name - you still do `import qutip`) but since it's on the ""wrong"" server, you first have to manually install `numpy` and `scipy`. When it's released properly on PyPI it'll handle the dependencies correctly - this is only an artifact of being on the testing server. Running that command will install a binary version with no compilation, and should work on any (reasonable) Linux machine, Mac (possibly not M1 chips) and Windows. It's possible you may get an error about `ndarray size changed ... this may indicate binary incompatibility` - if so, either force `numpy` up to the new 1.20 or down to 1.19 (whichever one you don't have). This was a breaking change in numpy 1.20. Per my reading of the release notes, it won't be an issue provided in the future we always build against `numpy>=1.20` (even when using lower `numpy` at runtime) because the new version updates a certain C-API macro to take into account the possibility of runtime variability. I have pushed an additional change to the build requirements to ensure this always happens. This has another knock-on effect: numpy 1.20 only supports Python 3.7+ (released June 2017). Currently, officially QuTiP supports Python 3.6, but I think it's reasonable to follow numpy's footsteps and **drop support for python 3.6 from qutip 5.0**. It's offset by gaining support for 3.9. (Apologies for all the force-pushing - whenever I want to re-run a test release on my own branch I have to temporarily add an extra commit to swap to the testing server, then force-push a rewind of this PR's branch.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429#issuecomment-770459519:1115,variab,variability,1115,https://qutip.org,https://github.com/qutip/qutip/pull/1429#issuecomment-770459519,1,['variab'],['variability']
Modifiability,"OK, I see. If you are refactoring the parallelization of the mcsolve (which is currently tightly integrated in the mc code and quite messy) I would strongly recommend and lobby for using the new parallel_map API, and do away with all multiprocessing code in the mcsolve module and not using the callback function. I think this could make the mcsolve module vastly more readable and easier to maintain.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65020826:22,refactor,refactoring,22,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65020826,1,['refactor'],['refactoring']
Modifiability,"OK, good. I see no harm in keeping bicg and lgmres though, if only for backwards compatibility, also in case one encounters a bug in one of them the other could be tried (this just happend to me, bicg failed with an undefined variable error deep in the scipy code, but bicgstab worked). The defaults should be chosen carefully though, of course.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/214#issuecomment-52879383:226,variab,variable,226,https://qutip.org,https://github.com/qutip/qutip/pull/214#issuecomment-52879383,1,['variab'],['variable']
Modifiability,"OK, this is a bit broken. The debug flag throughout qutip doesn't really support setting at run time, it's only consistent when set in the config file. But let's fix it some other day then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/261#issuecomment-64150936:139,config,config,139,https://qutip.org,https://github.com/qutip/qutip/pull/261#issuecomment-64150936,1,['config'],['config']
Modifiability,"Oh, I completely agree with the argument nested loops/if/else. I was more talking about the logistic depth requirement (edit: wrong again, it is called Cognitive Complexity) of code climate. I just realized that is not the climate issue here. But, anyway, indeed `circuit.py` is quite messy. And the Gate class is more or less just a place holder. A refactoring to define each gate as a subclass should make things much easier. Also for this latex method. I like it very much what is going on in `dev.major`!. Tbh the millions of `_gate_resolved` functions are actually already after a short refactoring last year by a brave volunteer. It used to be 400-line functions. That was horrible. Just like the `adjacent_gates` method in `spinchain.py` (another F). I haven't dared to touch it... > For say qobj.py, the master version has maintainability F, while `dev.major` has maintainability A with the only issues being TODOs and like 5 pep8s. That's amazing! When I joined QuTiP, the overall maintainability was D, as I remember. Now it is B. I'm keen to see it becomes A after `dev.major` got merged :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-782599642:350,refactor,refactoring,350,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-782599642,5,"['maintainab', 'refactor']","['maintainability', 'refactoring']"
Modifiability,"Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1513#issuecomment-829621066:141,rewrite,rewrite,141,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829621066,1,['rewrite'],['rewrite']
Modifiability,"Oh, also, about callback functions and `yield`: if we did this, the patterns for making `mesolve` re-entrant and forwards-compatible without hamstringing our ability to extend the APIs in the future would probably not be very ergonomic. Both callbacks and `yield` allow the caller to feed information back into `mesolve`, but in this architecture, we'd have to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:169,extend,extend,169,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,1,['extend'],['extend']
Modifiability,"Ok, I've reverted to using the PR number for the news fragment file names, and updated the contributing/PR instructions. I also looked into why the `towncrier-check` test is failing. It looks like towncrier is not finding the `pyproject.toml` config file because it is not running in the root directory. I added a `working-directory: /` specification to the action step to address this, hopefully this should fix it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537:243,config,config,243,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537,1,['config'],['config']
Modifiability,"Ok, it looks like the tests are finally going to pass. As the number of commits suggests, this was a pain. Not because the code was wrong, but because:. 1) The default config used by Travis has GCC 4.6 which contains an error that happens to get raised in our case. Thus, had to move to the Trusty build stack. 2) Although it took forever to hunt down, it appears that when .pyx files are included as package data, Py27 may try to rebuild them upon calling **init**. This would throw a missing header error. Since these files are not needed after building, removing them clears up this issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-254497807:168,config,config,168,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-254497807,1,['config'],['config']
Modifiability,"Ok, it seems that for some reason the 'mkl_info' key from the NumPy config info is no longer available in some miniconda installs. This took forever to find as I could not reproduce the error at home when using a fresh miniconda install. Now I look in the libs as well for BLAS info.; - Also removed matplotlib from the requirements as it is not a requirement. At least not at present.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/547#issuecomment-252450097:68,config,config,68,https://qutip.org,https://github.com/qutip/qutip/pull/547#issuecomment-252450097,1,['config'],['config']
Modifiability,"Ok, so I tweaked the template and configuration for towncrier so that it doesn't render an issue/PR number next to each changelog entry. This frees you from requiring an issue / PR number when writing a news fragment. ; @hodgestar yes I think with this configuration you can just use any unique string for the filename.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155:34,config,configuration,34,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155,2,['config'],['configuration']
Modifiability,"One can read a little bit of somewhat useful information in PEP517 -- https://peps.python.org/pep-0517/#config-settings. I tried `--build-option` instead of `--global-option`, but that didn't work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219672267:104,config,config-settings,104,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219672267,1,['config'],['config-settings']
Modifiability,PR #256 restores the old progress bar as TextProgressBar and renames the new progress bar to EnhancedTextProgressBar. Considering the circumstances I think this is the best solution at this point.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63271426:93,Enhance,EnhancedTextProgressBar,93,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63271426,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,PR #991 (in review) rewrite a good part of mcsolve and have this feature.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1006#issuecomment-497391220:20,rewrite,rewrite,20,https://qutip.org,https://github.com/qutip/qutip/issues/1006#issuecomment-497391220,1,['rewrite'],['rewrite']
Modifiability,"Perhaps someone else can give a more concrete answer, but I guess the driving frequency is too high for the number of time-steps? Try tweaking the ODE solver with options like the following:. `; options = Options(nsteps=15000, atol=1e-13, rtol=1e-13) ; `. and passing it to mesolve. `result1 = mesolve(Ha, psi0, times, [np.sqrt(T1)*sig01, np.sqrt(T2)*sig02, np.sqrt(gamma*(nth + 1))*a, np.sqrt(gamma*nth)*a.dag()], [a.dag()*a, sig00, sig11, sig22], progress_bar=True, options=options); `. More practically speaking, for the problem you are solving I guess explicitly including the time dependence is unneccessary, since you have already made a RWA on the drive and the coupling? . Moving to an interaction picture in w1, w2 and wph, and removing the explicit time-dependence might simplify the problem and might give you equivalent results, and in the process make your code much simpler and more efficient?. In other words just set w1=w2=wph=0, and put the drive as a time-independent term in the hamiltonian . `; H01 = g*(sig12*a.dag() + sig21*a) + pump1*(sig01 + sig01.dag()); `",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1038#issuecomment-508634514:669,coupling,coupling,669,https://qutip.org,https://github.com/qutip/qutip/issues/1038#issuecomment-508634514,1,['coupling'],['coupling']
Modifiability,"Picking a new random number at each time step would be an expensive way to do the computation since each call to the random number generator is costly. One could pre-generate a large array of random numbers before hand, but there is no way to know if you generated enough since we are using an adaptive step size ODE method. You are correct about the way mcsolve does its calculations. The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms. These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it. Regards,. Paul; On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:. > Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?; > ; > I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE me",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42092984:294,adapt,adaptive,294,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42092984,1,['adapt'],['adaptive']
Modifiability,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:748,coupling,couplings,748,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583,1,['coupling'],['couplings']
Modifiability,"Re tidyup dispatcher: I think this should still exist:. * It's useful for implementing efficient explicity tidyup calls on the different data layers.; * It's useful for specializations on data layer implementations if they want to do, e.g., `__matmul__(self, other): other = other.tidyup() ...` at the start of an operation (not 100% sure this is a good example -- probably other.tidyup() and conversion to sparse needs to happen in one step to happen efficiently, but I feel like there are cases like this out there).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980:142,layers,layers,142,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980,1,['layers'],['layers']
Modifiability,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:147,coupling,coupling,147,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790,2,['coupling'],['coupling']
Modifiability,"Repeat the test 20 times and accept if at least 19 pass?. I remember adapting the tests when numpy's rng changed. 1~2 where failing. I believe that the tests pass over 99% with a random seed, but with the number of tests, it's not enough. I did not realize the test tolerance was smaller than the test one. But the solver tolerance is for the state itself, not expectation values and other scalars obtained from them. The test is not to check numerical error. When there is an mistake in the code, the error is orders of magnitude greater. Not sure if using the sovler's tol is right, but probably better than using a number that just seems to work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-625307705:69,adapt,adapting,69,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-625307705,1,['adapt'],['adapting']
Modifiability,"Setting up the testing environment with `conda` avoids the segfault, but hangs indefinitely while running the tests. I'm using the following `run_tests_conda.sh`:; ~~~; #!/usr/bin/env bash; conda create -y -p venv python=3.8 'cython>=0.21' 'numpy>=1.12' 'scipy>=1.0' matplotlib ipython pytest; ./venv/bin/python setup.py install; ./venv/bin/pip freeze > test.log; ./venv/bin/python -c 'import scipy; print(""Scipy config:""); scipy.__config__.show()' >> test.log; ./venv/bin/python -c 'import numpy; print(""Numpy config:""); numpy.__config__.show()' >> test.log; (cd venv && ./bin/python -c 'from qutip.testing import run; run()' 2>&1 | tee -a ../test.log); ~~~. This produces the attached [`test.log`](https://github.com/qutip/qutip/files/4307943/test.log): testing hangs at `test_mcsolve.py::test_MCTDFunc`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939:413,config,config,413,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939,2,['config'],['config']
Modifiability,"Since I have been using GCC 4.8 for a while now, i did not think about compilers back to 4.4. I will take a look at this code on Monday, but my initial thinking is just to drop the optimization and leave it at that. This would save us from having to run an extra test suite on Travis. The only compiler flags that matter at the end are O3 and the fast math. Everything else is just a few percent improvement at best. . Paul. > On Feb 21, 2015, at 06:42, Dominic Meiser notifications@github.com wrote:; > ; > gcc 4.4 does not support the -flto option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6.; > ; > In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to setup.py to enable or disable link time optimization.; > ; > I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.; > ; > You can view, comment on, or merge this pull request online at:; > ; > https://github.com/qutip/qutip/pull/318; > ; > Commit Summary; > ; > Remove -flto compilation flags.; > Add gcc4.4 and clang builds to travis build matrix.; > File Changes; > ; > M .travis.yml (8); > M qutip/control/setup.py (4); > M qutip/cy/setup.py (2); > Patch Links:; > ; > https://github.com/qutip/qutip/pull/318.patch; > https://github.com/qutip/qutip/pull/318.diff; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318#issuecomment-75334652:784,variab,variable,784,https://qutip.org,https://github.com/qutip/qutip/pull/318#issuecomment-75334652,1,['variab'],['variable']
Modifiability,"So I did an update of my conda environment to the latest version and now also the installation via pip has a problem, producing an `ImportError` (but not a segfault!) in the same location:. goerz@mlhpc2 develop:~/Documents/Programming/QNET> ipython; Python 3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 5.1.0 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import qutip; ---------------------------------------------------------------------------; ImportError Traceback (most recent call last); <ipython-input-1-ad45215f3e51> in <module>(); ----> 1 import qutip. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 169; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/qobj.py in <module>(); 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/fastsparse.py in <module>(); 404 #Need to do some trailing imports here; 405 #-------------------------------------; --> 406 from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult). ImportError: /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/cy/spmath.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E. The verbose log file from the installation (`pip install -v --no-cache-dir qutip`) is here: [pip_log.txt](https://github.com/qutip/qutip/files/914669/pip_log.txt)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-293395036:406,enhance,enhanced,406,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-293395036,1,['enhance'],['enhanced']
Modifiability,"So, while I agree that having a flexible storage format is a good way to go, the truth of the matter is that no one has time to implement such a big change. SciPy supports both 32 and 64-bit ints, and checks to see which ones are needed at runtime. e.g. a tensor product of two sparse matrices with int32, may need int64 in the result since their shape is larger. We could also do a similar thing, but it is a lot of work. The reason why we no longer use standard SciPy sparse objects is: 1) They tend to have a sizeable overhead when being created and/or manipulated do to redundant safety checks. 2) Many of the sparse operations are not well optimized. Because SciPy supports many different sparse formats, they had to generalize many of their core operations, making them slower. For example, the sparse kronecker product first converts to COO format, does the tensoring, and then converts back to the original format. Our method is much faster. Supporting more than just the current CSR format is also problematic. As already mentioned, there would be type checks, conditionals, and format conversions everywhere. e.g. what happens when DIA * CSR. As usual, available time is the limiting factor here. Support for both int32 and int64 is not that hard, but would take some time. Just int64 would make smaller matrices larger, but would allow for much greater system dimensions. In this later case, it would be a simple switch `int` -> `int64` and `size_t` -> `uint64` in the Cython code, and the fastsparse module (plus probably other places.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384005667:32,flexible,flexible,32,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384005667,1,['flexible'],['flexible']
Modifiability,Some examples I found interesting:. PyPI - Downloads (monthly) ![PyPI - Downloads](https://img.shields.io/pypi/dm/qutip.svg?style=plastic). GitHub code size ![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/qutip/qutip.svg?style=plastic). PyPI - Python Version ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/qutip.svg?style=plastic). Code Climate maintainability ![Code Climate maintainability](https://img.shields.io/codeclimate/maintainability/qutip/qutip.svg?style=plastic). Conda platform support ![Conda](https://img.shields.io/conda/pn/conda-forge/qutip.svg?style=plastic). GitHub contributors ![GitHub contributors](https://img.shields.io/github/contributors-anon/qutip/qutip.svg?style=plastic). PyPI status ![PyPI - Status](https://img.shields.io/pypi/status/qutip.svg?style=plastic). Closed Pull Requests ![GitHub closed pull requests](https://img.shields.io/github/issues-pr-closed/qutip/qutip.svg?style=plastic). Already on Readme.md:. Travis status ![Travis (.org)](https://img.shields.io/travis/qutip/qutip.svg). Coveralls github ![Coveralls github](https://img.shields.io/coveralls/github/qutip/qutip.svg?style=plastic),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/983#issuecomment-484765518:393,maintainab,maintainability,393,https://qutip.org,https://github.com/qutip/qutip/issues/983#issuecomment-484765518,3,['maintainab'],['maintainability']
Modifiability,"Soon (TM). The refactor is all done (thanks to @tehruhn ). We are just mostly working up the example notebooks. . There is some uncertainty about how to include this in qutip, given recent discussions about qutip ""prime"" and external modules. But we will get it uploaded, and see what happens.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962#issuecomment-619398337:15,refactor,refactor,15,https://qutip.org,https://github.com/qutip/qutip/pull/962#issuecomment-619398337,1,['refactor'],['refactor']
Modifiability,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:258,adapt,adaptive,258,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054,2,['adapt'],"['adaptive', 'adaptively']"
Modifiability,"Sorry for the bad description. What I need to do (and which is already possible with `mesolve`) is to start with a hamiltonian H1, evolve for time T1, stop, change the hamiltonian to H2 and evolve for additional time T2. With `mesolve` I just use the final result of `mesolve(H1, initial_state,...)` as the initial result in `mesolve(H2,...)`. In `mcsolve` I can not do this, because I can not start `mcsolve` with a set of initial states over which to run single trajectories. In other words, I want to be able to run `mcsolve` up to time T1 and then be able to use the result in another call to `mcsolve` in order to run the trajectories for additional time T2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/120#issuecomment-41978600:131,evolve,evolve,131,https://qutip.org,https://github.com/qutip/qutip/issues/120#issuecomment-41978600,2,['evolve'],['evolve']
Modifiability,"Sorry for the delay in getting involved in this.; @bencbartlett Thank you for what looks like an excellent contribution.; @sahmed95 Thanks a lot for reviewing this. Personally I am ambivalent about 1 or 2 lines between functions. I just pick people up on it, as I was picked up on it by Rob with my first contribution. I thought pep8 says 1 between function and 2 between classes, but I happy to go with either. Regarding classes...; Yes, class objects could broadly fall into two categories: ; 1. data containers; 2. processing objects. QuTiP has historically used only the first kind.; Personally I am a big believer in the benefits of object-oriented (OO) programming. As can be seen in the control modules I contributed. I won't write an essay on it here, but being able to pass around processors of different kinds, with similar interfaces, has a many benefits. I would like to see all the solvers in QuTiP move to a class structure, as this would allow for some more code re-use, and this helps with maintainability.; Some of the more recent contributions have started using processor type classes, these I think @sahmed95 has already highlighted. If @sahmed95 has recommended an significant advantage of using some class object, then I support this. If it's not a lot of work, then I suggest implement it now. Otherwise I suggest merge now and consider a PR to implement in the near future, as @bencbartlett has waited patiently for us to look at this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-385964143:1006,maintainab,maintainability,1006,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-385964143,1,['maintainab'],['maintainability']
Modifiability,"Sorry for the delay on the docstrings and so on, I think all suggestions should be incorporated now. However, thanks to Paul's suggestion of adapting the tutorial 1e. I realized that I made a ""mistake from the very beggining"", namely the function used to fit the correlation function is only good if the imaginary part of the spectral density is 0 at t=0, because I'm using. $C(t)=\sum_{k}a_{k}e^{-b_{k} t}e^{i c_{k} t}$. so . $C_{R}(t)=\sum_{k}a_{k}e^{-b_{k} t}cos(c_{k} t)$. $C_{I}(t)=\sum_{k}a_{k}e^{-b_{k} t}sin(c_{k} t)$. No matter how many terms I take $C_{I}(0)=0$. I should have realized before but this can be bypassed by excluding $t=0$ from the fit, and starting at a small t, you get a decent fit, as long as you don't look at C(0), and I never check for these situations before. The results of doing this are pretty decent, but updating tutorial 1e I realized it required higher calculation times for the HEOMSolver when compared to using another ansatz for the correlation function, since solving is the expensive bit then I changed the code use another function for fitting. $C(t)=\sum_{k}(a_{k}+i d_{k})e^{-b_{k} t}e^{i c_{k} t}$. The downside is that since this function has 4 parameters, it required changing other functions as well, luckily only functions starting with _, hopefully this won't delay the PR too much. I updated the tutorials with this as well, and added a bit so that passing the parameters for the fitting is easier (after this comment), if the change is not desirable we can just go back to the commit before this comment",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764:141,adapt,adapting,141,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764,1,['adapt'],['adapting']
Modifiability,"Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (**1-P(no jump)**), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable? . I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the **array[1, 10, 11]**? ... . At this stage, I have to resort to the original author of the code, and would like to hear your opinions and detailed guidelines. I will write some test codes in Matlab first in the coming weeks, if I have time. Thanks for your response. Cheers,; Qi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42091087:456,evolve,evolve,456,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42091087,2,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"Sounds good, I'll get on that, then, and make that a PR to qutip-notebooks. Roughly, this produces a pair of partial isometries representing a quantum channel that are quite useful for some theory work. For instance, [Watrous showed that](http://theoryofcomputing.org/articles/v005a011/) the diamond norm can be expressed in terms of a semidefinite program parameterized by the Stinespring dilation. It's that application in particular that motivated me to get this working, as computing diamond norms would be very useful to a wide range of different quantum information projects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/332#issuecomment-93119397:357,parameteriz,parameterized,357,https://qutip.org,https://github.com/qutip/qutip/pull/332#issuecomment-93119397,1,['parameteriz'],['parameterized']
Modifiability,"Sounds good. I'll pull out the non-configobj version, then, and make sure everything's handled in the case that it's not there. I'll also rename the module and set `__all__`, that's easy enough. As for `configspec.ini`, I made that change but forgot to push it, sorry. Easily taken care of.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-61394612:35,config,configobj,35,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-61394612,2,['config'],"['configobj', 'configspec']"
Modifiability,Sounds like a good plan. I was hoping to standardise the way we read in file data. I used the ConfigParser in control/load_params,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/652#issuecomment-283903782:94,Config,ConfigParser,94,https://qutip.org,https://github.com/qutip/qutip/pull/652#issuecomment-283903782,1,['Config'],['ConfigParser']
Modifiability,"Sure! Here are the plots before the changes using the code posted in issue #1974. The bug we wanted to fix is that when choosing style 'm' and passing an array of colors as we did in V4, the scrip only plots one color, (additionally, i also plot one case with style 'l'):. ![M_self_test_old](https://github.com/qutip/qutip/assets/78165605/c0ed44c7-74d1-47f3-8787-254e4d6806d5) ![L_self_old](https://github.com/qutip/qutip/assets/78165605/66cfdb8c-18d2-45d9-a64e-97a28f72e10f). And these are the same plots after the changes using the variables `inner_point_color` (left graph) and `point_color` (right graph). As we can see for both variables we get the same result which is what we expected:. <img src=https://github.com/qutip/qutip/assets/78165605/1c6f0d5b-080f-49e2-98f7-8ead19ef739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/as",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:534,variab,variables,534,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617,2,['variab'],['variables']
Modifiability,"Thank for spotting another bug @Canoming, I'll check it and merge if everything is good. @quantshah I'd say we let the test wait for a while. @jakelishman 's refactoring is still not merged and adding tests now will lead to conflicts. He will need to rewrite the test again. Maybe we can build a more thorough test for the circuit module during the GSoC project @sarsid ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629662675:158,refactor,refactoring,158,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629662675,2,"['refactor', 'rewrite']","['refactoring', 'rewrite']"
Modifiability,"Thank you @AGaliciaMartinez as of late I was getting the same issue with the tests. @hodgestar ; dev.major lacks this lines in the toml. ``` ; [tool.pytest.ini_options]. addopts = ""-Werror --strict-config --strict-markers"". testpaths = [; ""tests"",; ]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212:198,config,config,198,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212,1,['config'],['config']
Modifiability,"Thank you @kevinsung. Closing this as the bug has been fixed by @jevonlongdell in #879. If you wish, please open a PR for the stability enhancement of `simuldiag`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/756#issuecomment-497302015:136,enhance,enhancement,136,https://qutip.org,https://github.com/qutip/qutip/issues/756#issuecomment-497302015,1,['enhance'],['enhancement']
Modifiability,"Thank you Marek,; It seems you forgot to add a seed variable in the definition of the rand_herm function (line 112~114). Because of this, many tests fails. ; Could you add it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-426421470:52,variab,variable,52,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-426421470,1,['variab'],['variable']
Modifiability,"Thank you for all your work @gsuarezr . Just for a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:737,coupling,coupling,737,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525,1,['coupling'],['coupling']
Modifiability,"Thank you for doing this quickly, I guess you did until quite late. Yes, tests in `test_integrator` are parameterized over all integrators registered in `sesolve_integrators`, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011:104,parameteriz,parameterized,104,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011,1,['parameteriz'],['parameterized']
Modifiability,"Thank you for the suggestions. (2) It should be easy. We could reuse the `parallel_map` as you said. I would make a good first contribution. . (1) We need to be careful about this. ; I can see case where the user think the correlation is gone by `tlist[-1]` but it is not, so it should be clear which output are `0` and which are not computed.; Also if we do that, maybe finer control could be given. We could have a variable `max_t_plus_tau` with default `np.inf`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043:417,variab,variable,417,https://qutip.org,https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043,1,['variab'],['variable']
Modifiability,"Thank you for your answer @Ericgig !. So, even though we are not using any quotes in our code, this internally maps to the string approach ?; I am trying to understand how to do what I want using callbacks instead, I could use a bit of help.; This is what the original code I shared here reads:. ```; # list of variational parameters ""a[]""; a=[]; for i in range(numite):; a.append(0.01*i). # define energy function by using variational parameters; def energy(a):; psi = initial_H.eigenstates(sparse=False)[1][0]; t = np.linspace(0, 1, timesteps+1); for i in range(numite):; 	H=[[initial_H,1-a[i]*t],[final_H,a[i]*t]]; 	result= qt.mesolve(H, psi, t, [], []); 	psi=result.states[timesteps]. E = qt.expect(final_H,psi); return E; ```. I tried to understand the documentation here: http://qutip.org/docs/latest/modules/qutip/mesolve.html; What I think I need to do is the following:. - I need to just pass callbacks instead of formulas / strings for the coefficients when defining the operators.; - these callbacks must have a signature with the format `(t, *args)` and should return an np.array; - `t` and `args` values are passed as arguments to mesolve. . I am a bit unclear whether or not ""args"" is a list or a dictionary and how I can access it inside my callbacks. I made an attempt but it returns errors: maybe it would be easy for you to fix some lines of this example and tell me if I am on the right track? Or do you have a link to an example, maybe ?; I am just targeting the innermost portion of the code, here:. ```; mesolve_args = ... # a dictionary ? a list? Something that lets me access the variable ""a""; def h_t1(t, *args):; return np.array(1-a[i]*t) # how do I retrieve a[i] by accessing args?; def h_t2(t, *args):; return np.array(a[i]*t) # same. H=[ [initial_H, h_t1], [final_H, h_t2] ]; result= qt.mesolve(H, psi, t, c_ops=[], e_ops=[], args=mesolve_args) # is this correct ?; psi=result.states[timesteps]; ```. Thank you for your help !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-474154477:1604,variab,variable,1604,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-474154477,1,['variab'],['variable']
Modifiability,Thanks @Ericgig for feedback.; I see (having read more carefully) in; https://github.com/qutip/qutip-notebooks/blob/master/examples/smesolve-inefficient-detection.ipynb; there is an example showing the equivalence of using `smesolve` and `general_stochastic` with a clear performance enhancement in the former. So I think I can easily switch my example to use `smesolve`. Thanks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581:284,enhance,enhancement,284,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581,1,['enhance'],['enhancement']
Modifiability,Thanks Chris. This is looking good. I'll try it out in more detail in the comings days. Some immediate comments:; - I don't think we should keep two code-paths for parsing the config file. So either we keep using the old manual parsing or we make configobj the official and only way to parse the config file. In that case I think it would be Ok to simply fail to parse the config file if configobj is not available. I don't think many users use the config file so would be to worried about breaking backwards compatibility with respect to this.; - I think I'd prefer to have the logging module called logging.py rather than _logging.py even though it is supposed to internal to qutip. ; - Please add a `__all__` list in logging.py; - Shouldn't configspec.ini be added to the setup.py file?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-61393881:176,config,config,176,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-61393881,7,['config'],"['config', 'configobj', 'configspec']"
Modifiability,"Thanks Jake. I've raised the Issue in regards to building deb packages from source (https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=999517), so pip can't be used in that context. The Debian build machinery invokes `python3 setup.py {config,build,install}` not `setup.py develop`, c.f. past build log with numpy 1.19 [here](https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-2&stamp=1630423818&raw=0).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138:235,config,config,235,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138,1,['config'],['config']
Modifiability,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:253,refactor,refactoring,253,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496,1,['refactor'],['refactoring']
Modifiability,"Thanks for reporting this bug. I'm working on refactoring the Qobj class in PR #95, and I have tried to fix this problem there. The PR is still work in progress though, and not quite ready for merging yet, but I think the problems you describe are fixed now. If you are interested you are very welcome to try it with the cleanup-qobj branch which that PR is based on. Code reviewing and general comments on the changes would also be very welcome of course :-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/96#issuecomment-39052411:46,refactor,refactoring,46,https://qutip.org,https://github.com/qutip/qutip/issues/96#issuecomment-39052411,1,['refactor'],['refactoring']
Modifiability,"Thanks for the clue, it was helpfull.; The source of problem is localization of `lscpu` util, which used by `_linux_hardware_info()` function.; The function expects `'Socket(s)'`, `'Core(s) per socket'`, etc in `lscpu` output, but in my system it actually `'Потоков на ядро'`, `'Сокетов'`, etc.; I think, maybe better less system dependent ways to calculate cpu count, for example, we could use `multiprocessing` module and it's `cpu_count` function. Or `len(os.sched_getaffinity(0))`for computers with dynamic cpu management (see [this](https://stackoverflow.com/questions/31346974/portable-way-of-detecting-number-of-usable-cpus-in-python) for details).; Or show exception/error, if we try to use lscpu and `LANG` is not english (or we couldn't found mentioned above `'Socket(s)'`).; Ideas?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1004#issuecomment-497325045:583,portab,portable-way-of-detecting-number-of-usable-cpus-in-python,583,https://qutip.org,https://github.com/qutip/qutip/issues/1004#issuecomment-497325045,1,['portab'],['portable-way-of-detecting-number-of-usable-cpus-in-python']
Modifiability,"Thanks for the feedback. I am very keen to spend some time making the control modules more QuTiP like in style. In particular trying to utilise QuTiP elements, e.g. maintaining Qobjs throughout the code. I am however focussed on trying to get some results out using the library, so it will probably be a month of so before I can start on this. ; Re the documentation, there is some theory in the first of our notebooks example-pulse_optim-Hadamard, however it could be a lot more detailed and better presented. I should be able to make a start on a general overview of the control modules though, i.e. one notebook that outlines the theory and then explains the different functions and classes and how / when to use them. Is that the kind of thing you mean?; I was wondering about the auto-generated API docs, how it deals with inherited and overidden methods etc. Do you use some specific tool to generate these? Can you point me to some docs about how it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/338#issuecomment-97736382:828,inherit,inherited,828,https://qutip.org,https://github.com/qutip/qutip/pull/338#issuecomment-97736382,1,['inherit'],['inherited']
Modifiability,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:888,inherit,inherited,888,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681,2,['inherit'],"['inheritance', 'inherited']"
Modifiability,"Thanks for the useful feedback, both here and in PR #1611 ! From the discussion in PR #1611 it seems that the second option with the modifications proposed by Jake in this issue seems to be the most sensible approach. Hence, if there are no objections, I will open a PR (which I will probably do tomorrow) where I implement the following changes (adapted from Simon's comment in PR #1611):. - `Qobj.__mul__(self, other) ` ; - dispatch to `data.matmul` if `other` is a `Qobj`; - dispatch to `data.mul` otherwise which will return `NotImplemented` if it does not know how to handle `other`. ; - `Qobj.__rmul__(self, other) `:; - Dispatch to `data.mul` (`other` will never be a Qobj): Notice that in this way both left and right multiplication will behave in the same way. This would also ""solve"" the inconsistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:347,adapt,adapted,347,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473,1,['adapt'],['adapted']
Modifiability,"Thanks for your replies.; I did not have any python on my computer. Firstly, I installed Anaconda, then build a qutip-env. I typed ""conda activate qutip-env"" and then used the following command to install the requirements: ""conda install numpy scipy cython matplotlib pytest pytest-cov jupyter notebook spyder"" .; Then, I added ""conda config --append channels conda-forge"", getting the following warning: ""conda-forge already in channels list, moving to the bottem"".; Then, I run ""conda install qutip"" with no errors.; qutip was installed in ""/root/anaconda3/env"" and i opened a terminal in ""/root"", typed ""python"" and then ""import qutip.testing as qt"" getting the above error.; I really appreciate any help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1391#issuecomment-735554120:335,config,config,335,https://qutip.org,https://github.com/qutip/qutip/issues/1391#issuecomment-735554120,1,['config'],['config']
Modifiability,"Thanks to some pointer from @nonhermitian I think I now understand this better; I will illustrate with some pseudo code. What we want to do is: M_out = (L_1 + L_2 + ... + L_i)*M; where L_i are sparse matrices and M is a dense matrix.; So one option (A) could be; ```; for L in L_list:; M = spmm(L, M); ```; which would seem more efficient than option B:; ```; for col in M:; for L in L_list:; col = spmv(L, col); ```; but as `spmm(L, M)` would effectively be:; ```; for col in M:; col = spmv(L, col); ```; Then options A & B would be the same efficiency wise.; As option B is much easier for us to implement within our existing codes, then this is what I will do. Just one note: M actually starts are sparse, but has to converted to a dense column stacked vector as it is used as the variable in the ODE solver",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/877#issuecomment-395350256:784,variab,variable,784,https://qutip.org,https://github.com/qutip/qutip/issues/877#issuecomment-395350256,1,['variab'],['variable']
Modifiability,"Thanks! I'll work out how to handle this numpy 1.20 C-API change properly before this is ready to merge, I think - turns out my reading of the numpy release notes was wrong, or (possibly) Cython is generating some compile-time-constant code it should be deciding at runtime (as of the latest numpy). Hopefully it's just a configuration change on our end that I can work out somewhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429#issuecomment-770779664:322,config,configuration,322,https://qutip.org,https://github.com/qutip/qutip/pull/1429#issuecomment-770779664,1,['config'],['configuration']
Modifiability,"Thanks, @jakelishman. Even you say that you didn't look into very details, your comments were very inspiring and helpful!. What code climate is complaining about is mostly left from the previous code structure. I do plan on further cleaning them. Another refactor probably. Actually, the `_EvoElement` here is a simplified ""copy"" of the `EvoElement` in `QobjEvo`, not directly referring to that. Switch to `dev.major` won't break it. I did this long ago because I was having problems initialize `QobjEvo` in my particular use case. But indeed exposing a private class is fragile and dangerous. Planning on remove it too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1444#issuecomment-815048230:255,refactor,refactor,255,https://qutip.org,https://github.com/qutip/qutip/pull/1444#issuecomment-815048230,1,['refactor'],['refactor']
Modifiability,"That is true. I'll try to look into why this is the case. However, it does have three expectation calculated. You can check this with output.expect ! . Edit: . So, I just realized that the noise-spectrum is associated with the coupling operator [sigmax()], I think the correct call to brmesolve must infact be (updated to current qutip standards) . `output = brmesolve(H, psi0, tlist, [[sigmax(), ohmic_spectrum]], e_ops)`. This is in line with the notation we use in example (https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/brmesolve-time-dependent-Liouvillian.ipynb). I will make a pull request updating both the example notebook (http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) to reflect this and make sure we depreciate the spectra_cb argument in bloch_redfield_tensor to eliminate the confusion. Thanks for bringing this to notice !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1223#issuecomment-605711703:227,coupling,coupling,227,https://qutip.org,https://github.com/qutip/qutip/issues/1223#issuecomment-605711703,1,['coupling'],['coupling']
Modifiability,"That is what I did in fact, but I had to add it myself. That is load them in from CPATH or C_INCLUDE_PATH. They were not included automatically. I am not suggesting that we do that in this PR, but maybe extending rather than overwriting the CFLAGS might be better. Unless there is good reason not to?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/570#issuecomment-265068820:203,extend,extending,203,https://qutip.org,https://github.com/qutip/qutip/pull/570#issuecomment-265068820,1,['extend'],['extending']
Modifiability,"That sounds good, I'll start refactoring this PR to address that structure, then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/255#issuecomment-64314727:29,refactor,refactoring,29,https://qutip.org,https://github.com/qutip/qutip/pull/255#issuecomment-64314727,1,['refactor'],['refactoring']
Modifiability,That's a bit unfortunate. Perhaps there is a way of configuring the textmate console to support the \r carriage return? Exactly how do you run a script from textmate?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63265163:52,config,configuring,52,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63265163,1,['config'],['configuring']
Modifiability,"The CI is still running but have you tried to align with other qutip API docs like this?; ```; .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like; ```; I am not sure if autosummary is fully configured in qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068:472,config,configured,472,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068,1,['config'],['configured']
Modifiability,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:226,adapt,adaptive,226,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508,1,['adapt'],['adaptive']
Modifiability,The Travis CI should be up and running now. Can you rebase your PR so we can rerun the tests with the latest travis ci configuration?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36082072:119,config,configuration,119,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36082072,1,['config'],['configuration']
Modifiability,"The `general_stochastic` function does process the `e_ops`. ; I see your point about it being it being a general solver of SDEs and so it makes sense that the variable is a vector. Certainly no value in changing the processing to work on Qobj.; I just think it would make usage easier if `state0` and `e_ops` (and I guess `m_ops`) could be provided as dm and opers rather than vectorised and superoperators. These could be recognised as such and converted before processing. We could then convert the `result.states` accordingly. . Anyway, I am only just beginning to understand this stuff, so I will leave it up to your judgement as to whether this is worth the effort. If the aim to try always to avoid `general_stochastic`, then I suppose it is not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547219289:159,variab,variable,159,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547219289,1,['variab'],['variable']
Modifiability,"The default Apple `clang` version doesn't recognise `-fopenmp` out-of-the-box, because Apple don't ship an OMP library with macOS. You'll have more luck (with most C/C++ projects!) if you install a fully-featured compiler and environment. On [homebrew](https://brew.sh) you can find both `clang`/`clang++` and `gcc`/`g++`, both of which can be installed with OMP support. Make sure your set `PATH`/`CC`/`CXX` environment variables are set up correctly after you've installed, so you're calling the compiler you've just installed, not just the Xcode versions. This isn't a bug in QuTiP, although we could remember this when somebody's working on modernising the distribution - in C/C++ land, tools like `automake` run through a big list of things to check during build configuration, and one of them is if OMP appears to exist. That way the error message is a little clearer (although in this case it's reasonable clear if you're used to C compilers).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1230#issuecomment-611425774:421,variab,variables,421,https://qutip.org,https://github.com/qutip/qutip/issues/1230#issuecomment-611425774,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"The dpsi option worked fine on my mac from jupyter. ; - please update the docstring to highlight this option (could also add the presence of the `name` option, besides directory and format); - It is a nice feature, it could be highlighted in the documentation, here https://github.com/qutip/qutip-doc/blob/master/guide/guide-bloch.rst; - add to 4.4.1 enhancements in the changelog, https://github.com/qutip/qutip-doc/blob/master/changelog.rst; Let's skip the codeclimate issues for the moment, but in the future it might be nice to refactor the Bloch class inner workings, as it took me a while to sort out issue #1027.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1104#issuecomment-541539574:351,enhance,enhancements,351,https://qutip.org,https://github.com/qutip/qutip/pull/1104#issuecomment-541539574,2,"['enhance', 'refactor']","['enhancements', 'refactor']"
Modifiability,The feature is very interesting and makes the propagator class very flexible. I like it! I left some small comments but otherwise looks good.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1256993343:68,flexible,flexible,68,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1256993343,1,['flexible'],['flexible']
Modifiability,"The main issue causing these errors though is that `cvxpy.Variable` and `cvxpy.Parameter` expect the first arg to be a tuple with dimensions. We are passing `num_rows, num_cols` is two args. Who knows how this has happened - cvxpy changed its interface?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/872#issuecomment-394201690:58,Variab,Variable,58,https://qutip.org,https://github.com/qutip/qutip/issues/872#issuecomment-394201690,1,['Variab'],['Variable']
Modifiability,"The old `cdef ndarray` syntax can _technically_ be a little faster in some Cython applications because it doesn't involve instantiating a new type; Cython just generates Numpy C-API code. However, this is legacy behaviour of Cython and using these variables generates very old Numpy C-API code in some instances (e.g. pre-Numpy 1.7 (2013)). The memory-view syntax does not require holding the GIL and is rather shorter and easier to read - the former makes threaded parallelisation more possible, particularly in `dev.major` where we are more aggressive about releasing the GIL during heavy computation. Closing for now because it's not really urgent to update old code, but we'll touch it up (speed permitting) as we modify this sort of file in the future. `dev.major` already removed well over half the uses of it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/866#issuecomment-809641984:248,variab,variables,248,https://qutip.org,https://github.com/qutip/qutip/issues/866#issuecomment-809641984,1,['variab'],['variables']
Modifiability,"The problem was that I was using a pytest plugin to output the docstrings, which are not available in conda. Now I just increased verbosity to 2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-560254158:42,plugin,plugin,42,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-560254158,1,['plugin'],['plugin']
Modifiability,"The problem with OPENMP is that the point where parallel processing begins to have an advantage is platform, and hardware dependent. As such, I have added a simple benchmark routine that calculates a good number of NNZ that a matrix should have for OPENMP to be utilized. This also required me to change the way the qutiprc file is done, i.e. it now uses the standard configparser module. This benchmark is called on first run, or anytime where the qutiprc 'openmp_thresh' flag is missing, or the qutiprc file itself does not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/652#issuecomment-283874454:368,config,configparser,368,https://qutip.org,https://github.com/qutip/qutip/pull/652#issuecomment-283874454,1,['config'],['configparser']
Modifiability,"The reason is the same as for https://github.com/qutip/qutip/issues/1265. The pulse starts with 0 for a long time and the adaptive solver skips the real part of the pulse. You need to set `max_step` in `qutip.Options`. You can see this by setting a very small but none-zero value:; ```python; def func(t, *args):; omega_R = 2e-3; if t <100:; return 0.00001; elif t>600:; return 0.00001; else:; return 2*np.pi*omega_R; ```; The result is correct. I'll close it for now but please feel free to ask further questions if there are any.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566:122,adapt,adaptive,122,https://qutip.org,https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566,1,['adapt'],['adaptive']
Modifiability,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:231,plugin,plugin,231,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503,1,['plugin'],['plugin']
Modifiability,"The suggestion that @Ericgig and I discussed is that qutip will set the the flags `-w -O3 -funroll-loops` via Cython's `extra_compile_args` *unless* the `CFLAGS` variable is set, in which case it will not set `extra_compile_args`, as Cython picks these `CFLAGS` up. That is if `CFLAGS` is set then qutip assumes the user knows what they are doing and won't interfere. We need to test that this will work with the conda-forge build etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/951#issuecomment-466654660:162,variab,variable,162,https://qutip.org,https://github.com/qutip/qutip/issues/951#issuecomment-466654660,1,['variab'],['variable']
Modifiability,"The tests ran fine, besides for the option with OpenMP, where it gave ; ```; /home/travis/miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+2fe7701-py3.7-linux-x86_64.egg/qutip/__init__.py:166: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Calibrating OPENMP threshold...; No output has been received in the last 10m0s, this potentially indicates a stalled build or something wrong with the build itself.; Check the details on how to adjust your build configuration on: https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received; The build has been terminated; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-566115975:557,config,configuration,557,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-566115975,1,['config'],['configuration']
Modifiability,"The variable e does not exist outside the except block even if the try failed...; So trying to give more information about the error resulted in more confusion, sorry. I would suggest to use functions instead of string for your coefficient, the speedpup is often less than the time it take to compile the string, (which is not included in the progressbar). . It is the first case where it would work once, but not the following times. I would be interested in the real error message and/or a code to reproduce the bug. If you are comfortable hacking your version of qutip: adding `print(e)` in the except block; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/qobjevo_codegen.py#L77-L80; should do it give the proper error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196#issuecomment-595847212:4,variab,variable,4,https://qutip.org,https://github.com/qutip/qutip/issues/1196#issuecomment-595847212,1,['variab'],['variable']
Modifiability,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:191,flexible,flexible,191,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798,1,['flexible'],['flexible']
Modifiability,"There is a bunch of .xml and .iml files that keep being tracked in your PR, I expect this is not part of the refactoring but just due to your local environment? You can fix it setting up a specific gitignore in your workspace I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1100#issuecomment-541548331:109,refactor,refactoring,109,https://qutip.org,https://github.com/qutip/qutip/pull/1100#issuecomment-541548331,1,['refactor'],['refactoring']
Modifiability,"These tests seem a little too scant in my opinion, I am not fully satisfied with the final result. They do not provide full coverage of these new functionalities. I am thinking of refactoring the whole thing and start all over again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607558652:180,refactor,refactoring,180,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607558652,1,['refactor'],['refactoring']
Modifiability,This also affects qutip-qip and other family packages that inherited the qutip `setup.py` file.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2036#issuecomment-1342861183:59,inherit,inherited,59,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1342861183,1,['inherit'],['inherited']
Modifiability,This builds fine except for the cqobjevo_omp module that uses unsigned variables for the openmp for loop which is not allowed on windows. It will work fine after that is fixed,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/954#issuecomment-466762659:71,variab,variables,71,https://qutip.org,https://github.com/qutip/qutip/issues/954#issuecomment-466762659,1,['variab'],['variables']
Modifiability,This is a good find. Previous versions of Anaconda did not show the correct dirs in numpy.**config**. They used to point the the Intel compiler directory that built them. This makes things easier than I thought.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204252414:92,config,config,92,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204252414,1,['config'],['config']
Modifiability,"This is an interesting bug, thanks for raising it! Roughly, QuTiP looks at `$HOME` to find where the `qutiprc`configuration file. If QuTiP can't find it, it will raise a warning and proceed with defaults, so that shouldn't adversely affect you unless you've set some flags like `debug=True`. That said, we should definitely raise a less intimidating warning when `$HOME` is unset.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/365#issuecomment-136613770:110,config,configuration,110,https://qutip.org,https://github.com/qutip/qutip/issues/365#issuecomment-136613770,1,['config'],['configuration']
Modifiability,"This is just a test. ; Since many failed Travis builds had a malloc error, also according to [this StackOverflow thread](https://stackoverflow.com/questions/19840671/malloc-error-incorrect-checksum-for-freed-object-object-was-probably-mod/19841133) it seemed that XCode was the source of the problem. . I added as osx environment in the travis configuration file xcode 10.2 (should be on osx 10.14 Mojave, not sure though). Build still fails, now at ; ```; Qobj subtraction ... python(2491,0x1192585c0) malloc: Incorrect checksum for freed object 0x7ffe6ff1ad50: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(2491,0x1192585c0) malloc: *** set a breakpoint in malloc_error_break to debug; /Users/travis/.travis/functions: line 104: 2491 Abort trap: 6 nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; The command ""nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip"" exited with 134.; ```; which seems a pretty basic test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/985#issuecomment-485054530:344,config,configuration,344,https://qutip.org,https://github.com/qutip/qutip/pull/985#issuecomment-485054530,1,['config'],['configuration']
Modifiability,"This is ready for a review. I incorporated the changes and the pep8 fixes. We still might go for a change in the name for the module as `piqs` and the class as `Dicke` to follow the naming in the paper. There are some more tests that we would like to add today. . However, for the rest of it, things remain the same. Since the `is_diagonal` feature is more general, I could open a PR to include that as a `Qobj` property. Otherwise, this function will only be used once we add the enhancement `diagonal_solver` which can solve for some special classes of Hamiltonians. But that is for later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-367197236:481,enhance,enhancement,481,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-367197236,1,['enhance'],['enhancement']
Modifiability,"This issue has a two-fold interest: decreasing test time in general and expand the platforms through which QuTiP is available. . What is the reason it takes so long on Nix? QuTiP, in the [latest PR](https://travis-ci.org/qutip/qutip/builds/628865624?utm_source=github_status&utm_medium=notification), takes on average 20 minutes to run its tests on a given platform. Much of this I think is due to the Cython configurations, indeed the no-cython option takes only 13 minutes. My first suggestion would be to try without Cython if things speed up, from those requirements (@Ericgig set that up and I am not knowledgeable about it). . From your PR on `nixpkgs` do you build on Travis CI or a similar cloud? If you could give a list of time taken by the different tests that would help. . The idea of a subset of tests is interesting (essential tests vs. thorough tests), in general; for example thorough tests could be done only in production and a lighter version could be called with `qutip.testing.run()`. Although, in specific, it is not clear to me how to triage which tests to skip. I would be glad to have the others opinion on this too (pinged them as assignees).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1147#issuecomment-569696700:409,config,configurations,409,https://qutip.org,https://github.com/qutip/qutip/issues/1147#issuecomment-569696700,1,['config'],['configurations']
Modifiability,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:321,flexible,flexible,321,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616,1,['flexible'],['flexible']
Modifiability,"This parallelism does not come from `qutip` but `scipy`: `coherent` use `scipy.sparse.linalg.expm` which run in parallel for big matrix.; This can be fixed with enviroment variable like`$ export OPENBLAS_NUM_THREADS=1` in bash or `os.environ[""OPENBLAS_NUM_THREADS""] = ""1""` in python, but there are a few possibilities:; ```; OMP_NUM_THREADS: openmp,; OPENBLAS_NUM_THREADS: openblas,; MKL_NUM_THREADS: mkl,; VECLIB_MAXIMUM_THREADS: accelerate,; NUMEXPR_NUM_THREADS: numexpr; ```; See https://stackoverflow.com/questions/30791550/limit-number-of-threads-in-numpy",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1175#issuecomment-583773226:172,variab,variable,172,https://qutip.org,https://github.com/qutip/qutip/issues/1175#issuecomment-583773226,1,['variab'],['variable']
Modifiability,"This randomly failing test appears again. It is really getting annoying. I copied the error message from Travis bellow:. ```; =================================== FAILURES ===================================; ___________________________ test_MCSimpleConstStates ___________________________; @pytest.mark.slow; def test_MCSimpleConstStates():; ""Monte-carlo: Constant H with constant collapse (states)""; N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; c_op_list = [np.sqrt(kappa) * a]; tlist = np.linspace(0, 10, 100); mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; options=Options(average_states=True)); assert_(len(mcdata.states) == len(tlist)); assert_(isinstance(mcdata.states[0], Qobj)); expt = expect(a.dag() * a, mcdata.states); actual_answer = 9.0 * np.exp(-kappa * tlist); avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > assert_equal(avg_diff < mc_error, True); E AssertionError: ; E Items are not equal:; E ACTUAL: False; E DESIRED: True; ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; ----------------------------- Captured stdout call -----------------------------; 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; Total run time: 20.34s; ---------- coverage: platform darwin, python 3.7.7-final-0 -----------; Name ; ```; Restart the tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607477749:529,coupling,coupling,529,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607477749,1,['coupling'],['coupling']
Modifiability,"This segfault is still _very_ occasionally present on Mac as of QuTiP 4.6.0 and the current master (624405e7). Unfortunately, I've not been able to find any sort of reliable reproducer, so I can't offer a huge amount of insight into what might be causing it. Here's an example output:; ```; jake@tauros$ pytest tests/test_superop_reps.py; =========================================================================================== test session starts ============================================================================================; platform darwin -- Python 3.8.8, pytest-6.2.3, py-1.10.0, pluggy-0.13.1; rootdir: /Users/jake/code/qutip/qutip/qutip/tests, configfile: pytest.ini; plugins: rerunfailures-9.1.1; collected 15 items. tests/test_superop_reps.py ..F............ [100%]. ================================================================================================= FAILURES =================================================================================================; ____________________________________________________________________________________ TestSuperopReps.test_ChoiKrausChoi ____________________________________________________________________________________. self = <qutip.tests.test_superop_reps.TestSuperopReps object at 0x11f1140d0>. Fatal Python error: Segmentation fault. Current thread 0x000000010c77b5c0 (most recent call first):; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 312 in _optimize_charset; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 120 in _compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 607 in _code; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 768 in compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/re.py"", line 304 in _compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/re.py"", line 252 in compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:669,config,configfile,669,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,2,"['config', 'plugin']","['configfile', 'plugins']"
Modifiability,This will take a bit of work. Especially since the docs are not so easy to read. Just changing the setup import does not work as we use numpy.distutils for the configuration.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/593#issuecomment-269730765:160,config,configuration,160,https://qutip.org,https://github.com/qutip/qutip/issues/593#issuecomment-269730765,1,['config'],['configuration']
Modifiability,"Update Travis build passes. ### Summary . This PR helps convert between superop reps with non-square shape. This is needed because quantum channels can have input and output spaces of different dimension. It works between super, choi, kraus. It correctly handles tensor product structures and systems with different dimensions e.g. a qubit and a qutrit. . It does not work for Chi rep or the Steinspring rep. In the Chi rep only the qubit Pauli basis has been implemented. One would need to first get the Chi rep working for Qudits. At the moment it is unclear how to generalize to the Stinespring rep. . **changes**; - in `type_from_dims` the flag `enforce_square` was set to `False`. This helps in the conversion.; - in `qobj`, `__mul__` was extended to allow construction of non square operators from an outer product using the suggestion of @Ericgig ; - `_super_tofrom_choi`, `choi_to_kraus`, `kraus_to_choi` have been changed so they work with non-square shapes.; - to support the above changes `vector_to_operator` and `vec2mat` were changed to allow for non square shapes. **other changes**; - `Qobj permute`. `tidyup` was removed from to resolve a failing test at the suggestion of @nonhermitian ; - `choi_to_kraus` and `to_kraus`. When converting from Choi to to Kraus there are many small norm Kraus operators. A `tol` parameter was added to help remove these spurious operators. ### Added Tests; **test_superoperator_reps**; - Convert non-square Kraus operator to Super + Choi matrix and back.; - Neglect tiny Kraus operators when converting Choi to Kraus. **test_superoper**; - Operator - vector - operator conversion with a tensor product state.; - Operator - vector - operator conversion for non-square matrix. **test_qobj**; - bra and ket multiplication with different dims e.g. [N, 1] and [1, M] for M \neq N",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-576981021:744,extend,extended,744,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-576981021,1,['extend'],['extended']
Modifiability,"We had an issue like this in the past. The ODE use variable steps sizes, when nothing happens, these steps can become very long and skip over the pulse. The option max_step can limit this step size, so it should be set to be shorter than the shortest pulse.; Here I beleive that using `options=qu.Options(max_step=5)` in the solver calls would fix it.; If it does not work, I can look in more details next week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1265#issuecomment-629712706:51,variab,variable,51,https://qutip.org,https://github.com/qutip/qutip/issues/1265#issuecomment-629712706,1,['variab'],['variable']
Modifiability,"We had it before and it introduced issues that lead us to remove it, see #1278, #1433, #1611... It also limits us to what is a `Qobj` which we have ideas extend.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2533#issuecomment-2400118195:154,extend,extend,154,https://qutip.org,https://github.com/qutip/qutip/pull/2533#issuecomment-2400118195,1,['extend'],['extend']
Modifiability,"We have decided not to continue to maintain the Ubuntu channel. Please; install from source to using qutip 3.2.; Alternatively you can use the conda-forge channel if you are able to work; with qutip 3.1. On 9 May 2016 at 02:52, Qi notifications@github.com wrote:. > There doesn't seem to be the package released under Ubuntu 16.04 channel.; > After I added the Ubuntu PPA for QuTiP, I got the following error/warning:; > ; > qxd@ubuntu1604$: sudo apt-get update; > ...; > W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; > N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; > N: See apt-secure(8) manpage for repository creation and user configuration details.; > E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; > E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; > ; > Thanks for maintaining it :); > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/472",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/472#issuecomment-218122293:765,config,configuration,765,https://qutip.org,https://github.com/qutip/qutip/issues/472#issuecomment-218122293,1,['config'],['configuration']
Modifiability,"What about the c99 complex math functions? Are those a possibility? Perhaps we could specify that 'j' is a reserved variable and then search the input string for 'j' and then call math or cmath, depending on the result.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/154#issuecomment-61041717:116,variab,variable,116,https://qutip.org,https://github.com/qutip/qutip/pull/154#issuecomment-61041717,1,['variab'],['variable']
Modifiability,"When I ran against @dick-t's example, it still violated the bound F ≤ 1, but by significantly less than before, as can be confirmed by the [success of `test_fidelity_bounded_purepure`](https://github.com/qutip/qutip/pull/362/files#diff-3e3c19be6d013d22c4823607e07cd240R106), introduced by #362. That PR doesn't fully adapt to the pure vs pure case that @dick-t lists, but it does avoid `sqrtm` in that case. I can fully specialize to that case, if you like, by using the inner product of the two pure states.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134930346:317,adapt,adapt,317,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134930346,1,['adapt'],['adapt']
Modifiability,"When I try it now, it says that the software plugin is incompatible with the OS, which is 10.14.5, Mojave.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1030#issuecomment-574232335:45,plugin,plugin,45,https://qutip.org,https://github.com/qutip/qutip/issues/1030#issuecomment-574232335,1,['plugin'],['plugin']
Modifiability,"When doing pulse type simulations, it is best to set the max_step size to be half the width of the smallest pulse in the simulation. This makes sure that pulses do not get over stepped. Propagators are unitaries. To compute them you need to evolve all basis vectors. In addition, it is normal to get a dense matrix for the resulting unitary. In contrast, canonical Hamiltonians are usually quite sparse, and the computing the evolution is quick sparse matrix - dense vector multiplication.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1265#issuecomment-629730292:241,evolve,evolve,241,https://qutip.org,https://github.com/qutip/qutip/issues/1265#issuecomment-629730292,1,['evolve'],['evolve']
Modifiability,"Whether it is an issue likely depends on you school of thought. The error comes from the finite accuracy of the solvers. By default, the solutions are found using a method that is accurate 12-order in the step size and looks for absolute and relative errors at the 1e-8 and 1e-6 levels, respectively. If you evolve for long enough then inevitably there is going to be some error, and you will not get perfectly Hermitian matrices. One can accept this, and possibly lower the tolerance levels for more accuracy, or you can take 0.5*(A+A.dag()) to force the Hermicity. What method you use likely depends on your question and taste. Either way, I do not think that I would call this an issue. It is more of a fact of life when doing numerics. Paul. > On Jun 1, 2015, at 20:00, mmensing notifications@github.com wrote:; > ; > I was wondering if this is still an issue? If so I could try to spend some thinking on possible ways to correct the errors.; > ; > —; > Reply to this email directly or view it on GitHub https://github.com/qutip/qutip/issues/122#issuecomment-107400015.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/122#issuecomment-108683653:308,evolve,evolve,308,https://qutip.org,https://github.com/qutip/qutip/issues/122#issuecomment-108683653,1,['evolve'],['evolve']
Modifiability,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:260,rewrite,rewrites,260,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970,1,['rewrite'],['rewrites']
Modifiability,"Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", Path.home() / "".config"")` rather than depend on the `xdg` package?. How does one know if one is on a system where XDG is supported? E.g. I know Windows used to use a special APP configuration folder of its own.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222:75,config,config,75,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222,2,['config'],"['config', 'configuration']"
Modifiability,"Wow, that a lot of work. Good to see you are still working on the lattice stuff. Right now, we don't have enough hands to maintain it and it pretty much abandoned. If you have the will to give it some love, it would be great. However could you make those PRs to qutip-lattice, in small review able chunks? v4.7 is the last of the v4 series and new feature like this can't be a bug-fix release. And in v5 we are splitting lattice, qip and control in other repo and keeping in Qutip only what me and @hodgestar can actively maintain. qutip-notebook is also taking the door in favour of qutip-tutorial, which tests notebooks and adds other maintainability features. Is this tools you created for your research that you are now contributing or do you plan to stick around contributing on qutip-lattice?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765:637,maintainab,maintainability,637,https://qutip.org,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765,1,['maintainab'],['maintainability']
Modifiability,"Yeah in my experience this is something one has to be careful of with the steady-state solver as it is. Depending on the method chosen it can either fail, return one of the possibilities, or some linear combination of them. The default one (direct) tends to fail, which at least sometimes lets you know you have this issue. . We could consider adding null_space solver which returns all possibilities, or modify the existing svd solver to do so if possible? ; Still, if the default ""direct"" method is silently failing it may trip people up still, so adding some examples to the documentation might help, as a minimum. I don't know of a way to extend that direct method to return all possible solutions, and connect those to possible initial conditions. It would be very interesting if its possible!. One minor thing; looking at the the example in the linked paper you provided seems to badly constructed. The dephasing operator they define there is actually just an identity, so does nothing, so technically the second example has no well-defined steady-state at all. A more useful example would be a proper dephasing through a collapse operator = sigma_z, and no driving on the qubit, so the degenerate steady-states are <sigmaz>=\pm 1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812:643,extend,extend,643,https://qutip.org,https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812,1,['extend'],['extend']
Modifiability,"Yeah, definitely there's no point running tests that aren't really testing the package properly. I would hope that if we're much more aggressive about converting time-dependent lists into QobjEvo objects inside `mesolve`, `mcsolve` and `sesolve` (or the class-based versions of them), we could significantly reduce the amount of testing that needs to be done with them. Most of the tests of time-dependent formats would then occur in the QobjEvo tests. We could still test all the configurations of the solvers without too heavy a time penalty. If we only use a small number of different time-dependent operators, we can compile them all only once, and have `pytest` manage the resources through shared fixtures. That would really cut down the run times, especially for the current ""slow"" tests. Another avenue for cutting down run time is if we could merge say the MKL and OpenMP tests into one Travis job - the setup time for one job is about 2.5 minutes, and that's before any tests have run at all. I would hazard a guess that having MKL but not OpenMP is a pretty rare case (maybe more common on high-performance clusters where people submit single-cpu jobs?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182:481,config,configurations,481,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182,1,['config'],['configurations']
Modifiability,"Yeah, in the context of #850, I was only thinking of a global switch for the storage format. But #437 makes a good point about using full storage. I'd add to that the [Lapack banded storage format](http://www.netlib.org/lapack/lug/node124.html) which is extremely efficient for diagonal or tri-diagonal operators (or scipy's [DIA](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.html#scipy.sparse.dia_matrix), which I think is mostly equivalent). I've actually had to solve the equivalent problem of allowing multiple internal formats in the [Fortran QDYN package](https://www.qdyn-library.net), so I'm not sure why I didn't think of that in the first place ;-). I can definitely vouch for the efficiency gained by being able to switch internal sparse representations. So yeah, you'd definitely have the most flexible solution by allowing `Qobj.data` to use varying storage classes from object to object. Maybe the ""protocol"" could be for `Qobj.data` to be any subclass of the [scipy `spmatrix` base class]( https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.html#scipy.sparse.spmatrix)? Then the `Qobj` constructor would probably need an additional parameter `format` for the class that should be used to convert the `inpt` argument to the `data` attribute. The onus would then be on Scipy to provide a full matrix that is a subtype of `scipy.spmatrix` (just to keep the interface contract), and also to have `int64` versions of all their existing sparse classes. From a community standpoint, it would seem like one would get much more bang for the buck to have this problem solved inside SciPy, instead of doing a lot of low-level stuff in QuTiP -- at least if they're amenable to pull requests, but worst case you can still define necessary new `scipy.spmatrix` subclasses externally. Take all of my musings with a little grain of salt... I never really looked too deep into QuTiP's low-level internals, specifically where QuTiP is using Cython.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-383937610:838,flexible,flexible,838,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-383937610,1,['flexible'],['flexible']
Modifiability,"Yeah, you're right, I should have done the style changes in a different PR. It was mostly a lack of thought - I have a linter hooked into my text editor, so I get gutter-marks telling me all the PEP8 inconsistencies and stuff like that, and I usually change them without thinking. The `assert_` usually gets changed to bare `assert` when I'm actually trying to debug the tests - the bare `assert` gives _far_ more debugging detail with `pytest`, so it's much more helpful. By the way, if you're interested, the list of files which _didn't_ change is; ```text; .codeclimate.yml; .coveragerc; .github/ISSUE_TEMPLATE/bug_report.md; .github/ISSUE_TEMPLATE/feature_request.md; .github/ISSUE_TEMPLATE/others.md; .github/pull_request_template.md; .mailmap; .travis.yml; CODE_OF_CONDUCT.md; LICENSE.txt; README.md; pyproject.toml; qutip.bib; qutip/_mkl/__init__.py; qutip/_mkl/spmv.py; qutip/_mkl/spsolve.py; qutip/_mkl/utilities.py; qutip/about.py; qutip/cite.py; qutip/configspec.ini; qutip/control/__init__.py; qutip/control/cy_grape.pyx; qutip/hardware_info.py; qutip/ipynbtools.py; qutip/logging_utils.py; qutip/matplotlib_utilities.py; qutip/orbital.py; qutip/parallel.py; qutip/qip/__init__.py; qutip/qip/algorithms/__init__.py; qutip/qip/circuit_latex.py; qutip/qip/compiler/__init__.py; qutip/qip/compiler/cavityqedcompiler.py; qutip/qip/compiler/gatecompiler.py; qutip/qip/compiler/spinchaincompiler.py; qutip/qip/device/__init__.py; qutip/qip/gates.py; qutip/qip/operations/__init__.py; qutip/qip/qasm.py; qutip/qip/qip_deprecation.py; qutip/tests/Hadamard_params.ini; qutip/tests/__init__.py; qutip/tests/conftest.py; qutip/tests/pytest.ini; qutip/tests/qasm_files/bracket_error.qasm; qutip/tests/qasm_files/command_error.qasm; qutip/tests/qasm_files/qasm_error.qasm; qutip/tests/qasm_files/teleportation.qasm; qutip/tests/qasm_files/test_add.qasm; qutip/tests/qasm_files/test_custom_gates.qasm; qutip/tests/test_control_pulseoptim.py; qutip/tests/test_entropy.py; qutip/tests/test_fileio.py; quti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332#issuecomment-671534803:963,config,configspec,963,https://qutip.org,https://github.com/qutip/qutip/pull/1332#issuecomment-671534803,1,['config'],['configspec']
Modifiability,"Yeah. Just do a 'git pull upstream master' on this branch. The Travis; config file was updated and it's not the same as this branch. You don't; have to do a painful rebase. The tests need to run online. On Mon, Jun 18, 2018, 9:03 PM Louis Tessler <notifications@github.com>; wrote:. > @sahmed95 <https://github.com/sahmed95> shouldn't the merge automatically; > take care of that without bothering to rebase?; >; > I'd like to avoid wasting time on a rebase if there's no tangible benefit; >; > —; > You are receiving this because you were mentioned.; >; >; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/883#issuecomment-398031660>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AGpUBArCWgSxWGFO-QoURjxQPLZ63Eeiks5t95crgaJpZM4UrUyK>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398048087:71,config,config,71,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398048087,1,['config'],['config']
Modifiability,"Yes, I had used it to check whether a variable was a string type. I saw it suggested somewhere. It has only just come up as I am adding (long overdue) tests for the control modules. I have now replaced the six based method with something else, but I think the six.string_types method was more elegant.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/378#issuecomment-145861008:38,variab,variable,38,https://qutip.org,https://github.com/qutip/qutip/issues/378#issuecomment-145861008,1,['variab'],['variable']
Modifiability,"Yes, configuring a bot is beneficial for several tasks. However, the scope would be broad then. Narrowing down seems reasonable. What do you think about opening a new issue, mentioning several examples that can be worked on?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1089#issuecomment-1852573254:5,config,configuring,5,https://qutip.org,https://github.com/qutip/qutip/issues/1089#issuecomment-1852573254,1,['config'],['configuring']
Modifiability,"Yes, how that will look like is still under discussion and a list in the qutip docs/website is indeed a good candidate. It will probably come along with QuTiP 5.0 later this year. I'm closing the issue as issues are meant for ongoing bugs and enhancement in code. Free feel to discuss further in our [Google group](https://groups.google.com/g/qutip) or per emails!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1439#issuecomment-779766759:243,enhance,enhancement,243,https://qutip.org,https://github.com/qutip/qutip/issues/1439#issuecomment-779766759,1,['enhance'],['enhancement']
Modifiability,"Yes, it is not the same thing. You need to rewrite it manually so that each collapse operator contribute on standard lindblad form.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/223#issuecomment-54383218:43,rewrite,rewrite,43,https://qutip.org,https://github.com/qutip/qutip/issues/223#issuecomment-54383218,1,['rewrite'],['rewrite']
Modifiability,"Yes, looks good to me. Think you should merge sooner rather than later. btw these other tests have appeared due trying to make this conda-forge package. Looks like I will have to create some kind of solution file for the appveyor one to work. However, nice to see the circleci one worked without any specific config.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/443#issuecomment-187578137:309,config,config,309,https://qutip.org,https://github.com/qutip/qutip/pull/443#issuecomment-187578137,1,['config'],['config']
Modifiability,"Yes, that is one of the solutions.; This issue could be included in the refactoring task of the quantum circuit library.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497#issuecomment-821950406:72,refactor,refactoring,72,https://qutip.org,https://github.com/qutip/qutip/issues/1497#issuecomment-821950406,1,['refactor'],['refactoring']
Modifiability,"Yes. I saw that. So should we have a single script for all the if statements (checking and installing python2.7, MKL, CVOPT etc.) and run it by passing some command line argument such as. ```; - travis_config install_conda; - travis_config install_mkl; - travis_config install; ```. to do all the complex config stuff?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/875#issuecomment-394644625:305,config,config,305,https://qutip.org,https://github.com/qutip/qutip/pull/875#issuecomment-394644625,1,['config'],['config']
Modifiability,"You are measuring the expectation of sigmax, if you measure the expectation value of sigmaz, or the population, you will not observe such a big oscillation but very small oscillations. Not sure what you want to achieve, but your detuning is negligibly small compared to the frequency. It has little effect. Also I'm not sure if there is a typo `v_0` and `drive_detuning` seems to have the unit of frequency, and 2*pi* frequency. You have a time-independent Hamiltonian, so if you want to compute the ZZ interaction, you can simply diagonalize the matrix and see if you have a ZZ coupling term.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908:579,coupling,coupling,579,https://qutip.org,https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908,1,['coupling'],['coupling']
Modifiability,"You can use it to select number of processes to use, right? I think it is useful if you don't want to use all processors for a calculation, although I usually use the .qutiprc configuration file for this rather than environment variables. I guess it is not really necessary but could be useful I guess.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41985199:176,config,configuration,176,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41985199,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"You'll find it easier installing from conda-forge, since we distribute binary releases there: see the [installation guide](http://qutip.org/docs/latest/installation.html) here. If you want to install from source using `pip`, you need to configure your C++ development environment correctly - you'll probably need to enable the XCode command-line tools ([see e.g. this](https://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/)).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404#issuecomment-742038577:237,config,configure,237,https://qutip.org,https://github.com/qutip/qutip/issues/1404#issuecomment-742038577,1,['config'],['configure']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1566656/badge)](https://coveralls.io/builds/1566656). Coverage decreased (-0.58%) when pulling **9dd4d43cc1b04894b7f7513425c594beccd0984d on jrjohansson:refactor-mcsolve-parallel** into **79c89f066522c8343a1cd0cdcd7bca2e9625db2a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65739997:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65739997,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1566697/badge)](https://coveralls.io/builds/1566697). Coverage decreased (-0.56%) when pulling **2255544d231c8c27d9221ba366b7842dbb37bcf6 on jrjohansson:refactor-mcsolve-parallel** into **79c89f066522c8343a1cd0cdcd7bca2e9625db2a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65741485:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65741485,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1567605/badge)](https://coveralls.io/builds/1567605). Coverage decreased (-0.49%) when pulling **6c04ce3700be46a4ca49d74490c2e5c16f8fd4f8 on jrjohansson:refactor-mcsolve-parallel** into **98fe91d9fe9c37b13835c21a12bd237bbab42c8f on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65765723:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65765723,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1568019/badge)](https://coveralls.io/builds/1568019). Coverage decreased (-0.55%) when pulling **c5c4ff11b39c2243126d8d9149befec0a7f9c39f on jrjohansson:refactor-mcsolve-parallel** into **74c548dc64c377c8e21dfcf662ea7017b97306c3 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65777213:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65777213,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1568060/badge)](https://coveralls.io/builds/1568060). Coverage decreased (-0.55%) when pulling **c5c4ff11b39c2243126d8d9149befec0a7f9c39f on jrjohansson:refactor-mcsolve-parallel** into **74c548dc64c377c8e21dfcf662ea7017b97306c3 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65778609:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65778609,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1588549/badge)](https://coveralls.io/builds/1588549). Coverage decreased (-0.55%) when pulling **aabbc2590895552d4b96cd2f42fb401ce6d0d80e on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66394630:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66394630,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1594952/badge)](https://coveralls.io/builds/1594952). Coverage decreased (-0.24%) when pulling **844f102113c37bdf1f599abff89c0d2d9a67c962 on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66604157:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66604157,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1594994/badge)](https://coveralls.io/builds/1594994). Coverage decreased (-0.25%) when pulling **844f102113c37bdf1f599abff89c0d2d9a67c962 on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66604437:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66604437,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1595281/badge)](https://coveralls.io/builds/1595281). Coverage decreased (-0.24%) when pulling **c6279c428887c4308a17c024e009d8888fd50c7d on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66605622:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66605622,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1595345/badge)](https://coveralls.io/builds/1595345). Coverage decreased (-0.4%) when pulling **cf9a5e766f11fc2d514267d2a643237e5c28cc96 on jrjohansson:refactor-mcsolve-parallel** into **1738f5f73b4b0225eab3c0fbc3ada97b56e70b9a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66605769:200,refactor,refactor-mcsolve-parallel,200,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66605769,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/37558676/badge)](https://coveralls.io/builds/37558676). Coverage increased (+1.3%) to 66.469% when pulling **702de3ece279dc9920332467af01b58d90b73829 on Ericgig:solve.evolve** into **0ca50e9d97ce4031ca886670bed43b960c36a226 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409#issuecomment-767650176:215,evolve,evolve,215,https://qutip.org,https://github.com/qutip/qutip/pull/1409#issuecomment-767650176,1,['evolve'],['evolve']
Modifiability,[![Coverage Status](https://coveralls.io/builds/38609281/badge)](https://coveralls.io/builds/38609281). Coverage increased (+0.05%) to 63.659% when pulling **862d0de844d9d5b39f0301d0ea4c47c37d995499 on jakelishman:tests-refactor-metrics** into **ee047df81e3fcb1b941d04588409c4a8de09e2c7 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815115509:220,refactor,refactor-metrics,220,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815115509,1,['refactor'],['refactor-metrics']
Modifiability,[![Coverage Status](https://coveralls.io/builds/45388930/badge)](https://coveralls.io/builds/45388930). Coverage increased (+0.007%) to 65.527% when pulling **6ec2612fbcd8f832dcba64ea5dbc6adeff8bd480 on fhopfmueller:dev.major-refactor-process-fidelity** into **6287bd37f3446110af82e2a038fdb3bd336268db on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1748#issuecomment-1003775123:226,refactor,refactor-process-fidelity,226,https://qutip.org,https://github.com/qutip/qutip/pull/1748#issuecomment-1003775123,1,['refactor'],['refactor-process-fidelity']
Modifiability,[![Coverage Status](https://coveralls.io/builds/49815148/badge)](https://coveralls.io/builds/49815148). Coverage increased (+0.2%) to 65.494% when pulling **286cce4bd3d5a778a7ad0ab817fe68db72bc30db on hodgestar:feature/flexible-result-base-class** into **e8f8b0fe6f343c585bc2d80f727a25a5f3cca1a1 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1139721813:219,flexible,flexible-result-base-class,219,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139721813,1,['flexible'],['flexible-result-base-class']
Modifiability,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:3,config,config-setting,3,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355,2,['config'],['config-setting']
Modifiability,`--config-setting=--global-option=--with-openmp` is still not working with git head (with #1978 merged). This is with; * python 3.10.6-1; * python3-build 0.7.0-3; * python3-setuptools 59.6.0-1.2; * python3-wheel 0.37.1-2; * gcc 12.1.0-7,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1220037489:3,config,config-setting,3,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1220037489,1,['config'],['config-setting']
Modifiability,"`general_stochastic` is very manual, halfway to scipy's ode solver. It can be used for both open and closed system and does not correspond to any particular physics equation. It the function that you use if you do weird stuff that does not fit already available template and I would discourage it's use. ; If other type of stochastic evolution are commonly used, it would be better to make a new specialized function than use `general_stochastic`. Old example should be adapted to `smesolve` as much as possible. The solver does not know if it is solving an close or open system (or something else). So e_ops are not touched. ; d1, d2 are working in array for performance issue. We could easily have them work in Qobj, but I would expect a significant slowdown. These function, taking no args, and being call many time at each step could benefit from being compiled with numba.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283:470,adapt,adapted,470,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283,1,['adapt'],['adapted']
Modifiability,`mcsolve` can only evolve ket states. The closest to what you want is `photocurrent_mesolve` which does master equation evolution of a density matrix with the liouvillian build from `H` and `c_ops` but using discrete jumps for `sc_ops`. It is a lot slower than mesolve since it use only basic ode method (Euler's or Heun's method) and you need to set a very small time step to keep the error resonable.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1375#issuecomment-720652251:19,evolve,evolve,19,https://qutip.org,https://github.com/qutip/qutip/issues/1375#issuecomment-720652251,1,['evolve'],['evolve']
Modifiability,"`python3 -mbuild` has a `-C` option (`--config-setting`), see`https://pypa-build.readthedocs.io/en/latest/`. It sounds like it could be used for build configuration options like qutip's openmp support. It doesn't seem to work with the current handling in setup.py however. Permutations of `-C--with-openmp`, `-Copenmp`, `-Copenmp=1` enable a succcessful qutip PEP517 build, but `qutip.about()` then reports; ```; OPENMP Installed: False; ```; indicating the option is ignored.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223:40,config,config-setting,40,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223,2,['config'],"['config-setting', 'configuration']"
Modifiability,"a>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 304 in wrap_session; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 316 in pytest_cmdline_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 84 in <lambda>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 162 in main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 185 in console_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/bin/pytest"", line 11 in <module>; Segmentation fault: 11; ```. This was done with commit 624405e7, SciPy 1.6.2 and Numpy 1.19.5. My BLAS version has chopped and changed an awful lot, but I believe that run was with MKL implementations. The ""random"" stack trace from pytest looks to me like the error came about during garbage collection, and I really don't imagine pytest is to blame. We have in the past had issues with some bad calls in SciPy linalg functions, so it's _possible_ that they are the cause again, but I doubt it; we'd expect the stack traces to reliably show scipy to be the problem in that case. I wasn't able to reproduce this segfault on Windows, but that doesn't mean a huge amount, because I also can't reliably reproduce it on Mac. I suspect that the cause is some",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:5727,config,config,5727,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,1,['config'],['config']
Modifiability,"actually, just realised my fork is configured to do CodeClimate on `dev.major`. For say `qobj.py`, the `master` version has [maintainability F](https://codeclimate.com/github/qutip/qutip/qutip/qobj.py), while `dev.major` has [maintainability A](https://codeclimate.com/github/jakelishman/qutip/qutip/core/qobj.py) with the only issues being TODOs and like 5 pep8s.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-782267965:35,config,configured,35,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-782267965,3,"['config', 'maintainab']","['configured', 'maintainability']"
Modifiability,"and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are not physics-related:; - 6 are related to plotting or visualization utilities ; - 6 are `Distribution` classes or subclasses, which seem to be only used for visualization; - 6 are related to solver options or results; - 3 are low-level classes that users typically wouldn't interact with; - This leaves only 4 ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:3338,config,configuration,3338,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['config'],['configuration']
Modifiability,"arallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactoring much of QuTiP to be more object-oriented will be a positive change to the framework. However, consider that: (1) properly rewriting this as a class-based module without losing functionality will take some time, (2) there are many other modules (for example, most solvers) which would benefit from being refactored into classes, and (3) rewriting these modules would be a breaking API change. . These reasons make me think it would be best to merge the current module now, including it in version 4.3 of QuTiP, and to refactor this (among many other modules) in version 5.0 of QuTiP. This option would make this module available quickly, would be most consistent with s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:2533,refactor,refactor,2533,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactor']
Modifiability,"back (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File ""<frozen importlib._bootstrap>"", line 693, in _load; File ""<frozen importlib._bootstrap>"", line 673, in _load_unlocked; File ""<frozen importlib._bootstrap_external>"", line 662, i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:1177,config,configuration,1177,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,2,['config'],"['config', 'configuration']"
Modifiability,"cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using the builtin Python module multiprocessing.; 36 """"""; 37 __all__ = ['parfor', 'parallel_map', 'serial_map']; 38 ; 39 from scipy import array; 40: from multiprocessing import Pool; 41 from functools import partial; 42 import os. /Users/shahnawaz/dev/qutip/qutip/settings.py:; 32 ###############################################################################; 33 """"""; 34: This module contains settings for the QuTiP graphics, multiprocessing, and; 35 tidyup functionality, etc.; 36 """"""; ```. Can the `pyximport` be dea",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:2268,config,config,2268,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,1,['config'],['config']
Modifiability,"cy, like you suggest. For the Milstein solver it might be the best, or at least the quickest, way to implement heterodyne, but I don't really agree that the current method is overcomplicated. It is in fact basically the same as the method you suggest, so I don't see that either would be more complicated or simpler than the other. The only issue is whether the two stochastic increments are divided up in several stochastic collapse operators or if the d2 function internally takes care of the both stochastic increments for a given stochastic collapse operator. The complexity is just shifted from the d2 function to somewhere else, which in general doesn't simplify anything. However, since the milstein solver you submitted is written so that it only support one increment per collapse operators, then there might be a real advantage of splitting the heterodyne process into two homodyne processes. . I've tried to make the qutip stochastic solver API as general as I could (and it is still a work in process), so that it will be as flexible as possible for implementing custom types of SMEs. Having support for multiple stochastic increments per collapse operators seems to be useful in certain applications. Although such SMEs could probably always be rewritten as multiple collapse operators with single stochastic increments, it might not always be the most natural way to define the SME. The heterodyne detection is one example of this, and it can be formulated in both ways, but I want the qutip SME API to work with both methods (at least with the basic euler solver, not necessarily with every solver we implement). However, that doesn't mean that the implementation of heterodyne for a particular solver has to use one way or the other. We should just document which solvers support multiple increments per operators and which solvers don't. So if it is easier to get the milstein solver working for heterodyne by simulating two homodyne detections, then let's go ahead use that method f",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22543416:1163,flexible,flexible,1163,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22543416,1,['flexible'],['flexible']
Modifiability,"e computation since each call to the random number generator is costly. One could pre-generate a large array of random numbers before hand, but there is no way to know if you generated enough since we are using an adaptive step size ODE method. You are correct about the way mcsolve does its calculations. The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms. These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it. Regards,. Paul; On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:. > Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?; > ; > I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the array[1, 10, 11]? ...; > ; > At this stage, I have to resort ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42092984:1182,evolve,evolve,1182,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42092984,1,['evolve'],['evolve']
Modifiability,"ed features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Best; Boxi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940:2052,Refactor,Refactoring,2052,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940,1,['Refactor'],['Refactoring']
Modifiability,"epresentations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qobj` representing the operator-sum decomposition of Λ and `phi` is the representation of Φ, then `lambda_ + phi` should be some superoperator representation (most likely Kraus to match inputs) of the function (Λ + Φ)(ρ) = Λ﴾ρ) + Φ(ρ). Similarly, multiplying by a scalar 𝑠 would rescale each term by √𝑠 so that the corresponding function is (𝑠Λ)(ρ) = s · (Λ(ρ)) and multiplying two channels in Kraus decomposition would return their decomposition, (ΦΛ)(ρ) = (Φ ∘ Λ)(ρ) = Φ(Λ(ρ)). > Given that currently `dims` describe the dimension of the Hilbert space and that the dimension isn't changing, I feel `dims` is perhaps an odd place to put the number of elements in the sum, but that doesn't prevent this becoming a feature of Qobj in some other way. Fair enough; I guess my thinking there was that the term index is indeed just another kind of index, but if there's a better way to represent that in the metadata for a Qobj than in `dims`, I'm all for it!. > Either way, QobjEvo would need to support this too (probably not a giant amount of work, but some careful checking would be needed) & some other parts of the code might be surprised.; > ; > @jakelishman had some ideas for revamping dims support in QuTiP. I don't think it's the same idea, but the two definitely overlap in terms of which parts of QuTiP they'd evolve. Jake, would you mind posting the link to your dims proposal here if you have it handy (apologies, I seem to have lost it). Even if dims isn't the right place for this, it would be good for me to reread it. Ah, nice, I hadn't realized! I'll take a look, then!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:4731,evolve,evolve,4731,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574,1,['evolve'],['evolve']
Modifiability,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:2042,extend,extends,2042,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,1,['extend'],['extends']
Modifiability,"eter search will be much more difficult to do if `scattering_probability` is changed to become a class method. There are some [hacky workarounds to this](https://stackoverflow.com/questions/27318290/why-can-i-pass-an-instance-method-to-multiprocessing-process-but-not-a-multipro), but these add extra overhead to implementing multiprocessing and don't work with methods that are not functionally static. . Given that these scattering calculations are among the most computationally expensive in QuTiP, I don't think that making parallelism more difficult to work with is a direction we should go in. I am confident that, with significant effort, I can make a clean and parallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactorin",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:1812,refactor,refactor,1812,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactor']
Modifiability,"ever, this also implies that `Qobj` should fulfil the numpy ufunc interface; `Qobj` would be a container for data such that operations like `np.sin` is the elementwise sin, or (most notably) `np.multiply` is the *elementwise* multiplication. Our `Qobj` _does not_ fulfil the ufunc interface:; 1. elementwise operations don't make sense on quantum objects, which are arrays only as an implementation detail - the `Qobj` class is meant to represent an abstract linear algebra object, not specifically a matrix.; 2. we don't honour the `shape` guarantees of numpy as we test compatibility based on `dims`, which are not 1D (superoperators) so cannot follow numpy's broadcasting rules; 3. we treat multiplication as matrix multiplication, violating how `np.multiply` should behave. My main concern is point 1: I don't think that `Qobj` provides a similar object to an `ndarray` at all. Right now we _do_ use matrices underneath, but proposed additions to QuTiP such as symbolic `Qobj` and adaptive Hilbert spaces are compatible with the idea of ""abstract linear algebra objects"", but do not necessarily have a backing array. Point 2 is mostly an extension of that: I'm not sure there is a sensible way for numpy's broadcasting rules to be applied to quantum objects as they exist now, even without extensions. ## More control over dispatch: `__array_ufunc__` and `__array_function__`. See [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html), [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html) and [NEP 35](https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html). Later versions of numpy allowed greater control over how ufuncs get implemented, which was most recently extended in 1.16 to cover non-ufuncs like `tensordot`. These functions are intended for classes to define how ufuncs operate on their data, but implementors should still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:4838,adapt,adaptive,4838,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,1,['adapt'],['adaptive']
Modifiability,"ey reduce conceptual clarity. (For example, `temporal_basis_vector` returns a specific vector in the temporal basis; I would expect a function named `temporal_basis` to return an enumeration of all basis vectors.) However, I will try to think of shorter names which don't reduce clarity and will make changes if I come up with any. > Moving temporal_scattered_state, scattering_probability, and temporal_basis_vector into a new class. I think this is the only proposed change worth significant amounts of discussion, and it's actually something I had considered before. I'm conflicted about whether this change would be good or not, and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:2851,Evolve,Evolver,2851,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['Evolve'],['Evolver']
Modifiability,"format-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c; > qutip/cy/spmatfuncs.c -o; > build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3; > -march=native -funroll-loops"" failed with exit status 1|; >; > Then, I cloned the qutip/qutip repository, and tried to build a wheel; > with |python setup.py bdist_wheel| under the qutip directory. Which; > gave me the following log:; >; > `running bdist_wheel; > running build; > running config_cc; > unifing config_cc, config, build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifing config_fc, config, build_clib, build_ext, build commands; > --fcompiler options; > running build_src; > build_src; > building py_modules sources; > building extension ""qutip.cy.spmatfuncs"" sources; > building extension ""qutip.cy.stochastic"" sources; > building extension ""qutip.cy.sparse_utils"" sources; > building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_e",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:3178,config,config,3178,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,2,['config'],['config']
Modifiability,"handle the multiple dispatch over potentially different data types of the two inputs. I would imagine that a better form of organisation for this sort of routine, which will be able to handle arbitrary tensor-network operations, will end up being made up of two components:; 1. a `Dispatcher` version of something akin to `einsum`, with a couple of limitations; 2. a high-level wrapper function to handle the specific case of local multiplication, which examines the dimensions and target specifiers to produce the input to the `einsum`-like function, then calls the `Dispatcher` with this information. I think this form would likely be preferable for several reasons:; 1. it will allow arbitrary mixing of different data types (`CSR` complete space and `Dense` operator, or both `CSR`, or whatever), with the allowed conversions respecting the global dispatcher rules, not having this function use a different, special configuration; 2. it will mean that the function can also be implemented by plug-in data types (TF/CuPy/etc), installed separately to QuTiP; 3. it will be more general, and easier to maintain; the current `subsystem_apply`, `partial_transpose`, `ptrace`, `tensor_contract` and this can all become special cases of this backing `einsum`-like routine.; 4. after we've implemented new dimensions objects, we'll be able to use a more standardised description of how to refer to individual subspaces of a Hilbert space, which will provide a more consistent UX across the library. This is particularly important if we want this to work well with superoperators. Really, thank you very much for making the PR - I really am excited to see people with an interest in the new data layer! I'm sorry that I took quite so long to respond properly to it, and that when I have, I've ended up being somewhat against the implementaton as it is. I would be really interested in pursuing this, likely after the initial release of 5.0, but right now I think we might need to get our ducks in a row ab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:3452,plug-in,plug-in,3452,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,1,['plug-in'],['plug-in']
Modifiability,"hat casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2944,Variab,Variable,2944,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,1,['Variab'],['Variable']
Modifiability,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2998,plug-in,plug-ins,2998,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,5,"['Variab', 'plug-in']","['Variable', 'plug-in', 'plug-ins']"
Modifiability,"hi gary, thanks for making this an issue, i think it fell through the cracks on the google groups. . I think the problem is with how the expectation values are calculated. Mesolve() returns the correct states, but they are wrongly flagged with isherm=True, even when they are not actually hermitian, so when expect() is called it takes the real part. I think this incorrect flagging happens here for the output states; https://github.com/qutip/qutip/blob/d285e96b3afc61afd1deceef61d9635f9d9aa505/qutip/mesolve.py#L520. and here for collating the expectation values; https://github.com/qutip/qutip/blob/d285e96b3afc61afd1deceef61d9635f9d9aa505/qutip/mesolve.py#L510; (where only the hermiticity of the operators are checked, not the state. you can check this by setting x.isherm=False in your code example, which fixes everything). @Ericgig is there any issue with just removing this isherm=True flag here, and fixing the hermiticity check in the expectation values output call? i guess all this is getting replaced with your solver rewrite anyway, but if not it might make a good ''first issue'' for gsoc?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796432374:1032,rewrite,rewrite,1032,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796432374,1,['rewrite'],['rewrite']
Modifiability,"https://github.com/qutip/qutip/blob/2ca20fb829dc67d0ee32498422bad1f8ff852a95/qutip/core/data/permute.pyx#L229-L230. `if n:` ignore it completely and assign the wrong variable... This is the main problem. https://github.com/qutip/qutip/blob/2ca20fb829dc67d0ee32498422bad1f8ff852a95/qutip/core/data/permute.pyx#L265. And here's the offending unchecked multiplication. That test is actually off from what I intended, which was hiding the buggy function call below it. The unchecked 32-bit overflow punched through the test and revealed the problematic function. In worse matrices, this would have actually been a huge segfault - the identity was only safe because it has the same number of elements in each row. ---. That's exciting that someone else is trying it out! I'm glad there are speed-ups. If you've got issues let me know and I can maybe help out with some of the internals (my email's in my github profile). I'm fine to wait to check out a PR if you guys are working on something between you. I still need to find the time to finish off the dispatching system and pull the OpenMP parts back into `dev.major`...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1382#issuecomment-728373500:166,variab,variable,166,https://qutip.org,https://github.com/qutip/qutip/issues/1382#issuecomment-728373500,1,['variab'],['variable']
Modifiability,"ide that (e.g. in `dnorm`), I overrode it by providing a definition in a tighter scope - either at class level or per-function (via `pytest.mark.parametrize` directly). The correct scoping just depends a lot on the type of tests you're writing - if you're going to have to overwrite something constantly then module scoping isn't good, but if you have lots of different functions to test, and every test for a given function will want the same parametrisation, then class scoping might be a good choice. If you only need the parametrisation once, then it's best to put it right next to the place it's used (like in the case of mine that you've highlighted). It means that if you've opened that file to read the tests, then everything you need to understand `Test_fidelity.test_known_cases` will be on your screen if you just scroll to it. That makes it much easier for the next person who has to come along to edit your code. I used a couple of temporary variables in that case just to aid readability - my cases wouldn't have nicely fit on one line if I'd shoved the `qutip.basis(2, 0)` stuff inside the `pytest.param` constructors, and it would be hard to read. This way you can easily verify that the code is correct bit-by-bit; you can see clearly that the names are descriptive and match exactly what they say, and that means you can trust them when they then appear in the parametrisation. I won't pretend to be perfect at any part of coding, and particularly testing. I rewrote all the testing files starting from those beginning with ""a"" up to (now) ""metrics"" while I was first getting to know the QuTiP codebase, and hopefully you can see that my early efforts weren't that great, and they get a bit better and easier to read as time went on. (The later files haven't been converted yet.) The main things are to always be thinking about readability both of the code and the error messages that are coming out, and making sure that your tests are really testing that your functions have your ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706:1448,variab,variables,1448,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706,1,['variab'],['variables']
Modifiability,if you run:. ``` python; import numpy as np; config = np.__config__; config.show(); ```. what do you get?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/552#issuecomment-259599373:45,config,config,45,https://qutip.org,https://github.com/qutip/qutip/issues/552#issuecomment-259599373,2,['config'],['config']
Modifiability,"ile ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 304 in wrap_session; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 316 in pytest_cmdline_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 84 in <lambda>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 162 in main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 185 in console_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/bin/pytest"", line 11 in <module>; Segmentation fault: 11; ```. This was done with commit 624405e7, SciPy 1.6.2 and Numpy 1.19.5. My BLAS version has chopped and changed an awful lot, but I believe that run was with MKL implementations. The ""random"" stack trace from pytest looks to me like the error came about during garbage collection, and I really don't imagine pytest is to blame. We have in the past had issues with some bad calls in SciPy linalg functions, so it's _possible_ that they are the cause again, but I doubt it; we'd expect the stack traces to reliably show scipy to be the problem in that case. I wasn't able to reproduce this segfault on Windows, but that doesn't mean a huge amount, because I also can't reliably reproduce it on Mac. I suspect that the cause is some dodgy handling of pointers in the `struct CSR_Matrix` type in `qutip/cy/sparse_routines.pxi`, but this is just a suspi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:5846,config,config,5846,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,1,['config'],['config']
Modifiability,"inistic where the current deterministic contributions are calculated. These functions can now be called from a stochastic rhs implementation, like this. ```; dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args); ```. In this way the implementation of a stochastic rhs function is relatively isolated from how the deterministic part is calculated (which right now is trivial, but which could become more complex when time-dependent systems are implemented). However, it also gives all the flexibility needed in the rhs function, and these deterministic rhs functions do not need to be used if it is not suitable in a particular stochastic rhs implementation. . I've added the changes to the rhs behavior to the https://github.com/qutip/qutip/tree/sme-rhs-restructuring and updated the gist with the variant of your notebook. http://nbviewer.ipython.org/6153688. Note that a few other things, like the rhs function signature, had to change in the process. I hope that this updated API will be flexible enough to let you implement implicit solver. Regards rhs implementation and d1,d2 function: Yes, I understand that not all possible rhs schemes might be compatible with the parameterization with d1 and d2 functions, but when it is possible it has the great advantage that the user do not need to worry about how the rhs is implemented, only define the SDE in terms of d1 and d2, and then possibly select a rhs solver using the solver argument to smesolve. This will not work in general for solvers like the milstein scheme, since it requires an analytical derivative (unless it can be evaluated numerically?), and in those cases it would be sufficient to implement problem specific rhs functions (like rhs_rho_milstein_homodyne etc). Regarding the use of expm: OK, I agree that it could be a nice method to have to be used on smallish system. However, since we are stepping with a small timestep dt, shouldn't it be sufficient to use an expansion of of expm as usual? Perhaps a second-order expansio",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22156426:1637,flexible,flexible,1637,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22156426,1,['flexible'],['flexible']
Modifiability,"is is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using what",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10914,refactor,refactor,10914,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['refactor'],['refactor']
Modifiability,"is set; ...; 164 qutip.settings.num_cpus = info['cpus']; 165 else:; 166: qutip.settings.num_cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using the builtin Python module multiprocessing.; 36 """"""; 37 __all__ = ['parfor', 'parallel_map', 'serial_map']; 38 ; 39 from scipy import array; 40: from multiprocessing import Pool; 41 from functools import partial; 42 import os. /Users/shahnawaz/dev/qutip/qutip/settings.py:; 32 ###############################################################################; 33 """"""; 34: This module contains settings for the QuTiP graphics, ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:2111,config,config,2111,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,1,['config'],['config']
Modifiability,"les in QuTiP follow the pep8 standard and wrap two newlines for top-level functions. I am in favor of the pep8 standard and have two newlines. @ajgpitch what do you suggest?. Please remove the helper function `count_filled` without the test if it is not required. We aim to test as much as possible and remove redundancy in code. About `__all__`, I will shift all the rest in a new PR and we can keep yours as it is now. Coming to the more important discussion regarding the `class` based implementation, I have started pushing for similar approaches in newer modules such as [qutip.models.piqs](https://github.com/qutip/qutip/blob/master/qutip/models/piqs.py). I am also working on a new non-Markovian method which requires a class. Something of that sort is already used in `qutip.nonmarkov.heom`. I understand that many of qutip's solvers are written to be isolated functions but that should not mean that we should not write code to fully use the object oriented framework Python provides. Moreover, I noticed that you have to rewrite wrappers for the functions anyways to deal with repeatedly calculating things such as `scattering_probability` which clearly can be made much more compact if we use a class based approach. I am not making this suggestion just for the minor performance improvement. It improves the organization of the code, allows greater flexibility in adding new things to an existing class and modifying it easily. In terms of user experience, this means less clutter in the code and verbosity of arguments. You can initialize something once and keep re-calculating things by dynamically changing the parameters and calling the `class` method. If it does not hurt to slowly shift in this direction then I think we should go for it. If there is an alternative reason for not having classes then please let us know as the cons @bencbartlett mentions has more to do with following qutip precedent than some fundamental disadvantage in performance or use. @ajgpitch @nonhermitian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384860713:1746,rewrite,rewrite,1746,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384860713,1,['rewrite'],['rewrite']
Modifiability,"lution that works for both. > * What is the advantage of this over using the existing superoperator representations?. I don't think there is one, per se, in the same sense that there's no strict advantage to superoperators over Choi operators over χ operators — each is useful in different contexts, such that QuTiP supports all three in order to allow users to pick the right representation for their problem. Similarly, operator-sum decompositions of channels are quite common and are useful in some special circumstances (e.g.: expressing a Choi-rank–sparse channel without requiring a 4^n × 4^n matrix). In the Quantum Development Kit, for instance, we use `qutip.to_kraus` to express user-supplied superoperators, Choi operators, and χ operators in terms of an operator-sum decomposition that is then passed to the underlying open systems simulator. While the operator-sum decomposition is quite useful internally to the simulator, that's not a detail that we want to enforce upon users, such that QuTiP's support for multiple superoperator representations is quite useful in presenting a user-friendly interface for configuring noise models. > * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?. I'm not sure I entirely follow, sorry?. > * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?. Perhaps, but at least for the operator-sum decomposition of channels, it would feel a bit weird to me to have superoperators, Choi operators and χ operators all have one Python type, but for Kraus representations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:2536,config,configuring,2536,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574,1,['config'],['configuring']
Modifiability,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2324,evolve,evolve,2324,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120,1,['evolve'],['evolve']
Modifiability,"m wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Pyt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2910,extend,extend,2910,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,1,['extend'],['extend']
Modifiability,"modules, also because in the other cases the title are self-explanatory. ; Regarding this comment:; ```; Function to build cython code from str, compile and import it.; Used by cQobjEvo.; cy/codegen.py does the same thing for specific solver; ```; could then this file by moved to `qutip/cy/`?. * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), block 24 online has a printed error `TypeError: __call__() got an unexpected keyword argument 'args'`, yet on my machine runs fine, it can be replaced. I opened a PR, also running the last blocks and qutip.about(), https://github.com/qutip/qutip-notebooks/pull/72. . * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), `Time for cte` could be more explanatory. Similarly elsewhere. * I wonder whether instead `QobjEvo`, `Qobjt` could be even more intuitive for the user. * I would really encourage you to write one notebook (or more), about the new functionalities of the stochastic solvers, as well as the old methods. This could be the to-go resource, beyond documentation, to understand how these stochastic solvers are now expanded and coherently defined. It does not need to be a lot of work, it can copy a lot of stuff from the development notebooks. It would be fundamental to have the solvers' master equations written down, explaining for each solver what each term is, e.g., the jump operator. Also, in `development-smesolve-tests`, the equations are already there for example. Block 23 is beautiful, and it could be reproduced in the tutorial. . * Similarly, a user guide entry would really enhance the adoption of these solvers. At a later stage, some more refined example applications could be provided. * Review is still ongoing, I will provide comments on the .py files and other solvers files. Help from other developers is welcome as these are massive changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:3849,enhance,enhance,3849,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['enhance'],['enhance']
Modifiability,"n my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`. Discussed more at the top.; - CuPy (CUDA operations on ndarray-likes) explicitly does not allow implicit conversion to `np.ndarray` (see cupy/cupy#3421) for performance reasons, but does implement `__array_ufunc__` and `__array_function__`.; - pydata/sparse (nd-sparse _arrays_ instead of scipy.sparse's sparse _matrices_): always implement `__array_ufunc__` and `__array_function__` because they are trying to be a sparse version of `ndarray`. By default, they do not implement `__array__` for performance/memory reasons, but they do allow turning it on by an environment variable. Do not implement anything:; - JAX (autodiff) tries really hard to replace numpy rather than interoperate with it; - scipy.sparse matrices are intended for use with a _matrix_ interface, not a broadcast-able _array_ interface. They specifically document that they will not provide this interface (see scipy/scipy#12279). Somewhat weirdly, they do have custom methods for some elementwise ufuncs, though (like `np.sin`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:7542,variab,variable,7542,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,1,['variab'],['variable']
Modifiability,"n you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wishes,; >; > Nathan; >; > Dr. Nathan Shammah; > Postdoctoral Research Scientist; > Theoretical Quantum Physics Laboratory; > RIKEN, Wako, Saitama, Japan; > www.nathanshammah.com; >; >; >; > On Sun, Feb 23, 2020 at 5:42 AM Boxi Li <notifications@github.com> wrote:; >; > > I have some detail information for the GSoC 2020 project ""Error; > mitigation; > > in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub; > > Wiki page. I post it here so if anyone finds it nice could copy it to the; > > Wiki page.; > >; > > I add some details based on the original description:; > > ------------------------------; > > 1. Error mitigation in QuTiP; > >; > > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > > quantum circuit simulator (which was a GSoC project) providing enhanced; > > features for a pulse-level description of quantum circuits and noise; > > models. A new class Processor and several subclasses are added to; > > represent different platforms for quantum computing. They can transfer a; > > quantum circuit into the corresponding control sequence and simulate the; > > dynamics with QuTiP solvers. Different noise models can be added to; > > qutip.qip.noise to simulate noise in a quantum device.; > >; > > This module is still young and many features can be improved, including; > > new device models, new noise models and integration with the existing; > > general framework for quantum circuits (qutip.qip.circuit). There are; > > also possible applications such as error mitigation techniques [1-3].; > >; > > The tutorial notebooks can be found at; > > http://qutip.org/tutorials.html#nisq. A recent presentation on the; > FOSDEM; > > conference may help you get an overview (; > > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:4572,enhance,enhanced,4572,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['enhance'],['enhanced']
Modifiability,"nfo on general resources to learn about QuTiP and more; references to the #3 project, i.e. your blog and the talk.; https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2020. Neill, Alex, if you have a lead, please add a HEOM project. Bests,. Nathan. Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com. On Tue, Feb 25, 2020 at 5:10 PM Boxi Li <notifications@github.com> wrote:. > Hi Nathan,; >; > I can't modify the Wiki page because I'm not a maintainer of QuTiP. And it; > seems that there is no way to make a PR to Wiki. I can also send you the; > markdown source code per email like this, but I’m not sure if it works as I; > expected.; >; > The following is the markdown source code:; >; > -----------------------------------; > ## 1. Error mitigation in QuTiP; > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > quantum circuit simulator (which was a GSoC project) providing enhanced; > features for a pulse-level description of quantum circuits and noise; > models. A new class `Processor` and several subclasses are added to; > represent different platforms for quantum computing. They can transfer a; > quantum circuit into the corresponding control sequence and simulate the; > dynamics with QuTiP solvers. Different noise models can be added to; > `qutip.qip.noise` to simulate noise in a quantum device.; >; > This module is still young and many features can be improved, including; > new device models, new noise models and integration with the existing; > general framework for quantum circuits (`qutip.qip.circuit`). There are; > also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:1095,enhance,enhanced,1095,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['enhance'],['enhanced']
Modifiability,"ng=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); I",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:1177,config,config-setting,1177,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152,1,['config'],['config-setting']
Modifiability,"o a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Instead, I have a nested list like `[L0, [L1, control1], ...]` where `L0`, `L1`, ... are super-operators. I should also note that I use `mesolve` both for Schrödinger equations and Lindblad equations (relying on `mesolve` delegating to `sesolve`), and the Krotov package uses `H` as a variable/attribute name to refer to nested-Lindbladians or nested Hamiltonians interchangeable. Sorry if that's causing a bit of confusion. I am ultimately interested both in open system and closed system dynamics interchangeably. > [...] In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:2282,variab,variable,2282,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['variab'],['variable']
Modifiability,"ocumentation of the data-layer isn't readily available yet (we weren't expecting interest this early!). It does individual detection on two different types, rather than creating a `Dispatcher` to handle the multiple dispatch over potentially different data types of the two inputs. I would imagine that a better form of organisation for this sort of routine, which will be able to handle arbitrary tensor-network operations, will end up being made up of two components:; 1. a `Dispatcher` version of something akin to `einsum`, with a couple of limitations; 2. a high-level wrapper function to handle the specific case of local multiplication, which examines the dimensions and target specifiers to produce the input to the `einsum`-like function, then calls the `Dispatcher` with this information. I think this form would likely be preferable for several reasons:; 1. it will allow arbitrary mixing of different data types (`CSR` complete space and `Dense` operator, or both `CSR`, or whatever), with the allowed conversions respecting the global dispatcher rules, not having this function use a different, special configuration; 2. it will mean that the function can also be implemented by plug-in data types (TF/CuPy/etc), installed separately to QuTiP; 3. it will be more general, and easier to maintain; the current `subsystem_apply`, `partial_transpose`, `ptrace`, `tensor_contract` and this can all become special cases of this backing `einsum`-like routine.; 4. after we've implemented new dimensions objects, we'll be able to use a more standardised description of how to refer to individual subspaces of a Hilbert space, which will provide a more consistent UX across the library. This is particularly important if we want this to work well with superoperators. Really, thank you very much for making the PR - I really am excited to see people with an interest in the new data layer! I'm sorry that I took quite so long to respond properly to it, and that when I have, I've ended up being so",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:3376,config,configuration,3376,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,1,['config'],['configuration']
Modifiability,"ommand python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File ""<frozen importlib._bootstrap>"", line 693, in _load; File ""<frozen importlib._bootstrap>"", line 673, in _load_unlocked; File ""<frozen impor",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:1121,config,configuration,1121,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,1,['config'],['configuration']
Modifiability,"omplicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me kno",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1576,variab,variable,1576,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,1,['variab'],['variable']
Modifiability,"or each stochastic collapse operator, but now it is also possible to do something more sophisticated, like in your milstein solver. I've edited your notebook so that it uses the standard (now modified) smesolve and your rhs functions for the milstein methods. http://nbviewer.ipython.org/6153688. Note that I still only use the rhs function for the contributions due to the stochastic collapse operators (both the deterministic and stochastic part), and it does not include the unitary part or the deterministic collapse operators (if those are given as well), so it is not quite what you suggested when proposing that the rhs should calculate \rho_{n+1}. Do you think this approach is reasonable, or do you see any problems with it?. Regarding your milstein implementation, it seems that it is only valid for homodyne detection, since your have hardcoded the d1 and d2 function into the rhs function. I've tried to separate the definition of the SDE (d1 and d2) from the implementation of the SDE integrator (rhs), and naively it seems like you could use the d1 and d2 functions in rhs_milstein to make it possible to use it with hetrodyne detection as well. Is there any difficulties in generalizing the milstein method and parameterize it in terms of d1 and d2 functions in this way?. I've also tried to use the smesolve_imp and smesolve_milstein with explicit=False in your original notebook, but I do not get resuls that agree with the other methods if I use these. Looking at the code for smesolve_imp, you do an inversion of some variant of the liouvillian to calculate Lsparse, what is the purpose of that calculation? And finally, I see you use expm in _smesolve_single_milstein_implicit: I think this should be avoided because it will be very computationally demanding for larger systems. If you are satisfied with how the new rhs functions work I'll merge the branch sme-rhs-restructuring into qutip master and then feel free to submit a pull request with your milstein rhs implementation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22088170:1998,parameteriz,parameterize,1998,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22088170,1,['parameteriz'],['parameterize']
Modifiability,"ossible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; >; > ### Expected outcomes; > - More devices defined in the `qutip.qip.device` module. At the moment, we; > have two models: spin chain and cavity QED. We would like to include some; > other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in `qutip.qip.device` and; > `qutip.qip.compiler`; > - Refactoring the circuit compiler to allow simple pulse scheduling, e.g.; > Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages or; > commonly used language e.g. through quantum assembly language (qasm); > ----------------------------------------------------------------; >; > Best; > Boxi; >; > From: Nathan Shammah<mailto:notifications@github.com>; > Sent: Tuesday, February 25, 2020 8:36 AM; > To: qutip/qutip<mailto:qutip@noreply.github.com>; > Cc: Boxi Li<mailto:etamin1201@gmail.com>; Author<mailto:; > author@noreply.github.com>; > Subject: Re: [qutip/qutip] More detailed information for GSoC 2020 project; > (#1184); >; > Hi Boxi,; >; > Can you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:2738,Refactor,Refactoring,2738,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['Refactor'],['Refactoring']
Modifiability,"quick note; we are still trying to decide about a few things, e.g., what to do about the units, i.e., whether to make hbar and boltzmann constant user definable parameters, or rescale the coupling and the cut-off frequency of the bath in a more sensible way to take them into account. I guess the latter is the 'more sensible' option, but will need to do it carefully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-112662390:188,coupling,coupling,188,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-112662390,1,['coupling'],['coupling']
Modifiability,"r a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments ca",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:1032,coupling,coupling,1032,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525,1,['coupling'],['coupling']
Modifiability,"r the qutip directory. Which; > gave me the following log:; >; > `running bdist_wheel; > running build; > running config_cc; > unifing config_cc, config, build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifing config_fc, config, build_clib, build_ext, build commands; > --fcompiler options; > running build_src; > build_src; > building py_modules sources; > building extension ""qutip.cy.spmatfuncs"" sources; > building extension ""qutip.cy.stochastic"" sources; > building extension ""qutip.cy.sparse_utils"" sources; > building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_ext; > customize UnixCCompiler; > customize UnixCCompiler using build_ext; > building 'qutip.cy.spmatfuncs' extension; > compiling C sources; > C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2; > -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; >; > compile options:; > '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:4043,config,config,4043,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['config'],['config']
Modifiability,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2834,variab,variables,2834,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,1,['variab'],['variables']
Modifiability,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3580,evolve,evolved,3580,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,1,['evolve'],['evolved']
Modifiability,"rence between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10192,refactor,refactoring,10192,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['refactor'],['refactoring']
Modifiability,"rules; 3. we treat multiplication as matrix multiplication, violating how `np.multiply` should behave. My main concern is point 1: I don't think that `Qobj` provides a similar object to an `ndarray` at all. Right now we _do_ use matrices underneath, but proposed additions to QuTiP such as symbolic `Qobj` and adaptive Hilbert spaces are compatible with the idea of ""abstract linear algebra objects"", but do not necessarily have a backing array. Point 2 is mostly an extension of that: I'm not sure there is a sensible way for numpy's broadcasting rules to be applied to quantum objects as they exist now, even without extensions. ## More control over dispatch: `__array_ufunc__` and `__array_function__`. See [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html), [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html) and [NEP 35](https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html). Later versions of numpy allowed greater control over how ufuncs get implemented, which was most recently extended in 1.16 to cover non-ufuncs like `tensordot`. These functions are intended for classes to define how ufuncs operate on their data, but implementors should still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (mostly elementwise operations or reductions). Several libraries implement only these, but _not_ `__array__`, but given my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:5574,extend,extended,5574,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,1,['extend'],['extended']
Modifiability,"s tests on all platforms. They pass for all besides Mac OS (similar error as for other PR). With `python setup.py install`, with `install` instead of `develop`, things seem to work. What it is unclear to me is why it reads that the QuTiP Version is `4.4.0.dev0+1a639d7a`, when I could not find this hash in here (or maybe I am confused). Now, after some tries with install and develop, I am on that version of qutip-dev. . To begin with, I am running the contents of the [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). Some comments below are relevant to the PR of the notebooks, https://github.com/qutip/qutip-notebooks/pull/71. * `development-qobjevo.ipynb`: Runs fine. ; * `development-qobjevo-adv.ipynb`: Runs fine. ; * `development-qobjevo-timing.ipynb`: Runs fine. * The notebook [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb) could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:984,adapt,adapted,984,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['adapt'],['adapted']
Modifiability,"s_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:3243,adapt,adapt,3243,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,1,['adapt'],['adapt']
Modifiability,"sistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex python scalar? At this moment, `qutip.data.add(dense, dense, np.array(10)` and and `qutip.data.add(dense, dense, tf.constant(10))` works just fine. I guess they work due to the `__complex__` method they implement. Furthermore `qutip.data.add(TfTensor, TfTensor, tf.Variable(10))` also works _and_ can be differentiated. I wonder this is intended behaviour. Supporting this behaviour would be desirable for qutip-tensoflow as functions that create a Qobj as a function of a scalar (such as `alpha` for `displace(N, alpha)` or `z` for `squeezing(a1, a2, z)`) could work with `tf.Variable ` instead if they do not assume at any moment that `alpha` and `z` are python scalars. This could be a huge bonus point for `qutip-tensorflow` or any other library (Jax or Pytorch) that implements auto differentiation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:2264,Variab,Variable,2264,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473,2,['Variab'],['Variable']
Modifiability,"site may help for future reference. On Wed, 13 May 2020 at 23:38, Eric Giguère <notifications@github.com> wrote:. > I did some tests and; > 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian; > matrices) (c's version Ok); > 2 - It happen when installing the scipy stack with pip but not when; > installing it with conda.; > 3 - It depend on the problem size, 64 seems particularly bad, usually it; > fails on the second call.; > 4 - I only got it in zheevr which is only used in brmesolve. But Nathan; > got it in other tests which use scipy's eigh.; > 4 - It happen in scipy in the fortan version of lapack:; >; > import numpy as np; > from scipy.linalg import eigh; > H = random_hermitian(64); > eigh(H) # Work fine; > eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; >; > Possible solutions (for zheevr):; >; > - Installing scipy with conda, the easiest solution, but not in our; > control.; > - Finding a way to link clapack from cython. Linking scipy's one would; > require good knowledge of scipy internals since only one cython interface; > is provided. Linking to another installation of lapack, but it would; > require the user to install lapack or install it with qutip. Both seems; > wrong to me.; > - For mac user, call scipy's eigh from cython i zheevr, slower but; > better than risking segfault.; > - Have the code directly in qutip. We can adapt it from OpenBlas:; > https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1197#issuecomment-628259492>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67AJF3WTZBCU4YWFY23RRMHMHANCNFSM4LCKXE6A>; > .; >; -- ; Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264:1662,adapt,adapt,1662,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264,1,['adapt'],['adapt']
Modifiability,"started looking into QuTiP only very recently, and I'm yet to start familiarising myself with its more intricate details and get to run the full set of tests, and investigate what kind of test failures occur. In the meantime, I'll generally share some (what I _think_ is) relevant experience in the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another con",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:1582,coupling,coupling,1582,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,1,['coupling'],['coupling']
Modifiability,"tigation techniques [1-3].; > >; > > The tutorial notebooks can be found at; > > http://qutip.org/tutorials.html#nisq. A recent presentation on the; > FOSDEM; > > conference may help you get an overview (; > > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > > Github Project page for a collection of related issues and ongoing Pull; > > Requests.; > > Expected outcomes; > >; > > - More devices defined in the qutip.qip.device module. At the moment,; > > we have two models: spin chain and cavity QED. We would like to include; > > some other commonly used planform such as Superconducting system, Ion; > trap; > > system or silicon system. Each model will need a new set of control; > > hamiltonian and a compiler that find the control pulse of a quantum gate.; > > This part is gonna involve some physics and study of commonly used; > hardware; > > platforms. The related code can be found in qutip.qip.device and; > > qutip.qip.compiler; > > - Refactoring the circuit compiler to allow simple pulse scheduling,; > > e.g. Restriction one pulses that can be turned on at the same time.; > > - Features to perform error mitigation techniques in QuTiP, such as; > > zero-error extrapolation.; > > - APIs to allow import quantum circuits from other software packages; > > or commonly used language e.g. through quantum assembly language (qasm); > >; > > ------------------------------; > >; > > Also, the last outcomes have some overlap with the last project. Although; > > I also find this circuit importation very important, I guess two projects; > > should not have overlap if they are both selected.; > >; > > —; > > You are receiving this because you are subscribed to this thread.; > > Reply to this email directly, view it on GitHub; > > <; > https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA; > >,; > > or unsubscribe; > > <; > https://g",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:6266,Refactor,Refactoring,6266,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['Refactor'],['Refactoring']
Modifiability,"tl;dr We should go ahead and change it according to PEP8. I vaguely remembered that. ```; string_one == string_two; ```. and. ```; string_one is string_two; ```. do something different. According to [post on stackoverflow](http://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python) ""=="" tests for value equality, while ""is"" checks for whether the variables point to the same thing. Since ""None"" is a singleton the two are the same (except for some [oddball cases](http://jaredgrubb.blogspot.sg/2009/04/python-is-none-vs-none.html)). The [post about the oddball case](http://jaredgrubb.blogspot.sg/2009/04/python-is-none-vs-none.html) also seems to suggest that ""is"" is faster. Anyway, it's a) safe to change and b) recommended, so we should do that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/10#issuecomment-10983787:378,variab,variables,378,https://qutip.org,https://github.com/qutip/qutip/issues/10#issuecomment-10983787,1,['variab'],['variables']
Modifiability,"ts calculations. The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms. These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it. Regards,. Paul; On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:. > Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?; > ; > I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the array[1, 10, 11]? ...; > ; > At this stage, I have to resort to the original author of the code, and would like to hear your opinions and detailed guidelines. I will write some test codes in Matlab first in the coming weeks, if I have time. Thanks for your response.; > ; > Cheers,; > Qi; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42092984:1953,variab,variables,1953,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42092984,1,['variab'],['variables']
Modifiability,"ttered_state` and `scattering_probability` into a single class. It is a major design change of course. @bencbartlett If you think it is a good idea to bundle both methods into a single class called `PhotonScattering`, I can help with that. In the spirit of your excellent notebook example, you can add the Hamiltonian generating function which can be passed to a `PhotonScattering` class. Each time you call the `scattering_probability` method of this class, you supply the arguments for the particular Hamiltonian, i.e., pulse_length, area, `n_emission` etc. This is similar to the wrapping function that you wrote for your `pool` processes in the notebook. I need to understand the physics a little bit more to ascertain which are the quantitites that would form the arguments for the scattering_probability function and which ones would be fixed for an experiment (hamiltonian for instance). But the overall idea is that you make a class for a particular scattering experiment, give it a fixed Hamiltonian function and keep the calculations flexible wrt to the parameters of interest (pulses, gamma etc). A prototype example would then be:; ```; from qutip.scattering import PhotonScattering; from qutip.scattering import hamiltonian_tls, hamiltonian_rft; ...; scatter = PhotonScattering(hamiltonian_tls, tlist, c_ops, zero_state = psi0, effective_hamiltonian = True); prob_scatter = scatter.scattering_probability(n_emissions, gamma, pulse_length, pulse_area); ```; For a different hamiltonian, the example would be:; ```; scatter = PhotonScattering(hamiltonian_spdc, tlist, c_ops_spdc, zero_state = psi0); prob_scatter = scatter.scattering_probability(n_emissions, pulse_length=pulse_len); ```; I will be happy to help with this and discuss if you are interested, @bencbartlett. Adding these small changes from your notebook example into the main code could make your module more general and flexible. It is just a design choice and is usually followed in many Machine Learning modules (sklearn) ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384566684:1150,flexible,flexible,1150,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384566684,1,['flexible'],['flexible']
Modifiability,"u supply the arguments for the particular Hamiltonian, i.e., pulse_length, area, `n_emission` etc. This is similar to the wrapping function that you wrote for your `pool` processes in the notebook. I need to understand the physics a little bit more to ascertain which are the quantitites that would form the arguments for the scattering_probability function and which ones would be fixed for an experiment (hamiltonian for instance). But the overall idea is that you make a class for a particular scattering experiment, give it a fixed Hamiltonian function and keep the calculations flexible wrt to the parameters of interest (pulses, gamma etc). A prototype example would then be:; ```; from qutip.scattering import PhotonScattering; from qutip.scattering import hamiltonian_tls, hamiltonian_rft; ...; scatter = PhotonScattering(hamiltonian_tls, tlist, c_ops, zero_state = psi0, effective_hamiltonian = True); prob_scatter = scatter.scattering_probability(n_emissions, gamma, pulse_length, pulse_area); ```; For a different hamiltonian, the example would be:; ```; scatter = PhotonScattering(hamiltonian_spdc, tlist, c_ops_spdc, zero_state = psi0); prob_scatter = scatter.scattering_probability(n_emissions, pulse_length=pulse_len); ```; I will be happy to help with this and discuss if you are interested, @bencbartlett. Adding these small changes from your notebook example into the main code could make your module more general and flexible. It is just a design choice and is usually followed in many Machine Learning modules (sklearn) where an experiment is abstracted in a class with global parameters (a Hamiltonian or propagators for instance) and then the methods of the class are used to compute things on-the-fly by supplying the variables of interest (gamma, pulse_area etc). We can still add the code in the current form but nevertheless I would like to discuss this once. This gives more functionality to the tool and could make it very flexible and easy to use. @ajgpitch @nonhermitian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384566684:2003,flexible,flexible,2003,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384566684,3,"['flexible', 'variab']","['flexible', 'variables']"
Modifiability,"uld still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (mostly elementwise operations or reductions). Several libraries implement only these, but _not_ `__array__`, but given my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`. Discussed more at the top.; - CuPy (CUDA operations on ndarray-likes) explicitly does not allow implicit conversion to `np.ndarray` (see cupy/cupy#3421) for performance reasons, but does implement `__array_ufunc__` and `__array_function__`.; - pydata/sparse (nd-sparse _arrays_ instead of scipy.sparse's sparse _matrices_): always implement `__array_ufunc__` and `__array_function__` because they are trying to be a sparse version of `ndarray`. By default, they do not implement `__array__` for performance/memory reasons, but they do allow turning it on by an environment variable. Do not implement anything:; - JAX (autodiff) tries really hard to replace numpy rather than interoperate with it; - scipy.sparse matrices are intended for use with a _matrix_ interfa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:6688,extend,extends,6688,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,1,['extend'],['extends']
Modifiability,"w the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inputs, that would be virtually impossible (or very close to that) to occur in practical scenarios. In any case, I'd strongly recommend performing a time-boxed exper",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:2080,coupling,coupling,2080,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,"['coupling', 'flexible']","['coupling', 'flexible']"
Modifiability,"which makes reading the code much easier, but bad because it adds unnecessary chaff which makes scanning lines take longer. I hadn't put much thought into it before, and I think I was just generally writing in my default style. #### Test ordering; I hadn't much considered this, but there are certainly ways of doing it. Essentially `pytest` goes through a few stages when you run `pytest` on the command line: discovery, generation, running, reporting, and it has lots of hook functions we can define to modify the state inbetween and during each of them. Default discovery is as you say: files in alphabetic order (I _think_ it's strictly shell globbing order, but generally that's alphabetical), then the contents of each file in order defined by the shared fixtures used. We tend not to need large amounts of state to be held in fixtures, so our files largely just run top-to-bottom. We can add in some logic into the collection-time hooks to re-order the tests. There's a `pytest` plugin called [`pytest-ordering`](https://github.com/ftobia/pytest-ordering), but it looks like it's not really actively maintained any more and the logic is pretty straightforwards, so perhaps not a terrible idea just to do it ourselves. Maybe I'm not javascript enough to enjoy a good micro-dependency?. It would also be quite nice if we could define the whole logical structure of the `qutip` package, to help keep everything in order as the package grows larger. By that I generally just mean the internal structure, though cutting down the amount of global names exported could also be done in a sort of organisation like this: we could get a little more aggressive at not exporting things like `enr_*` or `three_level_*` to the global namespace, but instead put them in submodules. While I think this isn't what you were asking, it's also quite easy to just run specific parts of the testing suite if you're doing it from the command line. You can do `pytest file.py` to run only those in a specific file, or ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-601793386:1925,plugin,plugin,1925,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-601793386,1,['plugin'],['plugin']
Modifiability,"would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1117,flexible,flexible,1117,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,1,['flexible'],['flexible']
Modifiability,"y given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactoring much of QuTiP to be more object-oriented will be a positive change to the framework. However, consider that: (1) properly rewriting this as a class-based module without losing functionality will take some time, (2) there are many other modules (for example, most solvers) which would benefit from being refactored into classes, and (3) rewriting these modules would be a breaking API change. . These reasons make me think it would be best to merge the current module now, including it in version 4.3 of QuTiP, and to refactor this (among many other modules) in version 5.0 of QuTiP. This option would make this module available quickly, would be most consistent with semantic versioning, and would keep this module's structure consistent with QuTiP in both pre-refactor v4.X and post-refactor v5.X.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:2860,refactor,refactoring,2860,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,5,['refactor'],"['refactor', 'refactored', 'refactoring']"
Modifiability,"y the implementation of a stochastic rhs function is relatively isolated from how the deterministic part is calculated (which right now is trivial, but which could become more complex when time-dependent systems are implemented). However, it also gives all the flexibility needed in the rhs function, and these deterministic rhs functions do not need to be used if it is not suitable in a particular stochastic rhs implementation. . I've added the changes to the rhs behavior to the https://github.com/qutip/qutip/tree/sme-rhs-restructuring and updated the gist with the variant of your notebook. http://nbviewer.ipython.org/6153688. Note that a few other things, like the rhs function signature, had to change in the process. I hope that this updated API will be flexible enough to let you implement implicit solver. Regards rhs implementation and d1,d2 function: Yes, I understand that not all possible rhs schemes might be compatible with the parameterization with d1 and d2 functions, but when it is possible it has the great advantage that the user do not need to worry about how the rhs is implemented, only define the SDE in terms of d1 and d2, and then possibly select a rhs solver using the solver argument to smesolve. This will not work in general for solvers like the milstein scheme, since it requires an analytical derivative (unless it can be evaluated numerically?), and in those cases it would be sufficient to implement problem specific rhs functions (like rhs_rho_milstein_homodyne etc). Regarding the use of expm: OK, I agree that it could be a nice method to have to be used on smallish system. However, since we are stepping with a small timestep dt, shouldn't it be sufficient to use an expansion of of expm as usual? Perhaps a second-order expansion would do if the first order isn't sufficient. Doing a full expm is fine too I guess, but if it can be avoided then the same method could be used on larger systems too. . Looking forward to seeing your new notebooks and the PR!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22156426:1819,parameteriz,parameterization,1819,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22156426,1,['parameteriz'],['parameterization']
Performance," /Users/shahnawaz/dev/qutip/qutip/__init__.py:; 33 from __future__ import division, print_function, absolute_import; 34 import os; 35: # Fix the multiprocessing issue with NumPy compiled against OPENBLAS; 36 if 'OPENBLAS_MAIN_FREE' not in os.environ:; 37 os.environ['OPENBLAS_MAIN_FREE'] = '1'; ..; 149 # cpu/process configuration; 150 #; 151: import multiprocessing; 152 ; 153 # Check if environ flag for qutip processes is set; ...; 164 qutip.settings.num_cpus = info['cpus']; 165 else:; 166: qutip.settings.num_cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:1703,Queue,Queue,1703,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,1,['Queue'],['Queue']
Performance," 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3562,optimiz,optimize,3562,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['optimiz'],['optimize']
Performance," br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (tau) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (Qobj) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (OO) ... ok; control.pulseoptim: Hadamard gate gradient check ... ok; control.pulseoptim: QFT gate with linear initial pulses ... ok; control.pulseoptim: QFT gate with linear initial pulses (bounds) ... ok; control: data dumping ... ok; control: unitarity checking (via dump) ... ok; control.pulseoptim: state-to-state transfer ... ok; control.pulseoptim: state-to-state transfer (Qobj) ... ok; control.pulseoptim: amplitude damping channel ... ok; control.pulseoptim: coupled oscillators (symplectic dynamics) ... ok; control.pulseoptim: Hadamard gate using CRAB algorithm ... ok; control.pulseoptim: Hadamard gate (loading config from file) ... ok; control.pulsegen: Check periodic control functions ... ok; control.pulseoptim: Hadamard gate with fixed and time varying drift ... ok; control.pulseoptim: Hadamard gate with fixed and time varying ctrls ... ok; correlation: legacy me and es for oscillator in coherent initial state ... ok; correlation: comparing me and es for oscillator in coherent initial state ... ok; correlation: comparing me and mc for driven oscillator in fock state ... ok; correlation: legacy me and es for oscillator in steady-state ... ok; correlation: comparing me and es for oscillator in steady-state ... ok; correlation: legacy spectrum from es and pi methods ... ok; correlation: comparing spectrum from es and fft methods ... ok; correlation: comparing spectrum from es and pi methods ... ok; correlation: comparing TLS emission corr., H td (str-list td format) ... ok; correlation: comparing TLS emission corr., H td (np-list td format) ... ok; correlation: comparing TLS emission ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:4439,load,loading,4439,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['load'],['loading']
Performance," conference may help you get an overview (; > > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > > Github Project page for a collection of related issues and ongoing Pull; > > Requests.; > > Expected outcomes; > >; > > - More devices defined in the qutip.qip.device module. At the moment,; > > we have two models: spin chain and cavity QED. We would like to include; > > some other commonly used planform such as Superconducting system, Ion; > trap; > > system or silicon system. Each model will need a new set of control; > > hamiltonian and a compiler that find the control pulse of a quantum gate.; > > This part is gonna involve some physics and study of commonly used; > hardware; > > platforms. The related code can be found in qutip.qip.device and; > > qutip.qip.compiler; > > - Refactoring the circuit compiler to allow simple pulse scheduling,; > > e.g. Restriction one pulses that can be turned on at the same time.; > > - Features to perform error mitigation techniques in QuTiP, such as; > > zero-error extrapolation.; > > - APIs to allow import quantum circuits from other software packages; > > or commonly used language e.g. through quantum assembly language (qasm); > >; > > ------------------------------; > >; > > Also, the last outcomes have some overlap with the last project. Although; > > I also find this circuit importation very important, I guess two projects; > > should not have overlap if they are both selected.; > >; > > —; > > You are receiving this because you are subscribed to this thread.; > > Reply to this email directly, view it on GitHub; > > <; > https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA; > >,; > > or unsubscribe; > > <; > https://github.com/notifications/unsubscribe-auth/ADPF67EWECDUIOQMTKK2N2DREGE2LANCNFSM4KZUPCQQ; > >; > > .; > >; >; >; > —; > You are receiving this because you authored t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:6425,perform,perform,6425,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['perform'],['perform']
Performance," could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being performed. . * I wonder whether `qobjevo_codegen.py` should stay there. It stands out from all other modules, also because in the other cases the title are self-explanatory. ; Regarding this comment:; ```; Function to build cython code from str, compile and import it.; Used by cQobjEvo.; cy/codegen.py does the same thing for specific solver; ```; could then this file by moved to `qutip/cy/`?. * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), block 24 online has a printed error `TypeError: __call__() got an unexpected keyword argument 'args'`, yet on my machine runs fine, it can be replaced. I opened a PR, also running the last blocks and qutip.about(), https://github.com/qutip/qutip-notebooks/pull/72. . * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), `Time ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:2023,perform,performed,2023,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['perform'],['performed']
Performance," passed `type` - nothing else is overwritten if passed explicitly - you could achieve all the same effects at approximately the same speed with correct application of the kwargs, such as; ```python; Qobj(data, dims=dims, copy=False, type='oper', isherm=...); ```; providing `data` is actually of a valid (`fast_csr_matrix`) format. Technically the `Qobj.data` attribute will be a new object that wraps the same numpy arrays as was passed, rather than the same `fast_csr_matrix`. In various forms, `expect` already does check the Hermicity, that's why `mc-dm` is careful to set it to avoid recalculating it. The expect functions in `qutip.expect` do this directly, and aren't aware of column-stacked density matrices - they'll just raise a TypeError. `mesolve` and `mcsolve` now bypass the `Qobj` stage and go direct to Cython - in 5.0 it might not be a terrible idea to route everything back through the `Qobj` form, since the performance issues there are solved (a column-stacked dense matrix can be directly wrapped by an f-ordered `Dense` type), and it's the natural central point of the code (and those parts are called from Python-space anyway, so no C concerns). Here though, the problem is actually that the expectation generator in `mesolve` correctly calculates the dtype of the output expectation array using both the state and the expectation operator, but then it does it incorrectly in the loop, and passes the hermicity down to Cython using only the expectation operator, which promptly throws out the complex part. So setting `fast='mc-dm'` in `Qobj` is a symptom of the same root cause as the problem here, rather than the cause itself. At the start of `mesolve` we don't assume that the state is Hermitian, but then inside the integration loop we do. We can still keep the speedup - if the output was created with a complex dtype, we can always safely say that we're passing in non-Hermitian operators, even if coincidentally at one timestep they happen to be anyway. See https://gith",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048:1159,perform,performance,1159,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048,1,['perform'],['performance']
Performance,"""""""; .................................................................................................................................../Users/nathanshammah/github/qutip/qutip/control/optimizer.py:1070: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working; elif not isinstance(self.pulse_generator, collections.Iterable):; ..............................................................................................................................................................SSSSSS.......................................................................................................................Segmentation fault: 11. kills nosetests, which do not even start doing QuTiP's tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-496380658:184,optimiz,optimizer,184,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-496380658,1,['optimiz'],['optimizer']
Performance,"**Summary of what was done:**. - Changes in floquet_master_equation_rates to make it faster.; - Corrected transposition errors in _floquet_master_equation_tensor_ and changes to make it faster. I also removed a line so that the ME is solved in the interaction picture, this implies a different basis change in the _floquet_markov_mesolve_ function.; - Correction in _floquet_markov_mesolve_. As explained in the point above, the Floquet-Markov ME was not being solved in the interaction picture, therefore I modified _floquet_master_equation_tensor_ and modified the basis change in _floquet_markov_mesolve_. This modification requires an additional variable in the entry of _floquet_markov_mesolve_ which can not be chosen by default. For the moment, if this variable is not given and _floquet_basis=False_, then the density matrix or expectation values are returned in the interaction picture, in the computational basis, and a warning message is sent. ; - Added integration options in: _floquet_modes, floquet_modes_t, floquet_modes_table, floquet_states_t, floquet_modes_t, floquet_wavefunction_t, fsesolve, floquet_master_equation_rates, fmmesolve_; - Added test functions to verify the dissipative dynamics:; a) Compare _fmmesolve_ and _mesolve_ for the cases: (NO drive but dissipation) and (Drive but NO dissipation); b) Compare numerical and analytical matrix elements for a driven-dissipative TLS with RWA. There are some places where the code could be modified to optimize the running time, especially in the basis change in _floquet_markov_mesolve_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949:1475,optimiz,optimize,1475,https://qutip.org,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949,1,['optimiz'],['optimize']
Performance,+1 on getting rid of the print statements. I think we can just drop them entirely -- users can just print their object if they want to see what was loaded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1811#issuecomment-1044423457:148,load,loaded,148,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044423457,1,['load'],['loaded']
Performance,"+1. This looks like a good PR to me. Just a quick note: We have had some side-effect issues when changing how isherm and other cached attributes are handled in the past, in particular with respect to performance. I used to monitor the performance over time with the continous-benchmarking suite in one of the respositories in the project, and that was sometimes useful to find unexpected performance hits. . Hopefully this PR will only improve performance, but it could still be worthwhile to check that for example the unit test suite does not take longer time on this branch than on master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130549106:127,cache,cached,127,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130549106,5,"['cache', 'perform']","['cached', 'performance']"
Performance,"--------------; TypeError Traceback (most recent call last); File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/pyplot.py:265, in _draw_all_if_interactive(); 263 def _draw_all_if_interactive() -> None:; 264 if matplotlib.is_interactive():; --> 265 draw_all(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/_pylab_helpers.py:131, in Gcf.draw_all(cls, force); 129 for manager in cls.get_all_fig_managers():; 130 if force or manager.canvas.figure.stale:; --> 131 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:1332,cache,cache,1332,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903,1,['cache'],['cache']
Performance,". **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are not physics-related:; - 6 are related to plotting or visualization utilities ; - 6 are `Distribution` classes or subclasses, which seem to be only used for visualization; - 6 are related to solver options or results; - 3 are low-level classes that users typically wouldn't interact with; - This leaves only 4 physics-related occurrences: ; - `Evolver` (in this module), which is not exported and which I might rename to `_Evolver` (this is necessary to be a class for cacheing purposes); - `Cubic_Spline`, which only has __init__ and __call__ methods, and thus could (should?) be refactored into a function (this class also doesn't interact with `QObj`s, so one could argue that it is not physics-related); - `eseries`, which represents an exponential expansion of `QObj`s and thus refers to something at least loosely physical; - `QObj`, which is the basic representation of a physical object; - This would mean that the proposed `PhotonScatterer` class would be the **only** exported occurrence of using a class to represent computations related to a `QObj`. I think there are points to be made for both sides, but I'm not sure that having a few extra helper functions or requiring slightly shorter function calls would be worth introducing what seems to me to be a big inconsistency in the use of functions vs. classes in QuTiP. Once again, thank you @sahmed95 for your suggestions to this module and I look forward to hearing everyone's thoughts on the main issue of c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:4546,cache,cacheing,4546,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['cache'],['cacheing']
Performance,".36s; Total run time: 5.51s; Total run time: 6.58s; Total run time: 9.64s; Total run time: 10.74s; Total run time: 12.29s; {'solver': 'pc-euler-2'}; Total run time: 1.54s; Total run time: 1.86s; Total run time: 2.50s; Total run time: 2.79s; Total run time: 3.36s; Total run time: 4.03s; Total run time: 4.98s; Total run time: 6.56s; {'solver': 'explicit1.5'}; Total run time: 5.28s; Total run time: 6.35s; Total run time: 7.74s; Total run time: 8.99s; Total run time: 10.34s; Total run time: 12.41s; Total run time: 15.40s; Total run time: 21.40s; {'solver': 'taylor1.5'}; Total run time: 3.30s; Total run time: 3.85s; Total run time: 4.52s; Total run time: 5.63s; Total run time: 7.22s; Total run time: 8.72s; Total run time: 9.51s; Total run time: 11.84s; {'solver': 'taylor1.5-imp'}; Total run time: 5.43s; Total run time: 6.81s; Total run time: 7.60s; Total run time: 10.05s; Total run time: 11.88s; Total run time: 12.88s; Total run time: 15.63s; Total run time: 22.31s. ```; ; **Minor issue: plots breaking notebook rendering**; Jupyter Notebooks have a broken rendering when cells with plots are run; refreshing the notebook sometimes works fine. This is sometimes fixed in the first place by adding; ```; plt.show(); plt.close(); ```; but not always. Maybe we can have a look at this minor issue in the development notebooks. . **Documentation**; It would really increase the adoption rate if the API doc and User Guide could be updated to highlight the stochastic solvers and new methods. The development notebooks are so well written that drawing from their examples should be simple. . Congratulations @Ericgig for this refurbishment, improvement, optimization and thorough benchmarking investigations of the stochastic solvers, which I hope will be widely tested by @nwlambert @ajgpitch @quantshah (and @fminga) for robustness once merged in the development master branch. I am merging this and the montecarlo split PR, hoping there are no incompatibility issues (#990 --> #991 --> #969).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990#issuecomment-500396003:6241,optimiz,optimization,6241,https://qutip.org,https://github.com/qutip/qutip/pull/990#issuecomment-500396003,1,['optimiz'],['optimization']
Performance,"/qutip-notebooks/pull/58), there are several instances where I create a 1- or 2-line helper function to multiprocess a parameter search of `scattering_probability` using `multiprocessing.pool.starmap`. . In my experience, implementing a parallelized parameter search will be much more difficult to do if `scattering_probability` is changed to become a class method. There are some [hacky workarounds to this](https://stackoverflow.com/questions/27318290/why-can-i-pass-an-instance-method-to-multiprocessing-process-but-not-a-multipro), but these add extra overhead to implementing multiprocessing and don't work with methods that are not functionally static. . Given that these scattering calculations are among the most computationally expensive in QuTiP, I don't think that making parallelism more difficult to work with is a direction we should go in. I am confident that, with significant effort, I can make a clean and parallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:1558,perform,perform,1558,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['perform'],['perform']
Performance,"15-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:2043,optimiz,optimizer,2043,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,1,['optimiz'],['optimizer']
Performance,"; ```; Map(Space(Map(Space, Space)), Space(Map(Space, Space))); ```; to; ```; Super(Space(Map(Space, Space)), Space(Map(Space, Space)), rep='super'); ```; and I definitely like having the superop rep included in it. The user is never ever meant to write any of this themselves, so the literal length shouldn't be too much of a problem. You'd still specify dimensions using the exact same list syntax that we currently use, it's just we'd immediately parse it into this internal representation and internally operate on this, because it's much faster. Essentially what I'm describing here is an abstract syntax tree for relevant linear algebra structures. We _could_ even have the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. Y",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:1480,perform,performance,1480,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,1,['perform'],['performance']
Performance,"========================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input lis",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:2222,load,loadparams,2222,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,1,['load'],['loadparams']
Performance,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:770,perform,performance,770,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192,1,['perform'],['performance']
Performance,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1677,perform,performance,1677,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739,1,['perform'],['performance']
Performance,"> Knowing the tensor structure is still necessary for enforcing the Hilbert spaces are of the correct dimensions, even if the resulting state can't be written as a product of states on individual spaces. I think there's a lot more design to do to work out a sensible data structure which can really take advantage of this lazy representation, but my morning-after reaction to this is that it's very non-trivial without a lot of code duplication.; > ; > It's easy enough to imagine how it will work for operators of structure `[scalar, oper, scalar] * [scalar, scalar, oper] -> [scalar, oper, oper]` - in this case the final result is fully expanded in the last two states, and not in the first. It's much trickier dealing with `[oper, scalar, scalar] * [scalar, oper, oper] -> [oper, scalar, oper]`. In this case, since there's a subspace in between them, you need a specifically ""lazy"" Kronecker product. I suspect that this would have to be supported via either a completely separate `tensor` mechanism, or the mechanisms which currently underpin the data-layer `kron` would have to be revisited.; > ; > At least at first, I think that's a very large undertaking, and it would really need a lot of careful design to ensure that we don't slow anything down, or balloon the amount of code to be maintained. Both your and Boxi's comments point to the fact that this probably needs to be something on top of Qobj as a QIP-state object rather than part of Qobj itself! Once the details on these changes are fleshed out, I shall certainly look into this. It could potentially be very useful to have a slightly more customized/optimized QIP state layer on top of Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320#issuecomment-658138964:1622,optimiz,optimized,1622,https://qutip.org,https://github.com/qutip/qutip/issues/1320#issuecomment-658138964,1,['optimiz'],['optimized']
Performance,"> Thanks @eendebakpt. This is a great improvement for a small change. I left one suggestion for adding a bit more of a description to the change log, but I think it looks good to merge. Are there any more changes you'd like to make?. I am creating a similar PR against dev.major. Perhaps there are more optimizations to be done (have not checked yet), but I think it is better to put it in a seperate PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615:303,optimiz,optimizations,303,https://qutip.org,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615,1,['optimiz'],['optimizations']
Performance,"> Thanks @jakobjakobson13. A few modules' tests fail, on all operating systems, https://travis-ci.org/github/qutip/qutip/jobs/746708587. I wonder why.; > ; I think I went a bit to far. Perhaps I will close this pull request and cut it down into smaller chunks. > By the way, what software did you use, `autoflake`?; >; No, `deepcode.ai` but I don't know really know how good or bad it performs in contrast to other static code checkers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1394#issuecomment-735719114:385,perform,performs,385,https://qutip.org,https://github.com/qutip/qutip/pull/1394#issuecomment-735719114,1,['perform'],['performs']
Performance,"> The issue I see with `BathExponent` is that it contain a `Q` which seems to be usually shared for one Bath. While the exponent themselves can share an instance, `_spreQ`, `_spostQ`, `_s_pre_minus_post_Q` and `_s_pre_plus_post_Q` will be independent for each exponent. I don't know how many exponent per Bath you expect, if it's 1~2, it could be fine, but if it get large, you are computing and storing too many copies of these. Usually the number of exponents is less than 10. I have thought about optimizing the `_spreQ` lists so that they share the instances of the superoperators if the underlying Q are the same, but it seemed a complication for not a huge benefit:. The shape of the RHS is `(block * nhe, block * nhe)` where `(block, block)` is the shape of `spre(Q)` and `nhe` is the number of labels in the hierarchy. `nhe ~ k**cutoff` where `k` is the number of exponents and `cutoff` is the maximum hierarchy depth. So the overall size of the RHS is `~ k**(2*cutoff - 1)` times the size of the `_spreQ` list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-965317784:500,optimiz,optimizing,500,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965317784,1,['optimiz'],['optimizing']
Performance,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:31,load,loading,31,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005,2,['load'],"['loaded', 'loading']"
Performance,">The compound assignment operators have different semantics,. I suggest to reconsider such a wording a bit more. :thought_balloon: I imagine that the discussed assignment variants should logically be equivalent. >which may change the behaviour of the code. Some differences are documented. :thought_balloon: Would you find any “effects” on the software run time characteristics desirable?. >… certain operations that need to perform a copy no longer do. How would you like to identify (and eventually mark) the source code places where in-place data modifications should be excluded? :thinking:. >We already do use compound assignments in many places where we absolutely want the operation to be in-place. Thanks for such a background information. >For immutable types on the left, …, the compound assignment has no difference (other than evaluating subscripts only once). :thought_balloon: Can this information trigger any further development considerations?. >…, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. How do you think about to clarify evolving development views any further by corresponding test cases? :thinking:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708:425,perform,perform,425,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708,1,['perform'],['perform']
Performance,"@Ericgig I'm just attempting some profiling with `cProfile` to make sure I'm optimising the right thing - do you know the best way to get it to work with the cython code. I've tried setting; ```; #cython: linetrace=True, profile=True, binding=True; #distutils: define_macros=CYTHON_TRACE_NOGIL=1; ```; But it doesn't appear to work.; When I use `pyinstrument` it appears that `_expect_csr_dense_ket` is the main performance bottleneck. This is probably because the function must iterate over all rows, even though most are empty. I think a COO format would be more suitable in this case - would you accept it if I added this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589:412,perform,performance,412,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"@arnelg and @cgranade, you are both raising good points here. I'm not exactly sure what the best solution for this particular issue is, but do tend to agree with @arnelg that we do not want functions that perform unexpected actions, if possible, and that explicit is better than implicit. However, ultimately, it has to be the docstrings that should resolve any ambiguities, because not all functions can be intuitive to everyone, since we all have different backgrounds and expectations. So if the current behaviour is clearly described in the docstring, it should also be an acceptable solution I think. But one important thing that @arnelg also alluded to is that if at some point we expect that we might want to use `composite(S, O)` to mean something different than `composite(S, to_super(O))`, then we should better not implement the operator-to-superoperator promotion implicitly in `composite` now. Since the `composite` function is brand new it might be a good idea at this point to avoid doing these implicit assumptions on how it will be used until various use-cases has been explored in more details. I absolutely agree that it is great to have discussions about these kind of design issues, and it's great that you both have taken an interest in this particular issue. I also agree that Qobj.dims is a bit obscure and not that flexible, and maybe insufficient for complex cases with mixes of operators, kets, superoperators along different subsystems. This would not be an easy thing to change, but having a discussion about the short-comings and possible solutions would be great. I've created a new page on the wiki for listing various issues and design short-comings in qutip:. https://github.com/qutip/qutip/wiki/Future-Design-Changes. Feel free to add to this page and edit what's already on it (and of course, propose solutions!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58190164:205,perform,perform,205,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58190164,1,['perform'],['perform']
Performance,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:865,perform,performed,865,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910,1,['perform'],['performed']
Performance,"@emilianomfortes Thanks! It looks good now. Is there anything we can do to make the sparse vs dense performance plotting block run faster? It has to run every time the documentation is built (i.e. on every PR) and it takes a minute or two to run locally (so likely longer on the GitHub action VMs). It's not so much of an issue by itself, but its easy for the length of the documentation build to get out of hand if we add a minute here and a minute there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1862#issuecomment-1125207449:100,perform,performance,100,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1125207449,1,['perform'],['performance']
Performance,"@hodgestar ; I added default values to options and a default `mcstep`. I added a doc-string entry for `integrator_options`, but please check it. About `mcstep` optimization for scipy's `ode`, I tested both the methods and there can be a factor 2 in timing between both, but it can be in both ways depending on the conditions. So I used `mcsolve`'s method for `zvode` and the new method for `lsoda`. This way, the default will run like `v4`, but you have an alternative when it's not ideal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294:160,optimiz,optimization,160,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294,1,['optimiz'],['optimization']
Performance,"@hodgestar I think it should work, but I never rendered retexet to html with sphinx, so maybe you could perform a quick check? (I travel to ireland tomorrow up until monday night, but im kind of excited for 4.7 so let me know, I can edit the file with my phone)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1862#issuecomment-1100042147:104,perform,perform,104,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1100042147,1,['perform'],['perform']
Performance,"@hodgestar I will merge this as is since it block the tests from passing everywhere. The situation with `except * nogil` is not perfect, but it's not a bottleneck in our computations. If you look at the generated code, the issue is only when calling an `except * nogil` function returning complex or void within another `nogil` function. Therefore I removed the nogil from function that called other nogil functions, not those who did the work. If you see optimisation I missed, please open another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168:152,bottleneck,bottleneck,152,https://qutip.org,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168,1,['bottleneck'],['bottleneck']
Performance,"@jakelishman this is great, also thanks @dweigand for this PR. I tried out the function and it is very fast and could be great for specific use cases. My idea was a bit more simple - precomputing the `coherent_dm` operators (using qutip.coherent_dm) and using the `expect` function. But that performs worse that the original `qfunc` as well as this implementation of course. So this is great. I would be happy to merge this but have one thought:. This new implementation is sacrificing the ease-of-understanding of how Q-functions are computed with a very efficient and fast, but complicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:292,perform,performs,292,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,1,['perform'],['performs']
Performance,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:234,load,loading,234,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,1,['load'],['loading']
Performance,"@jfeist @Ericgig I've added this to the 4.6.3 release milestone. The result of `enr_destroy` was not incorrect, but I'm sure users will appreciate the drastic performance improvement. Even 4s is a long time to wait at a Jupyter notebook prompt even before one starts to call `enr_destroy` often or allow more excitations.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1593#issuecomment-875447468:159,perform,performance,159,https://qutip.org,https://github.com/qutip/qutip/pull/1593#issuecomment-875447468,1,['perform'],['performance']
Performance,"@nonhermitian I went for the `overlap` solution, as timing using this approach were better than using the `c_op.matrix_element(f_mode_a, f_mode_b)` solution. For reference,. ```; from qutip import *. N = 20; f_mode_a = coherent(N, alpha=1); f_mode_b = coherent(N, alpha=0.5); c_op = destroy(N). for a in range(100):; for b in range(100):; c_op.matrix_element(f_mode_a, f_mode_b); ```. runs in 2.13s (± 0.03s). and. ```; from qutip import *. N = 20; f_mode_a = coherent(N, alpha=1); f_mode_b = coherent(N, alpha=0.5); c_op = destroy(N). for a in range(100):; ket_a = c_op * f_mode_a; for b in range(100):; ket_a.overlap(f_mode_b); ```; runs in 1.88s (± 0.04s). Additionnally, I replaced a manual `.dag()` construction with an `overlap` call in `floquet_state_decomposition`. Also, I have a few other changes to `floquet` module that I can contribute. I will open issues to discuss them in details. Finally, I got quite a large performance improvements by using `numba.jit` as most of the code of this module is pure Python and many `for` loops. This however requires the use of subfunctions and full numpy objects rather than sparse matrices. Not sure if this is something interesting or not. :/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/766#issuecomment-337263367:926,perform,performance,926,https://qutip.org,https://github.com/qutip/qutip/pull/766#issuecomment-337263367,1,['perform'],['performance']
Performance,"@nonhermitian could you please have a look at _pseudo_inverse_sparse when you have time, and see if you can think of any better way of doing this, from your experience with optimizing the steadystate solver? Would an iterative method make sense here? I basically run into memory problems quite quickly when using splu (which seems to be the most efficient method by far for this particular problem, according to my tests).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/272#issuecomment-67125235:173,optimiz,optimizing,173,https://qutip.org,https://github.com/qutip/qutip/pull/272#issuecomment-67125235,1,['optimiz'],['optimizing']
Performance,"@nonhermitian please review and test this PR. As far as I have seen it my test it works well, but it would be great if you could try this PR on some other mcsolve example. Perhaps paying special attention to possible performance regressions, although I think there shouldn't be any, but who knows.. With this PR mcsolve can also be used with the IPython.parallel framework. Here are some examples:. http://nbviewer.ipython.org/gist/jrjohansson/f37aa019080f8fb84c46",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66395472:217,perform,performance,217,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66395472,1,['perform'],['performance']
Performance,"@nonhermitian, @goerz: The lack of optimization in some `scipy.sparse` methods is indeed due to having a lot of formats to support and limited developer time. That said, we're always happy to accept faster implementations! The optimization for multiplying DIA * some sparse matrix would be especially nice.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-410124453:35,optimiz,optimization,35,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-410124453,2,['optimiz'],['optimization']
Performance,@nwlambert ; I think it depends on whether `sqrtm()` or `eigenenergies()` performs better (or less issues in general case) in `Qobj`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610:74,perform,performs,74,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610,1,['perform'],['performs']
Performance,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:660,perform,performs,660,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428,2,['perform'],"['performance', 'performs']"
Performance,"A few points which came up:. - We can make the solve call very similar to `mesolve` where the user specifies a Hamiltonian, the coefficients describing the system and the size of the system as an argument dictionary. ```; system = {""N"": 100, ""emmission"": 0.5, ""loss"": 0.1}; pisolve(H, tlist, c_ops, e_ops, args=system); ```; - However this only works for Hamiltonians constructed with some specific operators. As the method is for dicke states only, the distinction between this solver and `mesolve` should be stated clearly. This is to prevent someone trying to pass a generic Hamiltonian. - Checks have to be included to make sure that the Hamiltonian and the operators specified are proper for the dicke states. - Since the user will not be concerned with the matrix M which governs the evolution `dp/dt = Mp`, we should probably find better ways to represent it and perform the dot product to generate RHS. @nonhermitian We have the M matrix as a pure dictionary of {(row, col): val}. We can write our own function for the dot product just by using this dictionary. Or, is it better to convert it into a sparse matrix and use Scipy's dot product function ? Converting from the dictionary to sparse M has some overhead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-332725530:870,perform,perform,870,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-332725530,1,['perform'],['perform']
Performance,"A pull request would be most welcome. There are also two other functions in qutip.fileio that should probably be updated at the same time. Instead of using an if statement, I would write code like:; ```python; p = pathlib.Path(""filename""); ... # append suffix here; with p.open(...):; ... # load or save here; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324:291,load,load,291,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324,1,['load'],['load']
Performance,"A rationale for adding the operators to the language isn't the same as a reason to use them in a particular programme. The compound assignment operators have different semantics, which may change the behaviour of the code. For example,; ```python; >>> import numpy as np; >>> a = np.ones(5, dtype=np.int32); >>> a = a + 2.5; >>> a; array([3.5, 3.5, 3.5, 3.5, 3.5]); >>> b = np.ones(5, dtype=np.int32); >>> b += 2.5; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int32') with casting rule 'same_kind'; ```; Swapping to in-place operations can also mean that certain operations that _need_ to perform a copy no longer do. This can mean that a function or class may start holding a reference to an object that something else holds a reference too, so it might get mutated out from underneath it. We already do use compound assignments in many places where we absolutely want the operation to be in-place. For immutable types on the left, such as `tuple` or `int`, the compound assignment has no difference (other than evaluating subscripts only once). Technical reasons for _not_ doing it aside, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. It just creates churn of the code, and any change can introduce a new bug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972675136:720,perform,perform,720,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972675136,1,['perform'],['perform']
Performance,"About tests being very slow, I saw the following notice when I open the details:; ```; Please be aware travis-ci.org will be shutting down in several weeks, with all accounts migrating to travis-ci.com. Please stay tuned here for more information.; ```; I think we are still on `travis-ci.org`? Is this related to us? Maybe ""switch CI to GitHub Actions"" is more pressing than we thought.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1465#issuecomment-805920788:215,tune,tuned,215,https://qutip.org,https://github.com/qutip/qutip/pull/1465#issuecomment-805920788,1,['tune'],['tuned']
Performance,Absolutely - it already helped a load on `master` to catch pending deprecations and old code. As soon as we've got the warnings fixed on `dev.major` we'll turn it right back on.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1574#issuecomment-861857564:33,load,load,33,https://qutip.org,https://github.com/qutip/qutip/pull/1574#issuecomment-861857564,1,['load'],['load']
Performance,"Added optional argument `integrator` to choose between `propagator` or `mesolve` (also a `parallel={True,False}` argument). Realized there is probably not much to gain from `mesolve` returning a sparse matrix for large systems, however. This is because in the memorycascade method there is some postprocessing of the propagator using the `tensor_contract` method (written by @cgranade) which does not support sparse matrices, so it gets converted to dense anyway. Still `mesolve` actually performs a bit faster for small systems and small times, so still useful to be able to choose the method I guess.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/502#issuecomment-230115449:489,perform,performs,489,https://qutip.org,https://github.com/qutip/qutip/pull/502#issuecomment-230115449,1,['perform'],['performs']
Performance,"Ah, that seems like a good check. Given the current instability of Travis timings, I'll run a quick check on my local machine to see how this PR affects performance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130550000:153,perform,performance,153,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130550000,1,['perform'],['performance']
Performance,"All the same, I'd very much like to further reduce warnings. I've literally had Firefox crash trying to load the entire Travis logs.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/433#issuecomment-185792948:104,load,load,104,https://qutip.org,https://github.com/qutip/qutip/issues/433#issuecomment-185792948,1,['load'],['load']
Performance,An example is given in this gist https://gist.github.com/nathanshammah/f96f6c1db5c323243a4729467cb7351f. ; Some performance benchmarking was done in PR #1024.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1032#issuecomment-533145168:112,perform,performance,112,https://qutip.org,https://github.com/qutip/qutip/issues/1032#issuecomment-533145168,1,['perform'],['performance']
Performance,"As far as the ""known issues"" go, these are discussed in #484.; I don't think the issues I saw recently are the same as in that one.; ```; Intel MKL FATAL ERROR: Cannot load libmkl_avx.so or libmkl_def.so.; ```; I think this is just an MKL install problem.; It's difficult to test at the moment, as I don't seem to be able to create a conda env with mkl blas",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/872#issuecomment-394304854:168,load,load,168,https://qutip.org,https://github.com/qutip/qutip/issues/872#issuecomment-394304854,1,['load'],['load']
Performance,"Bumping an old topic with two major new considerations. Number one: Travis is [changing its pricing model for open source software](https://blog.travis-ci.com/2020-11-02-travis-ci-new-billing), and generally it seems like [it's going to become unfeasible for us](https://www.jeffgeerling.com/blog/2020/travis-cis-new-pricing-plan-threw-wrench-my-open-source-works). Over the past month or so, queue times on Linux builds have increased massively (from near-instant to up to 90 minutes), and the number of allowed concurrent builds has already limited the amount of testing we are able to do - we don't even have Windows tests because we couldn't fit them in. In around March 2021 we expect the old travis-ci.org that QuTiP is grandfathered onto to shut down completely, forcing us onto the new model on travis-ci.com. Number two: in November 2019, GitHub released their own CI, GitHub Actions. This is (as best as I can tell) completely free for open source, public repositories like QuTiP, and offers access to a large number of Linux, macOS and Windows containers. This completely free period of GitHub Actions might not last forever (you can imagine maybe they're just trying to drive adoption before increasing the cost), but especially with the new time pressure from Travis, this seems like the right choice for now. Our testing set up is fairly straightforward, so migrating to a new CI shouldn't be too difficult. I just wrote (#1429) a GitHub Actions workflow to build and distribute binary releases of QuTiP on Linux/Mac/Windows, and I'm pretty convinced by the power of their CI. It's got an awful lot of flexibility with a _lot_ of customisation so its initial learning curve is a little steep (or maybe I'm just not used to CI tools), but I'm impressed by what's available. I believe it comes with a degree of reusability as well; I think we can define a test as a single ""action"", and then reuse that in the PR-push workflow and the make-distribution workflow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/959#issuecomment-770455542:393,queue,queue,393,https://qutip.org,https://github.com/qutip/qutip/issues/959#issuecomment-770455542,2,"['concurren', 'queue']","['concurrent', 'queue']"
Performance,"But it seems to me that it would be best to avoid this type of issue when possible. For example, the squeezing operator is called squeez just to get around a namespace conflict. Otherwise people are bound to get errors that don't make any sense just because of the import order and then they will be emailing us. Of course we can not avoid all conflicts, but since loading scipy is so fundamental to what we do, having no conflicts with this package seems to be reasonable, at least to me. . On Wednesday, June 5, 2013 at 11:12 AM, Robert Johansson wrote:. > Yes, this can happen.. But I dont think this is a bug or error, although it can be confusing. There is always a risk of namespace collisions when importing different packages into the global namespace. For example, many conflicts of this kind occur between the math and numpy packages.. The only way to get around it safely is to import packages in different namespaces.; > ; > —; > Reply to this email directly or view it on GitHub (https://github.com/qutip/qutip/issues/25#issuecomment-18951570).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/25#issuecomment-18951920:365,load,loading,365,https://qutip.org,https://github.com/qutip/qutip/issues/25#issuecomment-18951920,1,['load'],['loading']
Performance,"Collaboration is open all the time, that's what open-source is for ;) It is required that all applicants have interaction with the community before applying so it is also kind of mandatory. And it will significantly increase the success probability of the application. Just notice that works done before GSoC won't give a reduction of the working load during the GSoC period (Google will check the process).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1457#issuecomment-794421929:347,load,load,347,https://qutip.org,https://github.com/qutip/qutip/issues/1457#issuecomment-794421929,1,['load'],['load']
Performance,"Could we just reach `Data` objects to be multiplied by a scalar so that the Tensorflow backend can accept multiplication by a `tf.Tensor` and either raise an error if it's a not a `1x1` tensor or perform the scalar multiplication if it is? It feels like this is a quirk of Tensorflow that scalars are represented by `1x1` matrices, so it would be nice if the tensorflow backend could handle that quirk itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-881323790:196,perform,perform,196,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-881323790,1,['perform'],['perform']
Performance,"For some reason my docs do not load on git. They work fine if loaded directly from my computer though. Seems some css files are not being found. A brief google search pulled up a variety of things. You seem to have had success with the 4.0.2 docs, so perhaps you can take a shot at uploading.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/649#issuecomment-285923373:31,load,load,31,https://qutip.org,https://github.com/qutip/qutip/issues/649#issuecomment-285923373,2,['load'],"['load', 'loaded']"
Performance,"Good spot. A lot of changes were made to the Optimizer class when the CRAB algorithm, I think this slipped in then. You will see on line 518 that the base class method passes the bounds as you suggest. Therefore the if you specify optim_method='l-bfgs-b' in any of the pulseoptim methods then your bounds should work and you will be using L-BFGS-B. . I'll create a pull request with this fix now though. ; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353#issuecomment-122956029:45,Optimiz,Optimizer,45,https://qutip.org,https://github.com/qutip/qutip/issues/353#issuecomment-122956029,1,['Optimiz'],['Optimizer']
Performance,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:322,bottleneck,bottlenecks,322,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489,2,['bottleneck'],['bottlenecks']
Performance,"Having `int64` integers for indexing could certainly be useful, although in this particular case I was tired/stupid, and trying to do something impossible. That being said, I wonder whether the use of sparse matrices in QuTiP could be encapsulated completely, allowing do drop in arbitrary (external) sparse-matrix implementations. Importing the desired implementation could happen dynamically at import-time. This would allow to use `int32`, `int64`, or infinite `bigint` implementations (if any exist), as well as allowing to switch between pure-python implementations and the standard cython-optimized ones. Pure-Python would obviously be slow, but it would get around the segfaults that happen occasionally (#674).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/853#issuecomment-382524680:595,optimiz,optimized,595,https://qutip.org,https://github.com/qutip/qutip/issues/853#issuecomment-382524680,1,['optimiz'],['optimized']
Performance,"Hello Nathan, in a couple of hours we will perform the final minor docstring improvements, since we reduced the Cognitive Complexity. Tomorrow is finally ready!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-992488933:43,perform,perform,43,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-992488933,1,['perform'],['perform']
Performance,Hey buddy. There is a much faster (100x or more) sparse solver in the `_mkl` folder. The call is `mkl_spsolve` and it is a replacement for the SUPERLU solver that comes with scipy. The mkl module is only loaded for the Anaconda and Intel Python distributions. So you will need to have an if statement to check for it. The setting `has_mkl` tells you if the module is found and can be loaded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/528#issuecomment-243981044:204,load,loaded,204,https://qutip.org,https://github.com/qutip/qutip/pull/528#issuecomment-243981044,2,['load'],['loaded']
Performance,"Hi @dev-aditya, did you try running the code with QuTiP 5.0.0? It is currently in a pre release which means you need to install it with `pip install --pre qutip`. This new version introduces many changes and since it is a pre release there may be some rough edges still. The main reason you will see a performance improvement for this issue is the new data layer implementation. In a nutshell, it now supports not only sparse arrays, already present in QuTiP 4, but also dense arrays (numpy-like arrays). Dense arrays are better suited for this operation and hence you should expect an improvement using them. I hope you can give a try to QuTiP 5 and feel free to let us know how it performs :smile:.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/818#issuecomment-1665893251:302,perform,performance,302,https://qutip.org,https://github.com/qutip/qutip/issues/818#issuecomment-1665893251,2,['perform'],"['performance', 'performs']"
Performance,"Hi @dweigand, this looks interesting. It would you be nice to push this forward, adding some tests for this and integrating @Ericgig suggested changes. I am wondering whether there is a more intuitive (explicit) option than `qfunc_amat `. Something like a Boolean `precompute`?. Writing some documentation for this, in https://github.com/qutip/qutip-doc, would allow users to discover this option more easily at http://qutip.org/docs/latest/guide/guide-visualization.html#husimi-q-function, it's very nice you have some performance checks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-536368295:520,perform,performance,520,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-536368295,1,['perform'],['performance']
Performance,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:245,optimiz,optimizer,245,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386,2,"['optimiz', 'perform']","['optimizer', 'performance']"
Performance,"Hi Louis,. There is work in development that will allow `QobjEvo` to be build from callback also, not just list. This will make callback work anywhere easily. . I was in the impression that H callback worked already for mcsolve. I rewrote part of mcsolve and broke it. Looking at your commit, I inverted `_funcrhs_with_state` and `_funcrhs`...; Sorry to have you take time to correct it. The 20x is big, but the list format allows for optimizations that are hard to do with a callback. A big one is that you don't need to create a new matrix/Qobj when calling `mul_vec`, just use it. With this code, I see a 20x between `mul_vec` and creating a Qobj a python function. . ```; import numpy as np; import qutip as qt. qoe = qt.QobjEvo([qt.qeye(3),[qt.destroy(3), lambda t,_:np.sin(t)]]); qoe.compile(). o1 = qt.qeye(3); o2 = qt.destroy(3) ; def H(t):; return o1 + o2 * np.sin(t). v = np.ones(3)+0j; %timeit qoe(0); %timeit qoe.mul_vec(0, v); %timeit H(0); %timeit H(0).data * v; ```. One optimization you could do is having the callback return a `np.array` instead of a Qobj. In `mcsolve`, this would probably be simple to implement and I expect some speed gain. But it can't really be officially supported in Qutip, for now. . ps. All those 'redundant' argument setting are for reusing the system (`ss`) in multiple call of `mcsolve` with different args, used in `correlation`. Using string coefficient, the compilation step can take a few second, so it is set to be able to reuse a compiled system, changing the `psi0`, `args`, `e_ops`, etc. This will become a less obscure feature in v5 when solver object are available.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634:435,optimiz,optimizations,435,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:384,perform,performance,384,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['perform'],['performance']
Performance,"Hi paul,. Thanks for the feedback. I think maybe Rob had originally included the mkl stuff, but I took it out when I was bug fixing. Will put it in, I didn't realize it gave such a big performance boost. thats cool. I will also follow your advice and stick in a finite frequency to make sure all the solvers work. . I had a poke around in discussion forums for numpy and scipy, and it seems like the problem is that they throw an exception when they decide L is ""exactly singular"" (which technically it is). Sometimes numerical rounding errors prevent this exception, as occurs in larger systems, or adding a finite frequency, so it tries to solve it anyway and succeeds, because the projector Q on the right-hand side guarantees a solution. Conversely, matlab will just throw a warning, and try and solve it anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/528#issuecomment-243988381:185,perform,performance,185,https://qutip.org,https://github.com/qutip/qutip/pull/528#issuecomment-243988381,1,['perform'],['performance']
Performance,"Hi!. About the comments: yes, absolutely I'll leave more. It's a bit silly that I haven't yet, since one thing that was frustrating me previously was not understanding what was trying to be done! I think as time goes by I'm getting a bit better about being clearer in the code - some of the earlier parametrizations I did were too aggressive because I wasn't used to the tools yet. The `test_control_pulseoptim` parts are very complex, in part because the underlying calling convention of that code is complex too. I'll try and add more comments to it to ease that along, especially in the part where I just defined a load of systems to test. That certainly should have been commented. There are general comments about what I was using the `pytest` tooling for in the commit messages, but I didn't necessarily want to leave ""intro to pytest"" comments throughout, because it would mostly crowd out the actual tests, and the `pytest` documentation online is probably going to be a better explanation than what I can do. I'm also learning `pytest` by doing this (I'd not used it before I opened the first PR)!. About the PRs: I'm happy with whatever workflow works best for you guys - I don't have any control over when the PR gets merged. It might be a little difficult for me to maintain two branches at once (i.e. if the first PR with ~10 tests is awaiting merging), because there's likely to be conflicts in `conftest.py` (in particular). Even if I branched the new PR off the previous one on the expectation that it would be merged, I'd have to keep adding merge commits into (or force-rebasing) the other branch to keep it up-to-date, which wouldn't be completely ideal in that it would make a bit of a mess in the git log. If you want to merge this one (after I've gone through and put some more comments in), I'm happy to start a new one. I can also start a new one on a new branch, I think it might just make a bit more of a mess than it solves. I think this one only got big because I had a goo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-591413241:618,load,load,618,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-591413241,1,['load'],['load']
Performance,"Hi, I was reading about builder patterns and came across this [discussion](https://stackoverflow.com/questions/11977279/builder-pattern-equivalent-in-python) which seems to suggest that builder patterns are not necessarily needed in Python. Instead, all the functions could probably be bundled into a single ```PulseOptimizer``` class and whatever the wrapper functions are doing right now can be methods of this class. The input arguments can be initialised in the __init__ of this class. This you could have something like. ```; from qutip.control.pulseoptim import PulseOptimizer. optimizer = PulseOptimizer(drift="""", ctlr="""", ....); crab = optimizer.opt_pulse_crab(args, ...); unitary_crab = optimizer.opt_pulse_crab_unitary(args,...); ```. @MichalKononenko - if you are suggesting something like [this](https://sourcemaking.com/design_patterns/builder/python/1) then perhaps it is that same as what I suggested on top.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/692#issuecomment-313407939:584,optimiz,optimizer,584,https://qutip.org,https://github.com/qutip/qutip/issues/692#issuecomment-313407939,3,['optimiz'],['optimizer']
Performance,"Hmmm... Well since we deal with complex numbers by default, perhaps it is best to use numpy by default and then mention that one can get a little better performance using cmath.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/154#issuecomment-45703141:153,perform,performance,153,https://qutip.org,https://github.com/qutip/qutip/pull/154#issuecomment-45703141,1,['perform'],['performance']
Performance,How does the performance of the using the C math functions compare to using cmath and the numpy functions?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/251#issuecomment-61602992:13,perform,performance,13,https://qutip.org,https://github.com/qutip/qutip/pull/251#issuecomment-61602992,1,['perform'],['performance']
Performance,"I agree that performing a ufunc like `np.sin(...)` on a `QObj` and getting an `np.array` back is not that useful since presumably one would like a QObj back (otherwise why not just call `.full()` and work with the resulting numpy array directly). Likely this is a breaking change for some people, so we should document whatever approach we take.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772330954:13,perform,performing,13,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772330954,1,['perform'],['performing']
Performance,"I apologize to all for the delay, but I just added checks for regression on this issue. They currently fail due to a problem with `to_chi` and multiple qubits. ``` python; ======================================================================; ERROR: Failure: TypeError (Incompatible Qobj shapes); ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Anaconda\lib\site-packages\nose\loader.py"", line 251, in generate; for test in g():; File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\tests\test_qobj.py"", line 671, in test_dag_preserves_superrep; yield case, to_chi(qobj); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 435, in to_chi; return to_chi(to_choi(q_oper)); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 432, in to_chi; return choi_to_chi(q_oper); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 258, in choi_to_chi; return Qobj(B.dag() * q_oper * B, superrep='chi'); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\qobj.py"", line 455, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes. ----------------------------------------------------------------------; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/375#issuecomment-152945134:447,load,loader,447,https://qutip.org,https://github.com/qutip/qutip/pull/375#issuecomment-152945134,1,['load'],['loader']
Performance,"I believe the issue is on lines 833-835:. ``` python. if ODE.t > tlist[k]:; ODE.set_initial_value(y_prev, t_prev); ODE.integrate(tlist[k], step=0); ```. removing these lines gives similar performance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64523119:188,perform,performance,188,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64523119,1,['perform'],['performance']
Performance,"I believe this is the only `-march=native` we have. It will cause problem if left here so it's better to remove it. . However it may create a bigger slowdown than expected. If you look at [qutip/cy/src/zspmv.cpp](https://github.com/qutip/qutip/blob/master/qutip/cy/src/zspmv.cpp), you will see low level optimization that only activate on certain cpus. This is the main function used in solver (mat*vec) and can be 30% slower or faster than than scipy's version depending on the situation. Without this low level optimization, we are essentially doing the same thing as scipy so should get similar times.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/949#issuecomment-463470158:304,optimiz,optimization,304,https://qutip.org,https://github.com/qutip/qutip/pull/949#issuecomment-463470158,2,['optimiz'],['optimization']
Performance,I believe we are not supporting any changes to the Fortran code now that the mcsolver is on par performance wise. Thus closing this question.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/213#issuecomment-186705504:96,perform,performance,96,https://qutip.org,https://github.com/qutip/qutip/issues/213#issuecomment-186705504,1,['perform'],['performance']
Performance,"I can reproduce this problem.; (Note: environment is different of my previous reply, but qutip is latest 4.6.2). I attached a notebook:; https://gist.github.com/KosukeMizuno/5f879603b6343a18fdf0dc50f3f8b7b0#file-checkpyx-ipynb. How to reproduce:; 1. run this notebook; - A `cqobjevo_compiled_coeff_xxx.pyx` file is generated at cell[2].; 2. save output by pickle (cell[4]); 3. load pickled file (cell[5]); - it succeeds.; 4. restart kernel; - At this timing, `pyx` file was automatically removed.; 5. run cell[5] (load pickled file); - it fails. ```; Exception ignored in: <function QobjEvo.__del__ at 0x000001E0295BC4C0>; Traceback (most recent call last):; File ""c:\users\mizuno\research\py38\lib\site-packages\qutip\qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-1-ca5f267c7a72> in <module>; 1 with Path('mesolvedat.pkl').open('rb') as f:; ----> 2 out2 = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_5082571634280'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770:377,load,load,377,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770,3,['load'],['load']
Performance,"I can't really see an application for checking whether two Gates are equal. Even if all the parameters are the same, but it will not be in the same place in the circuit, so it won't be doing the same job. This does not mean that there is not one. I just can't think of one. However if there exists a `__eq__` method, then it should just be checking whether the two gates would perform the same unitary operation, which I guess means comparing the name, arg_label and arg_value. If you want to check whether it is the same Gate in the network, then can you not use `is` as it should be the same object.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/612#issuecomment-270284097:377,perform,perform,377,https://qutip.org,https://github.com/qutip/qutip/issues/612#issuecomment-270284097,1,['perform'],['perform']
Performance,"I completely agree with you that random tests really aren't the right way to go in general, but right now our problem is that basically QuTiP's entire testing suite is based on randomised tests, and that's an awful lot of technical debt to overcome any time soon :(. . The `dnorm` tests have historically been a huge problem, even though basically nobody's worked on `dnorm` for a long long time now (for context, see in particular #880 and #874). We don't actually even know if the failures in `dnorm` are deterministic and reproducible, although it turns out that I had a brief look into this when I joined as a GSoC student about a year ago... I don't remember doing it at all!. I know this is super inelegant and not the perfect method, but it's kind of a nasty trade-off - I don't have time to really dig into `dnorm` (a topic I know almost nothing about) to work out an appropriate solution to temperamental errors, we do want `dnorm` to be tested since we're shipping it, and the slight flakiness keeps causing us test suite failures about 1 in 10 times. I'm somewhat opposed to fixing the random seed because having the variance over several test runs does actually help us cover more ground (eventually) - fixing it to a ""known good"" seed actually seems to me to be more of a mask of potential problems than this. Of note: the pytest plugin I'm using reports the number of reruns it performed in the analysis at the bottom - they show up in a yellow alongside the ""skips"" and ""xfails"" - so it's not completely hidden. I'd love to have a property-based testing suite like hypothesis up and running - that definitely seems like the proper solution to this in the end. In the meantime, I'm open to swapping to a fixed random seed if you think that's much better - testing is one place where I'm really aware of my lack of formal experience in software engineering, so I'm basically just learning as I go.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227:1392,perform,performed,1392,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227,1,['perform'],['performed']
Performance,"I do not think that much can be done for the mesolver. The update here ; just addresses the resetting of the ODE solver, which is not done in the ; mesolver. I still think that spawning ntraj processes is not a very ; efficient thing to do. So I am working on cleaning that up. However, ; you are correct, moving the ODE creation outside of the mc_alg routine ; does have little effect. > Robert Johansson mailto:notifications@github.com; > December 1, 2014 at 13:48; > ; > Nice speed up! Is there anything here that we could also benefit from ; > in mesolve? Or is it specific to mcsolve in that it mostly affect the ; > ODE restart?; > ; > I doubt that the initial setup of an ODE instance before spawning ; > processes would have any significant impact on the performance (note ; > that multiprocessing does not use threads, it uses processes, so there ; > is no sharing of ODE instances between processes). Creating the ODE ; > instance once in the parent processor, or N times in N processes in ; > parallel therefore should not make much difference, if any.; > ; > —; > Reply to this email directly or view it on GitHub ; > https://github.com/qutip/qutip/pull/264#issuecomment-65020496.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65020643:763,perform,performance,763,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65020643,1,['perform'],['performance']
Performance,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:473,load,loaded,473,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791,3,['load'],"['loaded', 'loading']"
Performance,"I don't think it breaks the functional API at all - in fact it almost makes it stronger, since everything is a ""function"" at every stage. This kind of partial application is classic part of functional programming. Perhaps I don't understand _why_ you want to move to a class-based API? I'd be quite strongly against having the user have to instantiate classes to do very simple parts like creating operators. Certainly in Python programming, I don't think a class-based interface is de facto the right sort to aim for, and procedural is much more ""Pythonic"". For one, it's a lot of unnecessary boilerplate for simple operations. It adds cognitive complexity for the advanced user to decide ""should I use `displace` or `Displacer`?"", and in the strong majority of use-cases, the operator creation is not a computational bottleneck so we'd be adding it for no gain. A lot of operators have no meaningful reason to live in a class, like `sigmax` and so on, so now you have a split between operators that need a class and operators that don't, or you do something really crazy like requiring the user to do; ```python; sx_builder = qutip.operators.SigmaX(); sx = sx_builder.get_operator(); sy_builder = qutip.operators.SigmaY(); sy = sy_builder.get_operator(); sz_builder = qutip.operators.SigmaZ(); sz = sz_builder.get_operator(); ```; when all they wanted was `qutip.sigmax(), qutip.sigmay(), qutip.sigmaz()`. Obviously that example is a bit facetious, but what benefit does the user derive from having to write boilerplate to access simple functionality?. All the operators already share a class in `Qobj`, and things like `displace` and `sigmax` are factory methods of `Qobj`. What shared functionality do the factory methods possess that means they should be classes?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293#issuecomment-646631332:819,bottleneck,bottleneck,819,https://qutip.org,https://github.com/qutip/qutip/issues/1293#issuecomment-646631332,1,['bottleneck'],['bottleneck']
Performance,"I dont think that there would be a performance issue. If everything builds​ fine, then that is what we should do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/647#issuecomment-279448031:35,perform,performance,35,https://qutip.org,https://github.com/qutip/qutip/issues/647#issuecomment-279448031,1,['perform'],['performance']
Performance,"I guess not. But my original motivation was to try to do the mcsolver in; cython. Perhaps the scipy blas calls work just as good in cython. I; already ran into these blas difficulties on the mac. You would think the; calling structure would be uniform by now.; On Aug 10, 2013 6:08 PM, ""Robert Johansson"" notifications@github.com; wrote:. > Now with a8b79f7https://github.com/qutip/qutip/commit/a8b79f7bd2ad58713e9ed7b104e204b155fcdc20it works again on my machine. Is there a big difference in performance; > between accessing the blas stuff through scipy instead of directly from a; > cython module? If not it would be good to let the scipy ppl worry about the; > linking to blas and not have to deal with that in qutip.; > ; > —; > Reply to this email directly or view it on GitHubhttps://github.com/qutip/qutip/issues/39#issuecomment-22436635; > .",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-22436693:494,perform,performance,494,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-22436693,1,['perform'],['performance']
Performance,"I had a quick play with the feature, for the cases I had stumbled on before, with `eigenstates()' ignoring default_dtype, using the scope of 'full' covers it now. I understand having this work with just 'creation' scope is problematic because you want to make sure the dtype is not used on results lists. heom+full breaks with dia and dense, as expected!. speaking of heom, manually converting the RHS to jaxdia and doing stuff it worked fine. i think generalizing the RHS construction in heom away from csr is probably very difficult without huge performance drop in the construction, so perhaps some kind of wrapper or option to do conversion of types after construction would be fine?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815:548,perform,performance,548,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815,1,['perform'],['performance']
Performance,"I had to move faster and complete the full implementation in a rather quick and unstructured manner for my lab. I will finish it and then systematically build this PR so that it becomes easy for review. I have a working implementation of the ICM model now and a partial implementation of [Pauli tracking](https://www.date-conference.com/files/proceedings/2014/pdffiles/05.6_7_ip2-19.pdf) which pushes all the corrections and measurement to the end of the circuit.; ### Circuit with a rotation gate (V gate). ![v](https://cloud.githubusercontent.com/assets/6968324/21744357/3fe6c324-d557-11e6-8829-7202ff6d3760.png). ### Pauli tracked ICM representation of circuit. ![v_p](https://cloud.githubusercontent.com/assets/6968324/21744360/48959432-d557-11e6-8a5e-02b47b33698f.png). Thus, we get a quantum circuit with qubit initializations in the begining, a mesh of CNOT gates in the middle and measurements in the end. This seems to be very useful as the starting point of topological quantum circuit optimization. Future work: . 1. Represent qubit initializations in some way. Right now I consider everything as a gate. (Perhaps make new objects for qubit intializations, measurement, correction etc.). 2. Better visualization such that all initializations, measurements and corrections can be stacked in one line. 3. Representing the information regarding P_dagger, T_dagger, V_dagger gate teleportation in some way. The difference is just based on the interpretation of the measurement. 4. Complete the Pauli tracking algorithm to get the gate sequence for correction based on measurement. Tests, tests and more tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-271102783:996,optimiz,optimization,996,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-271102783,1,['optimiz'],['optimization']
Performance,"I have noticed some performance benefits with openblas but nothing noticeable for the sparse matrix routines. Multithreading gets some extra performance but the scaling is sublinear for sure. Just a couple of percent. From what I understand many sparse routines are limited by memory bandwidth. This is usually discussed in the context of the spmv. The biggest benefit when going to openblas is the removal of the umfpack out of memory errors. I dont think this has anything to do with the actual openblas functions but somewhere in the build process (suitesparse, metis, or something) the memory limitation is removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/55#issuecomment-25365509:20,perform,performance,20,https://qutip.org,https://github.com/qutip/qutip/issues/55#issuecomment-25365509,2,['perform'],['performance']
Performance,"I have tried to address this in #464. It defaults to a dense method that runs about 10x faster. Also, as already discussed, one can use the MKL to get a performance benefit when the dimensionality becomes large.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/462#issuecomment-209203520:153,perform,performance,153,https://qutip.org,https://github.com/qutip/qutip/issues/462#issuecomment-209203520,1,['perform'],['performance']
Performance,"I have written a parallel spmv that performs quite well. Sadly, only compiles on linux since it uses openmp. Will create a pull tonight",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/438#issuecomment-215176723:36,perform,performs,36,https://qutip.org,https://github.com/qutip/qutip/issues/438#issuecomment-215176723,1,['perform'],['performs']
Performance,"I might oppose to the fact that it should be default. The reason is that majority of people don't read the documentation and don't know what ""segfault: illegal instruction"" means. It might better to note somewhere that `CFLAGS=""-march=native"" pip install qutip` will lead to 30% increased performance in certain scenarios.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/951#issuecomment-463772270:289,perform,performance,289,https://qutip.org,https://github.com/qutip/qutip/issues/951#issuecomment-463772270,1,['perform'],['performance']
Performance,I personally haven't used mcf90 for a looong time. If it is true that it does not give much of a performance improvement any more I think it makes sense to phase it out.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/439#issuecomment-221096657:97,perform,performance,97,https://qutip.org,https://github.com/qutip/qutip/issues/439#issuecomment-221096657,1,['perform'],['performance']
Performance,I see. `propagator` performed better with a system of d=2^5 in a simple test. I better do some testing of even larger systems then before merging this. Any thoughts on why `propagator` might be slower also for small systems and short integration times? Some overhead related to parallelization? Thanks for the info.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/502#issuecomment-230108497:20,perform,performed,20,https://qutip.org,https://github.com/qutip/qutip/pull/502#issuecomment-230108497,1,['perform'],['performed']
Performance,"I seems there is a few issues with Nonetypes in for loops, but otherwise this is a great speed up. We never got around to optimizing this function nor the floquet solver (I think) and it is about time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/336#issuecomment-94270233:122,optimiz,optimizing,122,https://qutip.org,https://github.com/qutip/qutip/pull/336#issuecomment-94270233,1,['optimiz'],['optimizing']
Performance,"I think it should be possible to do this within the pytest framework without touching the package `setup.py` or `MANIFEST`. [`pytest.fixture`](https://docs.pytest.org/en/stable/fixture.html#sharing-test-data) seems a natural choice for loading data. For file accessibility, [this](https://stackoverflow.com/questions/46019170/how-do-you-properly-integrate-unit-tests-for-file-parsing-with-pytest) might help. Porbably @jakelishman knows more about the natural way of doing this with pytest?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-655970508:236,load,loading,236,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-655970508,1,['load'],['loading']
Performance,"I think it would be great to have a fast implementation of tensor contraction. However, QuTiP has moved on since this PR and I think the right way to implement this now would be to add a new specialization to the data layer for tensor contraction (maybe something like einsum) and to implement that instead (or even just to re-implement methods for the new CSR representation). @IIAOPSW If you're up for giving that a try, that would be awesome. If not, I might close this PR and we can revisit it after QuTiP v5 alpha has been released. @IIAOPSW Separately, I've read through the code the PR, but I'd still like to get a high-level summary of the algorithm you're implementing (or a reference). Quite a lot of work has been done in optimizing these contractions in recent years, and it would be nice to implement a good algorithm in QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-983852684:733,optimiz,optimizing,733,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-983852684,1,['optimiz'],['optimizing']
Performance,"I think that typically you don't gain much by using more processes than the number of cores, even if hyperthreading is available. In some cases you even get a performance degradation, so that's the reason why we dont default to cores*threads. However if you want to you can set the num_cpu flag explicitly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/260#issuecomment-63587960:159,perform,performance,159,https://qutip.org,https://github.com/qutip/qutip/issues/260#issuecomment-63587960,1,['perform'],['performance']
Performance,"I think that you may have issues with xrange in Python3 as well. I believe it was dropped, as range in Python3 does what xrange does in Python2. I think the qutip philosophy is that we should be developing for Python3, but backwards compatible. As in this case, using range will have a performance hit in Python2, but not Python3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/358#issuecomment-128331704:286,perform,performance,286,https://qutip.org,https://github.com/qutip/qutip/pull/358#issuecomment-128331704,1,['perform'],['performance']
Performance,I think that's a good thing that we've tested that - we need to work out why performance is so bad on mac with Python 3.8.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1348#issuecomment-680004224:77,perform,performance,77,https://qutip.org,https://github.com/qutip/qutip/pull/1348#issuecomment-680004224,1,['perform'],['performance']
Performance,I think there are some optimized Cython routines which for some of the solvers which need cython in run-time. Not completely sure about it. Let me check.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/893#issuecomment-403675579:23,optimiz,optimized,23,https://qutip.org,https://github.com/qutip/qutip/issues/893#issuecomment-403675579,1,['optimiz'],['optimized']
Performance,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:481,perform,perform,481,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,1,['perform'],['perform']
Performance,"I understand completely!. I'd probably just go to `int64` with your internal CSR implementation for the moment. Would it be very easy to have the `int32`/`int64` boiled down to a single compile-time flag, for those people that compile QuTiP manually and feel they really need the smaller `int32` matrices? The pre-compiled pip/conda releases could be `int64`. That might be a simple way to provide some support for ""both"". Somehow, I thought that SciPy would put a lot more emphasis on performance, and do things like Kronecker products without conversion. It would seem that SciPy should be the place to really optimize the sparse linear algebra implementation, including all the possible combinations like `CSR * DIA`. Then everyone could build on top of that, making custom sparse-matrix implementation unnecessary. Maybe when someone gets some serious funding for working on QuTiP, encapsulating all of this better would be doable. So, just something to keep in mind before bolting on too many things onto the existing custom implementation (like multiple sparse and full storage formats). Once you open up that can of worms, it just might be better to re-design `Oobj.data` to have a very broad base (e.g. SciPy), and keep the custom CSR as an optional, highly efficient implementation for the special case, maybe in a separate package. Either way, it's going to be a lot of work, and not something for a minor-version release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384094285:486,perform,performance,486,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384094285,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"I wanted to follow up on the previous message. Are there indeed important performance reasons why basis(N, n) is by default implemented densely:. `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. as opposed to . `dtype = dtype or settings.core[""default_dtype""] or _data.CSR` ?. I similarly have run into issues where much of my existing code using collapse operators of the form `basis(N, n) * basis(N, n).dag()` takes significantly longer to run (or runs out of memory) in 5.0.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978:74,perform,performance,74,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978,1,['perform'],['performance']
Performance,"I was not referring to the implementation, I agree that the method you implemented is clearly much better, because as you say it only calculates matrix-vector product and trace in one go. However, you could have kept the same function API as previous cy_expect_rho_vec function and I doubt it would make any difference in the performance (perhaps a a small difference, and in that case we can keep both, but then the old cy_expect_rho_vec should use the same implementation as the one you suggested for cy_expect_rho_vec_fast).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/56#issuecomment-25358782:326,perform,performance,326,https://qutip.org,https://github.com/qutip/qutip/pull/56#issuecomment-25358782,1,['perform'],['performance']
Performance,"I will have to go back and take a look, but I could not get the compiled gcc code to go faster than the intrinsics. Also the plain c code version under clang was quite slow, sometimes performing worse that the Cython version. . Also note that the vector data in the spmv is fetched out of order, so I am not sure if grabbing multiple elements as can be done in AVX is going to give a performance benefit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-254813399:184,perform,performing,184,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-254813399,2,['perform'],"['performance', 'performing']"
Performance,I will take a look. That module underwent some optimizations that may be the cause.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/572#issuecomment-265288312:47,optimiz,optimizations,47,https://qutip.org,https://github.com/qutip/qutip/issues/572#issuecomment-265288312,1,['optimiz'],['optimizations']
Performance,"I would agree with what @quantshah had said. Builder patterns are useful in those languages like Java, where named parameters is not in-built. All functions bundled into a single class would be better alternative. This would help when adding new methods that differs in optimization algorithm to the class.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/692#issuecomment-612210011:270,optimiz,optimization,270,https://qutip.org,https://github.com/qutip/qutip/issues/692#issuecomment-612210011,1,['optimiz'],['optimization']
Performance,"I'm glad you like! As for squashing, I think that can make sense, yeah. I'd like to hold off on doing so with this PR I have the current test failures fixed (seems as though the difference-of-unitaries optimization still needs a bit of work). After that, though, I agree that'd make for a much more legible commit history.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/456#issuecomment-198569367:202,optimiz,optimization,202,https://qutip.org,https://github.com/qutip/qutip/pull/456#issuecomment-198569367,1,['optimiz'],['optimization']
Performance,I'm not too sure how to perform cascading PRs on a forked repository ... ?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2012#issuecomment-1291128875:24,perform,perform,24,https://qutip.org,https://github.com/qutip/qutip/pull/2012#issuecomment-1291128875,1,['perform'],['perform']
Performance,"I'm wondering whether setting `auto_tidyup` per data type is a good idea? One expects the mathematical operations performed by different data backends to give the same results but setting `auto_tidyup` to `[""CSR""]` by default will break that assumption quite badly. For example, matrices might become singular when sparse and not when dense. There is also a danger of making some benchmarks artificially fast. If we're going to compare backends, we should probably look at both backends with tidyup on or off. Is there a reason that tidyup cannot just be specialized for the new backends that need it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1610#issuecomment-881301573:114,perform,performed,114,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881301573,1,['perform'],['performed']
Performance,"I've just noticed that @BOBO1997's [proposed solution](https://github.com/qutip/qutip/issues/1497#issue-855992475) is effectively the same as what I've implemented in my PR. I also like that his solution takes care of possibly unsorted inputs - I've borrowed that idea and updated my PR accordingly. Thanks, @BOBO1997!. I've also noticed that there are multiple instantiations of the same `gate` object upon each loop iteration, but I suspect those probably need to be kept distinct, unless the desired behaviour would be that changing one of those objects affects equivalently the other ones. In my PR I have the gate instantiation behaviour as it originally was (i.e., not adding references to the same `gate` object, but creating a new object upon each iteration). Please, let me know if this should be changed to perform only one instantiation and insert multiple references to the same object instead. @BoxiLi, I hope my #1892 doesn't interfere with https://github.com/qutip/qutip-qip/discussions/15. Please, feel free to close/reject the PR, if it does.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497#issuecomment-1124338701:817,perform,perform,817,https://qutip.org,https://github.com/qutip/qutip/issues/1497#issuecomment-1124338701,1,['perform'],['perform']
Performance,"I've lost the plot a bit with a whole load of changes to `Coefficient` now merged into this PR. Is there a chance we can split that out into its own PR?. I would expect `QobjEvo.__call__` to be thread-safe/re-entrant. The fact that coefficients seemingly don't support this immediately is worrying to me. A simple call like that changing ""global"" state of the object is dangerous; it has a habit of leaking out even in single-threaded applications, just like the bug I described previously with a call to `mesolve` modifying an existing `QobjEvo` in place. In this case I don't see an immediate bug, but it's very non-obvious behaviour and it would be easy to accidentally introduce one in it in the future (or maybe I just can't think of one now). Having `_BaseElement` be mutable makes all time-dependent operations of `QobjEvo` unresolvably thread-unsafe without copying on every operation. That said, looking again, I'm not sure I understand `_BaseElement`: it seems like `_EvoElement` and `_FuncElement` do entirely different things on `call`? What's the purpose of it, and if we put all speed considerations aside what would the signature and behaviour of `_BaseElement._call` be?. Could you write some docstrings on all the elements to explain their use-cases as well, so we've got it all stored for the future?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122:38,load,load,38,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122,1,['load'],['load']
Performance,"If it helps in the future, you can use `pycodestyle` (available in `pip` and `conda`) to check pep8 compliance on your end before pushing a commit. As to the actual command, we might not actually want to remove the usage of `convert` - it's quite possible that a lot of people are still using ImageMagick 6, since for most people it's just a dependency that got installed by something else, and isn't frequently updated. `qutip` doesn't list it as an official dependency, so it wouldn't get updated on our behalf. We could catch which version of `ImageMagick` to use with something like; ```python; def _magick_comamnd():; for command in ['magick', 'convert']:; try:; subprocess.run((command, '--version'), capture_output=True); return command; except OSError:; pass; raise FileNotFoundError(""Couldn't locate system ImageMagick""); ```; and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; ```python; subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); ```; or something like that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473:840,cache,cache,840,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473,1,['cache'],['cache']
Performance,"If you click into ""Files changed"" you can just tick the files as you've looked at them. To make it easier for you, I'd suggest having a copy of the old version next to them and reading the full commit message, because I usually explain what I'm doing in them and why I'm doing it that way. If you're worried about the size of the PR in total, then I'd strongly recommend _not_ squashing this PR if/when it's merged, but instead just rebasing it onto `master` or doing a direct merge. That way it doesn't look huge, it looks like a series of commits which each change one file, which is what you'd get if the PR was initially split. The review doesn't end at the point the code is merged - somebody in the future may very well want to see why I made certain changes. I know I've spent a long time looking through the old `git` logs to work out why tests were the way they were, and it's always much much more difficult when you've got one of those squash commits with like 30 sub-parts. The commits in this PR are already modular, and with the exception that 7a0d6e6 could be squashed into ; 1d60b46, they all represent an isolated unit of progression and there aren't any ""work in progress"" commits. I didn't perform that squash locally because I would have had to force-push over 10+ commits. Squashing the PR does make sense when there are a lot of wip commits for a small unit of work, but for a very large unit of work like this one, it's much better to interactive rebase to keep it neat locally (I've already done that for the most part), and never push wip commits in the first place.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-605494875:1209,perform,perform,1209,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-605494875,1,['perform'],['perform']
Performance,"If you're concerned about the solvers, a) they skip tidyup til the end anyway and b) _technically_ the computational complexity of CSR * dense vector is identical to tidyup (though tidyup is a little more cache efficient), but really it's the constant factors that could kill you for small systems. For example, the ""naive"" way of implementing a relative tolerance would take the absolute value of a complex number, but that involves a floating-point square root, which is a very slow operation. That's likely partly why the current version compares real and imaginary components separately, even though the sparsity structure is only improved if _both_ go to zero. In a two-pass operation you'd sqrt twice for every entry (naively - all the square roots are very avoidable), and I'd start to worry that that really _could_ dominate small system operations. Or maybe you should just ignore me when assigning ""good first issues"" - I'm probably too opinionated about performance characteristics without enough experience at managing other people's code!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141:205,cache,cache,205,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"ImageMagick is only mentioned in our tutorial page and not listed elsewhere. So we didn't specify a required version for it. . > We could catch which version of `ImageMagick` to use with something like; > ; > ```python; > def _magick_comamnd():; > for command in ['magick', 'convert']:; > try:; > subprocess.run((command, '--version'), capture_output=True); > return command; > except OSError:; > pass; > raise FileNotFoundError(""Couldn't locate system ImageMagick""); > ```; > ; > and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; > ; > ```python; > subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); > ```. This solution looks neat. One minor thing is that maybe we should use `check=True` instead of `capture_output=True` since the latter one is only available from Python 3.7+. Despite those has already been discussed above, the plot sill does not work for me. I find the following lines also wrong on Windows; ``` python; os.system(""rm -f %s.aux %s.log"" % (filename, filename)). os.system(""mv %s-tmp.pdf %s.pdf"" % (filename, filename)); ```; because `rm` and `mv` are not Windows command. We should probably replace it by python script `os.remove` and `os.replace` to make it system independent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793:485,cache,cache,485,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793,1,['cache'],['cache']
Performance,"In [3e530c0](https://github.com/qutip/qutip/pull/1854/commits/3e530c01d9cf686fc195c38c2cc26d0ee5bccfa8) I borrowed @nonhermitian's suggestion and switched to `concurrent.futures.ProcessPoolExecutor` in the hopes that the core Python developers have figured out how to make that works on Windows too. It also simplifies the management of the pool of workers, which is a win by itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175:159,concurren,concurrent,159,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175,1,['concurren'],['concurrent']
Performance,"In general in pytest we use the bare keyword `assert` for almost everything. All the functions in `np.testing` are from the ""before times"", when test tooling wasn't as good as it is nowadays - they were a big improvement on available warning messages back before 2015. Nowadays, though, `pytest` does introspection on assertion failures, so it has even better message reporting than the `np.testing` functions, and it lets you write much clearer code. For example, `assert_equal(x, y)` is much better spelled in pytest as `assert x == y`, because it's much faster to read and pytest does better error reporting for it. Similarly, testing for exceptions is better with; ```python; with pytest.raises(ValueError):; call_that_raises(1, ""hello, world""); ```; as opposed to the numpy form `np.testing.assert_raises(ValueError, call_that_raises, 1, ""hello, world"")` - the pytest one is much easier to read, and the error message is better. The only numpy one we still use is `np.testing.assert_allclose` when we're comparing several numpy arrays. That's just because `pytest` doesn't have a good function that's aware of multidimensional arrays (at least not one that I know). This file still has a load of old numpy testing code in it (e.g. `np.testing.assert_equal`) because it was written quite a long time ago, when that was the recommended way of doing things. We're changing over slowly, so we can take advantage of all the nice features of pytest. In this case, I changed `np.testing.assert_allclose(x, y, atol=tol)` to `assert abs(x - y) < tol`. I removed `np.testing.assert_allclose`, because that gives the mistaken impression that we're comparing arrays (we're not, we're comparing two scalars). I could have changed it to `assert x == pytest.approx(y, tol=tol)`, except in this case the test file hasn't been converted to `pytest` style yet, and I wanted to keep the total change of this PR as small as possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-822737671:1193,load,load,1193,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-822737671,1,['load'],['load']
Performance,"In general the biggest thing you should consider is readability, and to be fair, that's a little subjective. You're welcome to comment on my PR if you think I've done anything that's unreadable. You can scope fixtures at whatever level is appropriate. In this particular case, I scoped the `dimension` fixture at the module level, because there's loads of places that needed to test varying dimensions, and it's very convenient to define it just once. In the few cases where we needed to override that (e.g. in `dnorm`), I overrode it by providing a definition in a tighter scope - either at class level or per-function (via `pytest.mark.parametrize` directly). The correct scoping just depends a lot on the type of tests you're writing - if you're going to have to overwrite something constantly then module scoping isn't good, but if you have lots of different functions to test, and every test for a given function will want the same parametrisation, then class scoping might be a good choice. If you only need the parametrisation once, then it's best to put it right next to the place it's used (like in the case of mine that you've highlighted). It means that if you've opened that file to read the tests, then everything you need to understand `Test_fidelity.test_known_cases` will be on your screen if you just scroll to it. That makes it much easier for the next person who has to come along to edit your code. I used a couple of temporary variables in that case just to aid readability - my cases wouldn't have nicely fit on one line if I'd shoved the `qutip.basis(2, 0)` stuff inside the `pytest.param` constructors, and it would be hard to read. This way you can easily verify that the code is correct bit-by-bit; you can see clearly that the names are descriptive and match exactly what they say, and that means you can trust them when they then appear in the parametrisation. I won't pretend to be perfect at any part of coding, and particularly testing. I rewrote all the testing files s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706:347,load,loads,347,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706,1,['load'],['loads']
Performance,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:30,cache,cached,30,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135,1,['cache'],['cached']
Performance,"It appears that they have removed hw.cpufrequency on these things (About this mac doesn't show a freq. either). I don't know what is their policy in this regard but I did find these two related issues: https://github.com/giampaolo/psutil/issues/1892 and https://github.com/shirou/gopsutil/pull/999. My workaround was to comment out the code and hard-wire a random value in there :-) A quick grep didn't seem to show any use of cpu_freq elsewhere in the code but then I didn't look too much in depth. I don't personally use qutip, my partner does, she's the physicist, I'm just the geek helping hand :). It does look like this code could use some error handling and put some ""reasonable"" default values if the sysctl's fail indeed. Happy to test a patch and report. She's currently away so there will be some latency (I can occasionally ssh into her laptop but it takes preparation), so I can't really submit a PR myself at this point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664:808,latency,latency,808,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664,1,['latency'],['latency']
Performance,It certainly look interesting. Fast diagonalisation of Liouvillian operators is certainly something we could make good use of. However we should wait for v5 of qutip. Some of the new features we are working on match well with this algorithm and should have a visible impact on performance.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1833#issuecomment-1065202673:277,perform,performance,277,https://qutip.org,https://github.com/qutip/qutip/issues/1833#issuecomment-1065202673,1,['perform'],['performance']
Performance,"It looks as though NumPy keeps some metadata on MKL if it was compiled with MKL support. The `numpy.__config__` module in particular gives a path to the directory that NumPy loads its MKL libraries from. On my Linux box, for instance:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_intel_lp64', 'mkl_intel_thread', 'mkl_core', 'iomp5', 'pthread']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['/home/cgranade/anaconda/lib']; ```. The case seems to be worse for Anaconda on Windows (naturally), with `C:\aroot\stage\` taking the place of the actual Anaconda root:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_core_dll', 'mkl_intel_lp64_dll', 'mkl_intel_thread_dll']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['C:\\aroot\\stage\\Library\\lib']; ```. In the case that NumPy is compiled without MKL support, it seems to just omit the `mkl_info` dict entirely:. ``` bash; cgranade@berith:~$ source activate py27-nomkl; discarding /home/cgranade/anaconda/bin from PATH; prepending /home/cgranade/anaconda/envs/py27-nomkl/bin to PATH; cgranade@berith:~$ ipython; Python 2.7.11 |Anaconda custom (64-bit)| (default, Dec 6 2015, 18:08:32); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 4.0.3 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); <ipython-input-2-ebe4f6e784e1> in <module>(); ----> 1 print(numpy.__config__.mkl_info['libraries']). AttributeError: 'module' object has no attribute 'mkl_info'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204251671:174,load,loads,174,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204251671,1,['load'],['loads']
Performance,"It seems the entire idea of printing from different threads in python is deeply troublesome. https://stackoverflow.com/questions/3029816/how-do-i-get-a-thread-safe-print-in-python-2-6. My guess is that the appropriate solution is to move all the printing to a single thread and use `Queue`, but I am not quite certain of that. I will see what I can do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-42067292:283,Queue,Queue,283,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-42067292,1,['Queue'],['Queue']
Performance,"It would be hard to enforce since we accept functions returning `Qobj`.; If someone passed `dtype` in `args`, there is nothing we can do.; Also since the most common use case is `part @ state`, they don't interact much together and each part can be optimized for it's sparsity without issue. Mixed case are not that rare. Per default `sigmax` is `CSR` and `qeye` is `Dia` and I can't say what is `sigmax & qeye` without checking. So `QobjEvo([sigmax(), [qeye(2), f]])` mixes `CSR` and `Dia`.; How do we decide which one we quietly transform? Everything else just work with whatever type is used. So we can't have this raise an exception. Personally I think we should only mix in a family of dtypes, `Dense`, `Dia` and `CSR` can be mixed, but no mixing of jax with CSR, etc. But we don't have what we need to enforce it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2325#issuecomment-1944589688:249,optimiz,optimized,249,https://qutip.org,https://github.com/qutip/qutip/pull/2325#issuecomment-1944589688,1,['optimiz'],['optimized']
Performance,"Just a small additional comment, the ODE solver is probably slow in your case because of the large disparity in parameters (particularly the very large dephasing rate), which makes it a bit stiff I guess (and hence maybe why BDF works a little better than adams in this case?). I will close this issue, but if you have any comments/updates on improving the performance of your example, feel free to comment or re-open it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1591#issuecomment-900015271:357,perform,performance,357,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-900015271,1,['perform'],['performance']
Performance,"Just to add, I tried to benchmark Eric's jax data layer a bit more with an Ising model, the example is at the end of this colab notebook we made for a tutorial talk, which shows some crossover in performance at certain system sizes: https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing. ![benchmark](https://github.com/qutip/qutip/assets/5094429/15d2dfaa-b269-44f7-8334-878b8e2c5910). Note colab does not have free GPUs, so you will have to download and use it locally. also in the actual ising example, replace ; `with jax.default_device(jax.devices(""cpu"")[0]):` ; with; `with jax.default_device(jax.devices(""gpu"")[0]):`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917:196,perform,performance,196,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917,1,['perform'],['performance']
Performance,"Just to get the ball rolling, I will go ahead and ask my question here and migrate it if necessary. . My code performs quantum annealing on a transverse-field Ising Hamiltonian as inspired by D-Wave Systems devices which is explained briefly [here](https://docs.dwavesys.com/docs/latest/c_gs_2.html), but the essential equation is; ![D-Wave-hamiltonian](https://user-images.githubusercontent.com/29308150/61193322-bdb48c00-a688-11e9-94ac-22c5d093b47a.png).; The A(s) and B(s) factors dictate the time-evolution from the initial Hamiltonian to the final Hamiltonian where s is a linear function of time, i.e. s(t) is linear with slope between 0 and some max and 0 <= s <= 1. In my code, my sesolve command looks like 'results = qt.sesolve(listH, init_state, discretized_times_list)' where 'listH = [[Hx, A(s(t))], [Hz, B(s(t))]]' and A(s(t)) and B(s(t)) and created by using QuTiP's interpolate.Cubic_Spline function that dictates what the A and B parameters should be at each point in time. . When I make successive calls, it is to do several different things. For example, I may change coupling (h and J) values to create a new spin-glass, adjust number of qubits (larger or smaller H), or anneal for a longer or shorter time. I am not sure how to directly relate this to what has been posted so far, but perhaps I am not fully understanding the point made in https://github.com/qutip/qutip/issues/966#issuecomment-474569011.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-511266095:110,perform,performs,110,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-511266095,1,['perform'],['performs']
Performance,"Looks interesting! Possibly a bit out of scope for qutip? In principle you could put this progress bar in a separate module and still use it with qutip (as long as it supports qutip's basic progressbar interface). Then it could also be used in non-qutip related projects. . If its to be included in qutip, I think it should not be added to qutip/ui/progressbar, but as an module of its own that would not be loaded by default, so a user would have to load it explicitly when using it, like the way the current ipynbtools and picloud modules work. . Perhaps it would make sense to move these ""extras"" or ""extensions"" modules to a subdirectory of their own, say ""qutip/extensions"" or ""qutip/ext"" to keep the import paths manageable. In that case I think that qutip.picloud should be moved to that directory as well. I think this would keep these extensions reasonably isolated for the core qutip modules, which I think we should prioritize if we are to allow these kind of peripheral modules to increase in number in the future. @nonhermitian any opinions on this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/255#issuecomment-63268318:408,load,loaded,408,https://qutip.org,https://github.com/qutip/qutip/pull/255#issuecomment-63268318,2,['load'],"['load', 'loaded']"
Performance,"Looks like there were breaking changes introduced in CVXPY 1.1 that changed some sort of matrix handling? I think the entirely of the `dnorm` function was written by Chris Granade about 5 years ago, and they're off at Microsoft now. As an immediate workaround, you can pin the version of CVXPY in conda to 1.0 (`conda install 'cvxpy=1.0'`) to fix it. Otherwise, probably there's a solution in swapping over a load of `*` to `@` in `qutip/semidefinite.py` and `qutip/metrics.py`, but that might be a bit nontrivial to solve. If you succeed, please do make a pull request. The reason that the ""simple"" cases work is that QuTiP detects them as known results and has fast paths avoiding `cvxpy`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713:409,load,load,409,https://qutip.org,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713,1,['load'],['load']
Performance,"Moving out _binary_search would could be done, but I don't believe it will make visible speed increase. I most cases the matrix operations are the bottleneck. Fused types are a good idea, but if you still have a lot to do in your project, they are not a priority.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1050#issuecomment-514654597:147,bottleneck,bottleneck,147,https://qutip.org,https://github.com/qutip/qutip/pull/1050#issuecomment-514654597,1,['bottleneck'],['bottleneck']
Performance,"Nice speed up! Is there anything here that we could also benefit from in mesolve? Or is it specific to mcsolve in that it mostly affect the ODE restart?. I doubt that the initial setup of an ODE instance before spawning processes would have any significant impact on the performance (note that multiprocessing does not use threads, it uses processes, so there is no sharing of ODE instances between processes). Creating the ODE instance once in the parent process, or N times in N processes in parallel therefore should not make much difference, if any.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65020496:271,perform,performance,271,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65020496,1,['perform'],['performance']
Performance,"Nice, I will do it in the following days. On a side note, I'd propose to make the printing optional in `qload` with a `debug` flag for instance. As it is a bit messy when you are loading a lot of objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1811#issuecomment-1044402997:179,load,loading,179,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044402997,1,['load'],['loading']
Performance,"Nice, good job!! How does the performance look like for small problems? Does it make any sense to add an option to select bicgstab or lmgres, or does lmgres beat bicgstab in all cases you have looked at? Anyways, performance for systems is not that important, but we badly need better performing steadystate solvers for large systems so your benchmarks looks very promising :-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/29#issuecomment-20392672:30,perform,performance,30,https://qutip.org,https://github.com/qutip/qutip/issues/29#issuecomment-20392672,3,['perform'],"['performance', 'performing']"
Performance,"No, this is not included in my project. The commit above seems to be lost so I can't see the original proposal. It is easy to add a new option to let some gates remain as they are (and I think this is what was proposed). To resolve other multiqubit gates into TOFFOLI basis needs, however, much more work :). If resolving gate becomes a high demand, it might be a good idea to refactor the current `resolve_gate` method as it is quite long and hard to maintain. An optimized gate resolving method needs more complex logic such as merging single-qubit gate.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/614#issuecomment-532940297:465,optimiz,optimized,465,https://qutip.org,https://github.com/qutip/qutip/issues/614#issuecomment-532940297,1,['optimiz'],['optimized']
Performance,"Not directly testing for commuting operators, but Qobj implements **eq** and **ne** which means that you can test for commuting operators simply by doing. ```; if a * b == b * a:; # a and b commutes; ```. Maybe it could be useful with function that performs this test for two Qobj instances, but currently we do not have such a function. The PR looks good so I'll merge it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/41#issuecomment-22768490:249,perform,performs,249,https://qutip.org,https://github.com/qutip/qutip/pull/41#issuecomment-22768490,1,['perform'],['performs']
Performance,"Not extremely familiar with pytest parametrizations, but I've just been reading it and performing some changes. Will keep doing it with the new suggestions. I'll add a couple of tests for bad instances of inputs just in case. . I agree with the with the bound functions part. I'll try to perform as many improvements as possible today. And thanks a lot for all of these <code>sx_list[i] == x_gate(N, i)</code> code improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417:87,perform,performing,87,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417,2,['perform'],"['perform', 'performing']"
Performance,"Not sure if I can answer your specific question but I have used QUTIP GRAPE before. I would first suggest opening a pull request or linking to your fork, so it's easier to compare your modifications to the original code.; I have briefly looked at your code and I would suggest dropping numba as qutip doesn't currently have numba as a dependency. I am confused about why you choose the cnot notebook as your example? There is an example of quantum optimal control using open quantum systems, control-pulseoptim-Lindbladian.ipynb .; Nonetheless, I believe grape.py is definitely not the place to place your additional support for open quantum systems. Grape is an optimization method, you should be looking extending support for open quantum systems in the pulseoptim class.; If you are interested you can also take a look at the quantum optimal control tool I built, QUTIP's quantum optimal control didn't satisfy my needs. ; https://github.com/lifeishard/PADQOC",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845:663,optimiz,optimization,663,https://qutip.org,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845,1,['optimiz'],['optimization']
Performance,"Note that the same holds for Cython:. ``` zsh; % pip install qutip; Collecting qutip; Using cached qutip-3.1.0.tar.gz; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:92,cache,cached,92,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,1,['cache'],['cached']
Performance,"Note: This appears broken on my M1 MacBookPro running Big Sur... there is no sysctl hw.cpufrequency at all on this machine, so it blows up (some error handling in that function would be good :-). ```$ sysctl hw; hw.ncpu: 8; hw.byteorder: 1234; hw.memsize: 17179869184; hw.activecpu: 8; hw.optional.amx_version: 2; hw.optional.arm64: 1; hw.optional.armv8_1_atomics: 1; hw.optional.armv8_2_fhm: 1; hw.optional.armv8_2_sha3: 1; hw.optional.armv8_2_sha512: 1; hw.optional.armv8_crc32: 1; hw.optional.breakpoint: 6; hw.optional.floatingpoint: 1; hw.optional.neon: 1; hw.optional.neon_fp16: 1; hw.optional.neon_hpfp: 1; hw.optional.ucnormal_mem: 1; hw.optional.watchpoint: 4; hw.cacheconfig: 8 1 1 0 0 0 0 0 0 0; hw.cachelinesize: 128; hw.cachesize: 3616980992 65536 4194304 0 0 0 0 0 0 0; hw.cpu64bit_capable: 1; hw.cpufamily: 458787763; hw.cpusubfamily: 2; hw.cpusubtype: 2; hw.cputype: 16777228; hw.ephemeral_storage: 0; hw.l1dcachesize: 65536; hw.l1icachesize: 131072; hw.l2cachesize: 4194304; hw.logicalcpu: 8; hw.logicalcpu_max: 8; hw.osenvironment: ; hw.packages: 1; hw.pagesize: 16384; hw.pagesize32: 16384; hw.physicalcpu: 8; hw.physicalcpu_max: 8; hw.serialdebugmode: 0; hw.tbfrequency: 24000000; hw.use_kernelmanagerd: 1; hw.use_recovery_securityd: 0; hw.targettype: J293; ```; Big Sur 11.4 on MacBookPro M1. Actually I'll open a separate issue...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1401#issuecomment-879469970:673,cache,cacheconfig,673,https://qutip.org,https://github.com/qutip/qutip/pull/1401#issuecomment-879469970,3,['cache'],"['cacheconfig', 'cachelinesize', 'cachesize']"
Performance,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:312,load,loads,312,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861,1,['load'],['loads']
Performance,"Nothing too clever here. As in cached flag cleared whenever unitarity threatened; The check could probably be more efficient, but as not expected to be used intensively, then this would seem acceptable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/817#issuecomment-364163769:31,cache,cached,31,https://qutip.org,https://github.com/qutip/qutip/pull/817#issuecomment-364163769,1,['cache'],['cached']
Performance,Now with a8b79f7bd2ad58713e9ed7b104e204b155fcdc20 it works again on my machine. Is there a big difference in performance between accessing the blas stuff through scipy instead of directly from a cython module? If not it would be good to let the scipy ppl worry about the linking to blas and not have to deal with that in qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-22436635:109,perform,performance,109,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-22436635,1,['perform'],['performance']
Performance,"Numpy Version: 1.13.3; Scipy Version: 1.0.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1458,optimiz,optimizer,1458,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['optimiz'],['optimizer']
Performance,"Oh yeah, that's a good point we should push out the change sooner rather than later. With how the data-layer classes are implemented, ufunc handling on them wouldn't actually add any memory footprint, but it does add complexity whenever someone wants to implement a new data-layer class. It's hard to fit general ufunc machinery into the Dispatcher spec, because the ufunc interface is rather general, and we don't want to entirely reimplement numpy. You also can't dispatch on ""unary"" / ""binary"" / ""arbitrary"" ufuncs as groups (could have been an alternative), because (e.g.) `sin` has very different performance characteristics to `cos` on sparse matrices. If the dispatchers aren't in use, then having a separate function (`apply_ufunc`) doesn't make a performance difference over defining `__array_ufunc__` in a Cython class in speed or memory, but it does make it harder for a user. Class functions like that in Cython are actually implemented as separate C-backed functions - you can't override them on an instance-by-instance basis, so the instances aren't carrying around extra vtables or anything like that. One option for user convenience there could be to allow unary ufuncs on data-layer objects and forbid binary+ ones. We can do that with `__array_ufunc__`. It's not so difficult to keep track of the few numpy ufuncs that have f(0) = 0 so different sparse structures can optimise based on that. *Edit*: oh, I think I misunderstood what you were saying about ""lightness"" - do you mean the spec of what they have to support is light, or their memory impact is light?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-774106830:602,perform,performance,602,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-774106830,2,['perform'],['performance']
Performance,"Oh, also to answer the question more explicitly about `_qfunc_alpha_matrix.__call__`: _that_ function always re-computes the matrix of alphas, returning the relevant bits of the Fock space. The caching behaviour is in the `QFunc` class itself, which manages how many Fock states it needs (see `QFunc._alphas`, which tries to pull the matrix from a cache, or expands the cache if necessary). `QFunc.__call__` calculates the Q function of any quantum state over the given phase-space coordinates, no matter how large the size of Hilbert space of the state is - that means it's got feature parity with `qfunc` in the sense that both; ```python; iterative = functools.partial(qutip.qfunc, xvec=xs, yvec=ys); classbased = qutip.QFunc(xs, ys); ```; can be called with the same objects, and will return the same result, even if the objects change size in between. I see this as sensible functionality in general - if you're plotting a few graphs, it's quite possible that you haven't calculated all your states with the same amount of Fock-space truncation (I frequently scaled the calculation sizes in my PhD for speed), so it's not very useful if the class-based version can only handle fixed Hilbert spaces.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877266741:348,cache,cache,348,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877266741,2,['cache'],['cache']
Performance,"Oh, sorry I forgot to reply to you Boxi. In theory it's not such a difficult change, but it does have quite some performance implications - doing it properly will involve writing Cython, and we need to make sure that there's no major regressions. The swap to relative amplitudes necessarily makes the code ~twice as slow (from a one-pass to two-pass algorithm), but we do need to take care that it's as fast as possible, because this code is called _all_ the time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793761801:113,perform,performance,113,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793761801,1,['perform'],['performance']
Performance,Ok so as I read it currently there is no iadd_ function for CSR matrices. Am I also right that there is no add_ operation for Dense + CSR? How does the current code deal with adding a Dense to a CSR matrix (I'm looking in `core/data/add.pyx`). I think replacing add_ with iadd and making a specialised iadd impl should help improve performance a lot.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904583250:332,perform,performance,332,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904583250,1,['perform'],['performance']
Performance,"Ok, let's drop the tensor thing then. I'll make a new patch which includes the time-dependence syntax that you suggest, indeed a more convenient way. Do you think it would be necessary to perform linear interpolation as I did or would just rounding to the nearest point be ok. It looks like I'll need to add code to sesolve and mesolve, and these files seem to have some duplicate code already, do you think it would be useful to make a new file with some shared helper functions (mostly for generating the cython code)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44796169:188,perform,perform,188,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44796169,1,['perform'],['perform']
Performance,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:1007,perform,perform,1007,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['perform'],['perform']
Performance,"Okay, involving writing Cython itself already makes it unsuitable for most new contributors I guess. I think even if the time of tidy up doubles it still won't be a significant bottleneck for solvers? Matrix multiplication itself will be O(dim^3) in the worst case, this one is at most O(n^2). But I do agree that we need to be very careful with such a low-level function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793947542:177,bottleneck,bottleneck,177,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793947542,1,['bottleneck'],['bottleneck']
Performance,"One can also think about moving the fortran solver to its own installer as a qutip add-on. With the recent performance gains of the Python based solver, this change is not so bad in my opinion.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/283#issuecomment-66561013:107,perform,performance,107,https://qutip.org,https://github.com/qutip/qutip/issues/283#issuecomment-66561013,1,['perform'],['performance']
Performance,"One more.; For dense matrix operation, do you intend to write the code or use blas/lapack? Using the libraries is less work and leave advanced user the ability to link optimized version for there systems, or gpu accelerated one if they want, with no more effort on our side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648259130:168,optimiz,optimized,168,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648259130,1,['optimiz'],['optimized']
Performance,"One thing to consider is that CSR and Dense already _dno't_ return the same result for every operation. For example, for matmul:; ```python; size = 100; random = np.random.random((size, size)); a = qt.data.Dense(random); b = qt.data.to['CSR'](a); np.all((a).to_array() == (b).to_array()) # True; np.all((a+a).to_array() == (b+b).to_array()) # True; # This one is different for Dense and CSR even though the operation is the same. ; # This seems to be due to the order at which the operations are performed with Dense; # and CSR matmul and the fact that floating point addition is not associative. ; # (something I learned by reading the test_mathematics in qutip); np.all((a@a).to_array() == (b@b).to_array()) # False.; ```; Although the change in `auto_tidyup` will probably make the difference bigger, given that with tidy-up ""all"" we can not ensure the same output for every operation, I would say that it should be ok to set auto_tidyup to `[CSR]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1610#issuecomment-882012839:496,perform,performed,496,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882012839,1,['perform'],['performed']
Performance,"Our tests could still be shortened, but right now the `pytest.mark.slow` marker does allow for a reasonable run time without sacrificing too much, and we have reduced our Travis load to only 5 concurrent tests by merging MKL and OpenMP tests. With `Coefficient` on `dev.major` we have a lot more scope for re-using compiled coefficients, which are typically the slow parts, but for now I think our testing is much faster than it was when this issue was first opened.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-809323357:178,load,load,178,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-809323357,2,"['concurren', 'load']","['concurrent', 'load']"
Performance,"Partially tracing either system out of a maximally mixed state _should_ be the same matrix (and is, in QuTiP), so the fidelity being 1 is correct from a matrix view. QuTiP doesn't track what systems used to exist before a partial trace, so a partial trace from 2 qubits to 1 qubit appears to live in the same Hilbert space no matter which qubit is traced out. This is the expected behaviour - it's generally the most convenient, rather than doing something odd like giving back the remaining systems tensored with a maximally mixed state on the parts we just traced out. I'm not sure of the relation between quantum state fidelity and concurrence that you're referring to, so I can't really comment on that. By the way, your code doesn't actually use a maximally mixed state, but the result is the same anyway. Being able to write (|00> + |01> + |10> + |11>)/2 in ket form like that shows it's pure over the basis you've defined. The maximally mixed state over this complete basis would be (|00><00| + |01><01| + |10><10| + |11><11|)/4, which isn't the same as the projector onto your state (which also has crossterms like |00><11| and so on).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1423#issuecomment-767739076:635,concurren,concurrence,635,https://qutip.org,https://github.com/qutip/qutip/issues/1423#issuecomment-767739076,1,['concurren'],['concurrence']
Performance,"Perhaps a bit more computationally efficient solution (although, it probably wouldn't make more than a marginal difference, at any reasonable order of number of indices, at which insertion is to be performed): insert at an index `i + k` , where `i` is the original index as per the `index` list, and `k` is the number of insertions performed so far, as part of the insertion loop. I'll raise a PR with the proposed fix. **Update:** The PR in question is https://github.com/qutip/qutip/pull/1892.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497#issuecomment-1123990033:198,perform,performed,198,https://qutip.org,https://github.com/qutip/qutip/issues/1497#issuecomment-1123990033,2,['perform'],['performed']
Performance,"Pseudocode for entrypoint suggestion:; ```python; entrypoints = importlib.metadata.entrypoints(group=""qutip.about""); for ep in entrypoints:; about_func = ep.load(); try:; title, lines = about_func(); except Exception as exc:; title, lines = ep.name, [str(exc)]; print(title); print(""-"" * title); print(); for line in lines:; print(line); print(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1870#issuecomment-1110986005:157,load,load,157,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1110986005,1,['load'],['load']
Performance,Running it through the profiler suggests that cy_expect_psi_csr is only responsible for a small part of the time (accumulative time 4.2 sec as compared to total run time of 148 sec). ```; Wed Nov 26 15:04:59 2014 profile.out; 5155120 function calls (5143582 primitive calls) in 148.280 seconds; Ordered by: cumulative time; List reduced from 3097 to 100 due to restriction <100>; ncalls tottime percall cumtime percall filename:lineno(function); 441/1 0.014 0.000 148.283 148.283 {built-in method exec}; 1 0.001 0.001 148.283 148.283 mcsolve-performance.py:1(<module>); 2 0.000 0.000 147.463 73.732 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:69(mcsolve); 2 0.000 0.000 147.411 73.706 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:446(run); 2 0.000 0.000 147.411 73.705 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:423(parallel); 2 0.011 0.006 147.411 73.705 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:415(serial); 1000 8.867 0.009 147.340 0.147 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:757(_mc_alg_evolve); 453518 1.543 0.000 130.497 0.000 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/scipy/integrate/_ode.py:376(integrate); 453518 127.846 0.000 128.245 0.000 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/scipy/integrate/_ode.py:859(run); 395940 0.709 0.000 74.413 0.000 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/scipy/integrate/_ode.py:747(step); 171960 4.219 0.000 4.219 0.000 {built-in method cy_expect_psi_csr}; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64519867:542,perform,performance,542,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64519867,1,['perform'],['performance']
Performance,"Running on Python 2.7 (Ubuntu 14.10) on my local system, this change significantly increased the performance. For some reason, the change was less pronounced using Python 3.4 on the same system (under 1 second change), but in both cases, this PR resulted in test times that were at least as fast as master. ```; cgranade@berith:~/Dropbox/software-projects/qutip (master u=)$ time nosetests qutip; ..............................................................................................SSSSSSS............................................................................................................................................................................................................................................/home/cgranade/Dropbox/software-projects/qutip/qutip/qobj.py:434: UserWarning: Multiplying superoperators with different representations; warnings.warn(msg); .............................................; ----------------------------------------------------------------------; Ran 382 tests in 292.925s. OK (SKIP=7). real 4m54.023s; user 11m20.584s; sys 0m5.356s; cgranade@berith:~/Dropbox/software-projects/qutip (master u=)$ git checkout fix-isherm-lazy ; Switched to branch 'fix-isherm-lazy'; cgranade@berith:~/Dropbox/software-projects/qutip (fix-isherm-lazy)$ time nosetests qutip; ..............................................................................................SSSSSSS.............................................................................................................................................................................................................................../home/cgranade/Dropbox/software-projects/qutip/qutip/qobj.py:436: UserWarning: Multiplying superoperators with different representations; warnings.warn(msg); .............................................; ----------------------------------------------------------------------; Ran 369 tests in 283.042s. OK (SKIP=7). real 4m43.554s; user 10m51.428s; sys 0m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130556638:97,perform,performance,97,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130556638,1,['perform'],['performance']
Performance,"Since I have been using GCC 4.8 for a while now, i did not think about compilers back to 4.4. I will take a look at this code on Monday, but my initial thinking is just to drop the optimization and leave it at that. This would save us from having to run an extra test suite on Travis. The only compiler flags that matter at the end are O3 and the fast math. Everything else is just a few percent improvement at best. . Paul. > On Feb 21, 2015, at 06:42, Dominic Meiser notifications@github.com wrote:; > ; > gcc 4.4 does not support the -flto option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6.; > ; > In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to setup.py to enable or disable link time optimization.; > ; > I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.; > ; > You can view, comment on, or merge this pull request online at:; > ; > https://github.com/qutip/qutip/pull/318; > ; > Commit Summary; > ; > Remove -flto compilation flags.; > Add gcc4.4 and clang builds to travis build matrix.; > File Changes; > ; > M .travis.yml (8); > M qutip/control/setup.py (4); > M qutip/cy/setup.py (2); > Patch Links:; > ; > https://github.com/qutip/qutip/pull/318.patch; > https://github.com/qutip/qutip/pull/318.diff; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318#issuecomment-75334652:181,optimiz,optimization,181,https://qutip.org,https://github.com/qutip/qutip/pull/318#issuecomment-75334652,3,['optimiz'],['optimization']
Performance,"Since this branch is unfortunately rather old, I didn't want to squash the early commits, but the most recent batch have been squashed down to just one. I think that this feature is now in a state I feel comfortable with reviewing, so I'll add the label. In the future, I would like to generalize the difference of unitaries optimization, but I think that will take a bit of Cython work to implement.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/456#issuecomment-198632131:325,optimiz,optimization,325,https://qutip.org,https://github.com/qutip/qutip/pull/456#issuecomment-198632131,1,['optimiz'],['optimization']
Performance,"So I did an update of my conda environment to the latest version and now also the installation via pip has a problem, producing an `ImportError` (but not a segfault!) in the same location:. goerz@mlhpc2 develop:~/Documents/Programming/QNET> ipython; Python 3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 5.1.0 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import qutip; ---------------------------------------------------------------------------; ImportError Traceback (most recent call last); <ipython-input-1-ad45215f3e51> in <module>(); ----> 1 import qutip. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 169; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/qobj.py in <module>(); 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/fastsparse.py in <module>(); 404 #Need to do some trailing imports here; 405 #-------------------------------------; --> 406 from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult). ImportError: /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/cy/spmath.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E. The verbose log file from the installation (`pip install -v --no-cache-dir qutip`) is here: [pip_log.txt](https://github.com/qutip/qutip/files/914669/pip_log.txt)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-293395036:1861,cache,cache-dir,1861,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-293395036,1,['cache'],['cache-dir']
Performance,"So far:; I have created the 4.1.x branch; Created the gztar and zip via sdist; (there was a problem with missing hpp files, now fixed); I have uploaded the packages to the website and updated the links.; I have updated the conda-forge recipe. I am waiting to see how the packages work out before going any further. The Windows ones take about 24 before they get processed in the queue",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/649#issuecomment-285766694:379,queue,queue,379,https://qutip.org,https://github.com/qutip/qutip/issues/649#issuecomment-285766694,1,['queue'],['queue']
Performance,"So now tests do run properly. They do not seem to fail. I did add an extra test for the case for the parameter `sparse=True`. This led me to a bug in `eigs_csr` that is now fixed. @jakelishman let me know if you are ok with this implementation. I am not very familiar with Cython so I am not sure how to handle the GIL in this case. I also find quire surprising to need the `sparse` argument in `trace_csr`. Shouldn't this function just perform a sparse computation of the trace norm (sparse always `True`?). Also, should the specialisation `traces_dense`, that currently does not exist, be mapped to the function `_trace_dense` I just wrote?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261:437,perform,perform,437,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261,1,['perform'],['perform']
Performance,"So, while I agree that having a flexible storage format is a good way to go, the truth of the matter is that no one has time to implement such a big change. SciPy supports both 32 and 64-bit ints, and checks to see which ones are needed at runtime. e.g. a tensor product of two sparse matrices with int32, may need int64 in the result since their shape is larger. We could also do a similar thing, but it is a lot of work. The reason why we no longer use standard SciPy sparse objects is: 1) They tend to have a sizeable overhead when being created and/or manipulated do to redundant safety checks. 2) Many of the sparse operations are not well optimized. Because SciPy supports many different sparse formats, they had to generalize many of their core operations, making them slower. For example, the sparse kronecker product first converts to COO format, does the tensoring, and then converts back to the original format. Our method is much faster. Supporting more than just the current CSR format is also problematic. As already mentioned, there would be type checks, conditionals, and format conversions everywhere. e.g. what happens when DIA * CSR. As usual, available time is the limiting factor here. Support for both int32 and int64 is not that hard, but would take some time. Just int64 would make smaller matrices larger, but would allow for much greater system dimensions. In this later case, it would be a simple switch `int` -> `int64` and `size_t` -> `uint64` in the Cython code, and the fastsparse module (plus probably other places.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384005667:645,optimiz,optimized,645,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384005667,1,['optimiz'],['optimized']
Performance,"Sorry for the slow response... It seems to me like @Ericgig summed it up pretty concisely. Although I'm not sure I understand how #1123 fits in: what is the plan for `Qobjevofunc`, and how would it fit in to specifying time-dependent Hamiltonians?. The only thing that's ever really bothered me was the mandatory `args` as part of the signature, even if it's not used. That's lead to the need for workarounds like the `allow_args` parameter in; https://github.com/qucontrol/qdynpylib/blob/f7b54af3e586683cdfd9b3dd666c5cf540d843e1/src/qdyn/pulse.py#L555. If there's a future `f(t)` option, I should be happy. In the abstract, `f(t, **args)` and `f(t, state_vec, **args)` would be the most elegant, but if there's a severe performance hit, that could be a problem. I'm surprised, though: I would have thought that `f(t, **args)` and `f(t, args)` should be almost the same thing in the Python internals, since you can modify `args` inside of `f` and pass it to lowerlevel function as `**args` again. Even from the user's perspective any current code with signature `f(t, args)` could have its signature replaced with `f(t, **args)` without requiring any change to the function body. But I'm clearly missing something. Can you point me to lines in the code where this becomes a bottleneck?. I'm also quite in favor of introspection to accept a wide variety of signatures: you can even introspect argument names, so the possibilities are endless. The introspection is probably slow, but if it only has to be done in a very high level function, that might be alright.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-562812696:721,perform,performance,721,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-562812696,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:92,race condition,race condition,92,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081,1,['race condition'],['race condition']
Performance,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:333,Load,LoadLibrary,333,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367,1,['Load'],['LoadLibrary']
Performance,Thanks @Ericgig for feedback.; I see (having read more carefully) in; https://github.com/qutip/qutip-notebooks/blob/master/examples/smesolve-inefficient-detection.ipynb; there is an example showing the equivalence of using `smesolve` and `general_stochastic` with a clear performance enhancement in the former. So I think I can easily switch my example to use `smesolve`. Thanks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581:272,perform,performance,272,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581,1,['perform'],['performance']
Performance,"Thanks Jake, I understand better how the cache is working. Okay let me suggest a few comments within the code so that we (or at least I) can keep track of how this implementation works. If you think they are sensible then feel free to accept and then we can merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877273495:41,cache,cache,41,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877273495,1,['cache'],['cache']
Performance,"Thanks Robert. As far as the problems with the sparse solver in scipy, I have read around a bit and found that the solver doesn't perform well for finding eigenvalues with small magnitude. From a scipy tutorial:. http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html. > Note that ARPACK is generally better at finding extremal eigenvalues: that is, eigenvalues with large magnitudes. In particular, using which = 'SM' may lead to slow execution time and/or anomalous results. A better approach is to use shift-invert mode."". See also the example on that page. I tried using the 'shift-invert mode' as suggested, and that gave better results. But, they are still pretty bad for the problem I want to solve: I'm trying to find the low lying spectrum for a very large Liouvillian, as I vary a single external Hamiltonian parameter. The smallest one (in magnitude) is always zero, and all others are negative. Supposedly, the vanishing of the real part of the eigenvalue with the second largest (closest to zero) real part can be useful for characterizing phase transitions, see, for example, this recent paper: http://prl.aps.org/abstract/PRL/v110/i15/e150401. I attach a plot where I have computed the eigenvalue with second largest real part (which is also the one with second smallest magnitude; the two criteria coincide) using 1) scipy.linalg.eigvals (green line) and 2) scipy.sparse.linalg.eigs (blue line): https://dl.dropboxusercontent.com/u/6042643/liouvspec.png. As you can see, the results from the sparse solver are pretty poor (I assume the dense solver results are correct). . As far as the physics goes: Another thing to notice is that the system goes through phase transitions at -2.0, 0.5 and 2.0 for the parameter along the x-axis, and there are no signs of that in the plot. On a side note, I also wasn't able to reproduce Fig 2(a), middle panel, of the PRL paper I linked to, although I got qualitative agreement if I tried with different parameters than what is quoted in th",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/16#issuecomment-16416062:130,perform,perform,130,https://qutip.org,https://github.com/qutip/qutip/issues/16#issuecomment-16416062,1,['perform'],['perform']
Performance,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:665,optimiz,optimized,665,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769,1,['optimiz'],['optimized']
Performance,"Thanks! I used git checkout for ecca45c and reinstalled with python setup.py install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Us",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:931,optimiz,optimizer,931,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212,1,['optimiz'],['optimizer']
Performance,"That is what I did in fact, but I had to add it myself. That is load them in from CPATH or C_INCLUDE_PATH. They were not included automatically. I am not suggesting that we do that in this PR, but maybe extending rather than overwriting the CFLAGS might be better. Unless there is good reason not to?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/570#issuecomment-265068820:64,load,load,64,https://qutip.org,https://github.com/qutip/qutip/pull/570#issuecomment-265068820,1,['load'],['load']
Performance,"That's the only two problems I ran into when testing the code, but I didn't test everything. About performance of numpy/lists for small arrays; I wouldn't worry much about that in this case. On a different note: Since we don't have unit tests for the plot functions in qutip it would be great if you could consider adding an ipython notebook to qutip/qutip-notebooks that demonstrates how to use these plot function, with some suitable input states.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/105#issuecomment-43740558:99,perform,performance,99,https://qutip.org,https://github.com/qutip/qutip/pull/105#issuecomment-43740558,1,['perform'],['performance']
Performance,"The current test implementation is taking 3 seconds locally. But the times are quite bigger on the CI.I am positive that the test I implemented is minimal both in dimensions and requirements, as the alternativeof limiting the number of `eigvals` claculated and checking distinct from 0 on unitary matrices impacts the performance negatively on my side.; Maybe we should ship this without tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-821186337:318,perform,performance,318,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-821186337,1,['perform'],['performance']
Performance,The difference in performance is huge for large dimensions. In the case of cy_expect_rho_vec we calculate n*(n-1) unnecessary values which we drop immediately with trace operation.; I didn't replace the cy_expect_rho_vec because of the API change. I don't know exactly where it is used. Maybe it make sense to use cy_expect_rho_vec as a wrapper for cy_expect_rho_vec_fast?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/56#issuecomment-25357042:18,perform,performance,18,https://qutip.org,https://github.com/qutip/qutip/pull/56#issuecomment-25357042,1,['perform'],['performance']
Performance,"The green line is after the first commit of this pull request where I used a for loop. The orange line is after the second commit when I switched to using numpy.cumprod.; The red line is from the quantum optics framework written in julia that I'm currently working on (https://github.com/bastikr/QuantumOptics.jl). While doing some benchmarks I realized that for large N qutips coherent function failed which is why I wrote this patch. I don't know where the constant offset in the benchmark originates from but I think the speed is fine now, creating coherent states is probably never a bottleneck anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/683#issuecomment-292929031:588,bottleneck,bottleneck,588,https://qutip.org,https://github.com/qutip/qutip/pull/683#issuecomment-292929031,1,['bottleneck'],['bottleneck']
Performance,"The last thing that needs to be done is too better optimize the parallel processing. Right now we spawn ntraj threads, each creating a ODE instance. This is major overkill since we really need a single instance per thread.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64838151:51,optimiz,optimize,51,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64838151,1,['optimiz'],['optimize']
Performance,"The negative values problem is definitely present when `state` is a density matrix, and right now that is the only case I have tested. . I understand it will be very slow for larger systems (exponentially so), but in my application is seems to be much slower even than the time evolution of the function, which seems like it should be more computationally complex. Given that, I suspect there is some room for optimization. . What's the best way to tell if there are any relevant differences between 4.7.2 and the 5.0.x alpha?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769:410,optimiz,optimization,410,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769,1,['optimiz'],['optimization']
Performance,"The performance hit come from filtering the args. This is pretty much what I am doing:; ```; def f(t, args):; args_now = {key:args[key] for key in dict if not key.startswith(""_"")}; return original(t, **args_now); ```; With some work, I should be able to remove the need for `args_now` and get much faster. But there is still an extra layer. ; Introspection only need to be done once at setup, not at each call so it should have a great effect.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-563011840:4,perform,performance,4,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-563011840,1,['perform'],['performance']
Performance,"The problem seems pretty simple, I think I could take care of it. However, I don't have much experience in collaborative programming, in particular I don't know what the local customs are. (I know how to use git, but I'm not familiar with the layout of the library, what tests should I perform [or even add my own, since this issue wasn't noticed before 5.0.0] etc.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457:286,perform,perform,286,https://qutip.org,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457,1,['perform'],['perform']
Performance,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:419,optimiz,optimization,419,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503,1,['optimiz'],['optimization']
Performance,"There's another interesting technique that's sometimes applicable in these sort of repeating cases. Rather than passing a list of the same elements to `tensor`, you can also consider building up the tensor product manually, going up in powers of two. So you go along with something like:; ```python; out, tmp = H, H; for i in n.bit_length():; tmp = tensor(tmp, tmp); if n & (1 << i):; out = tensor(out, tmp); ```; (very very approximately - I've almost certainly got the indexing wrong). The idea is that you only perform `lg(n)` tensor products. Now, this might not actually give you much of a speed up in this case, because the calculation is still going to be dominated by the final tensor product, since the output matrix keeps getting larger. But in things like integer matrix powers, bigint calculations, or binomial expansions, this type of thing can be super useful! QuTiP 5 uses an algorithm like this for matrix powers. (I imagine SciPy does too, but for all the normal reasons, we don't use their implementation.). *edit*: here it is: https://github.com/qutip/qutip/blob/559387e68eb2b07064d2ae6099fbdc81ea96d67c/qutip/core/data/pow.pyx#L17-L39",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997:514,perform,perform,514,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997,1,['perform'],['perform']
Performance,"There's no rabbit hole - it's just a bug on line 511 of `mesolve.py` and 526 of `mcsolve.py`. The output dtype is correctly calculated, it's just a bug in generating values for the output array. There's a similar bug in the states output caused by the use of `fast='mc-dm'` that requires a more effort to fix, and should be at some point, but that's not so important right now. Having `qutip.expect` return real values for Hermitian operators and states I'd say is the correct behaviour. It's by far the most common use-case, and it allows them to be directly plotted without generating a load of warnings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796887930:589,load,load,589,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796887930,1,['load'],['load']
Performance,"This is just a comment - by coincidence, I also had a situation yesterday where my code was very slow because the matrices I used were accidentally dense. In my case, the reason was that I created operators like; ```; basis(N, i) * basis(N, j).dag(); ```; The default_dtype applies here but, if I hadn't been primed by seeing this issue, it might have taken me a long time to understand what is going on. It is somewhat surprising that qutip would, by default, create vectors / operators with only one non-zero entry as dense. I am sure there are good performance reasons for that, but it would be good to think about how we can help users not to run into such traps. Applying the default_dtype (or several of them) more broadly is certainly good. Has it been considered to include the dtype information in the output of printed `Qobj`s?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1955804625:552,perform,performance,552,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1955804625,1,['perform'],['performance']
Performance,This is ready to be reviewed and added to QuTiP. Notebooks are in : https://github.com/nathanshammah/piqs/blob/master/notebooks/notebook_piqs.ipynb. One would need to change the import statement to `from qutip.models.dicke import *`. Perhaps some more testing could be done for the states and operators but I want to get this merged first before trying to optimize. The Liouvillian created here works with QuTiP's solver (thanks to Neill's suggestion). Thus one can easily work with ensembles of spins or even ensembles coupled to bosonic cavities and take full advantage of QuTiP machinery. We have an optimized solver for diagonal Hamiltonians which is faster and perhaps there is a scope to make this even faster with the correct RHS calculation. Please have a look and review the changes to get this merged. @nwlambert @nonhermitian @ajgpitch,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-360766438:356,optimiz,optimize,356,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-360766438,2,['optimiz'],"['optimize', 'optimized']"
Performance,This is very interesting! I was looking for some time already a way to incorporate assembler here. Now it is possible to use FMA (fused multiply add) which should greatly improve speed of almost anything or there is a very neat implementation of complex number product with FMA which is exact (avoids loss of precision) with almost no performance penalty.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-253969071:335,perform,performance,335,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-253969071,1,['perform'],['performance']
Performance,This is weird it is showing an apparently unrelated failure while saving and loading pickles. And the CI times seem longer.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-822631709:77,load,loading,77,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-822631709,1,['load'],['loading']
Performance,"This issue is mostly obseleted by the merging of #1465, since the complete build structure is now different. In that we didn't necessarily implement the complete change requested here (we don't have `pytest` as a requirement), but we do have the PEP-517-approved way of fully specifying build requirements, so getting a correct build environment is automated. I will note that `pip install -e .` doesn't play very nicely with packages with Cython components to build; at the time of writing, `pip` would tend to install dependencies and perform the build in a venv regardless of what was installed in the activated Python environment (especially if conda), which meant that the complete set of Cython files needed to be re-compiled every time this command was run. That's fine if you just want to edit the Python files, but `setup.py develop` would correctly remember which Cython files actually _needed_ to be re-compiled, so remains much more useful for low-level QuTiP development for practical purposes right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1263#issuecomment-809340570:537,perform,perform,537,https://qutip.org,https://github.com/qutip/qutip/issues/1263#issuecomment-809340570,1,['perform'],['perform']
Performance,This seems like a good idea to me though! It might also help with the upcoming TensorFlow backend (where we'll probably need to mostly create TF backend QObjs in order to get reasonable performance).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-809210105:186,perform,performance,186,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-809210105,1,['perform'],['performance']
Performance,"This seems like a really good start, thanks! Building on this, we may want to explore taking a more unified approach to performance testing, as there's a number of performance-sensitive features in QuTiP. One avenue may be to write performance testing into the unit testing builds, that seems to be an [older extension for Nose](https://github.com/disqus/nose-performance), not sure if there's a better one out there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454#issuecomment-193501554:120,perform,performance,120,https://qutip.org,https://github.com/qutip/qutip/pull/454#issuecomment-193501554,4,['perform'],"['performance', 'performance-sensitive']"
Performance,"Using `tempfile.TemporaryDirectory()` as a context manager doesn't change the current directory, so we should be allowed to `cd` into the directory it returns... The documentation doesn't mention anything about not being able to as far as I can see, and regardless, if it fails it should raise an `OSError` and not crash the interpreter. I need to get a Windows box to try and debug this myself - it's difficult to know how to proceed without working out exactly what the problem is. We could try using the `cwd` kwarg of `subprocess.run`, but if you're not allowed to change into a temporary directory on Windows in any manner, then that may also fail. We don't want to run `pdflatex` in the user's directory, but ""officially"" we don't know exactly what files it will produce, so we can't reliably clean them all up. That's also not to mention the potential race condition that we get if two processes are trying to draw circuits simultaneously.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605333270:859,race condition,race condition,859,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605333270,1,['race condition'],['race condition']
Performance,"Very nice! The fortran stuff never worked on travis. In fact, it builds and install ok, but fails to load when the tests are ran. Perhaps some missing library path?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/300#issuecomment-68425677:101,load,load,101,https://qutip.org,https://github.com/qutip/qutip/pull/300#issuecomment-68425677,1,['load'],['load']
Performance,"We can't implement `__hash__` for `Qobj`, sorry - it's just not possible while following the [Python data model](https://docs.python.org/3/reference/datamodel.html#object.__hash__). The two principle points that a hash function must follow from there are; 1. objects which compare equal with `__eq__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs an",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:847,cache,cache,847,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,2,['cache'],['cache']
Performance,"We don't use the same code for the sparse addition as in `v4`. v5 sparse addition is quite faster. But I expect it to be slower for 100 additions of 50 elements since you need to allocate memory for the 100 intermediate results, while for 1 addition with 5000 elements, there is only one memory allocation. But if you want to have a go at optimizing our basic operations, we will welcome any improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811:339,optimiz,optimizing,339,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811,1,['optimiz'],['optimizing']
Performance,"Weird CI error on f56d27f - the build log suggests there was an error in setup (looks like `numpy` failed to load?), but I don't think that commit actually caused it, since it doesn't touch `setup.py`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-586401030:109,load,load,109,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-586401030,1,['load'],['load']
Performance,"Welcome, and thanks for filing your first issue. `measurement_statistics_observable` determines the eigenvalues and eigenstates of the supplied operator, so it's likely to be slow as the size of the system grows. If there is a means to speed it up, we'd be happy to give that a try. You could also try the alpha release of QuTiP 5 (`pip install qutip==5.0.0a2`) and compare performance there. Are you only seeing the negative probabilities when `state` is a density matrix? Perhaps we can make the code a bit better and explicitly tidy up the small unphysical negative probabilities.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808:374,perform,performance,374,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808,1,['perform'],['performance']
Performance,Well the performance depends strongly on the number of elements in tlist. For the given example the only calls that change is the increased number of expectation value calculations and a larger number of times the overall for-loop is run.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64520234:9,perform,performance,9,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64520234,1,['perform'],['performance']
Performance,"Well, `-march=native` gives you couple of percents of performance in the compiled binary (I wonder, did anyone benchmark how much, actually?), but it is a promise ""I will never run this binary on another machine, than this"". It is better not to do it by default. Even worse if it propagates somewhere on Conda: typically it uses some modern Intel-based servers to build packages, and if one has AMD CPU, it will definitely segfault with an illegal instruction. I vaguely remember such problems with conda-forge packages, but not sure if it was QuTiP or some other package with the same problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/949#issuecomment-463255325:54,perform,performance,54,https://qutip.org,https://github.com/qutip/qutip/pull/949#issuecomment-463255325,1,['perform'],['performance']
Performance,"Well, the default implementation for states is actually nearly completely unchanged (the only difference is that I replaced `np.fliplr(array)` with `array[::-1]`, which I think is a more readable idiom for ""backwards""). You're right that in the new form, basically the method is that you cache various parts of the `np.polyval` call into a 3D tensor, rather than recomputing this large polynomial each time. The `np.polyval` call is how you actually go from an array of different values of `alpha` (which comes from the meshgrid) to the coherent state, but doing it with `polyval` means you construct the coherent state and do the dot product simultaneously to save memory. If you need to repeat the calculations a bunch, and you've got enough memory to spare, you can build up all the `alpha**n / sqrt(factorial(n))` tensor once, then just dot it against every state. Since we're dealing with _complex_ Hilbert spaces, the inner product isn't a straight dot product, it needs the conjugate of one of the sides, so we only store the conjugate of the alpha tensor. You can see in the timings that this isn't _always_ the biggest win you'd expect; in some cases, the additional memory usage causes you to be more heavily bound by memory bandwidth issues rather than CPU pipelined stuff, which is another reason we allow forcing either method to be used. If you're interested in the most readable implementation, you might want to look at the test:; https://github.com/qutip/qutip/blob/a20c26307e2f6e738f87efd75abafc3dff4daad5/qutip/tests/test_wigner.py#L251-L260",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212:288,cache,cache,288,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212,1,['cache'],['cache']
Performance,"Well, your opinion is definitely important, especially regarding core :) Performance is a top requirement there. Technically I think there is no need for square root at all because we can just compare the squared value to the squared tolerance. But I get your point that constant factor may dominate the performance of a small system. It's best to avoid Cython in ""good first issues"", so this one won't be on my list anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-794400401:73,Perform,Performance,73,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-794400401,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"Why not replace the current cy_expect_rho_vec instead of adding a new function cy_expect_rho_vec_fast? If we need both then a more descriptive name difference than _fast would be desirable. The key difference in the API is that one takes a sparse matrix and the other its data, idx and ptr components as arguments. I recall not seeing much performance difference between these two options so I opted for the sparse matrix as argument because it makes it more convenient.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/56#issuecomment-25355844:340,perform,performance,340,https://qutip.org,https://github.com/qutip/qutip/pull/56#issuecomment-25355844,1,['perform'],['performance']
Performance,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:258,load,loads,258,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390,1,['load'],['loads']
Performance,"Wow! Thanks for getting on this!. Let me elaborate a little. First,. > How useful would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:433,optimiz,optimization,433,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,2,['optimiz'],['optimization']
Performance,"Yeah I agree. Functionality should come first, performance is secondary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/154#issuecomment-45703206:47,perform,performance,47,https://qutip.org,https://github.com/qutip/qutip/pull/154#issuecomment-45703206,1,['perform'],['performance']
Performance,"Yeah, definitely there's no point running tests that aren't really testing the package properly. I would hope that if we're much more aggressive about converting time-dependent lists into QobjEvo objects inside `mesolve`, `mcsolve` and `sesolve` (or the class-based versions of them), we could significantly reduce the amount of testing that needs to be done with them. Most of the tests of time-dependent formats would then occur in the QobjEvo tests. We could still test all the configurations of the solvers without too heavy a time penalty. If we only use a small number of different time-dependent operators, we can compile them all only once, and have `pytest` manage the resources through shared fixtures. That would really cut down the run times, especially for the current ""slow"" tests. Another avenue for cutting down run time is if we could merge say the MKL and OpenMP tests into one Travis job - the setup time for one job is about 2.5 minutes, and that's before any tests have run at all. I would hazard a guess that having MKL but not OpenMP is a pretty rare case (maybe more common on high-performance clusters where people submit single-cpu jobs?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182:1106,perform,performance,1106,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182,1,['perform'],['performance']
Performance,"Yeah, it was not a fresh conda, but one that I did not previously install QuTiP in. However, that warning is essentially telling me that it is trying to build the Cython openmp stuff at init. It should not be doing this, but will do so if it is trying to load a Cython generated file that was not built yet.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1334#issuecomment-670133651:255,load,load,255,https://qutip.org,https://github.com/qutip/qutip/issues/1334#issuecomment-670133651,1,['load'],['load']
Performance,Yes I would agree that this is not something that we will add to qutip at least not directly. Of course if someone wants to add such features then more power to them. Like Rob I think that time is better spent optimizing qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/48#issuecomment-27613005:210,optimiz,optimizing,210,https://qutip.org,https://github.com/qutip/qutip/pull/48#issuecomment-27613005,1,['optimiz'],['optimizing']
Performance,"Yes, I have not been able to install mcf90 under anaconda.; I think I remember seeing some discussion suggesting that the mcf90 has little or any performance improvement over the standard mcsolver. I have not tried myself. Being an anaconda user, this would take some effort for me.; I think that if it is not offering much greater performance, then we should just exclude it from the conda package.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/439#issuecomment-186524698:146,perform,performance,146,https://qutip.org,https://github.com/qutip/qutip/issues/439#issuecomment-186524698,2,['perform'],['performance']
Performance,"Yes, it is a code clean-up issue, not performance related (since the time spent on setting up multiprocessing is negligible compared to the compute time we don't have anything much to gain here). But factoring out multiprocessing from mcsolve is nonetheless something I think would be important, but obviously not necessary for this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65052972:38,perform,performance,38,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65052972,1,['perform'],['performance']
Performance,"Yes, the Tavis tests fail due to the missing Normalize class from Matplotlib. This caused the failure in #248 and is why I resorted to the try statement on loading.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/249#issuecomment-61443740:156,load,loading,156,https://qutip.org,https://github.com/qutip/qutip/pull/249#issuecomment-61443740,1,['load'],['loading']
Performance,"You are probably installing with the Anaconda Python package. It points to a location that does not exist for the mkl blas libraries, which it doesnt ship with. . The fortran solver is somewhat dated, and the Python solver is now close in performance. You should probably use the latter one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/491#issuecomment-224636252:239,perform,performance,239,https://qutip.org,https://github.com/qutip/qutip/issues/491#issuecomment-224636252,1,['perform'],['performance']
Performance,"You can see from the attached figure that it works pretty good, even at lower Hilbert space sizes. I would be hesitant to add both options because the bicgstab method fails not because of too few iterations, but because of some ""breakdown"" that can not be figured out. Since the current method works so well, and the only issues are the number of iterations, which is taken care of by using a preconditioner, it seems that the LMGRES method is the way to go. . On Wednesday, July 3, 2013 at 11:52 AM, Robert Johansson wrote:. > Nice, good job!! How does the performance look like for small problems? Does it make any sense to add an option to select bicgstab or lmgres, or does lmgres beat bicgstab in all cases you have looked at? Anyways, performance for systems is not that important, but we badly need better performing steadystate solvers for large systems so your benchmarks looks very promising :-); > ; > —; > Reply to this email directly or view it on GitHub (https://github.com/qutip/qutip/issues/29#issuecomment-20392672).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/29#issuecomment-20393941:558,perform,performance,558,https://qutip.org,https://github.com/qutip/qutip/issues/29#issuecomment-20393941,3,['perform'],"['performance', 'performing']"
Performance,You'll see I had to make a coupled of other small changes to ensure the bounds passed in pulseoptim methods are applied to the Optimizer as well as the PulseGen. Thanks again for reporting this.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353#issuecomment-123288016:127,Optimiz,Optimizer,127,https://qutip.org,https://github.com/qutip/qutip/issues/353#issuecomment-123288016,1,['Optimiz'],['Optimizer']
Performance,[![Coverage Status](https://coveralls.io/builds/41895317/badge)](https://coveralls.io/builds/41895317). Coverage increased (+0.1%) to 65.914% when pulling **d6f993ef42c77803c6628914f381cc9933338623 on hodgestar:feature/remove-control-optimization-csr-support-and-fix-qobj-with-sparse-eigens** into **0eab37a0c49cb4cab31cd69c30ef14fb30089429 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1621#issuecomment-892573655:234,optimiz,optimization-csr-support-and-fix-qobj-with-sparse-eigens,234,https://qutip.org,https://github.com/qutip/qutip/pull/1621#issuecomment-892573655,1,['optimiz'],['optimization-csr-support-and-fix-qobj-with-sparse-eigens']
Performance,"`Qobj` also supports `tr()`. It would be nice for performance reasons to stay in QuTiP if possible. But if you do want to get the raw data, `Qobj.data` returns you a custom version of scipy's sparse matrix (at least for qutip 4.7). `qobj.data.trace()` already works for me. You need to use `scipy.sparse.csr_matrix(qobj.data)` to make it compatible with the default scipy csr matrix before using anything in `scipy.sparse.linalg` I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2176#issuecomment-1594313976:50,perform,performance,50,https://qutip.org,https://github.com/qutip/qutip/issues/2176#issuecomment-1594313976,1,['perform'],['performance']
Performance,"`general_stochastic` is very manual, halfway to scipy's ode solver. It can be used for both open and closed system and does not correspond to any particular physics equation. It the function that you use if you do weird stuff that does not fit already available template and I would discourage it's use. ; If other type of stochastic evolution are commonly used, it would be better to make a new specialized function than use `general_stochastic`. Old example should be adapted to `smesolve` as much as possible. The solver does not know if it is solving an close or open system (or something else). So e_ops are not touched. ; d1, d2 are working in array for performance issue. We could easily have them work in Qobj, but I would expect a significant slowdown. These function, taking no args, and being call many time at each step could benefit from being compiled with numba.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283:660,perform,performance,660,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283,1,['perform'],['performance']
Performance,"a that coding in qutip should be as similar to writing in dirac notation as possible (within reason). As an example, here is how you can do a partial trace:. ```; In [14]: rho = rand_dm(4,dims=[[2,2],[2,2]]). In [15]: out = Qobj(). In [16]: for i in range(2):; out += tensor(qeye(2),basis(2,i).dag())*rho*tensor(qeye(2),basis(2,i)); ....:. In [17]: out; Out[17]:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.39666875+0.j 0.13801792+0.01223399j]; [ 0.13801792-0.01223399j 0.60333125+0.j ]]. In [18]: rho.ptrace(0); Out[18]:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.39666875+0.j 0.13801792+0.01223399j]; [ 0.13801792-0.01223399j 0.60333125+0.j ]]; ```. Of course you can do far more general things than that.. you can pretty much do anything you can write in dirac notation. Similar behavior on the level of super-operators and operator-vectors, as suggested by @jrjohansson, earlier in this thread, would be similarly very powerful. For example, in the language of tensor networks, it would allow you to do arbitrary wire-bending operations using the maximally entangled state, as in the [paper](http://arxiv.org/abs/1111.6950) by Chris Wood et al., that @cgranade mentioned in relation to #238. As of now there is no convenient (i.e., ""index free"") way to do this (correct me if I am wrong), except explicitly performing the corresponding partial transpose directly on the underlying matrix data. 2) In the absence of this functionality it is a bad idea to assume something else. Assuming conjugation is unexpected behavior, and besides it is something the user can easily do him/herself by using `to_super()`. It is way better to ""force"" the user to be explicit about things by throwing an `Exception`, than assuming something that might be unexpected. It enforces good coding style, giving more readable code, and avoids code that will break if the functionality is changed in the future.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58035991:1978,perform,performing,1978,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58035991,1,['perform'],['performing']
Performance,"alse; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; td_brmesolve: passes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1637,load,loadparams,1637,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['load'],['loadparams']
Performance,"amd64-2.7\Release\pyrex\rhs14883.c: In function '__pyx_pw_8rhs14883_1cy_td_ode_rhs':; > C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t_off' may be used uninitialized in this function [-Wmaybe-uninitialized]; > C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_tp' may be used uninitialized in this function [-Wmaybe-uninitialized]; > C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t' may be used uninitialized in this function [-Wmaybe-uninitialized]; > ok; > correlation: comparing TLS emission correlations (fn-list td format) ... ok; > correlation: comparing TLS emission correlations (fn td format) ... ok; > Counting statistics: current and current noise in a DQD model ... ok; > Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; > Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; > Diagonalization of random two-level system ... ok; > Diagonalization of composite systems ... ok; > Excitation-number-restricted state-space: full state space ... ok; > Excitation-number-restricted state space: single excitations ... ok; > Excitation-number-restricted state space: two excitations ... ok; > Excitation-number-restricted state space: fock states ... ok; > Excitation-number-restricted state space: identity operator ... ok; > Excitation-number-restricted state space: thermal density operator (I) ... ok; > Excitation-number-restricted state space: thermal density operator (II) ... ok; > Entropy: von-Neumann entropy ... ok; > Entropy: Linear entropy ... ok; > Entropy: Concurrence ... ok; > Entropy: Mutual information ... C:\Anaconda3\envs\qutip_py2\lib\site-packages\qutip\ptrace.py:111: RuntimeWarning: invalid name encountered in remainder np.fix(counter / np.prod(dims[sel[k + 1:]])), dims[sel[k]]) + 1; > ; > —; > Reply to this email directly or view it on GitHub.; > ; > Untracked with Trackbuster",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-148786885:27527,Concurren,Concurrence,27527,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-148786885,1,['Concurren'],['Concurrence']
Performance,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:4188,load,load,4188,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742,1,['load'],['load']
Performance,"ata.todense(); Ldense[0, :] = +np.diag(weight*np.ones(n)).reshape((1, n ** 2)); rho1 = np.linalg.solve(Ldense, b). Weight 1.0000000000000001e-16. # Proposed modified version; weight = np.mean(np.abs(L.data).max(0)).real # added .real to get a float ; print('Weight',weight); b[0] = weight; Ldense = L.data.todense(); Ldense[0, :] = +np.diag(weight*np.ones(n)).reshape((1, n ** 2)); rho2 = np.linalg.solve(Ldense, b). Weight 1.0; ```. The current version leads to a very small weight because the imaginary part is discarded. Also, the mean is not doing anything. The proposed modification computes the modulus before evaluating the maximum for each line and then takes the mean. This may change the final steady state in some circumstances, but I could not rapidly find a situation where this is actually important. In this example, the two steady states are the same even though the weights are very different.; ```; np.linalg.norm(rho1-rho2); >> 1.1102230246251565e-16; ```. 2 ) Construction of the matrix to obtain the steady state; As mentioned by @fminga, this should not change anything in most situations. But the proposed modification will make the matrix identical to the one computed by the algorithm when the sparse option is chosen. Here is an example, where the proposed modification performs slightly better than the current version. ; ```; H = identity(2); c_op_list = [sigmam(), 1e-8*sigmap()]; L = liouvillian(H, c_op_list); weight = 1.0; n = 2; b = np.zeros(n ** 2); b[0] = weight; ```. The current version gives:; ```; Ldense = L.data.todense(); Ldense[0, :] = np.diag(weight*np.ones(n)).reshape((1, n ** 2)); np.linalg.solve(Ldense, b); >> array([0.+0.j, 0.-0.j, 0.-0.j, 1.+0.j]); ```. The proposed modification gives:; ```; Ldense = L.data.todense(); Ldense[0, :] += np.diag(weight*np.ones(n)).reshape((1, n ** 2)); np.linalg.solve(Ldense, b); >> array([1.e-16+0.j, 0.e+00-0.j, 0.e+00-0.j, 1.e+00+0.j]); ```; This is a better result than the one obtained with the current version.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1275#issuecomment-987894724:2104,perform,performs,2104,https://qutip.org,https://github.com/qutip/qutip/pull/1275#issuecomment-987894724,1,['perform'],['performs']
Performance,"base class]( https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.html#scipy.sparse.spmatrix)? Then the `Qobj` constructor would probably need an additional parameter `format` for the class that should be used to convert the `inpt` argument to the `data` attribute. The onus would then be on Scipy to provide a full matrix that is a subtype of `scipy.spmatrix` (just to keep the interface contract), and also to have `int64` versions of all their existing sparse classes. From a community standpoint, it would seem like one would get much more bang for the buck to have this problem solved inside SciPy, instead of doing a lot of low-level stuff in QuTiP -- at least if they're amenable to pull requests, but worst case you can still define necessary new `scipy.spmatrix` subclasses externally. Take all of my musings with a little grain of salt... I never really looked too deep into QuTiP's low-level internals, specifically where QuTiP is using Cython. Naively, I would sort of think that Cython would remain at the level of sparse linear algebra operations (and thus mostly in scipy) and that QuTiP could be mainly pure Python. Obviously, once you start implementing higher level things like time propagation or even optimal control in Cython, everything becomes a bit of a mess, because then you really do have to manually implement everything for every possible storage format (again, something I'm familiar with from Fortran, and it's *a lot* of work). Generally, though, I've personally come to the conclusion that the lowest-level thing to really optimize for quantum dynamics simulations (in any language) is the application of a (time-dependent) operator to a Hilbert space state, respectively the commutator with a density matrix (in QuTiP, the operators would be the nested ``[H0, (u(t), H1), ...]`` lists). Everything higher level is probably fine at Python speed, as long as the algorithms are sound and you avoid allocating temporary storage as much as possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-383937610:2602,optimiz,optimize,2602,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-383937610,1,['optimiz'],['optimize']
Performance,"be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8997,perform,performs,8997,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['perform'],['performs']
Performance,"e whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is identical to `Seq(1, 2, 3, 4)` and `Seq(1, Par(2), 3)` is identical to `Seq(1, 2, 3)` but distinct from `Seq(1, Par(2, 3))`). One alternative may be to have a single subclass `Outcome` of `tuple` instead of both, then overload operators like `|` to mean parallel. Internally, could use two subclasses like `Seq` and `Par` but display visually as `Outcome(1, 2 | 3, 4)` instead of `Outcome(1, Par(2, 3), 4)`. > * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:1612,perform,performed,1612,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562,1,['perform'],['performed']
Performance,"e_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] T",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:2137,optimiz,optimizer,2137,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,2,['optimiz'],"['optimize', 'optimizer']"
Performance,"ed features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Best; Boxi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940:2202,perform,perform,2202,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940,1,['perform'],['perform']
Performance,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:3333,cache,cached-property,3333,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563,1,['cache'],['cached-property']
Performance,"er than a hard limit, but it's a good rule of thumb for testing one piece of functionality. [Here's a (slightly out-dated) list of our current longest tests](https://github.com/qutip/qutip/issues/1217#issuecomment-604116373), bearing in mind that some of those ones actually test many many things in the same test function. The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up. With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead. I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them. Minor things that _may_ speed up - check the profiling!; 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements internally is effectively `tensor(...(tensor(tensor(els[0], els[1]), els[2]), ...), els[-1])`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640127213:1156,load,loads,1156,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640127213,2,['load'],['loads']
Performance,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1979,cache,caches,1979,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,1,['cache'],['caches']
Performance,"ete): qutip/essolve.py deleted in HEAD and modified in master. Version master of qutip/essolve.py left in tree.; CONFLICT (modify/delete): qutip/eseries.py deleted in HEAD and modified in master. Version master of qutip/eseries.py left in tree.; CONFLICT (content): Merge conflict in qutip/entropy.py; CONFLICT (modify/delete): qutip/cy/spmatfuncs.pyx deleted in HEAD and modified in master. Version master of qutip/cy/spmatfuncs.pyx left in tree.; CONFLICT (modify/delete): qutip/cy/sparse_routines.pxi deleted in HEAD and modified in master. Version master of qutip/cy/sparse_routines.pxi left in tree.; CONFLICT (modify/delete): qutip/cy/codegen.py deleted in HEAD and modified in master. Version master of qutip/cy/codegen.py left in tree.; CONFLICT (content): Merge conflict in qutip/core/superop_reps.py; CONFLICT (content): Merge conflict in qutip/core/subsystem_apply.py; CONFLICT (content): Merge conflict in qutip/core/states.py; CONFLICT (content): Merge conflict in qutip/core/semidefinite.py; CONFLICT (content): Merge conflict in qutip/core/metrics.py; CONFLICT (content): Merge conflict in qutip/control/pulseoptim.py; CONFLICT (content): Merge conflict in qutip/control/pulsegen.py; CONFLICT (content): Merge conflict in qutip/control/optimizer.py; CONFLICT (content): Merge conflict in qutip/control/dump.py; CONFLICT (content): Merge conflict in qutip/bloch.py; CONFLICT (content): Merge conflict in qutip/_pyxbuilder.py; CONFLICT (content): Merge conflict in qutip/_mkl/utilities.py; CONFLICT (content): Merge conflict in qutip/_mkl/spsolve.py; CONFLICT (content): Merge conflict in qutip/_mkl/spmv.py; CONFLICT (content): Merge conflict in qutip/_mkl/__init__.py; CONFLICT (content): Merge conflict in qutip/__init__.py; CONFLICT (add/add): Merge conflict in VERSION; CONFLICT (content): Merge conflict in MANIFEST.in; CONFLICT (add/add): Merge conflict in .github/workflows/tests.yml; ```. Uh-oh. (This is actually expected: most of these are benign, and I can fix them quickly.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:4284,optimiz,optimizer,4284,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165,1,['optimiz'],['optimizer']
Performance,"ey reduce conceptual clarity. (For example, `temporal_basis_vector` returns a specific vector in the temporal basis; I would expect a function named `temporal_basis` to return an enumeration of all basis vectors.) However, I will try to think of shorter names which don't reduce clarity and will make changes if I come up with any. > Moving temporal_scattered_state, scattering_probability, and temporal_basis_vector into a new class. I think this is the only proposed change worth significant amounts of discussion, and it's actually something I had considered before. I'm conflicted about whether this change would be good or not, and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:2798,perform,performance,2798,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['perform'],['performance']
Performance,"for review. I have a; > working implementation of the ICM model now and a partial implementation of Pauli; > tracking; > <https://www.date-conference.com/files/proceedings/2014/pdffiles/05.6_7_ip2-19.pdf>; > which pushes all the corrections and measurement to the end of the circuit.; > I have written a quick example which demonstrates the use of this :; >; > https://github.com/sahmed95/notebooks/blob/icm/qutip_icm/; > icm_pauli_tracked.ipynb; > Circuit with a rotation gate (T gate); >; > [image: t_example]; > <https://cloud.githubusercontent.com/assets/6968324/21744332/c723fc5e-d556-11e6-9007-83187de75867.png>; > Pauli tracked ICM representation of circuit; >; > [image: t_pauli_tracked]; > <https://cloud.githubusercontent.com/assets/6968324/21744335/c997f300-d556-11e6-9202-f3ed33955b8a.png>; >; > Thus, we get a quantum circuit with qubit initializations in the begining,; > a mesh of CNOT gates in the middle and measurements in the end. This seems; > to be very useful as the starting point of topological quantum circuit; > optimization.; >; > Future work:; >; > 1.; >; > Represent qubit initializations in some way. Right now I consider; > everything as a gate. (Perhaps make new objects for qubit intializations,; > measurement, correction etc.); > 2.; >; > Better visualization such that all initializations, measurements and; > corrections can be stacked in one line.; > 3.; >; > Representing the information regarding P_dagger, T_dagger, V_dagger; > gate teleportation in some way. The difference is just based on the; > interpretation of the measurement.; > 4.; >; > Complete the Pauli tracking algorithm to get the gate sequence for; > correction based on measurement.; >; > Tests, tests and more tests.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/603#issuecomment-271102783>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AI",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-271126423:1396,optimiz,optimization,1396,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-271126423,1,['optimiz'],['optimization']
Performance,"higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conv",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2381,perform,performed,2381,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,1,['perform'],['performed']
Performance,"https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ~~~. So I don't think you'd have to worry about these details: any implementation with low overhead that would allow me to get the states from `mesolve` as well as tweak the control fields for the next time step should be sufficient. In particular, the `.step` that you discuss in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 looks very much like it's going in the right direction! The one option from the earlier https://github.com/qutip/qutip/issues/1571#issue-917391349 that might *not* work very well is callback functions. I *might* be able to work around that, but it wouldn't really fit into the control flow of an optimization. The code. ~~~; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ~~~. from https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 on the other hand would definitely fit the bill, assuming that `args=new_args` is the way to modify the control fields. Sorry for the long explanation, but I hope this clarifies the use case. If not, I'll be happy to try to explain better! ;-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:5130,optimiz,optimization,5130,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,1,['optimiz'],['optimization']
Performance,"ier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:7304,queue,queue,7304,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['queue'],['queue']
Performance,"igation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; > Expected outcomes; >; > - More devices defined in the qutip.qip.device module. At the moment,; > we have two models: spin chain and cavity QED. We would like to include; > some other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in qutip.qip.device and; > qutip.qip.compiler; > - Refactoring the circuit compiler to allow simple pulse scheduling,; > e.g. Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages; > or commonly used language e.g. through quantum assembly language (qasm); >; > ------------------------------; >; > Also, the last outcomes have some overlap with the last project. Although; > I also find this circuit importation very important, I guess two projects; > should not have overlap if they are both selected.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67EWECDUIOQMTKK2N2DREGE2LANCNFSM4KZUPCQQ>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:2731,perform,perform,2731,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,1,['perform'],['perform']
Performance,"instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy transitive equality (i.e. `a == b and b == c` does not imply `a == c`). The primary consequence of this is that the cache will simply be a little un",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1372,cache,cache,1372,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,1,['cache'],['cache']
Performance,"is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy transitive equality (i.e. `a == b and b == c` does not imply `a == c`). The primary consequence of this is that the cache will simply be a little under-zealous, and sometimes it will calculate the value twice for three similar `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1470,cache,cache,1470,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,7,"['cache', 'perform']","['cache', 'cached', 'performance']"
Performance,"ith any. > Moving temporal_scattered_state, scattering_probability, and temporal_basis_vector into a new class. I think this is the only proposed change worth significant amounts of discussion, and it's actually something I had considered before. I'm conflicted about whether this change would be good or not, and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:2945,perform,performance,2945,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['perform'],['performance']
Performance,"les in QuTiP follow the pep8 standard and wrap two newlines for top-level functions. I am in favor of the pep8 standard and have two newlines. @ajgpitch what do you suggest?. Please remove the helper function `count_filled` without the test if it is not required. We aim to test as much as possible and remove redundancy in code. About `__all__`, I will shift all the rest in a new PR and we can keep yours as it is now. Coming to the more important discussion regarding the `class` based implementation, I have started pushing for similar approaches in newer modules such as [qutip.models.piqs](https://github.com/qutip/qutip/blob/master/qutip/models/piqs.py). I am also working on a new non-Markovian method which requires a class. Something of that sort is already used in `qutip.nonmarkov.heom`. I understand that many of qutip's solvers are written to be isolated functions but that should not mean that we should not write code to fully use the object oriented framework Python provides. Moreover, I noticed that you have to rewrite wrappers for the functions anyways to deal with repeatedly calculating things such as `scattering_probability` which clearly can be made much more compact if we use a class based approach. I am not making this suggestion just for the minor performance improvement. It improves the organization of the code, allows greater flexibility in adding new things to an existing class and modifying it easily. In terms of user experience, this means less clutter in the code and verbosity of arguments. You can initialize something once and keep re-calculating things by dynamically changing the parameters and calling the `class` method. If it does not hurt to slowly shift in this direction then I think we should go for it. If there is an alternative reason for not having classes then please let us know as the cons @bencbartlett mentions has more to do with following qutip precedent than some fundamental disadvantage in performance or use. @ajgpitch @nonhermitian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384860713:1994,perform,performance,1994,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384860713,2,['perform'],['performance']
Performance,"ly by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with nump",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3901,optimiz,optimization,3901,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['optimiz'],['optimization']
Performance,"n my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`. Discussed more at the top.; - CuPy (CUDA operations on ndarray-likes) explicitly does not allow implicit conversion to `np.ndarray` (see cupy/cupy#3421) for performance reasons, but does implement `__array_ufunc__` and `__array_function__`.; - pydata/sparse (nd-sparse _arrays_ instead of scipy.sparse's sparse _matrices_): always implement `__array_ufunc__` and `__array_function__` because they are trying to be a sparse version of `ndarray`. By default, they do not implement `__array__` for performance/memory reasons, but they do allow turning it on by an environment variable. Do not implement anything:; - JAX (autodiff) tries really hard to replace numpy rather than interoperate with it; - scipy.sparse matrices are intended for use with a _matrix_ interface, not a broadcast-able _array_ interface. They specifically document that they will not provide this interface (see scipy/scipy#12279). Somewhat weirdly, they do have custom methods for some elementwise ufuncs, though (like `np.sin`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:7126,perform,performance,7126,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['perform'],['performance']
Performance,"nbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Check diagonalization via eigenbasis transformation ... ok; > > > brmesolve: harmonic oscillator, finite temperature ... ok; > > > brmesolve: harmonic oscillator, finite temperature, states ... ok; > > > brmesolve: harmonic oscillator, zero temperature ... ok; > > > brmesolve: Jaynes-Cummings model, zero temperature ... ok; > > > brmesolve: qubit ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... ok; > > > correlation: compare spectrum from eseries and pseudo-inverse methods ... ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > expect: operator list and state list ... ok; > > > expect: operator and density matrix ... ok; > > > expect: operator and ket ... ok; > > > expect: operator list and state ... ok; > > > expect: operator list and state list ... ok; > > > expect: operator and state list ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > gates: expand 1 to N ... ok; > > > gates: expand 2 to N (using cnot, iswap, sqrtswap) ... ok; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:2142,Concurren,Concurrence,2142,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['Concurren'],['Concurrence']
Performance,"ouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:4238,optimiz,optimization,4238,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['optimiz'],['optimization']
Performance,"p` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1567,perform,perform,1567,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,1,['perform'],['perform']
Performance,"q__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy transitive equality (i.e. `a == b and b == c` does not imply `a == c`). The pr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1309,cache,cache,1309,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,1,['cache'],['cache']
Performance,"r current longest tests](https://github.com/qutip/qutip/issues/1217#issuecomment-604116373), bearing in mind that some of those ones actually test many many things in the same test function.; > ; > The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up.; > ; > With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead.; > ; > I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them.; > ; > Minor things that _may_ speed up - check the profiling!; > ; > 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; > 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements internally is effectively `tensor(...(tensor(tensor(els[0], els[1]), els[2]), ...), els[-1])`. Excellent Suggestions ! I already added some of the speed-ups you suggested, just haven't pushed",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273:1179,load,loads,1179,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273,2,['load'],['loads']
Performance,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2105,optimiz,optimize,2105,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,3,['optimiz'],"['optimize', 'optimizer']"
Performance,"re\include/numpy/__multiarray_api.h:1634:1: warning: '_import_array' defined but not used [-Wunused-function]; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c: In function '__pyx_pw_8rhs14883_1cy_td_ode_rhs':; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t_off' may be used uninitialized in this function [-Wmaybe-uninitialized]; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_tp' may be used uninitialized in this function [-Wmaybe-uninitialized]; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t' may be used uninitialized in this function [-Wmaybe-uninitialized]; ok; correlation: comparing TLS emission correlations (fn-list td format) ... ok; correlation: comparing TLS emission correlations (fn td format) ... ok; Counting statistics: current and current noise in a DQD model ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... C:\Anaconda3\envs\qutip_py2\lib\site-packages\qutip\ptrace.py:111: RuntimeWarning: invalid name encountered in remainder np.fix(counter / np.prod(dims[sel[k + 1:]])), dims[sel[k]]) + 1",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-148708318:26791,Concurren,Concurrence,26791,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-148708318,1,['Concurren'],['Concurrence']
Performance,"ream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1152,perform,performed,1152,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,1,['perform'],['performed']
Performance,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3547,perform,performing,3547,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,1,['perform'],['performing']
Performance,"resentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; >; > ### Expected outcomes; > - More devices defined in the `qutip.qip.device` module. At the moment, we; > have two models: spin chain and cavity QED. We would like to include some; > other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in `qutip.qip.device` and; > `qutip.qip.compiler`; > - Refactoring the circuit compiler to allow simple pulse scheduling, e.g.; > Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages or; > commonly used language e.g. through quantum assembly language (qasm); > ----------------------------------------------------------------; >; > Best; > Boxi; >; > From: Nathan Shammah<mailto:notifications@github.com>; > Sent: Tuesday, February 25, 2020 8:36 AM; > To: qutip/qutip<mailto:qutip@noreply.github.com>; > Cc: Boxi Li<mailto:etamin1201@gmail.com>; Author<mailto:; > author@noreply.github.com>; > Subject: Re: [qutip/qutip] More detailed information for GSoC 2020 project; > (#1184); >; > Hi Boxi,; >; > Can you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wishes,; >; > Nathan; >; > Dr. Nathan Shammah; > Postdoctoral Research Scientist; > Theoretical Quantum Physics Laboratory; > RIKEN, Wako, Saitama, Japan; > www.n",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:2893,perform,perform,2893,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['perform'],['perform']
Performance,"sh function must follow from there are; 1. objects which compare equal with `__eq__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1211,cache,cache,1211,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,1,['cache'],['cache']
Performance,"sounds good to me. On 10 Jan 2017 07:30, ""Paul Nation"" <notifications@github.com> wrote:. > A faster isherm function. 3-5x faster if operator is Hermitian, 100x+; > faster if not. Essentially does a modified adjoint calculation. This; > requires having a csr matrix in canonical format, which is not guaranteed; > under sparse multiplication. Since canonical format is important for; > time-dependent dynamics as well, fast_csr_matrix now does the indices and; > data sorting for canonical format after multiplication. This gives a slight; > performance hit, but having all Qobj in canonical format outweighs this.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/qutip/qutip/pull/629; > Commit Summary; >; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - ENH: Faster isherm; >; > File Changes; >; > - *M* qutip/cy/spmath.pyx; > <https://github.com/qutip/qutip/pull/629/files#diff-0> (82); >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/629#issuecomment-271928375:542,perform,performance,542,https://qutip.org,https://github.com/qutip/qutip/pull/629#issuecomment-271928375,1,['perform'],['performance']
Performance,"ssues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inputs, that would be virtually impossible (or very close to that) to occur in practical scenarios. In any case, I'd strongly recommend performing a time-boxed experiment on a small subset of tests, which are more suited to property-based testing, and examining how that affects the test-run-completion time(s) and whether it introduces more failures than what would be desired/cost-efficient.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:3063,perform,performing,3063,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,1,['perform'],['performing']
Performance,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13598,perform,performance,13598,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['perform'],['performance']
Performance,tip.tests.test_dimensions.test_deep_remove ... ok; qutip.tests.test_dimensions.test_unflatten ... ok; qutip.tests.test_dimensions.test_dims_idxs_to_tensor_idxs ... ok; qutip.tests.test_dimensions.test_dims_to_tensor_shape ... ok; qutip.tests.test_dimensions.test_type_from_dims ... ok; qutip.tests.test_dimensions.test_collapse ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Entropy: Conditional entropy ... ok; Entropy: Entangling power ... ok; expect: operator list and state list ... ok; expect: operator and density matrix ... ok; expect: operator and ket ... ok; expect: operator list and state ... ok; expect: operator list and state list ... ok; expect: operator and state list ... ok; fastsparse: fast_csr_matrix operations ... ok; fastsparse: transpose operations ... ok; fastsparse: adjoint operations ... ok; Read and write complex valued decimal formatted data ... ok; Read and write complex valued default formatted data ... ok; Read and write complex valued exp formatted data ... ok; Read and write real valued decimal formatted data ... ok; Read and write real valued default formatted data ... ok; Read and write real valued exp formatted data ... ok; Read and write with automatic separator detection ... ok; qsave/qload ... ok; Floquet: test unitary evolution of time-dependent two-level system ... o,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:7564,Concurren,Concurrence,7564,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['Concurren'],['Concurrence']
Performance,"turn same result, ... ok; > > > Non-composite system, operator on Hilbert space. ... ok; > > > Non-composite system, operator on Liouville space. ... ok; > > > Superoperator: Converting superoperator to Choi matrix and back. ... ok; > > > Superoperator: Test that to_choi(q) returns q if q is already Choi. ... ok; > > > Superoperator: Test that converting a two-qubit superoperator through ... /usr/local/lib/python2.7/dist-packages/qutip/qobj.py:412: UserWarning: Multiplying superoperators with different representations; > > > warnings.warn(msg); > > > ok; > > > Superoperator: Converting superoperator to Choi matrix and back. ... ok; > > > Superoperator: Test that to_super(q) returns q if q is already a ... ok; > > > Superoperator: Checks that the trace of matrices returned by to_choi ... ok; > > > Superoperator: Checks that iscp, istp and iscptp work in a few different ... ok; > > > Superoperator: Checks that randomly generated superoperators are ... ok; > > > Superoperator: Randomized comparison of standard and optimized ... ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test unitary transformation with operators and superoperators. ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > qutip.tests.test_superoperator.TestMatrixVector.test_reshuffle ... ok; > > > utilities: energy unit conversions ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; > > > Wigner: Compare Wigner fft and iterative for rand. ket ... ok; > > > Wigner: Compare Wigner fft and iterative for rand. dm ... ok. # . ## ERROR: Qobj ad",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:11083,optimiz,optimized,11083,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['optimiz'],['optimized']
Performance,"y install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/propcom",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:1085,optimiz,optimizer,1085,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212,1,['optimiz'],['optimizer']
Safety," (3,); >>> arr[0]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. This change purely affects `np.array` and similar constructors when passed sequences of objects that all implement `__array__`. It is still possible to make a Numpy array of `Qobj` even with `Qobj.__array__` defined in Numpy 1.20, but you have to be rather more indirect about it:. ```python; >>> arr = np.empty((3,), dtype=object); >>> arr[:] = [qutip.qeye(2), qutip.qeye(2), qutip.qeye(2)]; >>> arr.shape; (3,); >>> arr[0]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. The reason numpy does this now is because (my understanding is that) defining `__array__` was meant to be a much stronger guarantee than just ""it's convenient to let `np.array` know about this object"". It was meant to be an indication that your class can be safely coerced into `ndarray` (and potentially coerced back afterwards), and that mathematical operations will satisfy the normal ufunc broadcasting rules, which isn't true of `Qobj`. That means that arrays of things implementing `__array__` should be safely representable as `ndarray`, which clearly isn't true for us. Similarly, ever since `Qobj.__array__` was first defined you could use Numpy ufuncs on `Qobj`, which would get implicitly converted to `ndarray` and then return complete nonsense, rather than throwing an error like ""what you're doing is silly"":; ```python; >>> np.sin(qutip.basis(2, 1)); array([[0. ],; [0.84147098]]); ```; (imo that should really be a `TypeError` if done without an explicit conversion into Numpy semantics). There is a way around that latter point in modern Numpy - defining `Qobj.__array_ufunc__ = Qobj.__array_function__ = None` - but it does raise the question of whether we _should_ define `Qobj.__array__`; we have no intention of implying that `Qobj` satisfies the general Numpy ufunc interface, and it isn't any sort ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-773992094:2129,safe,safely,2129,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-773992094,1,['safe'],['safely']
Safety," Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:2166,avoid,avoid,2166,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,2,"['avoid', 'safe']","['avoid', 'safety']"
Safety," excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Entropy: Conditional entropy ... ok; Entropy: Entangling power ... ok; expect: operator list and state list ... ok; expect: operator and density matrix ... ok; expect: operator and ket ... ok; expect: operator list and state ... ok; expect: operator list and state list ... ok; expect: operator and state list ... ok; fastsparse: fast_csr_matrix operations ... ok; fastsparse: transpose operations ... ok; fastsparse: adjoint operations ... ok; Read and write complex valued decimal formatted data ... ok; Read and write complex valued default formatted data ... ok; Read and write complex valued exp formatted data ... ok; Read and write real valued decimal formatted data ... ok; Read and write real valued default formatted data ... ok; Read and write real valued exp formatted data ... ok; Read and write with automatic separator detection ... ok; qsave/qload ... ok; Floquet: test unitary evolution of time-dependent two-level system ... ok; gates: expand 1 to N ... ok; gates: expand 2 to N (using cnot, iswap, sqrtswap) ... ok; gates: expand 2 to N (using swap) ... ok; gates: expand 3 to N (using toffoli, fredkin, and random 3 qubit gate) ... ok; gates: expand 3 to 3 with permuTation (using toffoli) ... ok; gates: swap gate ... ok; qutip.tests.test_gates.TestGates.test_are_cliffords ... ok; qutip.tests.test_gates.TestGates.test_clifford_group_len ... ok; Graph: Graph Degree ... ok; Graph: Breadth-First Search ... ok; Graph: Reverse Cuthill-McKee Ordering (simple) ... ok; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:8454,detect,detection,8454,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['detect'],['detection']
Safety," it is not clear which is the best one:. 1. Ensure all eigen values and eigen vectors are computed.; 1.1 This could be done by finding an alternative to scipy to solve for sparse matrix decomposition, but it would add extra requirement and it must be easy to install with pip.; 1.2 Use a third call to `scipy.sparse.linalg.eigs`/ `scipy.sparse.linalg.eigsh` using `sigma` to find all the pseudo degenerate values. It need to be done while being careful about special cases. This would make the sparse eigen solver even slower than it already is.; 2. Allow to sort by other orders, such as the complex value or magnitude. This would not solve the issue, but give some options to go around it. However the dense eigen solver would be expected to behave the same and the dense eigen solver does not have this options, so we need to implement it ourselves. This sorting option would also be required for any other data type we want to support. To go around that, the `Qobj` methods could be responsible for the sorting, the `sort` argument would only be passed to the dispatched function when `sparse=True`.; 3. Refuse to use the sparse solver for the full decomposition as scipy does. The sparse eigensolver is both slow and hard to use in this case. Also the eigen vectors computed by the sparse solver are stored in a dense array, so it is not that useful to save memory...; 4. Implement our own sparse eigen decomposition...; 5. Only document the issue without fixing. The default is the dense solver, which is both faster and safer in almost all cases.; 6. Something else...; ; I would personally go for either 1.2 of 3. ; Adding different sorting options in `Qobj` methods (2) and removing them from the dispatched functions, could be nice, but it's not a fix. The place to start would be to debate on the solution. If you have some opinion on the matter, please let us know.; Once we've made up our mind, you can implement it, but only 5 would be an easy fix in line with other _good first issue_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161:1613,safe,safer,1613,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161,1,['safe'],['safer']
Safety," n = dg.data.nnz; @@ -1177,9 +1177,9 @@ class Dynamics(object):; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; - dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; + dg += self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; else:; - dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]; + dg += self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]; ; self._dyn_gen[k] = dg; if self.cache_phased_dyn_gen:; diff --git a/qutip/control/fidcomp.py b/qutip/control/fidcomp.py; index bb7a67ef..afa898ad 100644; --- a/qutip/control/fidcomp.py; +++ b/qutip/control/fidcomp.py; @@ -729,7 +729,7 @@ class FidCompTraceDiffApprox(FidCompTraceDiff):; if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; - evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; + evo_final_eps *=dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; diff --git a/qutip/control/pulsegen.py b/qutip/control/pulsegen.py; index ec5ac177..418da1ff 100644; --- a/qutip/control/pulsegen.py; +++ b/qutip/control/pulsegen.py; @@ -283,7 +283,7 @@ class PulseGen(object):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; - pulse = pulse*ramping_pulse; + pulse *= ramping_pulse; ; return pulse; ; @@ -379,7 +379,7 @@ class PulseGenRndFourier(PulseGen):; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); - wavelen = wavelen/2.0; + wavelen /= 2.0; ; num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); @@ -650,7 +650,7 @@ class PulseGenLinear(PulseGen):; for k in range(self.num_tslots):; y = self.gradient*t + self.start_val; pulse[k] = self.scaling*y; - t = t + self.tau[k]; + t += self.tau[k]; ; return self._apply_bounds_and_offset(pulse); ; @@ -745,7 +745,7 @@ class PulseGenSine(PulseGenPeriodic):; for k in range(self.num_tslots):; phase = 2*np.pi*self.freq*t +",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:2942,avoid,avoids,2942,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['avoid'],['avoids']
Safety," only _detected_ at garbage collection. Here is the output of a Python 3.8 crash on the `Malloc.py` file with some additional debugging enabled. This is with Python 3.8.8, Numpy 1.19.2, Scipy 1.6.2 and MKL:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler Malloc.py; 500; Debug memory block at address p=0x7fa2e02de610: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7fa2e02ed64f are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p: dd dd dd dd dd dd dd dd ... 00 00 00 00 00 00 00 00. Enable tracemalloc to get the memory block allocation traceback. Fatal Python error: bad trailing pad byte; Python runtime state: finalizing (tstate=0x7fa2ddc04270). Current thread 0x00000001123d55c0 (most recent call first):; <no Python frame>; Abort trap: 6; ```. ## Relation to `to_kraus`. The above `Malloc.py` file uses `scipy.linalg.eig` via use of an `eseries` version of `correlation`. The current test of superoperator representations uses `choi_to_kraus` which also calls `scipy.linalg.eig`. Here is a file `kraus.py` that can reproduce these segfaults semi-reliably (may need to run it a few times to get it to trigger):. ```python; import qutip. s = qutip.rand_super(); c = qutip.to_choi(s); k = qutip.to_kraus(c); ```. For example, here's a similar command on this file:. ```; Debug memory block at address p=0x7f98cc467db0: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7f98cc476def are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OU",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:3580,Abort,Abort,3580,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['Abort'],['Abort']
Safety," special about the value 1e-12 for Qobjs. Multiplying a Qobj with a float<1e-12 makes all entries 0.0. This can be worked-around as follows:; > ; > import qutip as qt; > ; > print ""Multiplying states by small numbers""; > state3 = qt.ket([0])_1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1476,detect,detector,1476,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,"'t access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6577,safe,safe,6577,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['safe'],['safe']
Safety,"**Update - Ignore this. This problem was because I called the file ""pyqtgraph"" which conflicted with the library name.**. > As I understand it, the new Mac M1 chips have an ARM-based architecture so there shouldn't be any compatible binary releases on conda yet for macos - I'm surprised conda even claimed to have solved the system. Maybe they've not updated to take the new chips into account either.; > ; > If you can, you might want to try building from source - you'll also need the Python package Cython, but this way should build all the binary components for your architecture. We know (#1395) that there's a minor problem with some hardware detection on the M1 macs at the moment, but you can comment out lines 48 and 49 of `qutip/hardware_info.py` to work around it.; > ; > None of us have one of the new macs, and I think we'll need a new release to get conda-forge updated. It might be a little while before we get that done, sorry. I have the same error on an Intel Mac (11.2.1) having installed pyqtgraph within PyCharm. ```; Connected to pydev debugger (build 203.7148.72); Traceback (most recent call last):; File ""<frozen importlib._bootstrap>"", line 991, in _find_and_load; File ""<frozen importlib._bootstrap>"", line 975, in _find_and_load_unlocked; File ""<frozen importlib._bootstrap>"", line 671, in _load_unlocked; File ""<frozen importlib._bootstrap_external>"", line 783, in exec_module; File ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed; File ""/Users/ben/Library/Application Support/JetBrains/PyCharm2020.3/scratches/pyqtgraph.py"", line 3, in <module>; pg.mkQApp(); AttributeError: partially initialized module 'pyqtgraph' has no attribute 'mkQApp' (most likely due to a circular import). ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-776702708:650,detect,detection,650,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-776702708,1,['detect'],['detection']
Safety,".array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Opti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:1185,predict,predictions,1185,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553,1,['predict'],['predictions']
Safety,"0: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7f98cc476def are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p: dd dd dd dd dd dd dd dd ... 00 00 00 00 00 00 00 00. Enable tracemalloc to get the memory block allocation traceback. Fatal Python error: bad trailing pad byte; Python runtime state: finalizing (tstate=0x7f98c9d018e0). Current thread 0x0000000109fe85c0 (most recent call first):; <no Python frame>; Abort trap: 6; ```. So these both use `scipy.linalg.eig`, which is suspicious. ## Valgrind checks. To see if I could track it down, I had a go with valgrind. This isn't guaranteed to find everything, because I'm not using a debug build of Python, and Python also typically optimises small allocations by using a custom allocator into some pre-allocated space it manages itself - invalid writes that still fall within this may not get detected by valgrind. Here is the output of `valgrind` running on the `kraus.py` file I wrote in the previous section: [kraus_valgrind.txt](https://github.com/qutip/qutip/files/6370180/kraus_valgrind.txt) (note I filtered out like 30,000 errors that stem from Python's internal memory management - they're nothing to worry about, they're just what happens when you have your own allocator). The important part is. ```; ==54133== Invalid write of size 8; ==54133== at 0x10AFAFA8A: ??? (in /Users/jake/.anaconda3/envs/py38/lib/libmkl_intel_thread.dylib); ==54133== by 0xFFFFFFFF: ???; ==54133== by 0x1162E4DEF: ???; ==54133== by 0x1162E3A5F: ???; ==54133== by 0x10550EB3F: ???; ==54133== by 0x3FEFFFFFFFFFFFFF: ???; ```. Obviously I don't have the debugging symbols for MKL, so it's pretty hard to say where exactly it's coming from, but it is at least clearly inside that l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:5297,detect,detected,5297,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['detect'],['detected']
Safety,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:1443,predict,predictions,1443,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553,1,['predict'],['predictions']
Safety,"1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub, or mute",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1608,detect,detector,1608,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,"; > ; > print ""Multiplying states by small numbers""; > state3 = qt.ket([0])_1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1553,detect,detector,1553,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,"; ```; Map(Space(Map(Space, Space)), Space(Map(Space, Space))); ```; to; ```; Super(Space(Map(Space, Space)), Space(Map(Space, Space)), rep='super'); ```; and I definitely like having the superop rep included in it. The user is never ever meant to write any of this themselves, so the literal length shouldn't be too much of a problem. You'd still specify dimensions using the exact same list syntax that we currently use, it's just we'd immediately parse it into this internal representation and internally operate on this, because it's much faster. Essentially what I'm describing here is an abstract syntax tree for relevant linear algebra structures. We _could_ even have the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. Y",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:1455,safe,safety,1455,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,1,['safe'],['safety']
Safety,"> ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. @AGaliciaMartinez Hey Asier, issue #1616 refers to a similar problem. Following it, I tried `plt.show()` and it works. But `b.show()` doesn't work. So, please suggest what to do? Now that `plt.show()` works, I can remove my minor addition in the `show()`, but still I would like to have `b.show()` working. Looking forward to your response.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059:227,avoid,avoid,227,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059,1,['avoid'],['avoid']
Safety,"> > I am not sure why it is only failing in the Python 3.8 case.; > ; > Well, it's a statistical average, so it can deviate. I don't think it has anything to do with Python 3.8. But probably it can be avoided? I guess its the same question as #1268; > ; > I'm thinking, what about adding a `targets` parameters to `QubitCircuit.run_statistics`. Usually, people don't interested in the full output state of the circuit because many of them are ancillary qubits. They can use `targets` to specify what is the qubits they want to look at. In the function, we can use `ptrace(state, targets)` to trace out the ancilla. Seems like a good idea, maybe we can add it as optional parameter to both `QubitCircuit.run_statistics` and `QubitCircuit.run`. Also, regarding Python 3.8, I was saying because both times it only failed in that test run, also never failed in any of my runs. Should I make tolerance higher ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640006594:201,avoid,avoided,201,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640006594,1,['avoid'],['avoided']
Safety,"> > _**Other minor changes**_; > > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > > ```; > > if self.fig:; > > plt.show(self.fig); > > ```; > ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. So, I found that the value of `self._shown` is false when it tries to execute `show()', and therefore, the Bloch sphere is not displayed. ; I use the following code to play around with the Bloch sphere, please let me know if I need to add something:; ```; b= Bloch(fig=None); b.xlabel = ['$\\left|+\\right>$',' ']; b.ylabel = ['$\\left|+i \\right> (r_8)$',' ']; b.xlpos = [1.1,-1.1]; b.zlabel = [' $\\left|0\\right> (r_7)$','$\\left|1\\right> $']; b.zlpos = [1.075,-1.08]. <b.add_other_stuff>. b.view=[-20,20,0]; b.show(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485:474,avoid,avoid,474,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485,1,['avoid'],['avoid']
Safety,"> As I understand it, the only way to avoid needing to touch `MANIFEST.in` is to not have files distributed with the test suite (or to have the temporary files by `*.py`, since `setup.py` automatically recognises them). That's not really a pytest thing, it's a `setuptools` one.; > ; > I don't think there's a problem distributing files as part of the tests. You can add a line which says; > ; > ```; > recursive-include qutip/tests/qasm_files *.qasm; > ```; > ; > to `MANIFEST.in`, and that should hopefully fix the problem. You won't have the problem locally, because you'll be running `./setup.py develop`, which ""installs"" in-place, so you don't notice the fact that you've missed files from the manifest. In the tests, it runs `./setup.py install`, which does the copy, missing files which aren't in the manifest.; > ; > Boxi: I'm not certain what more you'd like to do with fixtures here. Fixtures are good for setup and tear down, parametrisation and sharing resources (like network connections), but I'm not certain what further benefit you get for a test function which is testing whether it can open a known file, read it, and construct the expected output. I think Sidhant is already doing some nice parametrisation of his tests, from what I see.; > ; > Sidhant: I added a comment on the exception test, since pytest gives us an easier-to-read context manager you can use. It's also typically better practice to handle file paths like I did in that (using the overloaded `/` operator with `pathlib.Path`, or `os.path.join`) rather than manually putting in slashes. Windows _usually_ will do the right thing now with slashes, but it's better to let Python handle it for us. Thanks for this information, it seems to work ! I was wondering if the following statement is still needed (at all) in `PACKAGE_DATA` in setup.py? ; `'qutip/tests/qasm_files': ['*.qasm'],`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-656450639:38,avoid,avoid,38,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-656450639,1,['avoid'],['avoid']
Safety,"> Does anyone know how we would give some kind of deprecation warning when `from qutip import *` is made to say that only core functions will be imported from v5 onwards?. @ajgpitch . I know I'm resurrecting a dead thread, but I have a way of detecting star imports if you can cope with a fairly gross hack. The only internal difference in `from qutip import *` (that I know about) from `import qutip` is that in the former, the import system access the `qutip.__all__` list to see which names it should import. This is intended to be a list of names, so the star import doesn't _have_ to import every single name, i.e. so you can manually set what's public to a module; the star import is designed for use within packages, and the user importing a package like that is strongly recommended against (though in scientific code, I'm 100% sure that's a losing battle). So, what if we make `__all__` _look_ like a list, but a list that injects a warning whenever anyone tries to see what items it has? An example:; ```python; import warnings as _warnings. x = 2. class _all_wrapper(list):; def __iter__(self, *args, **kwargs):; _warnings.warn(""You star-imported!""); return super().__iter__(*args, **kwargs). __all__ = _all_wrapper(['x']); ```; I put that in a package called ""test"".; ```python; >>> from test import x; >>> x; 2; ```; or; ```python; >>> from test import *; /Users/jake/code/tmp/test/__init__.py:7: UserWarning: You star-imported!; _warnings.warn(""You star-imported!""); >>> x; 2; ```. I won't complain if you want to scream after that...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925:243,detect,detecting,243,https://qutip.org,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925,1,['detect'],['detecting']
Safety,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:244,avoid,avoid,244,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451,1,['avoid'],['avoid']
Safety,"> I am not sure why it is only failing in the Python 3.8 case. Well, it's a statistical average, so it can deviate. I don't think it has anything to do with Python 3.8. But probably it can be avoided? I guess its the same question as #1268 . I'm thinking, what about adding a `targets` parameters to `QubitCircuit.run_statistics`. Usually, people don't interested in the full output state of the circuit because many of them are ancillary qubits. They can use `targets` to specify what is the qubits they want to look at. In the function, we can use `ptrace(state, targets)` to trace out the ancilla.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640005926:192,avoid,avoided,192,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640005926,1,['avoid'],['avoided']
Safety,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:761,safe,safe,761,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667,1,['safe'],['safe']
Safety,"> I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine. Where were you running your example? Python console, IPython console, Jupyter notebook? I'm guessing the IPython console because of the reference to `display`, but I wanted to double check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1619#issuecomment-988089216:165,redund,redundant,165,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988089216,1,['redund'],['redundant']
Safety,"> It feels more 4.6.3 since it's not a new feature but removing unused code in `__init__`, making qutip's import safer. So it looks more like a bug fix to me. Is there any specific reason to wait for 4.7?. I was thinking that we're removing functions that users might be using in their own code. On the other hand it is functionality that is untested and breaks on many modern machines, so I am not completely against adding this to 4.6.3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1758#issuecomment-1015547699:113,safe,safer,113,https://qutip.org,https://github.com/qutip/qutip/pull/1758#issuecomment-1015547699,1,['safe'],['safer']
Safety,"> It would be good if our naming can help avoid confusion between the concept of a `dtype` (which is the type of elements within an array) and our `data backend type` (which is how the array itself is represented). I'm not sure what a good convention is, but ensuring the docstrings for the backend type have specific examples of valid inputs would definitely help (e.g. `dense` or `csr`). We actually deliberately called this `dtype` to make it familiar to Numpy syntax. The concept of the Numpy `dtype` is mostly irrelevant when using QuTiP, because all data is invariably `double complex`, and this `dtype` is the larger data type of `Qobj`. I suppose it could be `fmt` instead (as a common abbreviation of `format`)? Or even the full word `format` I suppose. Agree on the docstrings - we should have an alias like Numpy's `array_like` that we define clearly in documentation in one place.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-809213365:42,avoid,avoid,42,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-809213365,1,['avoid'],['avoid']
Safety,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:478,avoid,avoid,478,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845,2,['avoid'],['avoid']
Safety,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:278,avoid,avoid,278,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502,1,['avoid'],['avoid']
Safety,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:1482,avoid,avoids,1482,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695,1,['avoid'],['avoids']
Safety,"> This is the same as #1247; > ; > QuTiP uses sparse matrices, so a matrix element smaller than a certain threshold (by default 1e-7) will be discarded. This can be changed in the settings.; > ; > Consider changing your unit to avoid very small values, for instance, by writing the formula with h=1` and in nanosecond time unit. Sorry which formula are you referring to when you say h=1'?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1466#issuecomment-804906162:228,avoid,avoid,228,https://qutip.org,https://github.com/qutip/qutip/issues/1466#issuecomment-804906162,1,['avoid'],['avoid']
Safety,"> What's the preferred method to link functions that are not public APIs?. I don't think we should link to non-public API in the doc. Non-public API should not (at least no encouraged) be used outside of QuTiP because we may change it without issuing a deprecation warning. Besides, [`check_unitary`](http://qutip.org/docs/latest/apidoc/classes.html?highlight=check_isunitary#qutip.Qobj.check_isunitary) is a public API, it is a class method under `Qobj`, rather than a function, see bellow. > Qobj vs qobj link. `qutip.qobj.isoperbra` and `qutip.Qobj.isoperbra` are different. The lower case `qobj` is a submodule in QuTiP (qobj.py) while `Qobj` is a class. `isoperbra` is not a class method under `Qobj`. It is a function defined under the submodule `qobj`. So only `qutip.qobj.isoperbra` is the correct path. To make the life simpler, I would recommend to use the shortcut ``:func:`.isoperbra` `` for functions and ``:meth:`.Qobj.class_method` ``. Or even simpler: ``:obj:`.isoperbra` ``. Sphinx will automatically look for the correct match. As long as there are no two functions with the same name, we are safe. This isalso because `qutip.qobj.isoperbra` will be a wrong path in qutip 5.0. The file is moved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1499#issuecomment-824624079:1111,safe,safe,1111,https://qutip.org,https://github.com/qutip/qutip/pull/1499#issuecomment-824624079,1,['safe'],['safe']
Safety,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:937,avoid,avoid,937,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649,1,['avoid'],['avoid']
Safety,"> You see, the gate Gate(RY, targets=[0, 1], controls=None) is clearly wrong because RY acts only on one qubits. Yep ! That's what I thought as well..for all the single qubit gate outputs with two targets. I knew I was getting an error but was not sure why it was not the same error as both of you. It was because I was using the released version (like you predicted). . I was trying to put off installing from source for as long as I could because I would have to install conda and other dependencies manually. Now, I did get `ValuError`. Thanks !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1330#issuecomment-810592555:357,predict,predicted,357,https://qutip.org,https://github.com/qutip/qutip/issues/1330#issuecomment-810592555,1,['predict'],['predicted']
Safety,"> _**Other minor changes**_; > ; > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > ; > ```; > if self.fig:; > plt.show(self.fig); > ```; This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935:464,avoid,avoid,464,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935,1,['avoid'],['avoid']
Safety,"> state3 = qt.ket([0])_1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, vi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1582,detect,detector,1582,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,"@AGaliciaMartinez @RobHam99 I will put in a small vote that we leave sorting this out for QuTiP 5 (i.e. the dev.major) branch, where I suspect it has been sorted out already. The only QuTiP release it could go into before 5 would be 4.7 and I'd like to avoid doing too many minor clean-ups in 4.7 because I want 4.7 to just work nicely for existing users before the big just to 5. Happy to consider exceptions to that policy on a case by case basis though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1716#issuecomment-974502454:253,avoid,avoid,253,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-974502454,1,['avoid'],['avoid']
Safety,"@AGaliciaMartinez Perhaps it would be better to check for whether `other` is complex directly using `isinstance(other, numbers.Number)`. This is the canonical approach for detecting scalar numbers and avoids raising and catching an exception and allows objects that support just `__complex__` to still be dispatched for special handling.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-885075257:172,detect,detecting,172,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885075257,2,"['avoid', 'detect']","['avoids', 'detecting']"
Safety,"@AGaliciaMartinez The `.elements` are intentionally only accessible from Cython (it's not safe to modify the list from Python because the QobjEvo element lists are meant to be immutable). If you have an idea for a cleaner implementation of this though, maybe just write the idea here and then we can all look at it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808:90,safe,safe,90,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808,1,['safe'],['safe']
Safety,"@AGaliciaMartinez This doesn't look terrible to me, but we've avoided silencing warnings like this in qutip so far and it would be nice to keep it that way. Some questions:. * Do you know why qutip's own tests are not affected?; * Which qutip-tensorflow tests are affected? All of them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142:62,avoid,avoided,62,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142,1,['avoid'],['avoided']
Safety,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:643,avoid,avoid,643,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898,1,['avoid'],['avoid']
Safety,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:145,timeout,timeout,145,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801,1,['timeout'],['timeout']
Safety,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:289,timeout,timeout,289,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877,2,['timeout'],"['timeout', 'timeouts']"
Safety,"@Ericgig I re-factor the result class a fair bit to make it possible to re-use more of it for the HEOMSolver. Let me know if you like the general approach. I would like to remove the additional parameters to `_post_init(...)` and supply everything either directly via the result options (since that would avoid the HEOMResult class receiving parameters it doesn't use like ``rhs_is_super``). I'm happy to implement that here if you have an idea, but I'm also happy to leave it for a future PR (maybe post #1889).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1139694450:305,avoid,avoid,305,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139694450,1,['avoid'],['avoid']
Safety,"@Ericgig Ready for review again. I haven't implemented anything for detecting whether an .e_op returns a number that can be averaged, and I'd like to leave that for a later PR because it's really about a better implementation of the MultiTrajResult and MultiTrajResultAveraged classes and that feels quite separate (even if it tweaks the Result class a bit more). In the `HEOMResult` class in #1869 I override `_store_state`, `_store_final_state`, `_pre_copy` and `_e_op_func` which gives quite a lot of flexibility and might be sufficient to implement `MultiTrajResult` as a sub-class of `Result`. There is also a question of whether there should be a way to supply processors directly -- either in e_ops or a separate lists. Processors are almost identical to e_ops except their values are not stored in `.expect` or `.e_data` and they don't appear in `.e_ops`. I'd like to leave that for a later (maybe never) PR too -- currently I don't have an immediate use case for it, and I don't want to expose the extra feature directly until we do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664:68,detect,detecting,68,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664,1,['detect'],['detecting']
Safety,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:168,avoid,avoid,168,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156,1,['avoid'],['avoid']
Safety,"@Ericgig That is true. Possibly a check in `Qobj` constructor, would be the best to avoid mismatched `Qobj`s to be created in the first place. A rudimentary fix might be something like:. ```diff; diff --git a/qutip/qobj.py b/qutip/qobj.py; index bf82a4a6..6c7c630d 100644; --- a/qutip/qobj.py; +++ b/qutip/qobj.py; @@ -310,6 +310,11 @@ class Qobj(object):; ); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]; ; + if self._data.shape[0] != np.prod(self.dims[0]) or \; + self._data.shape[1] != np.prod(self.dims[1]):; + raise ValueError(f""Qobj has mismatched dims {self.dims} "" +\; + f""and shape {self._data.shape}""); +; if type == 'super':; # Type is not super, i.e. dims not explicitly passed, but oper-like; # shape.; ```; If you think this would be a good fix I can open a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782#issuecomment-1021447683:84,avoid,avoid,84,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021447683,1,['avoid'],['avoid']
Safety,"@Ericgig When I read the description of this PR I thought you might have implemented something that might be even faster. Instead of having the numpy proxy have dynamic access via `__getattr__` we could do either of the following:. * When the numpy backend is set, actually copy the attributes across to the proxy objects so that they are looked up in `__dict__` in the ordinary way without having to fall back to `__getattr__`.; * Do the same as the above but define the attributes as slots so that the `__dict__` lookup is avoided.; * Or implement `__getattribute__` so that the original `__dict__` lookup is never checked.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618:525,avoid,avoided,525,https://qutip.org,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618,1,['avoid'],['avoided']
Safety,"@Ericgig yes, I like the args idea. Let's go with that. And you are of course right about the use of `dense2D_to_fastcsr_fmode`. Should definitely be avoided in users code",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/947#issuecomment-462900455:150,avoid,avoided,150,https://qutip.org,https://github.com/qutip/qutip/issues/947#issuecomment-462900455,1,['avoid'],['avoided']
Safety,@Zac-HD Would you mind doing a quick sanity check of my `MatrixShapesStrategy` class (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L15-L62)? Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. I also wouldn't mind a quick check of `qobj_shared_shapes` (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L113-L131). Is this a good thing to be doing with shared strategies?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602:37,sanity check,sanity check,37,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602,1,['sanity check'],['sanity check']
Safety,"@ajgpitch I am trying to fix this will Pull #660. I do not see this on any other compiler, so it is hard to peg down. Hopefully, switching to a vector from a pointer does the trick. The strange thing is that Apple's own clang compiler does not abort with this error, but somehow XCODE does.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/649#issuecomment-286179882:244,abort,abort,244,https://qutip.org,https://github.com/qutip/qutip/issues/649#issuecomment-286179882,1,['abort'],['abort']
Safety,"@arnelg and @cgranade, you are both raising good points here. I'm not exactly sure what the best solution for this particular issue is, but do tend to agree with @arnelg that we do not want functions that perform unexpected actions, if possible, and that explicit is better than implicit. However, ultimately, it has to be the docstrings that should resolve any ambiguities, because not all functions can be intuitive to everyone, since we all have different backgrounds and expectations. So if the current behaviour is clearly described in the docstring, it should also be an acceptable solution I think. But one important thing that @arnelg also alluded to is that if at some point we expect that we might want to use `composite(S, O)` to mean something different than `composite(S, to_super(O))`, then we should better not implement the operator-to-superoperator promotion implicitly in `composite` now. Since the `composite` function is brand new it might be a good idea at this point to avoid doing these implicit assumptions on how it will be used until various use-cases has been explored in more details. I absolutely agree that it is great to have discussions about these kind of design issues, and it's great that you both have taken an interest in this particular issue. I also agree that Qobj.dims is a bit obscure and not that flexible, and maybe insufficient for complex cases with mixes of operators, kets, superoperators along different subsystems. This would not be an easy thing to change, but having a discussion about the short-comings and possible solutions would be great. I've created a new page on the wiki for listing various issues and design short-comings in qutip:. https://github.com/qutip/qutip/wiki/Future-Design-Changes. Feel free to add to this page and edit what's already on it (and of course, propose solutions!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58190164:992,avoid,avoid,992,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58190164,1,['avoid'],['avoid']
Safety,"@asma2farhat; If you don't use `countstat`, you can safely ignore this.; Otherwise it should be fixed in the `qutip-4.7.X` branch with #2323, (not released yet, coming in 4.7.6):; `pip install git+https://github.com/qutip/qutip@qutip-4.7.X`; It should also be fixed in v5 that is in beta `pip install qutip --pre`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977:52,safe,safely,52,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977,1,['safe'],['safely']
Safety,@cgranade did you test your PR #362 against dick-t example? If so what were the results?; It would seem that dick-t is comparing a method that works with states in general (mixed or pure) with one that assumes states are pure. Do we have some method in qutip that gives the fidelity when states are assumed pure? It would seem more efficient (and less numerical error risk) to compute the fidelity without the sqrtm (as dick-t did in the comparison) if we knew the states were pure.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134927300:368,risk,risk,368,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134927300,1,['risk'],['risk']
Safety,"@drew-parsons I imagine `MPLBACKEND=agg` avoids the issue by not using X at all. I have used it in the past for matplotlib tests, and it's not a bad idea perhaps to switch the QuTiP visualization tests to the `agg` backend, but it's not something I'm going to tackle right now I don't think (too many other big QuTiP changes up in the air at the moment).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571:41,avoid,avoids,41,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571,1,['avoid'],['avoids']
Safety,"@goerz I think one of Mølmer's papers (maybe the one I have pointed out) addressed the equivalence of the two methods. Sorry, I don't have a definite paper to point out at this moment. I was actually organizing the Julia community to work on this direction (see [JuliaQuantum](http://juliaquantum.github.io)) from scratch, and hence didn't follow up the efforts in the measurement simulation within QuTiP. . When I was writing my paper on continuous measurement ([PRA, 93.023817](http://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.023817)), I came up the argument that the former method may be more appropriate for measurement models. This is because measurements have to happen in evenly spaced time steps determined by the detector's integrating time, so it is intuitive to use a random number to judge if on each measurement step the quantum jump will happen. There may be a way to use the second method to implement the same measurement simulation model, but I didn't think too much on it. In reality, I developed another more efficient method without actually evolving the density operator in my paper to simulate continuous measurement using a set of stochastic equations for squeezing thousands of atoms' state which has not been included in QuTiP yet. Sorry I don't have more useful reference that explains this point in more details at this moment. Good luck!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-220744432:731,detect,detector,731,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-220744432,1,['detect'],['detector']
Safety,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:234,detect,detected,234,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548,3,['detect'],"['detected', 'detection']"
Safety,@jakelishman Leaving it as is sounds fine to me. Deprecation warnings are filtered out by default when running Python scripts these days (unless one runs with `-X dev`) so that and the notebook filtering probably avoids the majority of cases where someone will be annoyed or confused by the warnings.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1480#issuecomment-815581980:213,avoid,avoids,213,https://qutip.org,https://github.com/qutip/qutip/pull/1480#issuecomment-815581980,1,['avoid'],['avoids']
Safety,"@nonhermitian Hi Paul, I don't think it's super important to necessarily have the most efficient algorithm for allowing non-linear tlists, but I do think it's good to have to avoid tripping up more advanced users. Could you merge this solution and we can always re-visit later?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/520#issuecomment-245201155:175,avoid,avoid,175,https://qutip.org,https://github.com/qutip/qutip/pull/520#issuecomment-245201155,1,['avoid'],['avoid']
Safety,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:298,avoid,avoid,298,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354,1,['avoid'],['avoid']
Safety,@sahmed95 shouldn't the merge automatically take care of that without bothering to rebase? . I'd like to avoid wasting time on a rebase if there's no tangible benefit,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398031660:105,avoid,avoid,105,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398031660,1,['avoid'],['avoid']
Safety,"@victor-onofre Thank you for looking at this! I think it's important to address @nwlambert's concerns once @Ericgig has had a look. Note: Issue #1808 isn't part of the current Unitaryhack, so I am removing the ""[unitaryhack]"" from the issue title to avoid confusion.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1929#issuecomment-1153723802:250,avoid,avoid,250,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153723802,1,['avoid'],['avoid']
Safety,@wrzadkow thank you. It sounds good to me. Could [detect](https://stackoverflow.com/questions/5376837/how-can-i-do-an-if-run-from-ipython-test-in-python) whether the environment is `IPython`. ; If you can write a test too for it to avoid environment-dependent errors that would be great.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/989#issuecomment-493725091:50,detect,detect,50,https://qutip.org,https://github.com/qutip/qutip/issues/989#issuecomment-493725091,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"@ziofil, I just checked that updating the colab notebook to have the line; ```; !pip install scipy==1.2.1; !pip install qutip; ```; works for me, as @quantshah mentioned. ; QuTiP will find already the SciPy 1.2.1 requirement and will avoid keeping 1.3.; It is an issue with `IndexMixin` relocation in SciPy 1.3 (released this May 17), which has been changed from `scipy.sparse.sputils` to `scipy.sparse._index`.; I tested this also in My Binder and this works too, by setting in the `environment.yml` file, ; [in line 9,](https://github.com/nathanshammah/interactive-notebooks/blob/master/environment.yml#L9); from; ```; - scipy; ```; to ; ```; - scipy==1.2.1; ```; I will open a PR with this patch for `qutip-notebooks` for the time being. Once the next official version of QuTiP is released, this problem will not arise, as this issue has been taken care of by @Ericgig in PR #999 by updating scipy `IndexMixin`, now under private use, with scipy `get_index_dtype`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1008#issuecomment-499038616:234,avoid,avoid,234,https://qutip.org,https://github.com/qutip/qutip/issues/1008#issuecomment-499038616,1,['avoid'],['avoid']
Safety,"About pickling. `QobjEvo` doesn't contain any cython only data and cython autopickling is working fine.; There is a test for it. (But not for windows, there is still a risk there).; But function used in `linear_map` or in coefficient etc. may cause problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-815141272:168,risk,risk,168,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-815141272,1,['risk'],['risk']
Safety,"After a second look, I realize that small numbers might not be the problem here. I was thinking that the `coeffs` you computed is too small so that it gets discarded. It turned out that your `Delta` is around 10^6, which is not small at all. Apologies for the rush. ; Still, I would suggest changing the unit so that `Delta` is close to 1 to avoid this kind of pitfalls. Then, there could be the following reasons:; - In the example you give, `w-w0` is actually 0, if you then choose phi=0, the `coeffs` is always 0. But this maybe just a mistake from extracting this example.; - A more likely problem is that `pulse` function, `t` is not used at all. I guess you probably mean that the pulse is turned on at `t=t0`, which should be:; ```; def pulse(t0,t):; return np.heaviside(t - t0, 2e-9); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1466#issuecomment-805120396:342,avoid,avoid,342,https://qutip.org,https://github.com/qutip/qutip/issues/1466#issuecomment-805120396,1,['avoid'],['avoid']
Safety,"After you created a fork to work on #1242, a different PR (#1226) was merged into `master`. It so happens that #1242 and #1226 don't conflict so that merge succeeded, but the new changes you're now trying to make do. This is fundamentally a true merge conflict and so unfortunately there's no fancy way around it, though it could have been avoided if you'd matched the state of our `master` before beginning work here, and it would be a bit easier for you for future PRs to branch off before starting work (GitHub has [some nice material about this workflow](https://guides.github.com/introduction/flow/)). I've rebased your PR onto our `master` and fixed the resulting merge conflict for you. You should _immediately, without doing anything else_ reset your branch state to match mine, and then force-push your changes to GitHub to update the PR. To do this, do; ```bash; git remote add jakelishman https://www.github.com/jakelishman/qutip.git; git fetch jakelishman; git checkout master; git reset --hard jakelishman/Canoming-circuit-patch; git push --force; git remote remove jakelishman; ```; This will destroy anything on `master` that you may have but haven't yet pushed. You should do it anyway, because a lot of the underlying structure has changed from underneath you, and your changes aren't consistent with the current state of `circuit.py`. Please also note that the tests are failing after your modifications in (the current) 10e457e.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-630932121:340,avoid,avoided,340,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-630932121,1,['avoid'],['avoided']
Safety,"Agreed, safer to make it explicit. I'll prepare a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1451#issuecomment-784354122:8,safe,safer,8,https://qutip.org,https://github.com/qutip/qutip/issues/1451#issuecomment-784354122,1,['safe'],['safer']
Safety,"Ah ok, that makes it easier to understand what happened - the `MANIFEST.in` file got added at some point before the 4.5.2 release, but its mere presence overrides the content of `setuptools`' `package_data` option, in which we _do_ add the requisite files. If it's not desperately urgent, are you able to build from the `git` branch at 4.5.3 instead temporarily? I can merge this PR, but we're hoping to put out 4.6.0 in about two weeks' time (which I'll make sure has this patch), and our release process is still very manual - I'd rather not have to repeat it another time if I can avoid it!. Sorry this file got lost when `MANIFEST.in` turned up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1449#issuecomment-782615652:584,avoid,avoid,584,https://qutip.org,https://github.com/qutip/qutip/pull/1449#issuecomment-782615652,1,['avoid'],['avoid']
Safety,"Ah, nice catch thanks, and thanks for the super clear repro. We're overhauling the solvers for QuTiP 5.0, which will include a lot more rigorous input checking on entry, but also it uses far safer low-level datatypes that would catch this shape mismatch in the C layer (even though the `dims` _should_ have been checked by `mesolve`). I'll check the other solvers and patch in a sanity test - probably after these lines: https://github.com/qutip/qutip/blob/d5e305513d9186df74beee4fd8da680e89f29d15/qutip/mesolve.py#L259-L261; we can just insert a test; ```python; if rho0.dims[0] != rho0.dims[1]:; raise ValueError(; ""input state must be a pure state or square density matrix""; ); ```. There may also be other segfaults lurking if you use a Python function to generate a time-dependent `Qobj` value in the Liouvillian or the expectation operators, but right now you're unlikely to use that form (because it's slow as anything). The bug slips through because we unsafely pass off a matrix down to C code (where we currently don't have sanity checks) without first verifying that it is a valid shape in Python space - the C code is working as designed, so there shouldn't be problems with correct inputs. Removing `c_ops` causes `mesolve` to delegate to `sesolve` which presumably is better at its type-checking, and I expect that a small dimension size working is likely just `malloc` having slack in the memory it gives us for small sizes or small requests being allocated into the special pre-allocated store.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1456#issuecomment-791925169:191,safe,safer,191,https://qutip.org,https://github.com/qutip/qutip/issues/1456#issuecomment-791925169,3,"['safe', 'sanity check', 'unsafe']","['safer', 'sanity checks', 'unsafely']"
Safety,"Ahh, it is because I forgot to add the safety check to the propagator function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/761#issuecomment-336207115:39,safe,safety,39,https://qutip.org,https://github.com/qutip/qutip/issues/761#issuecomment-336207115,1,['safe'],['safety']
Safety,"An alternative solution if one does not wish to use Anaconda can be to change the Python version in use to a user installed one instead of the default version supplied by macOS. I have discussed it in #348 . It is perhaps because the default Python version does not detect the local python packages (numpy/scipy). After this fix, I was able to do a `sudo -H python setup.py install` and everything worked fine for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/382#issuecomment-263751111:266,detect,detect,266,https://qutip.org,https://github.com/qutip/qutip/issues/382#issuecomment-263751111,1,['detect'],['detect']
Safety,"Any news on this? I would personnally find it particularly useful to have `cosm` and `sinm` methods on `Qobj` class. I can submit a PR with it if you want. If such methods are not to be added, I think this issue can be safely closed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/427#issuecomment-203561277:219,safe,safely,219,https://qutip.org,https://github.com/qutip/qutip/issues/427#issuecomment-203561277,1,['safe'],['safely']
Safety,"As I understand it, the new Mac M1 chips have an ARM-based architecture so there shouldn't be any compatible binary releases on conda yet for macos - I'm surprised conda even claimed to have solved the system. Maybe they've not updated to take the new chips into account either. If you can, you might want to try building from source - you'll also need the Python package Cython, but this way should build all the binary components for your architecture. We know (#1395) that there's a minor problem with some hardware detection on the M1 macs at the moment, but you can comment out lines 48 and 49 of `qutip/hardware_info.py` to work around it. None of us have one of the new macs, and I think we'll need a new release to get conda-forge updated. It might be a little while before we get that done, sorry.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-736516068:519,detect,detection,519,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-736516068,1,['detect'],['detection']
Safety,"As I understand it, the only way to avoid needing to touch `MANIFEST.in` is to not have files distributed with the test suite (or to have the temporary files by `*.py`, since `setup.py` automatically recognises them). That's not really a pytest thing, it's a `setuptools` one. I don't think there's a problem distributing files as part of the tests. You can add a line which says; ```; recursive-include qutip/tests/qasm_files *.qasm; ```; to `MANIFEST.in`, and that should hopefully fix the problem. You won't have the problem locally, because you'll be running `./setup.py develop`, which ""installs"" in-place, so you don't notice the fact that you've missed files from the manifest. In the tests, it runs `./setup.py install`, which does the copy, missing files which aren't in the manifest. Boxi: I'm not certain what more you'd like to do with fixtures here. Fixtures are good for setup and tear down, parametrisation and sharing resources (like network connections), but I'm not certain what further benefit you get for a test function which is testing whether it can open a known file, read it, and construct the expected output. I think Sidhant is already doing some nice parametrisation of his tests, from what I see. Sidhant: I added a comment on the exception test, since pytest gives us an easier-to-read context manager you can use. It's also typically better practice to handle file paths like I did in that (using the overloaded `/` operator with `pathlib.Path`, or `os.path.join`) rather than manually putting in slashes. Windows _usually_ will do the right thing now with slashes, but it's better to let Python handle it for us.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-656255156:36,avoid,avoid,36,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-656255156,1,['avoid'],['avoid']
Safety,"At least in Sublime Text 3's case, it doesn't claim to be a TTY, such that checking `sys.stdout.isatty()` returns False. It's possible that this could be used to detect which bar to use. Since IPython QtConsole and Notebook also return `False` for `isatty()`, a combination of checking `qutip.settings.ipython` and `isatty()` may help eliminate edge cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63328522:162,detect,detect,162,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63328522,1,['detect'],['detect']
Safety,"Because things worked a bit differently 10 years ago. However, psutil does do everything QuTiP needs these days. They can also come up with a smarter M1 detection method.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1395#issuecomment-736677888:153,detect,detection,153,https://qutip.org,https://github.com/qutip/qutip/issues/1395#issuecomment-736677888,1,['detect'],['detection']
Safety,"But how would you know which ones are safe to remove? The fact that we can have many python interpreters running qutip at the same time makes this complicated. I'm not sure what would be the best solution, but I guess that in principle one could imagine an atexit handler that does the cleanup of files corresponding to the current PID. https://docs.python.org/3/library/atexit.html. But taking us down a path of complicated and and hard to maintain code...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/291#issuecomment-66948492:38,safe,safe,38,https://qutip.org,https://github.com/qutip/qutip/pull/291#issuecomment-66948492,1,['safe'],['safe']
Safety,"But it seems to me that it would be best to avoid this type of issue when possible. For example, the squeezing operator is called squeez just to get around a namespace conflict. Otherwise people are bound to get errors that don't make any sense just because of the import order and then they will be emailing us. Of course we can not avoid all conflicts, but since loading scipy is so fundamental to what we do, having no conflicts with this package seems to be reasonable, at least to me. . On Wednesday, June 5, 2013 at 11:12 AM, Robert Johansson wrote:. > Yes, this can happen.. But I dont think this is a bug or error, although it can be confusing. There is always a risk of namespace collisions when importing different packages into the global namespace. For example, many conflicts of this kind occur between the math and numpy packages.. The only way to get around it safely is to import packages in different namespaces.; > ; > —; > Reply to this email directly or view it on GitHub (https://github.com/qutip/qutip/issues/25#issuecomment-18951570).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/25#issuecomment-18951920:44,avoid,avoid,44,https://qutip.org,https://github.com/qutip/qutip/issues/25#issuecomment-18951920,4,"['avoid', 'risk', 'safe']","['avoid', 'risk', 'safely']"
Safety,"Can this be done legally?; Is it acceptable to remove the copyright in the files?; We would be changing the owner of the code. In #1405, it has to have the Nasa copyright by agency policy:; ```; Copyright 2020 United States Government as represented by the Administrator; of the National Aeronautics and Space Administration. All Rights Reserved; ```; I think we could have legal issues if we removed this without their permission. While I agree with removing the ~30 lines header with the license in each file, we should keep the copyright lines unless we can confirm it safe to do so. Luckily, it is mostly Paul, Robert and Alex that have specified it and if they agree then I guess it fine. But if any other contributor added their copyright, we should keep it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-864019462:572,safe,safe,572,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864019462,1,['safe'],['safe']
Safety,"Certainly the `zheevr` segfaults on my machine with scipy < 1.5 and _doesn't_ with scipy 1.5, but that's hardly a perfect test - segfaults are pretty intermittent at the best of times. It's easy to test that all eigenvectors are mathematically actually eigenvectors with the correct eigenvalue, but the harder bit is ensuring that we've actually found _all_ the eigenvectors, especially when we're dealing with a lot of eigenvalues that look like `(0, 0, 0, 1e-17, -1.1e-17, ...)`. Degeneracy is a more annoying to check that we've got the full spanning set of the degenerate basis, and it's even harder when we've got eigenvalues like `1e-17` which is almost certainly actually degenerate with 0, but hasn't been detected as such. This is roughly what I was trying to get at with method 2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1299#issuecomment-649525934:714,detect,detected,714,https://qutip.org,https://github.com/qutip/qutip/issues/1299#issuecomment-649525934,1,['detect'],['detected']
Safety,"Closing for now as the fix is not something QuTiP can detect - we need to have `max_step` to a suitable value to know how stiff the input is. If there's further discussion we need to have, let's talk about it more in other issues / the Google groups discussion boards.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1265#issuecomment-809335608:54,detect,detect,54,https://qutip.org,https://github.com/qutip/qutip/issues/1265#issuecomment-809335608,1,['detect'],['detect']
Safety,"Closing now due to lack of activity. The problem is likely caused by `from math import *` shadowing many functions that should be called from `numpy`, as noted above. (I take this opportunity to evangelise the belief that star-imports are evil and should be avoided in almost all situations.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1111#issuecomment-809411375:258,avoid,avoided,258,https://qutip.org,https://github.com/qutip/qutip/issues/1111#issuecomment-809411375,1,['avoid'],['avoided']
Safety,"Codeclimte detects the same code in matrix_histogram and matrix_histogram_complex, but matrix_histogram_complex will be deleted after matrix_histogram takes over it and the problem will be solved",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2193#issuecomment-1628641527:11,detect,detects,11,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1628641527,1,['detect'],['detects']
Safety,"Deleting everything that starts with 'tdname' sounds sub-optimal, but also not too risky.; I have not looked into it myself, and with this pull we are definitely better off than without.; I will merge now, as I am about to make the 4.1 release",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/655#issuecomment-285674287:83,risk,risky,83,https://qutip.org,https://github.com/qutip/qutip/pull/655#issuecomment-285674287,1,['risk'],['risky']
Safety,"Diffrax and I suspect some other ODE solves have direct support for coupled ODEs -- https://docs.kidger.site/diffrax/examples/coupled_odes/. It looks like diffrax supports these directly. The QuTiP equivalent would appear to be something like a QobjEvo which has a list of terms for each element of the direct product in the output space and, in addition, knows which subspace in the input space each term acts on. The HEOM is very sparse (tri-block diagonal) and just constructing the RHS is slow, so I suspect it will be hard to make any implementation faster than what we have now without a means to avoid constructing the RHS entirely. It would be interesting to try the current HEOM with the diffrax coupled-ODE support and see how big the gain is (if any) before putting a lot of effort into making something similar ourselves. @Ericgig Any thought on how crazy / difficult it would be to make something like an coupled-ODE PyTree / QobjEvo in QuTiP?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2384#issuecomment-2307877982:603,avoid,avoid,603,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2307877982,1,['avoid'],['avoid']
Safety,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:627,sanity check,sanity check,627,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732,1,['sanity check'],['sanity check']
Safety,"Except for setting the type of the `Qobj` (which is deleted at the end of `Qobj.__init__`), there's no need for the 'mc' or 'mc-dm' fast-paths to exist in `Qobj.__init__` at all, even in `master`. If we were to fix the handling of a passed `type` - nothing else is overwritten if passed explicitly - you could achieve all the same effects at approximately the same speed with correct application of the kwargs, such as; ```python; Qobj(data, dims=dims, copy=False, type='oper', isherm=...); ```; providing `data` is actually of a valid (`fast_csr_matrix`) format. Technically the `Qobj.data` attribute will be a new object that wraps the same numpy arrays as was passed, rather than the same `fast_csr_matrix`. In various forms, `expect` already does check the Hermicity, that's why `mc-dm` is careful to set it to avoid recalculating it. The expect functions in `qutip.expect` do this directly, and aren't aware of column-stacked density matrices - they'll just raise a TypeError. `mesolve` and `mcsolve` now bypass the `Qobj` stage and go direct to Cython - in 5.0 it might not be a terrible idea to route everything back through the `Qobj` form, since the performance issues there are solved (a column-stacked dense matrix can be directly wrapped by an f-ordered `Dense` type), and it's the natural central point of the code (and those parts are called from Python-space anyway, so no C concerns). Here though, the problem is actually that the expectation generator in `mesolve` correctly calculates the dtype of the output expectation array using both the state and the expectation operator, but then it does it incorrectly in the loop, and passes the hermicity down to Cython using only the expectation operator, which promptly throws out the complex part. So setting `fast='mc-dm'` in `Qobj` is a symptom of the same root cause as the problem here, rather than the cause itself. At the start of `mesolve` we don't assume that the state is Hermitian, but then inside the integration loop we do. W",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048:815,avoid,avoid,815,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048,1,['avoid'],['avoid']
Safety,"Extra safety check have been added to prevent this kind of errors. #1783, #1784, #1778",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1374#issuecomment-1074188292:6,safe,safety,6,https://qutip.org,https://github.com/qutip/qutip/issues/1374#issuecomment-1074188292,1,['safe'],['safety']
Safety,"Good catch, this seems to be a problem with how the arguments are structured in the function signature for brme_solve. For the tensor formation, . `def bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=[], use_secular=True, sec_cutoff=0.1):`. In this case, the spectra_cb is given the [ohmic_spectrum] argument, which is the correct argument. However, for the brme_solve, the signature is . ```; def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],. args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; ```. If you run the same code with . `output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, spectra_cb = [ohmic_spectrum]); `. the code will run perfectly. However, this is an issue we should fix since spectra_cb is a depreciated argument and technically the c_ops list should accommodate arbitrary noise power spectrum functions that spectra_cb handled before. The error seems to be originating because ohmic_spectrum is of type function but the safety checker expects either a Qobj or a tuple. Also, once we fix the documentation/code on how to use c_ops, we also need to add depreciate warning to bloch_redfield_tensor to maintain uniformity.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1223#issuecomment-605703993:1056,safe,safety,1056,https://qutip.org,https://github.com/qutip/qutip/issues/1223#issuecomment-605703993,1,['safe'],['safety']
Safety,"Having looked around a bit, it seems that the inverse should be avoided in general. The output is always dense, even for a sparse input. Perhaps there is a better way of calculating. https://github.com/jrjohansson/qutip/blob/counting-statistics/qutip/countstat.py#L150. that avoids finding the inverse?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/272#issuecomment-67448877:64,avoid,avoided,64,https://qutip.org,https://github.com/qutip/qutip/pull/272#issuecomment-67448877,2,['avoid'],"['avoided', 'avoids']"
Safety,Here are the associated notebook PR:; https://github.com/qutip/qutip-notebooks/pull/55 (QobjEvo). - development/development-qobjevo.ipynb; - development/development-qobjevo-adv.ipynb. https://github.com/qutip/qutip-notebooks/pull/56 (Stochastic); For general usage:. - examples/smesolve-heterodyne.ipynb; - examples/smesolve-inefficient-detection.ipynb; - examples/smesolve-jc-photocurrent.ipynb. Too see the convergence of each solvers:. - development/development-smesolver-new-methods.ipynb; - development/development-ssesolver-new-methods.ipynb,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/815#issuecomment-458813149:337,detect,detection,337,https://qutip.org,https://github.com/qutip/qutip/pull/815#issuecomment-458813149,1,['detect'],['detection']
Safety,"Hey @RobHam99. I have talked today with @hodgestar and we agreed that, since `**kwargs` is only used to pass the argument `num_cpus`, we think it is best to raise an _error_ (`TypeError`) when kwargs contains a key that is not `num_cpus`. This should hopefully avoid the same confusion to happen again with propagator, but we should definitely try to get the naming consistent for the new QuTiP version that is under active development. @RobHam99, are you still interested in opening a Pull Request for this issue?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1716#issuecomment-981512742:261,avoid,avoid,261,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-981512742,1,['avoid'],['avoid']
Safety,"Hey Eric,. I've been working on improving the underlying structure of FLiMESolve and; making it more efficient. I haven't done another review request yet because; I want to try to address as many things as I can at once. I've been delayed; heavily by a system I'm trying to solve for my paper about this solver, on; which Simon has offered to help such that I'll hopefully be moving forward; again soon. Additionally, there are some changes I want to make that I'm; not sure how to do which I'm going to try to address with Simon when we are; able to meet next. Most of those are in regards to structural things, e.g.; how to filter input ""args"" arguments to pull out the frequency of the; Hamiltonian in the same manner as other solvers in QuTiP are able to filter; arguments. I've been trying to avoid submitting review requests/questions; in the PR comments too much so as not to be a bother. I have definitely not; abandoned this PR, and plan on seeing it through fully, although I; apologize for my relative lack of communication the last few weeks. Thanks!. On Mon, Aug 21, 2023, 11:29 AM Eric Giguère ***@***.***>; wrote:. > @magnamancer <https://github.com/magnamancer> are you waiting for review,; > still working on the PR or abandoned it?; >; > There are still issues I raised here and in magnamancer#4; > <https://github.com/magnamancer/qutip/pull/4>, that you have not been; > addressed and I am waiting for them before the next round of review.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1686550860>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5GN3R6GPKYKYNOWSGDXWN5GDANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935:798,avoid,avoid,798,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935,1,['avoid'],['avoid']
Safety,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:139,avoid,avoid,139,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393,1,['avoid'],['avoid']
Safety,"Hi @Ericgig ; Thanks for investigating this so thoroughly. ; I guess it makes sense that unpacking a dict at each call is inefficient, so I think we should drop this idea. As you have suggested previously, users can always use module variables if they wish to avoid passing vars in `args`. So I think we should aim to keep it simple. I think adding `f(t)` as a signature option will be sufficient for what @goerz wanted and would be sufficient for using a Numba jit. So, my suggestion for the next major release (v5) would be that we have only two call sigs:; - `f(t, args)` (default); - `f(t)`. For now we will have to have the three (although I don't think the `rhs_with_state` is not widely used, if at all).; - `f(t, args)` (default); - `f(t)`; - `f(t, state, args)`; The default needs to remain as it is, because it is widely used. I think it makes sense to use introspection to decide which has been specified by the user, as the sig is clearly distinguishable by the number of args. So effectively we can ignore the `rhs_with_state` option, but I think we should give a deprecation warning that the `f(t, state, args)` signature will be removed in the next version. So, I think this means we can keep the new method of passing the state in the args dict. I would suggest we make it a bit more simple though. I notice that the processing of the option is a bit involved. So I suggest that any element of the `args` dict where the key is of the form `name:special_value_kind` be considered some kind of special value. If `special_value_kind` is not recognised then it should throw a `ValueError`. For now we will have the `special_value_kind` of:; - `state`: Qobj of the state at time `t`, with the correct dimensions; - `state_vec`: ndarray of state as a vector; - `expect`: I can't remember exactly what you did here. The `state_vec` will clearly be much more efficient, as this is what the ODE solver maintains. However, for completeness I think we should have the `state` option. The initial ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162:260,avoid,avoid,260,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162,1,['avoid'],['avoid']
Safety,"Hi @nonhermitian, I spent some time struggling with this as I recently shifted to macOS. This problem affects other Python installations too. I found a solution to this and if you could update it in the docs instead of the default macOS installation script, then it would be very helpful for new users. I will post the solution first and explain it below. . 1. Install a manual Python version which overrides the default Python supplied by Apple in the `usr/bin/python` path. You can check this using ```which python```. Installing using brew - . ```brew install python```. 2. Change the default Python interpreter from the one supplied by macOS in `usr/bin/python` to the user installed version in `/usr/local/bin/python`. This is explained in this [post](http://blog.manbolo.com/2014/09/27/use-python-effectively-on-os-x#p1). Edit the file `/etc/paths` using ```sudo vi etc/paths``` and move the line `/usr/local/bin` to the top. This makes the user installed Python default and the packages installed by pip or brew are imported instead of the ones supplied by apple. Restart the terminal. You may need to update numpy and scipy using ```pip install numpy``` or ```pip install numpy -U```. 3. Install qutip using ```python setup.py install```. Apple has its own Python version and a few modules such as numpy and scipy come along with it which are at `/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/include/python2.7`. These modules are difficult to manage and update due to issues with permission. Hence, even if you update numpy or scipy using `pip` or `brew`, it is not detected by Python. ~~This also raises an issue later `error: could not create 'build/src.macosx-10.12-x86_64-2.7': Permission denied`~~. This solution seems better since it does not mess with the system default. Edit 1 : sudo -H is needed to install using ```sudo -H python setup.py install```. The -H tag sets the home directory as the default for installing configuration files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-263745214:1602,detect,detected,1602,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-263745214,1,['detect'],['detected']
Safety,"Hi @sarsid! I'd like to recommend that we land #1090 separately. It's a stand alone piece of work and coupling PRs together into big PRs where it can be avoided generally makes things harder to review and land. I can show you how to merge that branch into this one if you need to it make progress before #1090 lands. I would also recommend making the formatting changes you have made (I assume using black or your editor?) in a separate PR to this one. Lumping them into one PR also makes reviewing harder since one doesn't know which changes are intentional or meaningful. I'm also happy to help with this if you need!. I've started work on the docs for #1090, so hopefully it can land this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691:153,avoid,avoided,153,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691,1,['avoid'],['avoided']
Safety,"Hi @sarsid, there are still some tests failing. When you think the PR is really, just make it a ready-for-review PR and request a review. Besides, it would be great to address some of the style issues in code climate like ""Continuation line under-indented for visual indent"". Not all of them must be fixed though, it's more like a guide. The `pycodestyle` package can help you detect them locally if you would like to use it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-646002967:377,detect,detect,377,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-646002967,1,['detect'],['detect']
Safety,"Hi Ben. Thanks a lot for your contribution. It's looking great!. A couple of small things:; - We try to make qutip python3 compatible, so please use python3 compatible print(...) function calls instead of print ... statements.; - Functions super_to_choi and choi_to_super seems to do the same thing, while the function names suggest complementary conversion. Is this intentional?; - I think it would be better if you move the test code from within the if **name** == '**main**' to a separate file in the examples directory, or even better as unit tests in qutip/tests/; - Avoid global import of qutip ""from qutip import *"" by only selectively importing the functions that you need (we try to do this internally in qutip to avoid circular module dependencies).; - Make relative import of qutip functions (for example from qutip.super_to_choi import super_to_choi). This is also required for python3 compatibility.; - Add an import of the main functions (for example subsystem_apply) to qutip/**init**.py ; - I would probably prefer the super_to_choi.py module be called something more general, like choi_decomposition,py (or something like that), which would reflect that it does not only contain the super_to_choi function but other related functions as well.; - Avoid printouts in choi_to_kraus function. If you want to enable debugging or diagnostic info, consider adding an optional function argument debug=False or verbose=False and print the vals and vecs variables only if the user explicitly asks for it. Otherwise, one could get an excessive amount of printouts if your code is used in a loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/22#issuecomment-18592742:572,Avoid,Avoid,572,https://qutip.org,https://github.com/qutip/qutip/pull/22#issuecomment-18592742,3,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"Hi Emily,. The photocurrent is the number of detector clicks (i.e., jumps) per unit time, averaged over all trajectories. For sufficiently many trajectories, it will approximate $tr[C_n \rho(t) C_n^\dagger]$. If I'm not mistaken, you should find that; ```math; x = \frac{1}{\Delta t} \frac{1}{N_t}; ```; where $\Delta t$ is the spacing in your `tlist` and $N_t$ the number of trajectories. The integer (photocurrent/x) is simply the number of clicks in that time interval in all trajectories; we multiply with x for the ""per unit time, averaged over all trajectories"" that I wrote above. Paul. (PS. I only noticed your username now - is it possible we had a chat at QTD in August? Hope you are doing well!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615:45,detect,detector,45,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615,1,['detect'],['detector']
Safety,"Hi Louis,. There is work in development that will allow `QobjEvo` to be build from callback also, not just list. This will make callback work anywhere easily. . I was in the impression that H callback worked already for mcsolve. I rewrote part of mcsolve and broke it. Looking at your commit, I inverted `_funcrhs_with_state` and `_funcrhs`...; Sorry to have you take time to correct it. The 20x is big, but the list format allows for optimizations that are hard to do with a callback. A big one is that you don't need to create a new matrix/Qobj when calling `mul_vec`, just use it. With this code, I see a 20x between `mul_vec` and creating a Qobj a python function. . ```; import numpy as np; import qutip as qt. qoe = qt.QobjEvo([qt.qeye(3),[qt.destroy(3), lambda t,_:np.sin(t)]]); qoe.compile(). o1 = qt.qeye(3); o2 = qt.destroy(3) ; def H(t):; return o1 + o2 * np.sin(t). v = np.ones(3)+0j; %timeit qoe(0); %timeit qoe.mul_vec(0, v); %timeit H(0); %timeit H(0).data * v; ```. One optimization you could do is having the callback return a `np.array` instead of a Qobj. In `mcsolve`, this would probably be simple to implement and I expect some speed gain. But it can't really be officially supported in Qutip, for now. . ps. All those 'redundant' argument setting are for reusing the system (`ss`) in multiple call of `mcsolve` with different args, used in `correlation`. Using string coefficient, the compilation step can take a few second, so it is set to be able to reuse a compiled system, changing the `psi0`, `args`, `e_ops`, etc. This will become a less obscure feature in v5 when solver object are available.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634:1241,redund,redundant,1241,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634,1,['redund'],['redundant']
Safety,"Hi Robert,. I was thinking about heterodyne and homodyne detection unification. It seems to me that the way how the heterodyne is done now in QuTip is a bit overcomplicated. Why don't we just produce two jump operators $s/sqrt2$ and $-is/sqrt2$ out of one heterodyne $s$ and run the homodyne scheme with these two operators. The Milstein will work automatically. Do I miss something?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22238086:57,detect,detection,57,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22238086,1,['detect'],['detection']
Safety,"Hi Vutshi. Yes, it is perfectly possible to implement the heterodyne detection using two homodyne detections with 50% efficiency, like you suggest. For the Milstein solver it might be the best, or at least the quickest, way to implement heterodyne, but I don't really agree that the current method is overcomplicated. It is in fact basically the same as the method you suggest, so I don't see that either would be more complicated or simpler than the other. The only issue is whether the two stochastic increments are divided up in several stochastic collapse operators or if the d2 function internally takes care of the both stochastic increments for a given stochastic collapse operator. The complexity is just shifted from the d2 function to somewhere else, which in general doesn't simplify anything. However, since the milstein solver you submitted is written so that it only support one increment per collapse operators, then there might be a real advantage of splitting the heterodyne process into two homodyne processes. . I've tried to make the qutip stochastic solver API as general as I could (and it is still a work in process), so that it will be as flexible as possible for implementing custom types of SMEs. Having support for multiple stochastic increments per collapse operators seems to be useful in certain applications. Although such SMEs could probably always be rewritten as multiple collapse operators with single stochastic increments, it might not always be the most natural way to define the SME. The heterodyne detection is one example of this, and it can be formulated in both ways, but I want the qutip SME API to work with both methods (at least with the basic euler solver, not necessarily with every solver we implement). However, that doesn't mean that the implementation of heterodyne for a particular solver has to use one way or the other. We should just document which solvers support multiple increments per operators and which solvers don't. So if it is easier t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22543416:69,detect,detection,69,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22543416,2,['detect'],"['detection', 'detections']"
Safety,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:537,avoid,avoid,537,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['avoid'],['avoid']
Safety,"Hi taw181,. Thank you for reporting the bug.; The patch will probably take some time to make and publish. ; A work around for now would be to use string based coefficient. Use `(t)` instead of t in the string, there is another bug in the string shifting code. -------------------------------------------------------------------------------------------; Self notes. The function _transform_L_t_shift of correlation.py has at least 2 bugs:; - lambda have side-effect when defined in loop:; ```; H = [0,1,2]; H_shift = []; for i in range(len(H)):; fn = lambda _: H[i]; H_shift.append(fn); ; for f in H_shift:; print(f(0)); ```; Using class is safer and can be used safely in parallel. - The shift is not applied properly to string when ""t"" is the first or last character of the string coefficient. Could/should this shift capacity be made part of QobjEvo?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1048#issuecomment-515517733:640,safe,safer,640,https://qutip.org,https://github.com/qutip/qutip/issues/1048#issuecomment-515517733,2,['safe'],"['safely', 'safer']"
Safety,"Hi, @Ericgig! I would like to work on this issue. We cannot adopt the 3rd option in the master branch due to backwards compatibility, right? I'd rather avoid any single character variable wherever possible. That said, I believe the second option you gave is the best one to adopt in the master branch. Once I finish, I can work on dev.major implementing the third option.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087:152,avoid,avoid,152,https://qutip.org,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087,1,['avoid'],['avoid']
Safety,"Hi, is the first time that I use sphinx and I am having trouble generating the apidoc. I understand that I have to run sphinx-apidoc to generate the .rst files from /qutip but I don't know where to put them, so they can be detected by autodoc. I tried but every time I run ""make html"" I get ""autodoc: failed to import module"".",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2144146337:223,detect,detected,223,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2144146337,1,['detect'],['detected']
Safety,"Hi, the cropping issue was there before. Even I had faced it when; visualizing circuits. I used to just add a redundant qubit to the circuit; to get that extra padding. I ll look into the cropping and resize it to; make the visualization better. Could you please open a new issue for that?. I opened a new issue to discuss that in #680 . On 05-Apr-2017 9:37 PM, ""Morten Kjaergaard"" <notifications@github.com>; wrote:. > Hi again @ajgpitch <https://github.com/ajgpitch> and @sahmed95; > <https://github.com/sahmed95>.; >; > I had a chance to work a little with the "".add_state"" feature this; > morning, and wanted to raise an issue in terms of the visualization. The; > problems are shown in the figure below:; > [image: image]; > <https://cloud.githubusercontent.com/assets/7925874/24715124/6f96cf7a-19f8-11e7-8ecd-76c937805bc5.png>; > (NB: this could just be due to jupyter notebook? In any case, I see the; > problem is also reproduced in @sahmed95 <https://github.com/sahmed95>'s; > post here: #679 (comment); > <https://github.com/qutip/qutip/pull/679#issuecomment-291652067>); >; > Two things:; >; > 1. The cropping seems to go bonkers if you use anything else than one; > symbol in the ket-state; > 2. It's not possible to use \textrm{xxx} in the ket-names.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/679#issuecomment-291911527>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AGpUBBFZyzHSm5vJxrIdu33IDkreVAMnks5rs7xQgaJpZM4MyxeC>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/679#issuecomment-291957664:110,redund,redundant,110,https://qutip.org,https://github.com/qutip/qutip/pull/679#issuecomment-291957664,1,['redund'],['redundant']
Safety,"Hi,. I think your new implementation of API should be flexible enough to incorporate any explicit scheme. The reason I think it is useful to calculate \rho_{n+1} is to apply a semi implicit method. This is what is done by Lsparse. I tried two ways of doing it. First, one can calculate (1 - (L+d1)_dt)^(-1) and apply it to to the stochastic part of the equation. Another way is to calculate the deterministic evolution expm[(L+d1)_dt] and also apply it to the stochastic part. Both of these methods work for linear deterministic part like in the homodyne detection. I've got good results with these semi-implicit methods on a problem with a few qubits. Due to a big nonlinearity for some parameters regime it really helps to apply the true deterministic evolution (or its approximation). For another regime it is better to use explicit method. In principle it should be good to adjust degree of implicitness. Anyway I'm still looking into the problem and comparing different possibilities. I hope to produce a new notebook with tests soon. This Milstein realisation is compatible in principle with the heterodyne detection. I'm not sure it is possible to express everything in terms of d1 and d2 only. The point is that I need to use derivatives of d2. I don't really see a problem to have separate RHSs for homodyne, heterodyne and photocurrent detections. I'll think a bit more about unification of homodyne and heterodyne and then I'll submit a pull request. Regarding expm for large systems. We need to calculate it only once, it works for small systems so I think it is a good option to have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22116628:555,detect,detection,555,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22116628,3,['detect'],"['detection', 'detections']"
Safety,"Hmm, I think that should still work. I think numpy is imported locally in `__init__.py` and if it is deleted before the init file ends, it will not overwrite existing symbols form where `from qutip import *` was called.. If this is not how it works we should do something like `import numpy as _numpy` .... `del _numpy` to avoid breaking code with the import pattern in your example.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/233#issuecomment-56173332:323,avoid,avoid,323,https://qutip.org,https://github.com/qutip/qutip/pull/233#issuecomment-56173332,1,['avoid'],['avoid']
Safety,"Hmm, it still seems to use the old travis ci configuration, where I tried to install numpy/scipy with pip without wheels. But took too long to install the dependencies that way, and the tests will probably timeout and get cancelled. In the current travis ci configuration uses pip with wheels to install numpy/scipy much faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36083480:206,timeout,timeout,206,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36083480,1,['timeout'],['timeout']
Safety,"Hmm. I think let's leave it out. We can reply to the issue with ""it's implemented in v5 and here is how you do it in v4"". That avoids adding a new feature in a point release (and potentially confusing users) while still solving everyone's immediate problems and making the future better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205:127,avoid,avoids,127,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205,1,['avoid'],['avoids']
Safety,"How about I just directly upload the files and we close the commit?. On Aug 29, 2014, at 2:20 PM, Robert Johansson notifications@github.com wrote:. > Now in order to avoid a +/- 7000 line diff effecting 148 files, a these commits should be squashed with a rebase.; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/221#issuecomment-53839695:166,avoid,avoid,166,https://qutip.org,https://github.com/qutip/qutip/pull/221#issuecomment-53839695,1,['avoid'],['avoid']
Safety,"I agree that this might seem a bit inconsistent. However, a quantum system with only 1 quantum state is not that meaningful since it does not have any degrees of freedom, and in some places in QuTiP, such as in the multiplication of two Qobj instances (like in your total_eye*total_eye example) we treat subsystems with only one quantum state as a subsystem that has been ""projected out"", and therefore we remove that subsystem. This is the reason for why you would get (total_eye*total_eye).dims as [[8], [8]] instead of [[1,8], [1,8]]. Perhaps tensor should also make this check (and drop subsystems with only 1 quantum state)... but on the other hand it is reasonable to avoid calling tensor on subsystems with only 1 quantum states, since it is not a very meaningful thing to do.. Is there any case when this causes a problem for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/222#issuecomment-53888260:674,avoid,avoid,674,https://qutip.org,https://github.com/qutip/qutip/issues/222#issuecomment-53888260,1,['avoid'],['avoid']
Safety,I also added a few more safety checks. These may be helpful for anyone trying to convert some old example to v4.4 compatible.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-546760124:24,safe,safety,24,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-546760124,1,['safe'],['safety']
Safety,"I am closing this: change to the documentation are redundant to previous PRs. The `requirements.txt` file refers to the packages needed to use qutip, which we keep to a minimum. Modules required to build the documentation are in `doc/requirements.txt`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988:51,redund,redundant,51,https://qutip.org,https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988,1,['redund'],['redundant']
Safety,"I am not sure what your example of 'n' photons represents. However, if ; you mean what is the probability of a single-photon in the state, as ; measured by calculating the expectation value,the answer converges to ; 0.272 at about 14 states to one-part in a thousand. > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 18:08; >; > OK, if it's intended then there's nothing to change in the code. But I ; > think it would be helpful to document this in a clearer way: there's a ; > big risk of misinterpreting the operator.; >; > —; > You are receiving this because you modified the open/close state.; > Reply to this email directly, view it on GitHub ; > <https://github.com/qutip/qutip/issues/661#issuecomment-286282270>, or ; > mute the thread ; > <https://github.com/notifications/unsubscribe-auth/ABMPqSiIdpvqRZIZO2kklDrotB4b-6b0ks5rldpigaJpZM4MbmLX>.; >; > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 11:48; >; > When I tried to use the |qutip.squeeze| function for my simulations I ; > noticed that something was off. Upon further investigation I found out ; > that the output is not a truncated version of the single-mode ; > squeezing unitary, but rather the matrix exponential of the truncated ; > generator. These are /very/ different things!; >; > Am I right in assuming that the most useful matrix would be the ; > truncated unitary? If that's the case, the current method to compute ; > it is wrong. To compute the right matrix one can use the disentangling ; > formula for SU(1,1) (formula (31) here ; > <http://aip.scitation.org/doi/pdf/10.1063/1.3413923>):; >; > def squeeze(n,z):; > s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); > s1 = -2*np.log(np.cosh(abs(z))); > s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); >; > L = s0*0.5*(qt.create(n)*qt.create(n)); > K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); > R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); >; > return (L.expm())*(K.expm())*(R.expm()); >; > As you can see, this definition does /not/ depend on th",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286284316:498,risk,risk,498,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286284316,1,['risk'],['risk']
Safety,"I am on the side on having 2 `default_dtype` options for the `Qobj` creation functions. I have some question as to how/where to make `default_dtype` more consistent. Applying the default at Qobj creation feels risky to me. In the solver it will end up converting the states before computing the expectation value. It could create strange interactions with operators and unitary transformations (`Qobj[Dense].dag() -> Qobj[CSR]`). `Qobj(scipy_csr)` could be converted to something else... However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion.; It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format? . In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. ps. Should `eigenstates` return the states in one operator instead of a list of kets? I guess the states were used to create the operators fed to `steadystate`, so operator output would be more practical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861:210,risk,risky,210,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861,1,['risk'],['risky']
Safety,I believe I have fixed all the conflicts. Will definitely try to avoid that situation again!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/294#issuecomment-67658347:65,avoid,avoid,65,https://qutip.org,https://github.com/qutip/qutip/pull/294#issuecomment-67658347,1,['avoid'],['avoid']
Safety,"I did some tests and ; 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian matrices) (c's version Ok); 2 - It happen when installing the scipy stack with pip but not when installing it with conda.; 3 - It depend on the problem size, 64 seems particularly bad, usually it fails on the second call.; 4 - I only got it in zheevr which is only used in `brmesolve`. But Nathan got it in other tests which use scipy's `eigh`.; 4 - It happen in scipy in the fortan version of lapack:. ```; import numpy as np; from scipy.linalg import eigh; H = random_hermitian(64); eigh(H) # Work fine; eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; ```. Possible solutions (for zheevr):. - Installing scipy with conda, the easiest solution, but not in our control.; - Finding a way to link clapack from cython. Linking scipy's one would require good knowledge of scipy internals since only one cython interface is provided. Linking to another installation of lapack, but it would require the user to install lapack or install it with qutip. Both seems wrong to me.; - For mac user, call scipy's eigh from cython i zheevr, slower but better than risking segfault.; - Have the code directly in qutip. We can adapt it from OpenBlas: https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492:1177,risk,risking,1177,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492,1,['risk'],['risking']
Safety,"I did this work some time ago, and so I did a git rebase in order to try and avoid any conflicts; I was advised this is the thing to do in such circumstances.; It seemed to go okay, some feedback on whether I did the right thing and did it correctly would be welcome",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/350#issuecomment-113537434:77,avoid,avoid,77,https://qutip.org,https://github.com/qutip/qutip/pull/350#issuecomment-113537434,1,['avoid'],['avoid']
Safety,I didn't realise that was causing a problem too. Seems like a good idea generally to try and avoid conflicts with built in names where possible.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/379#issuecomment-147354304:93,avoid,avoid,93,https://qutip.org,https://github.com/qutip/qutip/pull/379#issuecomment-147354304,1,['avoid'],['avoid']
Safety,"I disabled cython support on python 3.12 with [this patch](https://salsa.debian.org/science-team/qutip/-/blob/master/debian/patches/python3.12_no_cython_support.patch?ref_type=heads):; ```; Index: qutip/qutip/__init__.py; ===================================================================; --- qutip.orig/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install();",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:693,detect,detected,693,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543,1,['detect'],['detected']
Safety,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:351,safe,safe,351,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422,1,['safe'],['safe']
Safety,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:250,avoid,avoid,250,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515,3,"['avoid', 'detect', 'safe']","['avoid', 'detect', 'safe-by-default']"
Safety,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:1071,safe,safe,1071,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180,1,['safe'],['safe']
Safety,"I had a bit more success by switching as much as possible in the setup of the testing environment to pip:; ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y numpy scipy cython; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install -e .; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install nose ipython; ~~~; I also added a `unittest.skipIf` decorator to `qutip/tests/test_stochastic_se.py:test_smesolve_homodyne_methods`, which is the only test that consistently fails on `master`. With this, the test suite runs through about 50% of the time. The other 50% it crashes with the following:; ~~~; ...; PIQS: Test the warning for diagonal Hamiltonians to use internal solver. ... ok; Propagator: HO ('single mode') ... ok; Propagator: HO ('batch mode') ... ok; Propagator: HO parallel ... ok; Propagator: str td format ... ok; Propagator: func td format ... ok; Propagator: steady state ... python(52709,0x10fc1f5c0) malloc: Incorrect checksum for freed object 0x7fcbf338af10: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(52709,0x10fc1f5c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ~~~",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378:1265,Abort,Abort,1265,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378,1,['Abort'],['Abort']
Safety,"I had some more thoughts about this while responding in the Google group (see: [this post and associated email chain](https://groups.google.com/g/qutip/c/NAGU4iKZNBY/m/3i-oLXAzAgAJ)). I think perhaps a good solution is to move away from keeping track of the ""dimensions"" of each space, to keeping track of what ""basis"" each space is represented by. This actually allows more safety, and I think is probably a more natural way of thinking about the underlying physics for most people.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320#issuecomment-667164574:375,safe,safety,375,https://qutip.org,https://github.com/qutip/qutip/issues/1320#issuecomment-667164574,1,['safe'],['safety']
Safety,"I haven't checked, but I'd bet it's because we construct a new Liouvillian `QobjEvo` on entry to `mesolve` with collapse operators. If so, this is definitely a bug - we should have detected that the collapse operators have no time-dependence, so don't need to overwrite the `tlist`. As a temporary work-around, you can construct the Liouvillian directly and pass it to `mesolve`:; ```python; liouvillian = qutip.liouvillian(ham, collapse); qutip.mesolve(liouvillian, rho, eval_times); ```; which should work fine for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1560#issuecomment-849604641:181,detect,detected,181,https://qutip.org,https://github.com/qutip/qutip/issues/1560#issuecomment-849604641,1,['detect'],['detected']
Safety,"I made a snipped with dummy arrays that reproduce the error. Is it enough?; ````; H=[]. timelist_Jump_op=[]; time=[]; for i in range(t):; H.append(Qobj(np.ones((2,2)))); list_Jump_op.append(Qobj(np.ones((2,2)))); time.append(0.5). estados_val=np.array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:810,predict,predictions,810,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553,1,['predict'],['predictions']
Safety,"I made some tests with this PR and ran into one problem: the iscptp is very computationally demanding for large system, so it cannot be used in the `__str__` and `_latex_repr_`, because it prevents large systems from being displayed. Also, whether a super operator is CPTP is not always relevant so it does not need to be shown in every printed Qobj. Also, superrep should probably only be displayed if it is not 'super' (to avoid both type and superrep duplicating the same information),",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/90#issuecomment-37786513:425,avoid,avoid,425,https://qutip.org,https://github.com/qutip/qutip/pull/90#issuecomment-37786513,1,['avoid'],['avoid']
Safety,"I made the change for immutable `Coefficient` and `_Elements`. ; `replace` is about 200ns slower than the previous inplace `arguments`.; With `_Elements` 'immutable', `QobjEvo.copy`'s default is to do a shallow copy of the `elements` list. ; The `_BaseElement._call` is not returning the (data, coeff) pair, but stores it to save on time to create of a python object.; This it may not safe with threading: if 2 copies of a `QobjEvo` are called at the same time with different `t`, both could return the same result. I am not sure how good is the GIL in this case.; I don't expect it to be an issue, in the rare case threading would be used, a deepcopy is available with `QobjEvo.copy(deepcopy=True)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-817018631:385,safe,safe,385,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-817018631,1,['safe'],['safe']
Safety,"I mean the motivation behind the np array format itself. And indeed, the spline assumes equidistant points. > On Aug 24, 2016, at 12:04, kafischer notifications@github.com wrote:; > ; > I'm a bit confused by your comment: Are asking about the purpose of the np array format itself or did you mean why it should accept non-linear tlists?; > ; > The reason it should accept non-linear tlists is because such a thing is good to have when you simulate rapid dynamics followed by slow dynamics. This currently works for all other types of time-dependent formats, so it should also work for this one to avoid confusion. The cubic spline would indeed be nicer here, except it seems to me like it assumes the x values are linear?; > ; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub https://github.com/qutip/qutip/pull/520#issuecomment-242156352, or mute the thread https://github.com/notifications/unsubscribe-auth/ABMPqQvb7gOJPOTVk9VN5KseYyslkRUTks5qjIe8gaJpZM4JpQHD.; > ; > Untracked with Trackbuster https://trackbuster.com/?sig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/520#issuecomment-242156997:597,avoid,avoid,597,https://qutip.org,https://github.com/qutip/qutip/pull/520#issuecomment-242156997,1,['avoid'],['avoid']
Safety,"I moved the Coefficient changes to #1507, all should be thead-safe and _[...]Element are better documented.; #1507 should be merged before this.; The commit history somewhat a mess... I suggest squash and merge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-825047432:62,safe,safe,62,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-825047432,1,['safe'],['safe']
Safety,"I realised I never replied to this. I suggested `2*rtol` in this case because the error propagation in this case would guarantee that this is always sufficient. For other tests, we can always design the test so that it's calculable what the error term should be. I'd say it's generally a good idea to have the tests be as tight as we can possibly make them without risking false-negatives on the results, because otherwise we're not properly testing that the parameters do what they say. Regardless, that test failure isn't due to any of my PRs - it's a pre-existing problem that we happened to get unlucky on this time round. It'll get fixed when I modify `test_mesolve.py`. Can we review this PR to get the ball rolling on getting all of the test refactoring considered?. Possible reviewers: @Ericgig, @BoxiLi, @nathanshammah",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133:365,risk,risking,365,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133,1,['risk'],['risking']
Safety,"I rechecked the equations:; The stochastic integration has the general form:; ![image](https://user-images.githubusercontent.com/17770236/140782543-9d8ff092-b9cb-4b17-98e8-85ab0254b425.png); For `ssesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140783379-72e48698-4f2d-4ebc-bfac-95630e8724b1.png). And for `smesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140784174-e9fdb33b-2fee-4795-a93d-e7d1abe32ddd.png). The liouvillian use both the `sc_ops` and `c_ops` for collapse, but the `d_2` part only use `sc_ops`. In heterodyne detection, each `sc_ops` is split into 2 parts computed individually: ; ![image](https://user-images.githubusercontent.com/17770236/140784227-39e67d38-33bf-47c8-ab57-afd41c23afa6.png). `m_ops` for homodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784715-a7861965-6b30-4a47-a7a6-e19d4dd8b430.png). `m_ops` for heterodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784760-5adb2535-ff63-4b2d-bba8-b10b6422b5db.png). In both case the `dW`'s default is `1`. In the heterodyne case, the `sqrt(2)` is expected to be included inside `dW_factor` when it's length is the same as `m_ops`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778:571,detect,detection,571,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778,1,['detect'],['detection']
Safety,"I report local tests failing on my MacOS 10.13.6 by running qutip.testing.run(). Tests fail for python 3.7 and 3.6 environments, if QuTiP 4.4. is installed in develop mode (openmp = True). ; Tests fail also for QuTiP 4.3.1 installed with conda. . ### py36; Broken test for python 3.6 with: (1) QuTiP 4.4-dev, with openmp =True and (2) conda install qutip, QuTiP 4.3.1: ; Error Message below: ; ``` ; Metrics: Trace dist. & Fidelity mixed/pure inequality ... ok ; Metrics: Check avg gate fidelities for random ... ; python(35852,0x7fff9757f380) malloc: *** error for object 0x7fe189168a10: incorrect checksum for freed object - object was probably modified after being freed. *** ; set a breakpoint in malloc_error_break to debug ; Abort trap: 6 ---------------------------------------------- ; ``` . Building the dev environment: ; ``` conda create --name qutip-dev-44-py36 ; source activate qutip-dev-44-py36 ; conda install python=3.6 cython numpy scipy nose jupyter matplotlib; python setup.py develop --with-openmp; ``` . ### py37; Broken test for python 3.7 with: (1) QuTiP 4.4-dev, with openmp =True and (2) conda install qutip, QuTiP 4.3.1. Error Message below: ; ``` ; qutip.tests.test_qobj.test_expect_exception ... ok Qobj data ... ok Qobj type ... ok Qobj Hermicity ... ok ; Qobj unitarity ... ok ; Qobj shape ... ok ; Qobj: multiplication w/ non-square qobj.dims ... ok ; Qobj addition ... ok ; Qobj subtraction ... ok ; Qobj multiplication ... ok ; Qobj division ... ok ; Qobj power ... ; python(35379,0x7fff9757f380) malloc: *** error for object 0x7fbf1089fa90: incorrect checksum for freed object - object was probably modified after being freed. *** ; set a breakpoint in malloc_error_break to debug ; Abort trap: 6 ; ``` . Building the dev environment: ; ``` conda create --name qutip-dev-44-py37 ; source activate qutip-dev-44-py37 ; conda install python=3.7 cython numpy scipy nose jupyter matplotlib; python setup.py develop --with-openmp```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-473772867:731,Abort,Abort,731,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-473772867,2,['Abort'],['Abort']
Safety,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:358,risk,risky,358,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866,1,['risk'],['risky']
Safety,"I think I agree that the two PRs should be kept separate. Initially, I wanted to make them the same since I was trying to use the code in #1090 but right now the two don't interact much. . Wrt the formatting changes, they were put inadvertently and I'll make sure to revert them but thanks for pointing them out. Let me know what you think of the code in this PR and if you think there's some redundancy between the two (I think there should be but I can't quite put a finger on it).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-633964657:393,redund,redundancy,393,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-633964657,1,['redund'],['redundancy']
Safety,"I think it's quite important to understand why this happened. Previously we reliably had an exactly correct result, and now we don't. This particular check for `p != 0` of a float is I think okay because it's there specially to avoid division by exactly zero. I can think of at least two plausible scenarios:. 1. The issue was caused by the removal of auto_tidyup, in which case I think either a setting like this with an explicit check in either the measurement functions or the simulator are good solutions (although it should be possible to override the setting on a per-call basis, just like with atol). 2. The issue was caused by the removal of the data layer mathematical operations, and in particular, by the replacement of `data / value` by `data.mul(data, 1 / value)`, in which case I think the solution is to add a `div` operation to the data classes so that we don't lose this accuracy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1656#issuecomment-917229773:228,avoid,avoid,228,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917229773,1,['avoid'],['avoid']
Safety,"I think that `qutip.testing` and the tests in CI are different. The former are in that file, the latter look at the instructions from [`.travis.yml`](https://github.com/qutip/qutip/blob/master/.travis.yml), which basically call `python setup.py install` (or `test`). Also looking at the Travis CI reports, it seems that they work fine. Locally, I'm getting tests to fail on my machine, with malloc or abort trap 6 errors every other time, although some time they pass (hence I opened #1160). It may be that they fail on my machine due to some mess with the gcc compiler.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1158#issuecomment-576002319:401,abort,abort,401,https://qutip.org,https://github.com/qutip/qutip/issues/1158#issuecomment-576002319,1,['abort'],['abort']
Safety,"I think that this is the correct solution though, so big bonus points for hunting this down! At work, we have no use for OSX, and would love py3 on win, so I can fiddle around to get something working. Having two separate sources may be the route we need to go. It wouldn't be the end of the world, but should be avoided unless absolutely necessary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/647#issuecomment-279727419:313,avoid,avoided,313,https://qutip.org,https://github.com/qutip/qutip/issues/647#issuecomment-279727419,1,['avoid'],['avoided']
Safety,"I think the bug is bigger than that. `Qobj` never ensure that the shape and dims match but in many places, solver check only the dims and not the shape. Here `rho` is shaped as an `operator-ket` but with `oper` dims, so it slip through the dims check. I wouldn't be surprised that we can cause other segfault with `Qobj` where the shape and dims don't match. . It would be safer to add a check when entering cython code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782#issuecomment-1021398103:373,safe,safer,373,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021398103,1,['safe'],['safer']
Safety,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1672,detect,detecting,1672,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735,2,"['detect', 'safe']","['detecting', 'safe']"
Safety,"I think there are two separate issues here. . As for the fortran module, it's true that the it adds a lot of build complexity, but most users do not need it and can easily install qutip without it. There is a case for removing it from qutip and put it in a separate module, but think this should be low priority, since it would require non-negligible amount work, would break backwards compatibility (it should bump next release to 4.0), and does not really provide any new features (other than a less complex code base). There might users who rely on it and for them it might be annoying if we remove it. So I would vote for postponing it until there are very strong arguments for removing it. As for the topic of this issue, I think that qutip should follow the lead of NumPy, even if it breaks backwards compatibility in the configuration methods, so that users that are familiar with NumPy and related projects does not have any surprises when using qutip. Also, if I understand correctly, this would mostly change how one configure and build against blas libraries such as openblas? Then I guess it would not effect the typical user that just download and install the package with standard configuration (no site.cfg file), and it should be safe the follow the advice of the OP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-155058653:1246,safe,safe,1246,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-155058653,1,['safe'],['safe']
Safety,"I think this is still relevant and could be a topic of work for future google SoC students or other students. . Recently I met Johannes Bausch who at Caltech used the algorithm toolbox for some fun example (predict the winner of the [world cup](https://quantumfrontiers.com/2018/07/02/the-world-cup-from-a-quantum-perspective/)), but this points to the fact that the QIP suite is still used. . Also, there might be room for basic I/O functionality to QiSKit and Rigetti. This quantum compiler integrability would further drive interest from the educational point of view. QuTiP is the best playground to learn realistic quantum mechanics and the notion of a compiler back-end could prove enticing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/441#issuecomment-464298751:207,predict,predict,207,https://qutip.org,https://github.com/qutip/qutip/issues/441#issuecomment-464298751,1,['predict'],['predict']
Safety,"I thought we had resolved the installation issues with the Fortran side by making the MC solver a optional (default to False).; I am not that I have fully digested everything in this thread, but @zerothi seems confident that there is just some small change that we need to improve integration with the latest Numpy. Its not clear to me what are the risks or other downsides.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-155040632:349,risk,risks,349,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-155040632,1,['risk'],['risks']
Safety,"I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1619#issuecomment-988068295:163,redund,redundant,163,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988068295,1,['redund'],['redundant']
Safety,"I tried running the same test with pytest and it fails.; ```; ============================= test session starts ==============================; platform darwin -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0; rootdir: /Users/shahnawaz/Dropbox/dev/qutip, inifile:; plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3; collected 13 items. test_superop_reps.py ..Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458572211:391,Abort,Abort,391,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458572211,1,['Abort'],['Abort']
Safety,"I vote for setting the dtype. This is probably safer since there are some; parts of the code that expect arrays.; On Sep 10, 2014 11:36 PM, ""Robert Johansson"" notifications@github.com; wrote:. > Thanks for reporting this problem! It seems to be related to the recent; > numpy 1.9 (works fine with older numpy releases). We should either add; > dtype=object in the call to np.array or use list, as you suggests.; > ; > —; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/228#issuecomment-55124130.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/228#issuecomment-55211686:47,safe,safer,47,https://qutip.org,https://github.com/qutip/qutip/issues/228#issuecomment-55211686,1,['safe'],['safer']
Safety,I will add tests. I changed the status to draft to avoid merging.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1636#issuecomment-929639158:51,avoid,avoid,51,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-929639158,1,['avoid'],['avoid']
Safety,"I'm a bit confused by your comment: Are asking about the purpose of the np array format itself or did you mean why it should accept non-linear tlists?. The reason it should accept non-linear tlists is because such a thing is good to have when you simulate rapid dynamics followed by slow dynamics. This currently works for all other types of time-dependent formats, so it should also work for this one to avoid confusion. The cubic spline would indeed be nicer here, except it seems to me like it assumes the x values are linear?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/520#issuecomment-242156352:405,avoid,avoid,405,https://qutip.org,https://github.com/qutip/qutip/pull/520#issuecomment-242156352,1,['avoid'],['avoid']
Safety,"I'm also using Anaconda on Macbook M1 and ran into 2 errors today when importing qutip. . 1. With the M1 chip, qutip had a problem with hardware detection and as @jakelishman said, commenting lines 48 and 49 on `qutip/hardware_info.py` fixed this error. 2. Then I got the same error message with ""IPYTHON not defined"" and ""'qutip' has no attribute 'settings'."" I thought my conda environment must have been missing the ipython package somehow(?) so I tried `conda install ipython` and importing qutip again and it worked! (I then ran qutip.testing.run() to test out all functions and everything worked perfectly).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-759733240:145,detect,detection,145,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-759733240,1,['detect'],['detection']
Safety,"I'm not sure about any of these options:; 1. this absolutely should not happen. Trying to detect ""magic"" behaviour based on size is counterintuitive, and breaks other behaviour; it makes it impossible for `Qobj` to correctly handle 1x1 Hilbert spaces. While very infrequently used in practice, trying to backdoor different behaviour through something because it's already there is a nightmare to maintain, and prevents any other use. We've had large problems with 1x1 Hilbert spaces in the past, and 5.x is very strict about handling them safely now.; 2. `mul` should not be defined between two instances of `Data`, because `Data` represents a matrix, and `mul` is between a scalar and a matrix. Still, this seems closest to the correct solution to me, but instead, perhaps the `mul` dispatcher might take an arbitrary Python object as the scalar, and the inner function is responsible for returning `NotImplemented` if it can't handle it? This would require a couple of wrappers around the existing `csr` and `dense` methods, but that's not a huge deal, since the dispatchers are meant to be called from Python space anyway.; 3. same argument as the start of 2: `mul` is already defined as ""scalar \* matrix"", and there's no need for ""matched-shape elementwise multiplication"" to be a defined operation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863:90,detect,detect,90,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863,2,"['detect', 'safe']","['detect', 'safely']"
Safety,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:779,safe,safe,779,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301,1,['safe'],['safe']
Safety,"I'm trying it now on a Windows without ImageMagick installed. However, it finds a wrong executable `convert`, which is a default command on Windows...... Is there a way to identify if the `convert` is the one we want? Otherwise, we can also just catch the CalledProcessError at line 148 and add an instruction. ```; 147 in_file = file_stem + "".pdf""; 148 out_file = file_stem + ""."" + configuration.file_type; --> 149 _run_command((which, *configuration.arguments, in_file, out_file)); 150 with open(out_file, mode) as file:; 151 return file.read(). ~\Miniconda3\envs\qutip-dev-py3\lib\subprocess.py in run(input, capture_output, timeout, check, *popenargs, **kwargs); 485 if check and retcode:; 486 raise CalledProcessError(retcode, process.args,; --> 487 output=stdout, stderr=stderr); 488 return CompletedProcess(process.args, retcode, stdout, stderr); 489 . CalledProcessError: Command '('convert', '-density', '100', 'qcirc.pdf', 'qcirc.png')' returned non-zero exit status 4.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125:628,timeout,timeout,628,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125,1,['timeout'],['timeout']
Safety,"I'm wondering, maybe for the colour-blind-safe mode, the traditional black-or-white colour is a better choice? The colour blind cmap goes from dark to bright. If one has a large number of entries, it is inevitable that some of them will be close to the threshold and become hard to distinguish from the background, regardless of the threshold. An alternative could be using a white edge for each blob, distinguish it from the background, e.g.:; ![image](https://user-images.githubusercontent.com/12125783/124672592-967ba880-deb7-11eb-90cb-91c78690a633.png)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1595#issuecomment-875116010:42,safe,safe,42,https://qutip.org,https://github.com/qutip/qutip/issues/1595#issuecomment-875116010,1,['safe'],['safe']
Safety,"I've lost the plot a bit with a whole load of changes to `Coefficient` now merged into this PR. Is there a chance we can split that out into its own PR?. I would expect `QobjEvo.__call__` to be thread-safe/re-entrant. The fact that coefficients seemingly don't support this immediately is worrying to me. A simple call like that changing ""global"" state of the object is dangerous; it has a habit of leaking out even in single-threaded applications, just like the bug I described previously with a call to `mesolve` modifying an existing `QobjEvo` in place. In this case I don't see an immediate bug, but it's very non-obvious behaviour and it would be easy to accidentally introduce one in it in the future (or maybe I just can't think of one now). Having `_BaseElement` be mutable makes all time-dependent operations of `QobjEvo` unresolvably thread-unsafe without copying on every operation. That said, looking again, I'm not sure I understand `_BaseElement`: it seems like `_EvoElement` and `_FuncElement` do entirely different things on `call`? What's the purpose of it, and if we put all speed considerations aside what would the signature and behaviour of `_BaseElement._call` be?. Could you write some docstrings on all the elements to explain their use-cases as well, so we've got it all stored for the future?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122:201,safe,safe,201,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"If those editors claim to provide terminal emulation it should be reported as bugs to them. However, even if it is fixed there it will take a long time before such a fix would reach end-users. I think in the interest of avoiding regressions I think we should restore the previous TextProgressBar and rename the current one to EnhancedTextProgressBar or something like that. Then this new progress bar would not disrupt peoples workflow and users who wants to use it can do so by creating an instance of it and pass it to progress-bar enabled functions using the progress_bar keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63267628:220,avoid,avoiding,220,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63267628,1,['avoid'],['avoiding']
Safety,"If you're concerned about the solvers, a) they skip tidyup til the end anyway and b) _technically_ the computational complexity of CSR * dense vector is identical to tidyup (though tidyup is a little more cache efficient), but really it's the constant factors that could kill you for small systems. For example, the ""naive"" way of implementing a relative tolerance would take the absolute value of a complex number, but that involves a floating-point square root, which is a very slow operation. That's likely partly why the current version compares real and imaginary components separately, even though the sparsity structure is only improved if _both_ go to zero. In a two-pass operation you'd sqrt twice for every entry (naively - all the square roots are very avoidable), and I'd start to worry that that really _could_ dominate small system operations. Or maybe you should just ignore me when assigning ""good first issues"" - I'm probably too opinionated about performance characteristics without enough experience at managing other people's code!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141:764,avoid,avoidable,764,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141,1,['avoid'],['avoidable']
Safety,"In development version 4.4: . - For Python 3.6, when running `qutip.testing.run()`. ```; uTiP Version: 4.4.0.dev0+0bf3e05e; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.6.8; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```; I obtain an error at ; ```; Propagator: steady state ... Segmentation fault: 11; ```. - For Python 3.7 with ; ```; QuTiP Version: 4.4.0.dev0+0bf3e05e; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/miniconda3/envs/py37/lib/python3.7/site-packages/qutip-4.4.0.dev0+0bf3e05e-py3.7-macosx-10.7-x86_64.egg/qutip; ```; the error occurs at . ```; Metrics: Check avg gate fidelities for random ... python(42424,0x7fffa34a8380) malloc: *** error for object 0x7fc74f258880: incorrect checksum for freed object - object was probably modified after being freed.; *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-482116179:1201,Abort,Abort,1201,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-482116179,1,['Abort'],['Abort']
Safety,"In the release version `qutip-4.7.X`, it is set in `qutip/__init__.py`. On master it is at https://github.com/qutip/qutip/blob/253d91c2776fef5cc0025e3c537d046f6e9c97a1/qutip/settings.py#L159; It's a property and can't be changed, but we can change that if useful.; The condition is the same. Qutip's sparse `eig` is not safe for matrices with degenerate real part of the eigen value (#1998), but I have not seen issues with the dense one (calling lapack through numpy).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751:320,safe,safe,320,https://qutip.org,https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751,1,['safe'],['safe']
Safety,"Is multiprocessing used by default in some functions ? Can we do away with that in the __init__.py file and add it where it is used ? . Why do we need to check for numpy and scipy versions at each import ? Is it not enough to check it when installing qutip ?. What do you mean by ""avoiding internal imports"" ? Do you mean to say that we should remove all * imports ? . ```; from qutip.tomography import *; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-269518208:281,avoid,avoiding,281,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-269518208,1,['avoid'],['avoiding']
Safety,"Is there any possibility to make the JAX data layer `_data.isherm` JIT / autograd safe? If not, do we perhaps need a general way for the data layer to allow something like `_data.isherm(..., ensure_jit_safe=True)`? The syntax of my suggestion doesn't look great to me, but you understand the question.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2329#issuecomment-2152637027:82,safe,safe,82,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-2152637027,1,['safe'],['safe']
Safety,It aborted at the 12nd loop which consist of 200 sub-loop.; see:; ![fig](https://cloud.githubusercontent.com/assets/16291224/26436825/f53e0a06-414b-11e7-8e71-e9df9fa107f4.PNG),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697#issuecomment-303924473:3,abort,aborted,3,https://qutip.org,https://github.com/qutip/qutip/issues/697#issuecomment-303924473,1,['abort'],['aborted']
Safety,"It could be that a pulse is too thin and missed.; When working with pulse, it's safer to always set [max_step](https://qutip.readthedocs.io/en/latest/guide/dynamics/dynamics-time.html#working-with-pulses).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658:80,safe,safer,80,https://qutip.org,https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658,1,['safe'],['safer']
Safety,"It feels more 4.6.3 since it's not a new feature but removing unused code in `__init__`, making qutip's import safer. So it looks more like a bug fix to me. Is there any specific reason to wait for 4.7?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1758#issuecomment-1015544419:111,safe,safer,111,https://qutip.org,https://github.com/qutip/qutip/pull/1758#issuecomment-1015544419,1,['safe'],['safer']
Safety,"It is already in the latest dev version on github. . > On Mar 30, 2016, at 12:13, Lucas Verney notifications@github.com wrote:; > ; > Any news on this? I would personnally find it particularly useful to have cosm and sinm methods on Qobj class. I can submit a PR with it if you want.; > ; > If such methods are not to be added, I think this issue can be safely closed.; > ; > —; > You are receiving this because you were mentioned.; > Reply to this email directly or view it on GitHub; > ; > Untracked with Trackbuster",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/427#issuecomment-203563729:354,safe,safely,354,https://qutip.org,https://github.com/qutip/qutip/issues/427#issuecomment-203563729,1,['safe'],['safely']
Safety,It is not so much the safety checks as the order in which a simple single operator is converted internally to a list vs. when the safety checks are run. This is fixed in #631.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/630#issuecomment-272360048:22,safe,safety,22,https://qutip.org,https://github.com/qutip/qutip/issues/630#issuecomment-272360048,2,['safe'],['safety']
Safety,"It looks to me like the old-style format requires args not have mixed type so [args, 0] actually doesn't work. But I tried to make it safer - on that note I think it seems cleaner to just leave the old-style form only implemented for dictionary inputs. I also changed the function list format to have args in a dictionary format. This way any internal code will always reference args[""_t0""] regardless of the format used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/206#issuecomment-52397664:134,safe,safer,134,https://qutip.org,https://github.com/qutip/qutip/pull/206#issuecomment-52397664,1,['safe'],['safer']
Safety,"It refers to the system's Liouvillian, I'd say. I think all the `C_n` there are stochastic jumps, `sc_ops `, while the system Liouvillian is the constant part, `c_ops`. But I am not 100% sure. . The user guide is partly out of date there, @Ericgig and others have considerably extended the functionalities of the stochastic solvers. Looking at the [API documentation](http://qutip.org/docs/latest/apidoc/functions.html#module-qutip.stochastic) is safer, and the [source code](http://qutip.org/docs/latest/modules/qutip/stochastic.html) is even more complete. . Meanwhile, you can also have a look at these development notebooks [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-milstein-speed-test.ipynb), [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb), and [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb) with regards to the new methods (you can find them all, a bit hidden, at the bottom of the http://qutip.org/tutorials.html list). Technically this issue could be transferred under [`qutip/qutip-doc`](https://github.com/qutip/qutip-doc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702:447,safe,safer,447,https://qutip.org,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702,1,['safe'],['safer']
Safety,"It seems the entire idea of printing from different threads in python is deeply troublesome. https://stackoverflow.com/questions/3029816/how-do-i-get-a-thread-safe-print-in-python-2-6. My guess is that the appropriate solution is to move all the printing to a single thread and use `Queue`, but I am not quite certain of that. I will see what I can do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-42067292:159,safe,safe-print-in-python-,159,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-42067292,1,['safe'],['safe-print-in-python-']
Safety,"It would be good if our naming can help avoid confusion between the concept of a `dtype` (which is the type of elements within an array) and our `data backend type` (which is how the array itself is represented). I'm not sure what a good convention is, but ensuring the docstrings for the backend type have specific examples of valid inputs would definitely help (e.g. `dense` or `csr`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-809209356:40,avoid,avoid,40,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-809209356,1,['avoid'],['avoid']
Safety,"It would be nice to avoid a proliferation of settings if we can. Could we perhaps add a casting function to the data layer somewhere? For example:; ```; if oper.isherm and ...:; out = oper.data.cast_to_real(out); ```; where for the JAX backend `cast_to_real` is something like `jax.numpy,real`. This is a little bit awkward if `oper.data` and `state.data` are different dtypes, because there are two possible functions to choose from, but perhaps that's okay?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2329#issuecomment-1953218505:20,avoid,avoid,20,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-1953218505,1,['avoid'],['avoid']
Safety,"It would maybe be good to keep everything in one PR that can be squashed into a single commit at the end - this is only a single ""logical"" change at the end of the day. Nice to get these things tidied up. You probably need to run all the tests locally before just pushing to check if everything works; QuTiP has quite a few code generation steps and indirect evaluation that can't be detected with static analysis, which is why you're seeing a lot of test failures (though that's _mostly_ `.pyx` files). Something seems wrong with the static analyser if it's not spotting that `Qobj` is used _everywhere_, though, and I notice in several commits it has a lot of false positives for removal. I can't imagine any situation where a static analyser should remove an in-library import from an `__init__.py` file, but it's done that in a couple of places. Similarly, in `cy/pyxbuilder.py` I can see that it's removed a line `import pyximport`, but I can see that that import _is_ used - it's so close it's even within the minimal diff!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1394#issuecomment-735738116:384,detect,detected,384,https://qutip.org,https://github.com/qutip/qutip/pull/1394#issuecomment-735738116,1,['detect'],['detected']
Safety,"It's not completely contradictory: if you provide an instance of `BaseProgressBar`, it'll work. And the argument is optional. Just that on top of that, you can just say `True` to avoid instanciating yourself the progress object, and this is not documented.; Anyway, I'm just noticing, I don't know the code neither. ;)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/444#issuecomment-190621256:179,avoid,avoid,179,https://qutip.org,https://github.com/qutip/qutip/issues/444#issuecomment-190621256,1,['avoid'],['avoid']
Safety,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:79,avoid,avoid,79,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230,2,['avoid'],"['avoid', 'avoids']"
Safety,"Knowing the number of CPUs in the system may help in the future in debugging OpenMP code and setting sensible OpenMP thread counts - we may want to keep that part of the detection. I don't see any need for CPU frequency or memory size, though. That said, we should probably switch to using a library (like [`psutil`](https://github.com/giampaolo/psutil)) if we're going to keep it - it'll be a lot more reliable. For example, I've no idea why the current mac hardware detection in QuTiP ignores the `hw.ncpu` entry in `sysctl`, but the FreeBSD version explicitly uses it...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1395#issuecomment-736675351:170,detect,detection,170,https://qutip.org,https://github.com/qutip/qutip/issues/1395#issuecomment-736675351,2,['detect'],['detection']
Safety,"Looking at the Travis CI, it looks as if the Python 3 renaming of `__builtin__` to `builtins` is confusing the IPython detection in my changes to `qutip.settings`. Do you have any suggestions as to how would be best to handle that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-61394654:119,detect,detection,119,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-61394654,1,['detect'],['detection']
Safety,"Looks like there were breaking changes introduced in CVXPY 1.1 that changed some sort of matrix handling? I think the entirely of the `dnorm` function was written by Chris Granade about 5 years ago, and they're off at Microsoft now. As an immediate workaround, you can pin the version of CVXPY in conda to 1.0 (`conda install 'cvxpy=1.0'`) to fix it. Otherwise, probably there's a solution in swapping over a load of `*` to `@` in `qutip/semidefinite.py` and `qutip/metrics.py`, but that might be a bit nontrivial to solve. If you succeed, please do make a pull request. The reason that the ""simple"" cases work is that QuTiP detects them as known results and has fast paths avoiding `cvxpy`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713:625,detect,detects,625,https://qutip.org,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713,2,"['avoid', 'detect']","['avoiding', 'detects']"
Safety,"Looks like you two could have a productive conversation. It'd be good to avoid duplication and make the best use of everyone's time, even for the computer ;). Sorry, I accidentally clicked close...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320#issuecomment-657778570:73,avoid,avoid,73,https://qutip.org,https://github.com/qutip/qutip/issues/1320#issuecomment-657778570,1,['avoid'],['avoid']
Safety,Maybe macos needs a slightly longer timeout? It is a bit slow.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1028431140:36,timeout,timeout,36,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1028431140,1,['timeout'],['timeout']
Safety,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:39,safe,safe,39,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561,2,['safe'],['safe']
Safety,"No, `dtype` should always be respected, even for jax.; So the default need to be changed.; One options would be to set `dtype=None` for the default and then if it's `None` and sparse, then use dense. (+ update the docstring and tests.); Another options would be to remove the `dtype` parameter and replace it with `sparse` like `eigenenergies`. But I would like to keep support for both for a while has we should no introduce breaking change outside of major release which won't come anytime soon (detect if the user input a dtype and warn it in that case, but still give him his intended behaviour.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388:498,detect,detect,498,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388,1,['detect'],['detect']
Safety,"Note that we don't use threads but the multiprocessing library, which uses processes. So print not being thread safe is not an issue, but there might be other difficulties.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-42090970:112,safe,safe,112,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-42090970,1,['safe'],['safe']
Safety,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:299,detect,detection,299,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861,1,['detect'],['detection']
Safety,"Note: the reported changes (other than the deletion of the licence from each source file) are all whitespace-only, or simply a reflow of the hard-wrapped text in `LICENSE.txt`. I didn't change the licence at all, other than the holder. I've also checked this with the same tool that GitHub uses, and it will definitely recognise the licence correctly after this. The whitespace-only changes in other files weren't actually 100% intended, but it was a function of how I did the licence detection - I normalised the whitespace at the ends of lines first. Looking through, I guess I only did that when changing the `doc` folder, not the main source code (I had to handle those two cases separately).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684:485,detect,detection,485,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684,1,['detect'],['detection']
Safety,"Now in order to avoid a +/- 7000 line diff effecting 148 files, a these commits should be squashed with a rebase.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/221#issuecomment-53838419:16,avoid,avoid,16,https://qutip.org,https://github.com/qutip/qutip/pull/221#issuecomment-53838419,1,['avoid'],['avoid']
Safety,"OK, if it's intended then there's nothing to change in the code. But I think it would be helpful to document this in a clearer way: there's a big risk of misinterpreting the operator.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286282270:146,risk,risk,146,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286282270,1,['risk'],['risk']
Safety,"Oh, yes, I increase the sampling rate. Indeed the correct result is recovered. Great thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479:68,recover,recovered,68,https://qutip.org,https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479,1,['recover'],['recovered']
Safety,"Ok, I think I may have some more information. I am fairly sure that this is the same bug as #1120, #963 and #944 (which I believe was not actually ever fixed). I'm going to put the information here. My working theory is currently that this is a MKL bug on Mac. For posterity, let me just dump out some information. ## Things you should know if you've not worked with segfaults before. - `Abort trap 6`, `Segmentation fault` and a few other points can all be from the same cause; - Segmentation faults are typically caused by reading or writing to memory that isn't owned by our process. These often occur by reading/writing too much data to an allocated pointer, or trying to read/write a memory location where the location was read from uninitialised memory.; - Segfaults will not always reliably occur. It's _very_ difficult to prove that swapping tools ""fixes"" a segfault; it can often just move around enough allocations to mask the problem, not fix it.; - Python stack traces are likely to be almost entirely unreliable in these cases, because the segfault may often occur while the garbage collector is running, and that will happen at seemingly non-deterministic times.; - Running files in a slightly different interpreter, running within a test runner with differing numbers of files, doing different work before and after will all cause the segfault to change, and may mask it.; - As annoying as they are, segfaults are actually the _good_ case of the bug - the worst is when we have invalid memory writes but _no_ segfault, because then we have memory corruption that's gone undetected. ## Thoughts about #1120. This issue is still present using Andrew's `Malloc.py` file as of the current master branch (commit 624405e7), and is in QuTiP 4.6.0 and most previous versions. I have been able to reproduce the segfaults with Python 3.7, but not Python 3.8, and I can reproduce it with all allowable values of `PYTHONMALLOC`. The most telling is `pymalloc_debug`, where the entire operation comp",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:388,Abort,Abort,388,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['Abort'],['Abort']
Safety,"Ok, yeah, I definitely see the use-case here. I'll leave it removed from `matmul` for the time being because I hadn't really organised that code to allow safe calling of the function with an `out` parameter, but I'll look to re-instate it, similarly with `add`. For `add`: I envisage a nice possibility for `QobjEvo` using `CSR` backing along the vein of `CQobjEvoTdMatched`: on instantiation we add together all the matrices, then we `memset` all zeroes along the `data` array and store it as `self._structure`. Then each time we `__call__` the object, we simply do `out = self._structure.copy()`, and use that as the output matrix, because we guarantee we'll always have enough space and the correct structure. There's a couple of minor kinks in the logic of `add_csr` that we might have to iron out in order to avoid an additional matrix addition, but the savings in memory allocation could be good. You're absolutely right about the `pxd` files - I haven't taken enough care to make sure they've got all the definitions in yet. Basically everything that isn't prefixed with an underscore in the `.pyx` files _should_ be in the `.pxd` files. I'll add them in tomorrow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648371869:154,safe,safe,154,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648371869,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,On the other hand I'm not completely against just having this as a safety net for wonky tests anyway.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098:67,safe,safety,67,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098,1,['safe'],['safety']
Safety,"Perhaps an example will help:. Say that I want to squeeze the vacuum with z=1. What I should do is compute the vector S(z)|0> for z=1. What I would expect is that the amplitudes of the result shouldn't depend on whether I decide to truncate at dimension 10 or 20 or 30, but with the current implementation of `qutip.squeeze` it does:; ```python; (qt.squeeze(5,1)*qt.basis(5,0)); ```; tells me that (for instance) the 5-photon state has amplitude 0.453, while according to ; ```python; (qt.squeeze(10,1)*qt.basis(10,0)); ```; the same state has amplitude 0.310. This is a physically relevant difference, so how do I answer the question: what's the probability of detecting n photons in the S(z)-squeezed vacuum? With the current implementation of `qutip.squeeze` I cannot. Do you see the problem?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286262389:662,detect,detecting,662,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286262389,1,['detect'],['detecting']
Safety,Please consider changing your unit to avoid small terms like `e-6` and `hbar`. QuTiP uses sparse matrix and removes very small (~<e-7) matrix entries. Possible improvement was discussed in https://github.com/qutip/qutip/issues/1349.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1402#issuecomment-739775446:38,avoid,avoid,38,https://qutip.org,https://github.com/qutip/qutip/issues/1402#issuecomment-739775446,1,['avoid'],['avoid']
Safety,"Please merge with master and resolve conflicts and push the updates. In general, to avoid conflicts, you should do 'git pull upsteam master' into your master before creating a new branch.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/294#issuecomment-67649107:84,avoid,avoid,84,https://qutip.org,https://github.com/qutip/qutip/pull/294#issuecomment-67649107,1,['avoid'],['avoid']
Safety,Please rebase this against the current master @IIAOPSW . There are some changes in the travis.yml file put in by @ajgpitch which selectively avoids some py2.7 tests. There were many new additions to tackle some Python 2 issues too.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398000185:141,avoid,avoids,141,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398000185,1,['avoid'],['avoids']
Safety,"Probably the safest solution for us right now is to completely elide this run-time check, and have `setup.py` hard-code the value of `settings.has_openmp` at compile time. Does that sound reasonable to you (since you wrote most of the original OpenMP stuff [and most of the current QuTiP code...])? Also checking with @Ericgig, since I know you're a heavy user of it too. Edit: I forgot, I actually already fixed the possibility of this happening in `dev.major` - it uses a much more rigorous `importlib` import to ensure that we're attempting the OpenMP bit with the natural import system, and so it doesn't conflict with relative imports elsewhere in `qutip`:. https://github.com/qutip/qutip/blob/3f5c2980cff42067c0f93b226d3f07be9ef9022a/qutip/__init__.py#L107-L117",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1334#issuecomment-670170527:13,safe,safest,13,https://qutip.org,https://github.com/qutip/qutip/issues/1334#issuecomment-670170527,1,['safe'],['safest']
Safety,"Redundant to #1768, we will keep that one for those 2 files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642:0,Redund,Redundant,0,https://qutip.org,https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642,1,['Redund'],['Redundant']
Safety,"Repeating just changes the probability of failure, rather than actually detecting whether it was a rare fail, and `mesolve` tests aren't always the fastest, so repetition here isn't great. For simple unitary qubit operations, I think it should be easy enough to work out how the tolerance translates. It's difficult to say that if there's a numerical error then the error will be much greater - I caught some errors in the `test_gates.py` (I think) that were sneaking through because the tolerances were set too high. It's probably best to keep as tight a tolerance as is reasonable - here I think `2 * qutip.Options.rtol` would always be correct if the numerics are.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-625344751:72,detect,detecting,72,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-625344751,1,['detect'],['detecting']
Safety,Seems like a good fix. Can't see any risks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/375#issuecomment-142891700:37,risk,risks,37,https://qutip.org,https://github.com/qutip/qutip/pull/375#issuecomment-142891700,1,['risk'],['risks']
Safety,"Setting up the testing environment with `conda` avoids the segfault, but hangs indefinitely while running the tests. I'm using the following `run_tests_conda.sh`:; ~~~; #!/usr/bin/env bash; conda create -y -p venv python=3.8 'cython>=0.21' 'numpy>=1.12' 'scipy>=1.0' matplotlib ipython pytest; ./venv/bin/python setup.py install; ./venv/bin/pip freeze > test.log; ./venv/bin/python -c 'import scipy; print(""Scipy config:""); scipy.__config__.show()' >> test.log; ./venv/bin/python -c 'import numpy; print(""Numpy config:""); numpy.__config__.show()' >> test.log; (cd venv && ./bin/python -c 'from qutip.testing import run; run()' 2>&1 | tee -a ../test.log); ~~~. This produces the attached [`test.log`](https://github.com/qutip/qutip/files/4307943/test.log): testing hangs at `test_mcsolve.py::test_MCTDFunc`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939:48,avoid,avoids,48,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939,1,['avoid'],['avoids']
Safety,"So beside that if i have also normal collapse operators, i just need to define and put them at the fourth argument of mesolve. I thank you very much dear Jakelishman. Be safe.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1435#issuecomment-774028841:170,safe,safe,170,https://qutip.org,https://github.com/qutip/qutip/issues/1435#issuecomment-774028841,1,['safe'],['safe']
Safety,So did the simulations complete the second time? Or did it abort in the same location?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697#issuecomment-303783251:59,abort,abort,59,https://qutip.org,https://github.com/qutip/qutip/issues/697#issuecomment-303783251,1,['abort'],['abort']
Safety,"So, while I agree that having a flexible storage format is a good way to go, the truth of the matter is that no one has time to implement such a big change. SciPy supports both 32 and 64-bit ints, and checks to see which ones are needed at runtime. e.g. a tensor product of two sparse matrices with int32, may need int64 in the result since their shape is larger. We could also do a similar thing, but it is a lot of work. The reason why we no longer use standard SciPy sparse objects is: 1) They tend to have a sizeable overhead when being created and/or manipulated do to redundant safety checks. 2) Many of the sparse operations are not well optimized. Because SciPy supports many different sparse formats, they had to generalize many of their core operations, making them slower. For example, the sparse kronecker product first converts to COO format, does the tensoring, and then converts back to the original format. Our method is much faster. Supporting more than just the current CSR format is also problematic. As already mentioned, there would be type checks, conditionals, and format conversions everywhere. e.g. what happens when DIA * CSR. As usual, available time is the limiting factor here. Support for both int32 and int64 is not that hard, but would take some time. Just int64 would make smaller matrices larger, but would allow for much greater system dimensions. In this later case, it would be a simple switch `int` -> `int64` and `size_t` -> `uint64` in the Cython code, and the fastsparse module (plus probably other places.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384005667:574,redund,redundant,574,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384005667,2,"['redund', 'safe']","['redundant', 'safety']"
Safety,"Solvers: absolutely the solvers should always be packaged with the main `qutip`. I had sort of envisaged that we'd put them in a `solve` package, which would be exported into the main namespace just like `core` is. This way is more just for greater separation, so that the full core isn't entangled with the solvers themselves - I think separating them like this will help us ensure that we specify the data layer API much more cleanly if the solvers aren't referenced within it. (i.e. there's no reference to any solver within `core`, but the API is built sufficiently cleanly that they can still access all the internals). OpenMP check: I think there's two neater ways:; 1. perhaps `settings` should just be in `core` too? I avoided putting the check in `core/__init__.py` because I'm really trying to avoid bi-directional dependencies between the packages, but moving `settings.py` into `core` would solve that.; 2. alternatively, we could just write `settings.py` as part of `setup.py` - determine whether we built against OpenMP/MKL at compile-time, and then just write it in? We can still choose whether or not to use it in various runtime situations. As for the current test - yeah, the comparative complexity is kind of indicative that this isn't the right way to do it. It's a relatively straightforward use of `importlib`, but still it's more difficult. (By the way: are you and @ajgpitch getting notified when I post in [the discussion board](https://github.com/orgs/qutip/teams/data-layer-devs)?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1282#issuecomment-638730654:727,avoid,avoided,727,https://qutip.org,https://github.com/qutip/qutip/pull/1282#issuecomment-638730654,2,['avoid'],"['avoid', 'avoided']"
Safety,"Sorry I didn't get round to commenting on this PR sooner. Since it's now come up in #1579 around the subject of sorting out licensing in general in QuTiP, let me also note some stuff about that here. #1579 proposes to remove all individual-file licence text, because it is in general redundant, and makes it harder for us to centrally manage our licence. There is some concern (mostly mine), that it will be a little difficult for us to manage additional code which does not sign over copyright to the QuTiP admin team; if we accept it, we will have to keep the notice in perpetuity. This will pose a bit of a Theseus' ship problem for us if we ever want to re-organise the file that contains this code; after how many modifications is the code no longer NASA's, but QuTiP's? As long as it's not _ours_, we can't separate it out into different files, or mix it with other code (say additional implementations). I'm definitely not a lawyer, but I'm worried that will cause us code organisation problems in the future, and while the licence would give us permission to improve the code, it's the reorganisation I'm worried about. Secondly, about the code itself: this sort of local operation is something I absolutely would like to include, but I'm not certain that the form it's in right now is the best, general way to do it. I think this is part of much larger discussion about how to handle tensor networks - for example, at the moment, `targets` is fine for states and operators, but it won't work for superoperators. I'm not sure that this is solvable in an ergonomic way with QuTiP's current dimensions specifiers, but it's something we're definitely going to look into after the initial release of 5.0. Also, there are already several disparate functions in QuTiP that provide sort-of similar functionality, and I think we need to have a proper go at tidying them all up into one cohesive interface. This includes `subsystem_apply` (most similar to this), but also `ptrace` and `partial_tranpose",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:284,redund,redundant,284,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,1,['redund'],['redundant']
Safety,"Sorry, I'm not sure of the meaning of the failed Travis CI check. I actually came back to comment, that just adding the missing sign may be safer than recursive calls of the function to itself. In the present case I don't see an actual danger of getting stuck in a loop, even with future changes to one of the involved functions, but it now feels safer to just add the missing sign. Maybe someone more experience can comment or just merge the request...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/565#issuecomment-263870324:140,safe,safer,140,https://qutip.org,https://github.com/qutip/qutip/pull/565#issuecomment-263870324,2,['safe'],['safer']
Safety,"Sounds good to me. Yeah, even if `packaging` _were_ in `setuptools`, it'd still be an explicit dependency of ours, so you're right to put it in, thanks. Yeah, that coveralls thing just looked like a network timeout on their side. Not the fault of this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1715#issuecomment-973127486:207,timeout,timeout,207,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973127486,1,['timeout'],['timeout']
Safety,"Switching `auto_tidyup` to being a relative tolerance not an absolute tolerance I think is a really good idea. It raises the cost of it a bit by making it a two-pass operation (and for sure let's use the max norm, not the trace norm!), but I think it's a sensible compromise. We could even have two options - `tidyup_atol` and `tidyup_rtol` to have both, and have `tidyup_atol` default to `0`. Also, fine point about `QobjEvo` - I'd forgotten that it internally called `tidyup`. I'm certainly in favour of swapping the default to `False` for the next major release. I know people may still want the option, so not a good idea to remove it completely, but I think having the default be `False` is safer numerically.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-680027055:696,safe,safer,696,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-680027055,1,['safe'],['safer']
Safety,"Thank for the remark. ; @NS2LPS Replacing the first row of the Liouvillian is a standard way to ensure the algorithm produces a steady state with trace one. Since this condition is, in theory, redundant, adding the weighted first-row or substituting the first line should be equivalent. Often the algorithm is unstable, so one weights the trace 1 condition. Maybe how much of the first row is kept can make the algorithm even more stable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1275#issuecomment-661868732:193,redund,redundant,193,https://qutip.org,https://github.com/qutip/qutip/pull/1275#issuecomment-661868732,1,['redund'],['redundant']
Safety,"Thank you for all your work @gsuarezr . Just for a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:580,avoid,avoid,580,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525,1,['avoid'],['avoid']
Safety,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:62,detect,detection,62,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367,1,['detect'],['detection']
Safety,"Thank you for your review. > The default seems to be a relative weight of `1`. Meaning that it should work fine in solver which does not use it (stochastic). But should they just keep using `Result` until we have a use for those weight?. I let them use `Result` again for now. I needed to add some lines [here](https://github.com/pmenczel/qutip/blob/weighted-trajectories/qutip/solver/result.py#L710) so that the new `MultiTrajResult` can deal with it. (Which might be a good idea anyway.). > It there a balancing tools for weight values? If there are 2 runs, can both have a relative weight of 10 or 0.1 without affecting the end results? If there are 2 starting kets that we want to merge with a weight of 10:1, does the actual values matter or only the ratio?. I have added a `merge` function that lets the user merge trajectory results with custom relative weights. I think trajectories with absolute or relative weights are handled consistently. Calling `result1 + result2` uses default values for the relative weights, chosen such that every trajectory contributes equally.; (That doesn't currently work for the stochastic solvers, but to my understanding, adding results didn't work for them previously either. It raises a `NotImplementedError` now.). > I feel it would be safer to compute the relative weight as `W(T) / sum_T(W(T))` instead of using the number of trajectories. Hmm unfortunately I think that this won't work. For the ""improved sampling"" case, the sum of the relative weights is not one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2369#issuecomment-2029539933:1280,safe,safer,1280,https://qutip.org,https://github.com/qutip/qutip/pull/2369#issuecomment-2029539933,1,['safe'],['safer']
Safety,"Thank you. Turning off auto tidy of course fixes my issue.; I use QuTiP for quantum photonics, where our down-conversion probabilities are of order 1e-7, and sometimes we do two cascaded. This tiny photon component is nonetheless measurable in the lab, and QuTiP is really helpful to predict rates and noise. I guess the problem is unitless in the sense that these small elements are directly the photon probability amplitudes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242072924:284,predict,predict,284,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242072924,1,['predict'],['predict']
Safety,Thanks @Ericgig for feedback.; I see (having read more carefully) in; https://github.com/qutip/qutip-notebooks/blob/master/examples/smesolve-inefficient-detection.ipynb; there is an example showing the equivalence of using `smesolve` and `general_stochastic` with a clear performance enhancement in the former. So I think I can easily switch my example to use `smesolve`. Thanks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581:153,detect,detection,153,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581,1,['detect'],['detection']
Safety,"Thanks Chris,; This seems like a useful addition. I have taken a quick look at the code, and it seems like it is fairly independent, and so could be merged with little risk. The interface seems good, so I can't see any issues immediately. . Are you planning to do a notebook example?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/358#issuecomment-127953580:168,risk,risk,168,https://qutip.org,https://github.com/qutip/qutip/pull/358#issuecomment-127953580,1,['risk'],['risk']
Safety,"Thanks for reporting this - it's an important bug that's snuck in. Right now, there's a few errors in your code that you can fix to get on your way again, but we need to fix the error on our side. You're using `sigmap()` which is the Pauli excitation operator and is only defined for a Hilbert space with dimension 2. You actually are working with a Hilbert space of dimension `nmax * nmax` (a tensor-product space), so your `e_ops` argument to `sesolve` is wrong - it's difficult to know exactly what you meant here. `destroy(2)` is equivalent to `sigmap()`, so it's possible you intended to have `e_ops` be `[qutip.tensor(a1, a2)]`?. ---. Maintainers: The error is actually a segfault, because QuTiP 4.5 (probably 4.4 too) does not do sufficient error checking on`e_ops` arguments - probably they're missing in the conversion to `CQobjEvo`. When the expectation is called, it has already sidestepped `Qobj`'s dimensions check and there is no matrix size check, so it simply segfaults on OOB access. The fix for the 4.x branch is to have a very loud Python-space error due to mismatched `Qobj` dimensions on entry to the solvers, or insert a size check within `CQobjEvo`. High priority: there's no reason we should be segfaulting here. Partially fixed in the 5.x branch; all matrix multiplications that take place in C-space have a size check and throw a Python exception, however the solvers still sidestep the `Qobj` dimension check so a tensor-product-space mismatch will not be detected.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1374#issuecomment-717495492:1483,detect,detected,1483,https://qutip.org,https://github.com/qutip/qutip/issues/1374#issuecomment-717495492,1,['detect'],['detected']
Safety,"Thanks for reporting this. This appears to have _always_ been an inconsistency between the documentation and the code. These lines were added in one commit in #166, with no reference to any changes. I note at the moment that calling `max` on an array of complex (like this) finds the number with the maximal _real_ part, and then takes the absolute value of that. I suspect that the `max` call got added in after everything else was written - if you remove that call, you would retrieve the documented behaviour, though I don't know enough about the numerical strategies to know which method is safer; I don't know whether we should change the documentationi or the behaviour. @nwlambert might be better placed to answer that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1512#issuecomment-829102786:595,safe,safer,595,https://qutip.org,https://github.com/qutip/qutip/issues/1512#issuecomment-829102786,1,['safe'],['safer']
Safety,"Thanks for the clue, it was helpfull.; The source of problem is localization of `lscpu` util, which used by `_linux_hardware_info()` function.; The function expects `'Socket(s)'`, `'Core(s) per socket'`, etc in `lscpu` output, but in my system it actually `'Потоков на ядро'`, `'Сокетов'`, etc.; I think, maybe better less system dependent ways to calculate cpu count, for example, we could use `multiprocessing` module and it's `cpu_count` function. Or `len(os.sched_getaffinity(0))`for computers with dynamic cpu management (see [this](https://stackoverflow.com/questions/31346974/portable-way-of-detecting-number-of-usable-cpus-in-python) for details).; Or show exception/error, if we try to use lscpu and `LANG` is not english (or we couldn't found mentioned above `'Socket(s)'`).; Ideas?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1004#issuecomment-497325045:599,detect,detecting-number-of-usable-cpus-in-python,599,https://qutip.org,https://github.com/qutip/qutip/issues/1004#issuecomment-497325045,1,['detect'],['detecting-number-of-usable-cpus-in-python']
Safety,"Thanks! I don't think we should include ipynb files into the main repo though as they are usually pretty large binary files. . If we want to have this figure, it would be nice to include the source code stored somewhere in a file under `qutip\doc` and generate the figure automatically when building the doc. Just like other matplotlib figures. In addition, it would be good to avoid using `pandas` and `mpmath` in the code if possible. Python has its own JSON reader and for mpmath, I'm not sure if such a high float precision is necessary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1828#issuecomment-1065880645:378,avoid,avoid,378,https://qutip.org,https://github.com/qutip/qutip/pull/1828#issuecomment-1065880645,1,['avoid'],['avoid']
Safety,"Thanks!. @Ericgig ; > If you need to use an array coefficient and this is your restriction on tlist, use qutip.Cubic_spline (or build the QobjEvo before the solver, but I don't remember if it is safe in v4). This is exactly my case. I see, I can just give mesolve a Cubic_spline object, very nice. I didn't know that give `tlist` to mesolve is same as asking these intermediate results. I was using it just as a match for array coefficient. Actually, I've been using array coefficient for a while and I don't even know such functionality exists. And I remember someone else mentioned this to me before, so I shouldn't be the only one. I see in the doc there is a section mentioning it. Probably we could stress it a bit more. @jakelishman ; > We probably shouldn't mutate the given Options object, but the call as written here doesn't make a huge amount of sense - why would you want to run the integrator but not have any output stored at all? You'd just be spinning your processor. Sorry, my post was a bit unclear. I only need the final result. So I set `store_final_state=True`, but that doesn't change the behaviour of `store_state` at all. Indeed, I'm doing so just because I didn't know the solution Eric pointed out before. For me a warning before changing `Options` would be nice. And probably pointing out the solution Eric mentioned?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1437#issuecomment-775319207:195,safe,safe,195,https://qutip.org,https://github.com/qutip/qutip/issues/1437#issuecomment-775319207,1,['safe'],['safe']
Safety,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:1464,redund,redundant,1464,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845,2,"['redund', 'risk']","['redundant', 'risk']"
Safety,"The `dims` in the line you commented out appear to be incorrect. They are the dims for the Liouvillian (i.e. operator over the density matrix) and not of the density matrix itself. Specify `dims=[[2, 2, 2], [2, 2, 2]]` instead. Slightly longer answer; If you don't specify the dims when creating a Qobj from an ndarray, QuTiP assumes the dims are the shape of the array. Your Hamiltonian is constructed by tensoring together operators on single qubits, so it's dims are more structured and QuTiP detects the mismatch.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1989#issuecomment-1232217541:496,detect,detects,496,https://qutip.org,https://github.com/qutip/qutip/issues/1989#issuecomment-1232217541,1,['detect'],['detects']
Safety,"The `general_stochastic` function does process the `e_ops`. ; I see your point about it being it being a general solver of SDEs and so it makes sense that the variable is a vector. Certainly no value in changing the processing to work on Qobj.; I just think it would make usage easier if `state0` and `e_ops` (and I guess `m_ops`) could be provided as dm and opers rather than vectorised and superoperators. These could be recognised as such and converted before processing. We could then convert the `result.states` accordingly. . Anyway, I am only just beginning to understand this stuff, so I will leave it up to your judgement as to whether this is worth the effort. If the aim to try always to avoid `general_stochastic`, then I suppose it is not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547219289:699,avoid,avoid,699,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547219289,1,['avoid'],['avoid']
Safety,"The problem is recognising what a true 0 is from a small value. In your example on the new data layer, there will already be exactly 0 items explicitly stored (and `data.add_csr` is going to get faster and smarter in another PR, too) without `tidyup`, but much more concerningly `1e-15 * qutip.rand_herm(5)` will end up in a zero matrix, which is clearly absolutely wrong. The argument from Liouvillian doesn't work here - even before the new data layer, `liouvillian` never called the `tidyup` code because it accessed the `Qobj.data` field directly, rather than used `Qobj`. Since it then goes into `CQobjEvo` in most of the solvers, which also don't touch the `tidyup` code, it doesn't get called. I don't think there's any safe way to know if small values should actually be zero, or if they're just small values. It makes sense that we want to maintain as much sparsity as possible when values are truly zero, but I think having the QuTiP default be to attempt to tidy up after every addition, multiplication and matrix multiplication is quite unsafe, and for people who aren't doing very very sparse calculations, it's actually a slow down.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-680011384:727,safe,safe,727,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-680011384,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"The question about the mandatory default for states is a good one. So currently we call the `QobjEvo` with `t=0` to get its dims. This is slightly hacky, but very convenient, and usually `t=0` is a valid time. Feedback breaks this assumption though because now `t=0` is insufficient information. We also need the current state, but we can't create a dummy state because we don't know what its dims should be yet. So there is a cycle we have to break somehow. Currently we break this by having the user supply an initial state, but perhaps we could do other things. The worst case is when the Qobj part of an EvoElement is supplied by a function. Then we can't get the dims without calling it. When the Qobj part is just a Qobj, getting the dims is fairly straight forward. So one option would be to ask the user to supply the dims if there are no EvoElements that provide a Qobj to look at, or to guarantee that their function is callable with just `t=0`. I'm not sure this is entirely nicer, but it does avoid having to supply a dummy initial state. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2210#issuecomment-1846240598:1005,avoid,avoid,1005,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1846240598,1,['avoid'],['avoid']
Safety,"The tests fail because if one defines `f(t, args, k)` and defines `g = partial(f, k=0.5)` then the signature of g is `<Signature (t, args, *, k=5)>`. There will likely be other cases like this (e.g. many decorators will change the signature). I vote that we give up on all the complicated detection of the old syntax and simply ask users to change `f(t, args)` to `f(t, **args)` when they upgrade to QuTiP 5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1609#issuecomment-892540881:289,detect,detection,289,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-892540881,1,['detect'],['detection']
Safety,The timeouts are because of a GitHub actions outage. It appears to have been resolved earlier today -- https://www.githubstatus.com/incidents/29xnrws671f0.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1023376091:4,timeout,timeouts,4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023376091,1,['timeout'],['timeouts']
Safety,"There is a chance that this is the same bug as #1495, which has a fix posited in #1498 - it matches all the versioning criteria, though on that issue we hadn't detected a problem with this particular test at these dimensions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-820355903:160,detect,detected,160,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-820355903,1,['detect'],['detected']
Safety,"There is one pitfall I know but I'm not sure if that is the reason here:. Is your Hamiltonian mostly 0 in the time duration? QuTiP solves dynamically change the step size, if there are a lot of zeros, it may skip the non-zero part accidentally (see https://github.com/qutip/qutip/issues/1265). You will detect it by adding a small constant `H` (magntitude~10^-6) on top of your Hamiltonian (if this H does not affect your true dynamic significantly). If that's not your case, we may need more information to actually identify the problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-808904001:303,detect,detect,303,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-808904001,1,['detect'],['detect']
Safety,"There's maybe some tricks here to do with multiprocessing and pickle/unpickle, but since the objects are deterministic and completely immutable, I can't see anything inherently wrong with a singleton approach here. These objects are purely data; they must not have _behaviour_ attached to them (methods) only immutable state (properties), so they're inherently thread-safe.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764066603:368,safe,safe,368,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764066603,1,['safe'],['safe']
Safety,"This is expected. I don't see any reason to compute the state at a time if you don't want the state or and expectation value... If you only want the last state use tlist=[0, t_last]. Also `tlist` does not have to be a linear space, if you want to save only the few last values you can do: `tlist=[0,990,1000]`, etc. If you need to use an array coefficient and this is your restriction on `tlist`, use `qutip.Cubic_spline` (or build the `QobjEvo` before the solver, but I don't remember if it is safe in v4).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1437#issuecomment-775216732:495,safe,safe,495,https://qutip.org,https://github.com/qutip/qutip/issues/1437#issuecomment-775216732,1,['safe'],['safe']
Safety,"This is just a test. ; Since many failed Travis builds had a malloc error, also according to [this StackOverflow thread](https://stackoverflow.com/questions/19840671/malloc-error-incorrect-checksum-for-freed-object-object-was-probably-mod/19841133) it seemed that XCode was the source of the problem. . I added as osx environment in the travis configuration file xcode 10.2 (should be on osx 10.14 Mojave, not sure though). Build still fails, now at ; ```; Qobj subtraction ... python(2491,0x1192585c0) malloc: Incorrect checksum for freed object 0x7ffe6ff1ad50: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(2491,0x1192585c0) malloc: *** set a breakpoint in malloc_error_break to debug; /Users/travis/.travis/functions: line 104: 2491 Abort trap: 6 nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; The command ""nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip"" exited with 134.; ```; which seems a pretty basic test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/985#issuecomment-485054530:770,Abort,Abort,770,https://qutip.org,https://github.com/qutip/qutip/pull/985#issuecomment-485054530,1,['Abort'],['Abort']
Safety,"This is the same as https://github.com/qutip/qutip/issues/1247. QuTiP uses sparse matrices, so a matrix element smaller than a certain threshold (by default 1e-7) will be discarded. This can be changed in the settings. Consider changing your unit to avoid very small values, for instance, by writing the formula with h=1` and in nanosecond time unit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1466#issuecomment-804264437:250,avoid,avoid,250,https://qutip.org,https://github.com/qutip/qutip/issues/1466#issuecomment-804264437,1,['avoid'],['avoid']
Safety,This is very interesting! I was looking for some time already a way to incorporate assembler here. Now it is possible to use FMA (fused multiply add) which should greatly improve speed of almost anything or there is a very neat implementation of complex number product with FMA which is exact (avoids loss of precision) with almost no performance penalty.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-253969071:294,avoid,avoids,294,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-253969071,1,['avoid'],['avoids']
Safety,"This latest commit 77c21f8 fixes several bugs in the testing of `qutip.qip.operations.gates` - see the commit message for more details. (Force-pushed a new version of it to increase the commit hash references by one character, so GitHub would pick them up and link them.). We should also add tests that the explicit forms of the gates are correct (comparing to hard-coded arrays) in their base forms. These tests should never really fail, but they should be there as a fail-safe sanity check against somebody changing things in that module in the future.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-593333553:474,safe,safe,474,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-593333553,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"This run will still timeout, as it was started before the fix.; Hopefully it will work on a rerun.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1023399263:20,timeout,timeout,20,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023399263,1,['timeout'],['timeout']
Safety,"This shouldn't segfault (we should detect it and turn it into a Python error, so that's definitely a bug), but do note that you'd need a supercomputer to actually use a system of that size - storing a single operator or state of this system would require 8GB of RAM even if it were the 0 operator.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1406#issuecomment-747009088:35,detect,detect,35,https://qutip.org,https://github.com/qutip/qutip/issues/1406#issuecomment-747009088,1,['detect'],['detect']
Safety,"To elaborate a little on the syntax: There's two prefixes (which can also be combined), `.` and `~`. (There's also `!`, but I don't know when you'd ever use that one.). The `~` cuts down the name in the *output* to the last component. That is, if you write a reference using the fully qualified name `` :class:`~qiskit.QuantumCircuit` `` it will show up in the rendered HTML as ""QuantumCircuit"" (without the tilde, it would be the full ""qiskit.QuantumCricuit"". The`.` is for cutting down the name in the *input*, e.g. you could write `` :func:`.mesolve` `` instead of `` :func:`qutip.mesolve.mesolve` `` anywhere, and Sphinx will search its internal index for any fully qualified name that ends in `.mesolve` and use that. This is great for keeping docstrings readable, but I'd avoid using it to refer to *external* functions (from intersphinx). See the Sphinx documentation on [Cross-referencing syntax](https://www.sphinx-doc.org/en/1.8/usage/restructuredtext/domains.html#cross-referencing-syntax) and the explanations at the end of [Cross-referencing Python objects](https://www.sphinx-doc.org/en/1.8/usage/restructuredtext/domains.html#cross-referencing-python-objects) for details.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1528#issuecomment-619413454:778,avoid,avoid,778,https://qutip.org,https://github.com/qutip/qutip/issues/1528#issuecomment-619413454,1,['avoid'],['avoid']
Safety,"To me this is a question of what guarantees our primary type makes, so it's quite a big decision to be taken. I'm not sure I agree that implementing `__array_wrap__` is a good idea - `Qobj` does not support ufunc semantics, and implementing that implies that we're a similar class to `ndarray`, which I don't think we are. I don't think `np.sin(qobj)` should return `ndarray` _or_ `Qobj`; I think it should be a TypeError. To me, we should be rather conservative about adding features like that when there's little tangible benefit - when there's a slightly more explicit alternative syntax, it's better to fail-safe than add potential ""gotchas"". The fact that elementwise operations are not part of the algebra of `Qobj` should be enough of a reason to cause you to have to explicitly ask for it, otherwise it tacitly _becomes_ part of the algebra. For your point three, if that's the case, I'd argue you're doing something wrong: are you constructing the `Qobj` before you've finalised your data? Shouldn't it be; ```python; incomplete_data = np.array([[theta, 0, 0], ...]); return Qobj(np.sin(incomplete_data)); ```; not; ```python; return np.sin(Qobj(incomplete_data)); ```. As a compromise, we could ensure that all our data-layer types (`CSR`, `Dense`, whatever else) will support ufuncs with ndarray syntax; then you could do `Qobj(np.sin(qobj.data))` to be explicitly elementwise if you really wanted, rather than absolutely requiring you to produce a full dense matrix. I'm still not sure I see the use case there, though. I'm in favour of removing `np.array([qobj1, qobj2, ...], dtype=object)` usage inside QuTiP no matter which way we come down on this, though. As far as I recall from seeing it, there no reason to use `ndarray` over a regular Python list in any of our internal use, and it's rarely (if ever) actually returned out of a QuTiP function. Given it might cause subtle differences between different numpy versions, probably best to avoid it. If GSoC applications are imminent, ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-774058408:612,safe,safe,612,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-774058408,1,['safe'],['safe']
Safety,"Uninstalling cython or using a virtualenv without it will make the risky code make an import error and not crash. cython is needed for installation, but mostly optional at runtime. It can be used to speedup some computations but usually the compilation time is not worth it. Or, you can run tests per section:; ```; import nose; import glob; for testfile in glob.glob("".../qutip/qutip/tests/*.py):; test = testfile[N:-3].repace(""\"",""."") # remove the whole path and the .py: ( ""qutip.tests.test_qobj"" ); nose.run(defaultTest=test, argv=['nosetests', '-v']); ```; test_mccolve, test_stochastic_se and test_stochastic_me will fail/crash, but I expect most of the rest to pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1084#issuecomment-531884694:67,risk,risky,67,https://qutip.org,https://github.com/qutip/qutip/issues/1084#issuecomment-531884694,1,['risk'],['risky']
Safety,"Using singleton will certainly speed thing up. ; 1. With `subspace` to represent `enr` or other special case, it should be able to represent everything. But super operators have multiple representation (`choi`, `kraus`, `super`, etc.). So I would suggest adding a `super` subclass with that information instead of using `map`.; 2. Basis safety, if required, will make Qutip usage heavier. ; 4. Let's keep it as an inside representation only: having `Space(2)` for a ket but `Map(Space, Field)` for bra will only cause confusion and super-operator of tensor system will get very long.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764826119:337,safe,safety,337,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764826119,1,['safe'],['safety']
Safety,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:865,safe,safe,865,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497,2,"['detect', 'safe']","['detect', 'safe']"
Safety,"We could take this PR as an example of how to work with a very messy git history. I see some forced pushes which should probably have been rebases to avoid conflicts. But at this point I would suggest to Boxi that you open a fresh PR branching from the current master on your local qutip repo. So do:. ```; git checkout master; git pull upstream master; git push origin master; ```. This syncs your master to QuTiP. Then, start a new branch and make the same changes that you did here on that new branch. . Make the changes, add commit etc.; ```; git checkout -b user_gate2; ...; git add .; git commit -m ""message""; ```. and then make a new PR and close this (without merging). Then delete this branch (locally and remote). ```; git branch -D user_gate; git push origin -delete user_gate; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1025#issuecomment-505060556:150,avoid,avoid,150,https://qutip.org,https://github.com/qutip/qutip/pull/1025#issuecomment-505060556,1,['avoid'],['avoid']
Safety,We should avoid any file output related to Result objects. This could be costly in loops that produce a lot of results.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/752#issuecomment-330591946:10,avoid,avoid,10,https://qutip.org,https://github.com/qutip/qutip/pull/752#issuecomment-330591946,1,['avoid'],['avoid']
Safety,"Well, your opinion is definitely important, especially regarding core :) Performance is a top requirement there. Technically I think there is no need for square root at all because we can just compare the squared value to the squared tolerance. But I get your point that constant factor may dominate the performance of a small system. It's best to avoid Cython in ""good first issues"", so this one won't be on my list anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-794400401:348,avoid,avoid,348,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-794400401,1,['avoid'],['avoid']
Safety,What I did in stochastic.py is a totally redundant mess. This is the reason I didn't do the pull request. I feel that an elegant way to add the Milstein with multiple Wiener increments (as well as any other more advanced methods) is to switch to a RHS function which is provided with all A_ops and which returns rho_{n+1}. Since it involves changing of API I want to discuss it with you first.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22015755:41,redund,redundant,41,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22015755,1,['redund'],['redundant']
Safety,"When I ran against @dick-t's example, it still violated the bound F ≤ 1, but by significantly less than before, as can be confirmed by the [success of `test_fidelity_bounded_purepure`](https://github.com/qutip/qutip/pull/362/files#diff-3e3c19be6d013d22c4823607e07cd240R106), introduced by #362. That PR doesn't fully adapt to the pure vs pure case that @dick-t lists, but it does avoid `sqrtm` in that case. I can fully specialize to that case, if you like, by using the inner product of the two pure states.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134930346:380,avoid,avoid,380,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134930346,1,['avoid'],['avoid']
Safety,"With the latest changes, `Qobj.type` now points at the new `dims_utils.type_from_dims`, which consolidates the type-detection logic in one place and makes it more robust to ragged `dims`. On Python 2 all tests of `qobj`, `tensor` and `dims_utils` now pass locally, I'll try with Python 3 soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/389#issuecomment-152941888:116,detect,detection,116,https://qutip.org,https://github.com/qutip/qutip/pull/389#issuecomment-152941888,1,['detect'],['detection']
Safety,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:695,avoid,avoid,695,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970,1,['avoid'],['avoid']
Safety,"Yeah, definitely there's no point running tests that aren't really testing the package properly. I would hope that if we're much more aggressive about converting time-dependent lists into QobjEvo objects inside `mesolve`, `mcsolve` and `sesolve` (or the class-based versions of them), we could significantly reduce the amount of testing that needs to be done with them. Most of the tests of time-dependent formats would then occur in the QobjEvo tests. We could still test all the configurations of the solvers without too heavy a time penalty. If we only use a small number of different time-dependent operators, we can compile them all only once, and have `pytest` manage the resources through shared fixtures. That would really cut down the run times, especially for the current ""slow"" tests. Another avenue for cutting down run time is if we could merge say the MKL and OpenMP tests into one Travis job - the setup time for one job is about 2.5 minutes, and that's before any tests have run at all. I would hazard a guess that having MKL but not OpenMP is a pretty rare case (maybe more common on high-performance clusters where people submit single-cpu jobs?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182:1011,hazard,hazard,1011,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182,1,['hazard'],['hazard']
Safety,"Yeah, on the practical side I was using those states to construct collapse operators, and then using these in steadystate() for a large range of parameters. Bit surprised to see what took 20 minutes in 4.7 took >5 hours in in v5 :0 I guess this is a combo of Liouvillian construction taking much longer as it then converts the Hamiltonian to Dense as well, and steady-state solving taking a bit longer too. Of course I can manually make those operators sparse (and then v5 just takes 7 mins!), but more generally, I think the logic of default_dtype is nice; essentially allows you to run QuTiP in that 'mode'. Also useful for cases like making jax objects, etc. ; I have another case where I actually want all operators to be dense, as I use .expm() a lot. . I think most functions in operators.py and states.py follow this logic, e.g., `basis()` in states.py: `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. I think it seems to make sense to apply it universally, irrespective of whether a particular object is naturally of one type or another, to avoid the cost of conversion when doing lots of repetitive things, avoid accidentally getting or making a particular type when you expect something different from default_dtype, etc. edit: Just to add, your suggestion of having two different default_dtypes could be nice too. I can imagine situations were you want to define both separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496:1067,avoid,avoid,1067,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1951469496,2,['avoid'],['avoid']
Safety,"Yeah, that's good. There are plenty of cases (like in the tests) where we want to change something like `ntraj` on-the-fly within the same script. Even just in regular REPL work, I mess around with tolerances and things like that, and it's much much easier to be able to do that case-by-case, rather than having to set global state, which often ends up with boilerplate when you're trying to be safe - you can't do quick checks as one-liners, and you have to use `try/finally` if you only want to temporarily set it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1297#issuecomment-651144540:395,safe,safe,395,https://qutip.org,https://github.com/qutip/qutip/pull/1297#issuecomment-651144540,1,['safe'],['safe']
Safety,"Yeah, using `np.int`, `np.long` or `np.longlong` when it _matters_ what size they are is a recipe for disaster. C99 guarantees that `stdint.h` will be available, so you can always safely use `np.int8`, `np.int16`, `np.int32` and `np.int64` if you know the size you need. If you just need ""at least"" whatever, then in C `int` is >= 16-bit, `long` is >= 32-bit and `long long ` is >= 64-bit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1313#issuecomment-655142649:180,safe,safely,180,https://qutip.org,https://github.com/qutip/qutip/pull/1313#issuecomment-655142649,1,['safe'],['safely']
Safety,"Yeah. Just do a 'git pull upstream master' on this branch. The Travis; config file was updated and it's not the same as this branch. You don't; have to do a painful rebase. The tests need to run online. On Mon, Jun 18, 2018, 9:03 PM Louis Tessler <notifications@github.com>; wrote:. > @sahmed95 <https://github.com/sahmed95> shouldn't the merge automatically; > take care of that without bothering to rebase?; >; > I'd like to avoid wasting time on a rebase if there's no tangible benefit; >; > —; > You are receiving this because you were mentioned.; >; >; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/883#issuecomment-398031660>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AGpUBArCWgSxWGFO-QoURjxQPLZ63Eeiks5t95crgaJpZM4UrUyK>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398048087:427,avoid,avoid,427,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398048087,1,['avoid'],['avoid']
Safety,"Yes, I agree, it would be much better to avoid separate sources. It is just the spmv.c that does the parallel spmv work is it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/647#issuecomment-279789981:41,avoid,avoid,41,https://qutip.org,https://github.com/qutip/qutip/issues/647#issuecomment-279789981,1,['avoid'],['avoid']
Safety,"Yes, I also get a few abort trap 6 crashes. I wonder why on Travis CI they seem to always run fine lately. By the way, we have migrated to `pytest`. Hopefully this will help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-576516559:22,abort,abort,22,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-576516559,1,['abort'],['abort']
Safety,"Yes, the QT stuff is bit troublesome.. and it is not a core functionality in qutip. The about() and demos() does not do much harm, so deprecate them in next release we can drop them alltogether in the following release. The progressbar is a bigger problem, because (if I got this right) it is partly due to the event-loop tricks we need to do to get the qt progressbar to work we have problems with catching keyboardinterrupt properly in for example mcsolve, and this makes it difficult to abort a calculation cleanly. This is big problem in IPython notebooks, where one cannot hit Ctrl-C and Ctrl-Z until process is stopped.. Factoring the qt progressbar out of mcsolve should therefore be a priority, and the simplest way to do this would obviously be to drop the qt progressbar function completely... I'll add a note about this in the roadmap wiki and closing this issue now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/19#issuecomment-18917941:490,abort,abort,490,https://qutip.org,https://github.com/qutip/qutip/issues/19#issuecomment-18917941,1,['abort'],['abort']
Safety,"Yes, the operator is acting like it should. When working with ; oscillators, you need to truncate at some point, and so issues similar ; to the one you raise are part of the territory. However, if one wants ; to be self-consistent, then you start with truncated operators, and then ; build all other operators / states and whatnot from there. -P. > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 18:08; >; > OK, if it's intended then there's nothing to change in the code. But I ; > think it would be helpful to document this in a clearer way: there's a ; > big risk of misinterpreting the operator.; >; > —; > You are receiving this because you modified the open/close state.; > Reply to this email directly, view it on GitHub ; > <https://github.com/qutip/qutip/issues/661#issuecomment-286282270>, or ; > mute the thread ; > <https://github.com/notifications/unsubscribe-auth/ABMPqSiIdpvqRZIZO2kklDrotB4b-6b0ks5rldpigaJpZM4MbmLX>.; >; > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 11:48; >; > When I tried to use the |qutip.squeeze| function for my simulations I ; > noticed that something was off. Upon further investigation I found out ; > that the output is not a truncated version of the single-mode ; > squeezing unitary, but rather the matrix exponential of the truncated ; > generator. These are /very/ different things!; >; > Am I right in assuming that the most useful matrix would be the ; > truncated unitary? If that's the case, the current method to compute ; > it is wrong. To compute the right matrix one can use the disentangling ; > formula for SU(1,1) (formula (31) here ; > <http://aip.scitation.org/doi/pdf/10.1063/1.3413923>):; >; > def squeeze(n,z):; > s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); > s1 = -2*np.log(np.cosh(abs(z))); > s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); >; > L = s0*0.5*(qt.create(n)*qt.create(n)); > K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); > R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); >; > return (L.expm())*(K.e",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286284923:577,risk,risk,577,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286284923,1,['risk'],['risk']
Safety,"Yes, this can happen.. But I dont think this is a bug or error, although it can be confusing. There is always a risk of namespace collisions when importing different packages into the global namespace. For example, many conflicts of this kind occur between the math and numpy packages.. The only way to get around it safely is to import packages in different namespaces.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/25#issuecomment-18951570:112,risk,risk,112,https://qutip.org,https://github.com/qutip/qutip/issues/25#issuecomment-18951570,2,"['risk', 'safe']","['risk', 'safely']"
Safety,"Yes, you should avoid printing such a large object. I imagine the memoryerror occurs when it is generating the full() representation for printing. ```; q = qutip.tensor(qutip.destroy(20), qutip.destroy(20), qutip.destroy(20)); ```. would avoid the object being printed in the notebook.; I have no experience of working with such a large object though, so I can't say that you would be able to anything useful with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/432#issuecomment-184466115:16,avoid,avoid,16,https://qutip.org,https://github.com/qutip/qutip/issues/432#issuecomment-184466115,2,['avoid'],['avoid']
Safety,"You can run. ```; cython spmatfuncs.pyx; ```. to generate the C file. Yes I agree, there isn't a huge point in using spmv over. We get some speed improvement because we type checks and stuff like that, and can avoid the overhead of an extra function call. It is mostly useful when the RHS function itself is implemented in cython, but also in that case it doesn't make a huge difference.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/52#issuecomment-25343399:210,avoid,avoid,210,https://qutip.org,https://github.com/qutip/qutip/pull/52#issuecomment-25343399,1,['avoid'],['avoid']
Safety,"You may find it easier to create tensor-producted identity operators by using the shorthand `qeye([2, 2, 2])`, which will automatically sort out the tensor product for you. You may also want to look at `qutip.qip.operations.expand_operator`, which will handle applying your operator to qubits. You _can_ bypass the dimension checking by retrieving the underlying matrix at `C.data` or `C.full()` (these may change in QuTiP 5, but for now you're fine), doing your calculations, then reconstructing the `Qobj` at the end. If all you're really using from QuTiP is the tensor product structure though, then you may achieve what you want with `numpy.kron` and avoid all of the overhead. The only part of your example that I'd consider is convoluted is the duplication in the `rand_unitary_haar` and `rand_ket` requiring you to specify both `N` and `dims` - we probably could merge those, like how we do with `qeye`, `basis` and others.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1253#issuecomment-624739240:655,avoid,avoid,655,https://qutip.org,https://github.com/qutip/qutip/issues/1253#issuecomment-624739240,1,['avoid'],['avoid']
Safety,Your welcome and thanks for looking into this. I understand that there are functionality considerations to be made. Perhaps a simple assertion check would strike the right balance -- giving the functionality you want while avoiding the danger of faulty assumptions.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/18#issuecomment-17175299:223,avoid,avoiding,223,https://qutip.org,https://github.com/qutip/qutip/issues/18#issuecomment-17175299,1,['avoid'],['avoiding']
Safety,[![Coverage Status](https://coveralls.io/builds/44887329/badge)](https://coveralls.io/builds/44887329). Coverage remained the same at 65.525% when pulling **d3a5c6e3ebb43afa0c2eb7b2456c886cb9651bd1 on Ericgig:safe.integrator** into **298316b4f034f467788943015b3277bf88f3fc9b on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1734#issuecomment-989070040:209,safe,safe,209,https://qutip.org,https://github.com/qutip/qutip/pull/1734#issuecomment-989070040,1,['safe'],['safe']
Safety,[![Coverage Status](https://coveralls.io/builds/46207692/badge)](https://coveralls.io/builds/46207692). Coverage decreased (-0.04%) to 68.373% when pulling **70743870eae1ee47e1f3229d846b99a51c0a708e on Ericgig:pytest.timeout** into **97f668227f35ab0a97dcb1ca5fbc14c060e7ac6a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1028481056:217,timeout,timeout,217,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1028481056,1,['timeout'],['timeout']
Safety,`2 * Options.rtol` could be good enough for most the tests.; ; But expecting `Options.rtol` to be a good estimation of the numerical error in all case is risky. There is no promise by the solver that the result is within rtol of the analytical solution and it ignore error propagation in the post-treatment steps.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-625407196:154,risk,risky,154,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-625407196,1,['risk'],['risky']
Safety,"`Qobj` has some fast-path constructors that are basically the solvers saying ""this data is valid, just trust me"", causing it to skip sanity checks. There are a few slow points that can be skipped: copying unnecessary data, parsing/verifying the `dims` data, and determining the properties (`isherm`, `iscp`, etc). All of those add on very non-negligible construction time, but at most points in QuTiP we _know_ the values when passing them. Old-style code uses these magic ""fast-path"" constructors, but the new 5.0 branch gets rid of all of them - you can achieve much more, and more explicitly, by using the kwargs, and function-specific logic stays at the call location, rather than being bolted into `Qobj`. We still want to maintain passing `isherm` to `Qobj` when we know it for speed reasons, especially when we know the most common use of the `Qobj` created by `mesolve` is for finding expectation values. However, you can set the value based on the hermicity of the input density matrix; if you're passed a true density matrix, you'll always get a Hermitian matrix out, whereas you'll generally be in an unknown state if you're not. The test can be; ```python; def mesolve(H, rho0, tlist, ...):; hermicity = rho0.isherm or None; ...; for t in tlist:; output.states.append(Qobj(fdata, dims=dims, isherm=hermicity)); ```; which forces `isherm=True` if that's _known_, but leaves it unset if not. This is approximately how we handle things in 5.0, which is in part why we have huge reductions in `Qobj` construction time in the new version.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796689049:133,sanity check,sanity checks,133,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796689049,1,['sanity check'],['sanity checks']
Safety,"`scipy` 1.5 has changed some of its private attributes for matrix multiplication (to a _much_ better name!), and so matrix-matrix multiplication is completely broken for us at the moment: see scipy/scipy@53fac7a. There's also been some changes to how Hermitian eigenvalues and vectors are calculated (which actually is good news for us in general), which may has a bit of a knock-on for some of the `zheevr` tests, which is going to be a bit of a nuisance to fix. To avoid polluting this PR with (any more) off-topic discussion, I've opened #1299. The new data layer types will fix the matrix multiplication issue permanently, because we'll not be duplicating/reusing large tracts of `scipy` private code - we have our own Cython versions that operate faster on more optimised types. In the meantime, #1298 is a patch to catch the renames.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-649446743:467,avoid,avoid,467,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-649446743,1,['avoid'],['avoid']
Safety,"a that coding in qutip should be as similar to writing in dirac notation as possible (within reason). As an example, here is how you can do a partial trace:. ```; In [14]: rho = rand_dm(4,dims=[[2,2],[2,2]]). In [15]: out = Qobj(). In [16]: for i in range(2):; out += tensor(qeye(2),basis(2,i).dag())*rho*tensor(qeye(2),basis(2,i)); ....:. In [17]: out; Out[17]:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.39666875+0.j 0.13801792+0.01223399j]; [ 0.13801792-0.01223399j 0.60333125+0.j ]]. In [18]: rho.ptrace(0); Out[18]:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.39666875+0.j 0.13801792+0.01223399j]; [ 0.13801792-0.01223399j 0.60333125+0.j ]]; ```. Of course you can do far more general things than that.. you can pretty much do anything you can write in dirac notation. Similar behavior on the level of super-operators and operator-vectors, as suggested by @jrjohansson, earlier in this thread, would be similarly very powerful. For example, in the language of tensor networks, it would allow you to do arbitrary wire-bending operations using the maximally entangled state, as in the [paper](http://arxiv.org/abs/1111.6950) by Chris Wood et al., that @cgranade mentioned in relation to #238. As of now there is no convenient (i.e., ""index free"") way to do this (correct me if I am wrong), except explicitly performing the corresponding partial transpose directly on the underlying matrix data. 2) In the absence of this functionality it is a bad idea to assume something else. Assuming conjugation is unexpected behavior, and besides it is something the user can easily do him/herself by using `to_super()`. It is way better to ""force"" the user to be explicit about things by throwing an `Exception`, than assuming something that might be unexpected. It enforces good coding style, giving more readable code, and avoids code that will break if the functionality is changed in the future.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58035991:2484,avoid,avoids,2484,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58035991,1,['avoid'],['avoids']
Safety,"ack); 100 except StopIteration as exc:; 101 # Suppress StopIteration *unless* it's the same exception that. ~/miniconda3/lib/python3.6/site-packages/matplotlib/animation.py in saving(self, fig, outfile, dpi, *args, **kwargs); 239 yield self; 240 finally:; --> 241 self.finish(); 242 ; 243 . ~/miniconda3/lib/python3.6/site-packages/matplotlib/animation.py in finish(self); 365 def finish(self):; 366 '''Finish any processing for writing the movie.'''; --> 367 self.cleanup(); 368 ; 369 def grab_frame(self, **savefig_kwargs):. ~/miniconda3/lib/python3.6/site-packages/matplotlib/animation.py in cleanup(self); 403 def cleanup(self):; 404 '''Clean-up and collect the process used to write the movie file.'''; --> 405 out, err = self._proc.communicate(); 406 self._frame_sink().close(); 407 _log.debug('MovieWriter -- Command stdout:\n%s', out). ~/miniconda3/lib/python3.6/subprocess.py in communicate(self, input, timeout); 841 ; 842 try:; --> 843 stdout, stderr = self._communicate(input, endtime, timeout); 844 finally:; 845 self._communication_started = True. ~/miniconda3/lib/python3.6/subprocess.py in _communicate(self, input, endtime, orig_timeout); 1503 selector.register(self.stdin, selectors.EVENT_WRITE); 1504 if self.stdout:; -> 1505 selector.register(self.stdout, selectors.EVENT_READ); 1506 if self.stderr:; 1507 selector.register(self.stderr, selectors.EVENT_READ). ~/miniconda3/lib/python3.6/selectors.py in register(self, fileobj, events, data); 349 ; 350 def register(self, fileobj, events, data=None):; --> 351 key = super().register(fileobj, events, data); 352 poll_events = 0; 353 if events & EVENT_READ:. ~/miniconda3/lib/python3.6/selectors.py in register(self, fileobj, events, data); 235 raise ValueError(""Invalid events: {!r}"".format(events)); 236 ; --> 237 key = SelectorKey(fileobj, self._fileobj_lookup(fileobj), events, data); 238 ; 239 if key.fd in self._fd_to_key:. ~/miniconda3/lib/python3.6/selectors.py in _fileobj_lookup(self, fileobj); 222 """"""; 223 try:; --> 224 r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/799#issuecomment-497315077:2143,timeout,timeout,2143,https://qutip.org,https://github.com/qutip/qutip/issues/799#issuecomment-497315077,1,['timeout'],['timeout']
Safety,"arately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:3061,safe,safe,3061,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,1,['safe'],['safe']
Safety,"base class]( https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.html#scipy.sparse.spmatrix)? Then the `Qobj` constructor would probably need an additional parameter `format` for the class that should be used to convert the `inpt` argument to the `data` attribute. The onus would then be on Scipy to provide a full matrix that is a subtype of `scipy.spmatrix` (just to keep the interface contract), and also to have `int64` versions of all their existing sparse classes. From a community standpoint, it would seem like one would get much more bang for the buck to have this problem solved inside SciPy, instead of doing a lot of low-level stuff in QuTiP -- at least if they're amenable to pull requests, but worst case you can still define necessary new `scipy.spmatrix` subclasses externally. Take all of my musings with a little grain of salt... I never really looked too deep into QuTiP's low-level internals, specifically where QuTiP is using Cython. Naively, I would sort of think that Cython would remain at the level of sparse linear algebra operations (and thus mostly in scipy) and that QuTiP could be mainly pure Python. Obviously, once you start implementing higher level things like time propagation or even optimal control in Cython, everything becomes a bit of a mess, because then you really do have to manually implement everything for every possible storage format (again, something I'm familiar with from Fortran, and it's *a lot* of work). Generally, though, I've personally come to the conclusion that the lowest-level thing to really optimize for quantum dynamics simulations (in any language) is the application of a (time-dependent) operator to a Hilbert space state, respectively the commutator with a density matrix (in QuTiP, the operators would be the nested ``[H0, (u(t), H1), ...]`` lists). Everything higher level is probably fine at Python speed, as long as the algorithms are sound and you avoid allocating temporary storage as much as possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-383937610:2969,avoid,avoid,2969,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-383937610,1,['avoid'],['avoid']
Safety,"braries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:6299,detect,detect,6299,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['detect'],['detect']
Safety,"ck); 97 value = type(); 98 try:; ---> 99 self.gen.throw(type, value, traceback); 100 except StopIteration as exc:; 101 # Suppress StopIteration *unless* it's the same exception that. ~/miniconda3/lib/python3.6/site-packages/matplotlib/animation.py in saving(self, fig, outfile, dpi, *args, **kwargs); 239 yield self; 240 finally:; --> 241 self.finish(); 242 ; 243 . ~/miniconda3/lib/python3.6/site-packages/matplotlib/animation.py in finish(self); 365 def finish(self):; 366 '''Finish any processing for writing the movie.'''; --> 367 self.cleanup(); 368 ; 369 def grab_frame(self, **savefig_kwargs):. ~/miniconda3/lib/python3.6/site-packages/matplotlib/animation.py in cleanup(self); 403 def cleanup(self):; 404 '''Clean-up and collect the process used to write the movie file.'''; --> 405 out, err = self._proc.communicate(); 406 self._frame_sink().close(); 407 _log.debug('MovieWriter -- Command stdout:\n%s', out). ~/miniconda3/lib/python3.6/subprocess.py in communicate(self, input, timeout); 841 ; 842 try:; --> 843 stdout, stderr = self._communicate(input, endtime, timeout); 844 finally:; 845 self._communication_started = True. ~/miniconda3/lib/python3.6/subprocess.py in _communicate(self, input, endtime, orig_timeout); 1503 selector.register(self.stdin, selectors.EVENT_WRITE); 1504 if self.stdout:; -> 1505 selector.register(self.stdout, selectors.EVENT_READ); 1506 if self.stderr:; 1507 selector.register(self.stderr, selectors.EVENT_READ). ~/miniconda3/lib/python3.6/selectors.py in register(self, fileobj, events, data); 349 ; 350 def register(self, fileobj, events, data=None):; --> 351 key = super().register(fileobj, events, data); 352 poll_events = 0; 353 if events & EVENT_READ:. ~/miniconda3/lib/python3.6/selectors.py in register(self, fileobj, events, data); 235 raise ValueError(""Invalid events: {!r}"".format(events)); 236 ; --> 237 key = SelectorKey(fileobj, self._fileobj_lookup(fileobj), events, data); 238 ; 239 if key.fd in self._fd_to_key:. ~/miniconda3/lib/python3.6/se",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/799#issuecomment-497315077:2058,timeout,timeout,2058,https://qutip.org,https://github.com/qutip/qutip/issues/799#issuecomment-497315077,1,['timeout'],['timeout']
Safety,"d_col)),; shape=(nds**2, nds**2),; dtype=np.complex128); ```; and recompile. If you want to make a PR of something similar against QuTiP, I'll accept it. I would actually file this against `scipy.sparse` - I think our usage is completely in line with the contract of `scipy.sparse.csr_matrix` and they've got a bug in their dtype handling. You currently can't construct a CSR matrix using the COO triplet format for complex data, unless the dtype is made explicit _somewhere_, but the constructor is meant to correctly infer a suitable dtype if one is not passed. Basic Scipy reproducer to illustrate the problem:; ```python; >>> import scipy.sparse; >>> scipy.__version__; '1.6.1'; >>> scipy.sparse.csr_matrix(([1+1j], ([0], [0])), shape=(2, 2)); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/scipy/sparse/compressed.py"", line 54, in __init__; other = self.__class__(coo_matrix(arg1, shape=shape,; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/scipy/sparse/coo.py"", line 161, in __init__; self.data = np.array(obj, copy=copy, dtype=data_dtype); TypeError: can't convert complex to float; ```. This can be fixed either by passing `dtype=np.complex128` to the constructor, or passing the data inside a NumPy array, since that'll also fix the dtype. I imagine with their implicit conversions, SciPy may also need to test the special cases where all list elements are things like `1+0j`, which have type `complex` but can be safely represented by reals - the Python call `float(1 + 0j)` is forbidden even though the imaginary part is 0. I actually originally thought this was the problem in this issue, since all the Lindbladian data tested is real numbers with complex type. I suppose it's up to SciPy to decide how they want to handle that case - either always maintaining `complex` or putting in a special-case cast (`np.real(x)`) for known-safe complex -> float conversions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1451#issuecomment-784265398:1878,safe,safely,1878,https://qutip.org,https://github.com/qutip/qutip/issues/1451#issuecomment-784265398,2,['safe'],"['safe', 'safely']"
Safety,"e1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub, or mute the thread.; > ; > Untracked with Trackbuster",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1684,detect,detectors,1684,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,14,['detect'],"['detector', 'detectors']"
Safety,"ecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:2704,safe,safe,2704,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,1,['safe'],['safe']
Safety,"ers of files, doing different work before and after will all cause the segfault to change, and may mask it.; - As annoying as they are, segfaults are actually the _good_ case of the bug - the worst is when we have invalid memory writes but _no_ segfault, because then we have memory corruption that's gone undetected. ## Thoughts about #1120. This issue is still present using Andrew's `Malloc.py` file as of the current master branch (commit 624405e7), and is in QuTiP 4.6.0 and most previous versions. I have been able to reproduce the segfaults with Python 3.7, but not Python 3.8, and I can reproduce it with all allowable values of `PYTHONMALLOC`. The most telling is `pymalloc_debug`, where the entire operation completes (it prints ""500""), and _then_ the fault occurs. This along with the error message should hopefully make it clear that an out-of-bounds write occurs occasionally, and it is temperamental where exactly this happens. This is typically not detected until the object is freed, when the Python allocators do a little bit of checksumming. I think that in _all_ cases we're seeing the failure come from the garbage collection, but I can't be 100% certain - note that this almost certainly means the failure is somewhere completely different, and it's only _detected_ at garbage collection. Here is the output of a Python 3.8 crash on the `Malloc.py` file with some additional debugging enabled. This is with Python 3.8.8, Numpy 1.19.2, Scipy 1.6.2 and MKL:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler Malloc.py; 500; Debug memory block at address p=0x7fa2e02de610: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7fa2e02ed64f are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:2243,detect,detected,2243,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['detect'],['detected']
Safety,"fine for states and operators, but it won't work for superoperators. I'm not sure that this is solvable in an ergonomic way with QuTiP's current dimensions specifiers, but it's something we're definitely going to look into after the initial release of 5.0. Also, there are already several disparate functions in QuTiP that provide sort-of similar functionality, and I think we need to have a proper go at tidying them all up into one cohesive interface. This includes `subsystem_apply` (most similar to this), but also `ptrace` and `partial_tranpose`, which can be seen as special cases of this exact same type of tensor contraction (not to mention `tensor_contract`!). The other thing from a code perspective is that this doesn't use the data-layer in the intended manner. A lot of this may be because our documentation of the data-layer isn't readily available yet (we weren't expecting interest this early!). It does individual detection on two different types, rather than creating a `Dispatcher` to handle the multiple dispatch over potentially different data types of the two inputs. I would imagine that a better form of organisation for this sort of routine, which will be able to handle arbitrary tensor-network operations, will end up being made up of two components:; 1. a `Dispatcher` version of something akin to `einsum`, with a couple of limitations; 2. a high-level wrapper function to handle the specific case of local multiplication, which examines the dimensions and target specifiers to produce the input to the `einsum`-like function, then calls the `Dispatcher` with this information. I think this form would likely be preferable for several reasons:; 1. it will allow arbitrary mixing of different data types (`CSR` complete space and `Dense` operator, or both `CSR`, or whatever), with the allowed conversions respecting the global dispatcher rules, not having this function use a different, special configuration; 2. it will mean that the function can also be implemented by ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:2383,detect,detection,2383,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,1,['detect'],['detection']
Safety,"g`. Here is a file `kraus.py` that can reproduce these segfaults semi-reliably (may need to run it a few times to get it to trigger):. ```python; import qutip. s = qutip.rand_super(); c = qutip.to_choi(s); k = qutip.to_kraus(c); ```. For example, here's a similar command on this file:. ```; Debug memory block at address p=0x7f98cc467db0: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7f98cc476def are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p: dd dd dd dd dd dd dd dd ... 00 00 00 00 00 00 00 00. Enable tracemalloc to get the memory block allocation traceback. Fatal Python error: bad trailing pad byte; Python runtime state: finalizing (tstate=0x7f98c9d018e0). Current thread 0x0000000109fe85c0 (most recent call first):; <no Python frame>; Abort trap: 6; ```. So these both use `scipy.linalg.eig`, which is suspicious. ## Valgrind checks. To see if I could track it down, I had a go with valgrind. This isn't guaranteed to find everything, because I'm not using a debug build of Python, and Python also typically optimises small allocations by using a custom allocator into some pre-allocated space it manages itself - invalid writes that still fall within this may not get detected by valgrind. Here is the output of `valgrind` running on the `kraus.py` file I wrote in the previous section: [kraus_valgrind.txt](https://github.com/qutip/qutip/files/6370180/kraus_valgrind.txt) (note I filtered out like 30,000 errors that stem from Python's internal memory management - they're nothing to worry about, they're just what happens when you have your own allocator). The important part is. ```; ==54133== Invalid write of size 8; ==54133== at 0x10AFAFA8A: ??? (in /Users/jake/.anaconda3/envs/py38/lib/libmkl_int",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:4863,Abort,Abort,4863,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['Abort'],['Abort']
Safety,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3871,avoid,avoiding,3871,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,1,['avoid'],['avoiding']
Safety,"https://github.com/qutip/qutip/blob/2ca20fb829dc67d0ee32498422bad1f8ff852a95/qutip/core/data/permute.pyx#L229-L230. `if n:` ignore it completely and assign the wrong variable... This is the main problem. https://github.com/qutip/qutip/blob/2ca20fb829dc67d0ee32498422bad1f8ff852a95/qutip/core/data/permute.pyx#L265. And here's the offending unchecked multiplication. That test is actually off from what I intended, which was hiding the buggy function call below it. The unchecked 32-bit overflow punched through the test and revealed the problematic function. In worse matrices, this would have actually been a huge segfault - the identity was only safe because it has the same number of elements in each row. ---. That's exciting that someone else is trying it out! I'm glad there are speed-ups. If you've got issues let me know and I can maybe help out with some of the internals (my email's in my github profile). I'm fine to wait to check out a PR if you guys are working on something between you. I still need to find the time to finish off the dispatching system and pull the OpenMP parts back into `dev.major`...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1382#issuecomment-728373500:648,safe,safe,648,https://qutip.org,https://github.com/qutip/qutip/issues/1382#issuecomment-728373500,1,['safe'],['safe']
Safety,"ken. I'm not sure I agree that implementing `__array_wrap__` is a good idea - `Qobj` does not support ufunc semantics, and implementing that implies that we're a similar class to `ndarray`, which I don't think we are. I don't think `np.sin(qobj)` should return `ndarray` _or_ `Qobj`; I think it should be a TypeError. To me, we should be rather conservative about adding features like that when there's little tangible benefit - when there's a slightly more explicit alternative syntax, it's better to fail-safe than add potential ""gotchas"". The fact that elementwise operations are not part of the algebra of `Qobj` should be enough of a reason to cause you to have to explicitly ask for it, otherwise it tacitly _becomes_ part of the algebra. For your point three, if that's the case, I'd argue you're doing something wrong: are you constructing the `Qobj` before you've finalised your data? Shouldn't it be; ```python; incomplete_data = np.array([[theta, 0, 0], ...]); return Qobj(np.sin(incomplete_data)); ```; not; ```python; return np.sin(Qobj(incomplete_data)); ```. As a compromise, we could ensure that all our data-layer types (`CSR`, `Dense`, whatever else) will support ufuncs with ndarray syntax; then you could do `Qobj(np.sin(qobj.data))` to be explicitly elementwise if you really wanted, rather than absolutely requiring you to produce a full dense matrix. I'm still not sure I see the use case there, though. I'm in favour of removing `np.array([qobj1, qobj2, ...], dtype=object)` usage inside QuTiP no matter which way we come down on this, though. As far as I recall from seeing it, there no reason to use `ndarray` over a regular Python list in any of our internal use, and it's rarely (if ever) actually returned out of a QuTiP function. Given it might cause subtle differences between different numpy versions, probably best to avoid it. If GSoC applications are imminent, we could open an issue and tag it with ""good first issue"" to give prospective applicants a potential PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-774058408:1956,avoid,avoid,1956,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-774058408,1,['avoid'],['avoid']
Safety,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7965,detect,detect,7965,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507,1,['detect'],['detect']
Safety,"lement heterodyne, but I don't really agree that the current method is overcomplicated. It is in fact basically the same as the method you suggest, so I don't see that either would be more complicated or simpler than the other. The only issue is whether the two stochastic increments are divided up in several stochastic collapse operators or if the d2 function internally takes care of the both stochastic increments for a given stochastic collapse operator. The complexity is just shifted from the d2 function to somewhere else, which in general doesn't simplify anything. However, since the milstein solver you submitted is written so that it only support one increment per collapse operators, then there might be a real advantage of splitting the heterodyne process into two homodyne processes. . I've tried to make the qutip stochastic solver API as general as I could (and it is still a work in process), so that it will be as flexible as possible for implementing custom types of SMEs. Having support for multiple stochastic increments per collapse operators seems to be useful in certain applications. Although such SMEs could probably always be rewritten as multiple collapse operators with single stochastic increments, it might not always be the most natural way to define the SME. The heterodyne detection is one example of this, and it can be formulated in both ways, but I want the qutip SME API to work with both methods (at least with the basic euler solver, not necessarily with every solver we implement). However, that doesn't mean that the implementation of heterodyne for a particular solver has to use one way or the other. We should just document which solvers support multiple increments per operators and which solvers don't. So if it is easier to get the milstein solver working for heterodyne by simulating two homodyne detections, then let's go ahead use that method for that solver. The required preprocessing can be done in the smesolve function, or something like that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22543416:1538,detect,detection,1538,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22543416,2,['detect'],"['detection', 'detections']"
Safety,"liouvillian_fast doesn't set the isherm flag at all, so it becomes the default value True. Unless H=0, the liouvillian should usually be nonhermitian, so False would be a better default value.. Will fix this. Don't think I want to do a full check of the underlaying data in this funciton, because the point of liouvillian_fast is to avoid some unnecessary overhead (although it is still a bit experimental).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/17#issuecomment-16149887:333,avoid,avoid,333,https://qutip.org,https://github.com/qutip/qutip/issues/17#issuecomment-16149887,1,['avoid'],['avoid']
Safety,"minate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` tha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5740,safe,safely,5740,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['safe'],['safely']
Safety,"mization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself bein",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5262,safe,safe,5262,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['safe'],['safe']
Safety,"n2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qut",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:1631,detect,detected,1631,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543,1,['detect'],['detected']
Safety,"nstructors when passed sequences of objects that all implement `__array__`. It is still possible to make a Numpy array of `Qobj` even with `Qobj.__array__` defined in Numpy 1.20, but you have to be rather more indirect about it:. ```python; >>> arr = np.empty((3,), dtype=object); >>> arr[:] = [qutip.qeye(2), qutip.qeye(2), qutip.qeye(2)]; >>> arr.shape; (3,); >>> arr[0]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. The reason numpy does this now is because (my understanding is that) defining `__array__` was meant to be a much stronger guarantee than just ""it's convenient to let `np.array` know about this object"". It was meant to be an indication that your class can be safely coerced into `ndarray` (and potentially coerced back afterwards), and that mathematical operations will satisfy the normal ufunc broadcasting rules, which isn't true of `Qobj`. That means that arrays of things implementing `__array__` should be safely representable as `ndarray`, which clearly isn't true for us. Similarly, ever since `Qobj.__array__` was first defined you could use Numpy ufuncs on `Qobj`, which would get implicitly converted to `ndarray` and then return complete nonsense, rather than throwing an error like ""what you're doing is silly"":; ```python; >>> np.sin(qutip.basis(2, 1)); array([[0. ],; [0.84147098]]); ```; (imo that should really be a `TypeError` if done without an explicit conversion into Numpy semantics). There is a way around that latter point in modern Numpy - defining `Qobj.__array_ufunc__ = Qobj.__array_function__ = None` - but it does raise the question of whether we _should_ define `Qobj.__array__`; we have no intention of implying that `Qobj` satisfies the general Numpy ufunc interface, and it isn't any sort of `ndarray`-like type, because it satisfies matrix semantics, not array semantics. That's the reason `scipy.sparse` types don't implement `__array__`. There always was a sanctioned method",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-773992094:2381,safe,safely,2381,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-773992094,1,['safe'],['safely']
Safety,"obj(data, dims=dims, copy=False, type='oper', isherm=...); ```; providing `data` is actually of a valid (`fast_csr_matrix`) format. Technically the `Qobj.data` attribute will be a new object that wraps the same numpy arrays as was passed, rather than the same `fast_csr_matrix`. In various forms, `expect` already does check the Hermicity, that's why `mc-dm` is careful to set it to avoid recalculating it. The expect functions in `qutip.expect` do this directly, and aren't aware of column-stacked density matrices - they'll just raise a TypeError. `mesolve` and `mcsolve` now bypass the `Qobj` stage and go direct to Cython - in 5.0 it might not be a terrible idea to route everything back through the `Qobj` form, since the performance issues there are solved (a column-stacked dense matrix can be directly wrapped by an f-ordered `Dense` type), and it's the natural central point of the code (and those parts are called from Python-space anyway, so no C concerns). Here though, the problem is actually that the expectation generator in `mesolve` correctly calculates the dtype of the output expectation array using both the state and the expectation operator, but then it does it incorrectly in the loop, and passes the hermicity down to Cython using only the expectation operator, which promptly throws out the complex part. So setting `fast='mc-dm'` in `Qobj` is a symptom of the same root cause as the problem here, rather than the cause itself. At the start of `mesolve` we don't assume that the state is Hermitian, but then inside the integration loop we do. We can still keep the speedup - if the output was created with a complex dtype, we can always safely say that we're passing in non-Hermitian operators, even if coincidentally at one timestep they happen to be anyway. See https://github.com/qutip/qutip/blob/d285e96b3afc61afd1deceef61d9635f9d9aa505/qutip/mcsolve.py#L525-L529 and https://github.com/qutip/qutip/blob/d285e96b3afc61afd1deceef61d9635f9d9aa505/qutip/mesolve.py#L509-L511",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048:2094,safe,safely,2094,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048,1,['safe'],['safely']
Safety,"or each stochastic collapse operator, but now it is also possible to do something more sophisticated, like in your milstein solver. I've edited your notebook so that it uses the standard (now modified) smesolve and your rhs functions for the milstein methods. http://nbviewer.ipython.org/6153688. Note that I still only use the rhs function for the contributions due to the stochastic collapse operators (both the deterministic and stochastic part), and it does not include the unitary part or the deterministic collapse operators (if those are given as well), so it is not quite what you suggested when proposing that the rhs should calculate \rho_{n+1}. Do you think this approach is reasonable, or do you see any problems with it?. Regarding your milstein implementation, it seems that it is only valid for homodyne detection, since your have hardcoded the d1 and d2 function into the rhs function. I've tried to separate the definition of the SDE (d1 and d2) from the implementation of the SDE integrator (rhs), and naively it seems like you could use the d1 and d2 functions in rhs_milstein to make it possible to use it with hetrodyne detection as well. Is there any difficulties in generalizing the milstein method and parameterize it in terms of d1 and d2 functions in this way?. I've also tried to use the smesolve_imp and smesolve_milstein with explicit=False in your original notebook, but I do not get resuls that agree with the other methods if I use these. Looking at the code for smesolve_imp, you do an inversion of some variant of the liouvillian to calculate Lsparse, what is the purpose of that calculation? And finally, I see you use expm in _smesolve_single_milstein_implicit: I think this should be avoided because it will be very computationally demanding for larger systems. If you are satisfied with how the new rhs functions work I'll merge the branch sme-rhs-restructuring into qutip master and then feel free to submit a pull request with your milstein rhs implementation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22088170:1913,detect,detection,1913,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22088170,2,"['avoid', 'detect']","['avoided', 'detection']"
Safety,"re exactly it's coming from, but it is at least clearly inside that library. I ran `valgrind` on the `Malloc.py` file above, and get the exact same invalid write, which is promising. So the most likely public Python call is `scipy.linalg.eig`. ## Minimal reproducer. Ok, so now let me cut it down to a minimum `eig.py`:. ```python; import numpy as np; import scipy.linalg. x = np.random.rand(25, 25) + 1j*np.random.rand(25, 25); scipy.linalg.eig(x); ```. Note that this file does not even use `qutip`. You can run `PYTHONMALLOC=pymalloc_debug python -Xfaulthandler,tracemalloc eig.py`, and it will occasionally trigger a segfault (it happens to me about 1 in 5 times). It's not always the same message as above, e.g.:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler,tracemalloc eig.py; python(54517,0x10a5505c0) malloc: Incorrect checksum for freed object 0x7fe6cb4150e0: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(54517,0x10a5505c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ```. However if I run it within valgrind:; ```; jake@tauros$ valgrind --suppressions=valgrind-python.supp python -Xfaulthandler eig.py; ==54530== Memcheck, a memory error detector; ==54530== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.; ==54530== Using Valgrind-3.17.0.GIT-lbmacos and LibVEX; rerun with -h for copyright info; ==54530== Command: python -Xfaulthandler eig.py; ==54530==; ==54530== Invalid write of size 8; ==54530== at 0x10ABF7A8A: ??? (in /Users/jake/.anaconda3/envs/py38/lib/libmkl_intel_thread.dylib); ==54530== by 0xFFFFFFFF: ???; ==54530== by 0x103124AFF: ???; ==54530== by 0x10312376F: ???; ==54530== by 0x10550F0BF: ???; ==54530== by 0x3FEFFFFFFFFFFFFF: ???; ```; the exact same. ## Further steps. I'm now reasonably convinced that this isn't directly an issue with QuTiP. I suspect it isn't an issue with `scipy` either, but I'm not sure - it looks like a slight overwrite in MKL on macOS, ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:7153,Abort,Abort,7153,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['Abort'],['Abort']
Safety,"re those written in the notebook. Various stochastic integration method are provided, the default is the taylor expansion of order 1.5. Thank you very much for your reply, but I still don't quite understand `smesolve`'s `expect` are just the expectation value of the state of each trajectories”. In my understanding, solving for 'smesolve' gives the corresponding 'ρ(t)' and then 'expect'. But 'smesolve' provides **[ntraj [int] number of trajectors]**, which means that there are _ntraj_ 'ρ(t)' (`expect`). If I want to show all _ntraj_ ‘s 'expect', how can I do it?. Can I understand `result.measurement` as measuring(POVM) the `smesolve.result` (where ρ(t) was given by solving the stochastic master equation) .$\hat{\rho}_{f}=\frac{\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}}{\mathrm{Tr}[\hat{\Omega}_{m}\hat{\rho}\hat{\Omega}_{m}^{\dagger}]}$。If this is the case, I don't understand the point of doing the measurement again here, because the stochastic master equation itself has a continuous measurement. What I want to do is simply solve the stochastic master equation to get enough trajectories **ρ(t)** and solve the relevant expected value **Tr[ρ(t)A]**. On the one hand, I want to see the expectations of all N quantum trajectories ρ(t)'s expect (**Tr[ρ(t)A] maybe with different dW**), and on the other hand I want to compare the expected average of N quantum trajectories with the result of the master equation(`mesolve.expect`). This is similar to this code in Note (but the result in [Note](https://nbviewer.org/urls/qutip.org/qutip-tutorials/tutorials-v4/time-evolution/016_smesolve-inefficient-detection.ipynb) is `result.measurement`). `fig, ax = plt.subplots(figsize=(8, 4)). for m in result.measurement:; ax.plot(times, m[:, 0].real, ""b"", alpha=0.025). ax.plot(times, result_ref.expect[1], ""k"", lw=2). ax.set_ylim(-25, 25); ax.set_xlim(0, times.max()); ax.set_xlabel(""time"", fontsize=12); ax.plot(times, np.array(result.measurement).mean(axis=0)[:, 0].real, ""b"", lw=2);`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206:2395,detect,detection,2395,https://qutip.org,https://github.com/qutip/qutip/issues/2194#issuecomment-1635364206,1,['detect'],['detection']
Safety,"restructuring) where I have experimented with rhs functions that internally loop through the A_ops list. In simple cases it only loops through the list and calculates a contribution for each stochastic collapse operator, but now it is also possible to do something more sophisticated, like in your milstein solver. I've edited your notebook so that it uses the standard (now modified) smesolve and your rhs functions for the milstein methods. http://nbviewer.ipython.org/6153688. Note that I still only use the rhs function for the contributions due to the stochastic collapse operators (both the deterministic and stochastic part), and it does not include the unitary part or the deterministic collapse operators (if those are given as well), so it is not quite what you suggested when proposing that the rhs should calculate \rho_{n+1}. Do you think this approach is reasonable, or do you see any problems with it?. Regarding your milstein implementation, it seems that it is only valid for homodyne detection, since your have hardcoded the d1 and d2 function into the rhs function. I've tried to separate the definition of the SDE (d1 and d2) from the implementation of the SDE integrator (rhs), and naively it seems like you could use the d1 and d2 functions in rhs_milstein to make it possible to use it with hetrodyne detection as well. Is there any difficulties in generalizing the milstein method and parameterize it in terms of d1 and d2 functions in this way?. I've also tried to use the smesolve_imp and smesolve_milstein with explicit=False in your original notebook, but I do not get resuls that agree with the other methods if I use these. Looking at the code for smesolve_imp, you do an inversion of some variant of the liouvillian to calculate Lsparse, what is the purpose of that calculation? And finally, I see you use expm in _smesolve_single_milstein_implicit: I think this should be avoided because it will be very computationally demanding for larger systems. If you are satisfie",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22088170:1591,detect,detection,1591,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22088170,1,['detect'],['detection']
Safety,"s defines what an scalar is at the _specialisation_ level. However:; - It may cause inconsistent behaviour where some operations are allowed for a data layer (`TfTensor` or any other) but not for another one. I would argue that all specialisations should accept the same input, although operations may be handled differently internally (for example, in tensorflow we want to keep the graph state).; - `NotImplemented` only makes sense for some special binary methods (`__add__`, `__lt__`, etc) as Python employs `NotImplemented` to try `other`'s binary method. My concern is that if the dispatcher is used by itself at some points of the code (such as for the solver) returning `NotImplemented` may cause wrong error messages or even unexpected behaviour with future specialisations ( for instance, although it now raises a deprecation warning, `NotImplemented` is considered as `True` when evaluated as a condition). It seems to me that we should avoid having `NotImplemented` in python space (except for arithmetic operations in a class where they are useful and always make sense).; ; 2) Simon suggested to define what a scalar is at the _dispatcher_ level (or something similar to this but correct me if I am wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that define",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:1640,avoid,avoid,1640,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,1,['avoid'],['avoid']
Safety,"s ea1c129 to b4f75cf as ""new"" (the first three commits of this PR). However, when those commits are taken together, they make the same changes as commit 4102b99 (the one which merged #1242) in `qutip/master`. The Github ""Files changed"" dialog is a pretty-printed version of the `git` command `git diff qutip/master...Canoming/master`, which means ""show all changes on either branch since `qutip/master` and `Canoming/master` diverged"". Because they diverged before #1242 was merged, it includes those changes. The merge completes without conflict, however, because `git` is clever and recognises that the changes introduced in the two branches `qutip/master` and `Canoming/master` are identical, even though the commits are different. As a consequence, however, merging this PR without squashing it would cause commits ea1c129 to b4f75cf to suddenly appear in our commit history, which we don't want. ### If Canoming wanted to fix this (not necessary). First run; ```; git remote add qutip https://github.com/qutip/qutip.git; git fetch qutip; ```; to add the upstream `qutip` remote. Then run; ```; git checkout master; git rebase -i $(git merge-base qutip/master master); ```; and modify the file so that the instruction list looks like (only the first word of each line changes); ```; pick ea1c129a fix function QubitCircuit.remove_gate; fixup 3bd94603 fix function QubitCircui.remove_gate; fixup b4f75cfe fix; pick 4aa90f56 fix bug in QubitCircuit.add_circuit; pick 3a2676de fix function QubitCircuit.add_circuit; pick 58aebc7f fix indent; ```; Should you save and close the file, it would modify your commit history. We'd only do this to avoid a merge conflict which would otherwise occur in the next step. Then, run; ```; git rebase qutip/master; ```; which should complete without error. Finally, your local `master` would now have diverged from Github's copy (and this PR's), so you'd have to force-push the changes by doing; ```; git push --force; ```; which would update this PR accordingly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269:2697,avoid,avoid,2697,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269,1,['avoid'],['avoid']
Safety,"series and pseudo-inverse methods ... ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > expect: operator list and state list ... ok; > > > expect: operator and density matrix ... ok; > > > expect: operator and ket ... ok; > > > expect: operator list and state ... ok; > > > expect: operator list and state list ... ok; > > > expect: operator and state list ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > gates: expand 1 to N ... ok; > > > gates: expand 2 to N (using cnot, iswap, sqrtswap) ... ok; > > > gates: expand 2 to N (using swap) ... ok; > > > gates: expand 3 to N (using toffoli, fredkin, and random 3 qubit gate) ... ok; > > > gates: swap gate ... ok; > > > Graph: Breadth-First Search ... ok; > > > Graph: Graph Degree ... SKIP: Networkx not installed.; > > > Graph: Reverse Cuthill-McKee Ordering (simple) ... ok; > > > Graph: Reverse Cuthill-McKee Ordering (Bucky) ... ok; > > > Graph: Reverse Cuthill-McKee Ordering (boost) ... ok; > > > Monte-carlo: Constant H with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H (str format) with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H (func format) with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H (str",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:2943,detect,detection,2943,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['detect'],['detection']
Safety,"site may help for future reference. On Wed, 13 May 2020 at 23:38, Eric Giguère <notifications@github.com> wrote:. > I did some tests and; > 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian; > matrices) (c's version Ok); > 2 - It happen when installing the scipy stack with pip but not when; > installing it with conda.; > 3 - It depend on the problem size, 64 seems particularly bad, usually it; > fails on the second call.; > 4 - I only got it in zheevr which is only used in brmesolve. But Nathan; > got it in other tests which use scipy's eigh.; > 4 - It happen in scipy in the fortan version of lapack:; >; > import numpy as np; > from scipy.linalg import eigh; > H = random_hermitian(64); > eigh(H) # Work fine; > eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; >; > Possible solutions (for zheevr):; >; > - Installing scipy with conda, the easiest solution, but not in our; > control.; > - Finding a way to link clapack from cython. Linking scipy's one would; > require good knowledge of scipy internals since only one cython interface; > is provided. Linking to another installation of lapack, but it would; > require the user to install lapack or install it with qutip. Both seems; > wrong to me.; > - For mac user, call scipy's eigh from cython i zheevr, slower but; > better than risking segfault.; > - Have the code directly in qutip. We can adapt it from OpenBlas:; > https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1197#issuecomment-628259492>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67AJF3WTZBCU4YWFY23RRMHMHANCNFSM4LCKXE6A>; > .; >; -- ; Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264:1599,risk,risking,1599,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264,1,['risk'],['risking']
Safety,"t into this internal representation and internally operate on this, because it's much faster. Essentially what I'm describing here is an abstract syntax tree for relevant linear algebra structures. We _could_ even have the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. You'd still type `dims=[[2], [1]]` to get a qubit ket and `dims=[[1], [2]]` for a qubit bra, so I don't think there's any confusion there. The reason there's not a special ""bra"" structure internally is because it's not necessary; a bra really is just a linear mapping from a particular vector space to the field, so having a special case for that makes more complex - the matmul compatibility test with `Map(Space, Field)` and `Map(Space, Space)` is the exact",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:2021,safe,safe,2021,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,1,['safe'],['safe']
Safety,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:12872,safe,safe,12872,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['safe'],['safe']
Safety,"the quick response @bencbartlett. . Feel free to ignore the comments regarding the shortening of arguments. That was just a suggestion to make things shorter. But as you said clarity is more important. I will not change `waveguide` to `wg` and I think you should leave the others as they are if you can't think of shorter ones. Same applies to the `temporal_basis_vector`. I think you can even add a `temporal_basis` as you mentioned. Regarding the double line breaks wrapping top-level functions, I know the pep8 standard is two newlines but some other QuTiP modules follow just a single line break, e.g., [floquet](https://github.com/qutip/qutip/blob/master/qutip/floquet.py). But again some other modules in QuTiP follow the pep8 standard and wrap two newlines for top-level functions. I am in favor of the pep8 standard and have two newlines. @ajgpitch what do you suggest?. Please remove the helper function `count_filled` without the test if it is not required. We aim to test as much as possible and remove redundancy in code. About `__all__`, I will shift all the rest in a new PR and we can keep yours as it is now. Coming to the more important discussion regarding the `class` based implementation, I have started pushing for similar approaches in newer modules such as [qutip.models.piqs](https://github.com/qutip/qutip/blob/master/qutip/models/piqs.py). I am also working on a new non-Markovian method which requires a class. Something of that sort is already used in `qutip.nonmarkov.heom`. I understand that many of qutip's solvers are written to be isolated functions but that should not mean that we should not write code to fully use the object oriented framework Python provides. Moreover, I noticed that you have to rewrite wrappers for the functions anyways to deal with repeatedly calculating things such as `scattering_probability` which clearly can be made much more compact if we use a class based approach. I am not making this suggestion just for the minor performance impro",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384860713:1025,redund,redundancy,1025,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384860713,1,['redund'],['redundancy']
Safety,"the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. You'd still type `dims=[[2], [1]]` to get a qubit ket and `dims=[[1], [2]]` for a qubit bra, so I don't think there's any confusion there. The reason there's not a special ""bra"" structure internally is because it's not necessary; a bra really is just a linear mapping from a particular vector space to the field, so having a special case for that makes more complex - the matmul compatibility test with `Map(Space, Field)` and `Map(Space, Space)` is the exact same test as for two operators, which simplifies the logic. ---. After sleeping on it, I still generally like the singleton pattern for this, but I think _completely_ relying on referential equality is probably a bit ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:2265,safe,safety,2265,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,1,['safe'],['safety']
Safety,"tl;dr We should go ahead and change it according to PEP8. I vaguely remembered that. ```; string_one == string_two; ```. and. ```; string_one is string_two; ```. do something different. According to [post on stackoverflow](http://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python) ""=="" tests for value equality, while ""is"" checks for whether the variables point to the same thing. Since ""None"" is a singleton the two are the same (except for some [oddball cases](http://jaredgrubb.blogspot.sg/2009/04/python-is-none-vs-none.html)). The [post about the oddball case](http://jaredgrubb.blogspot.sg/2009/04/python-is-none-vs-none.html) also seems to suggest that ""is"" is faster. Anyway, it's a) safe to change and b) recommended, so we should do that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/10#issuecomment-10983787:724,safe,safe,724,https://qutip.org,https://github.com/qutip/qutip/issues/10#issuecomment-10983787,1,['safe'],['safe']
Safety,"to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4241,avoid,avoid,4241,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['avoid'],['avoid']
Safety,"ucer. Ok, so now let me cut it down to a minimum `eig.py`:. ```python; import numpy as np; import scipy.linalg. x = np.random.rand(25, 25) + 1j*np.random.rand(25, 25); scipy.linalg.eig(x); ```. Note that this file does not even use `qutip`. You can run `PYTHONMALLOC=pymalloc_debug python -Xfaulthandler,tracemalloc eig.py`, and it will occasionally trigger a segfault (it happens to me about 1 in 5 times). It's not always the same message as above, e.g.:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler,tracemalloc eig.py; python(54517,0x10a5505c0) malloc: Incorrect checksum for freed object 0x7fe6cb4150e0: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(54517,0x10a5505c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ```. However if I run it within valgrind:; ```; jake@tauros$ valgrind --suppressions=valgrind-python.supp python -Xfaulthandler eig.py; ==54530== Memcheck, a memory error detector; ==54530== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.; ==54530== Using Valgrind-3.17.0.GIT-lbmacos and LibVEX; rerun with -h for copyright info; ==54530== Command: python -Xfaulthandler eig.py; ==54530==; ==54530== Invalid write of size 8; ==54530== at 0x10ABF7A8A: ??? (in /Users/jake/.anaconda3/envs/py38/lib/libmkl_intel_thread.dylib); ==54530== by 0xFFFFFFFF: ???; ==54530== by 0x103124AFF: ???; ==54530== by 0x10312376F: ???; ==54530== by 0x10550F0BF: ???; ==54530== by 0x3FEFFFFFFFFFFFFF: ???; ```; the exact same. ## Further steps. I'm now reasonably convinced that this isn't directly an issue with QuTiP. I suspect it isn't an issue with `scipy` either, but I'm not sure - it looks like a slight overwrite in MKL on macOS, though it's also possible that `scipy` passes some invalid pointers when dropping down to BLAS/LAPACK. I get the impression that the next steps involve dropping down a level of abstraction, down to Cython to directly call scipy's wrappers, or even fully down t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:7339,detect,detector,7339,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['detect'],['detector']
Safety,"umerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6159,safe,safely,6159,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['safe'],['safely']
Safety,"useless redundant code. creates so much of a problem. @nonhermitian...merge it please, neill will add the rest",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-102252338:8,redund,redundant,8,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-102252338,1,['redund'],['redundant']
Safety,"y the implementation of a stochastic rhs function is relatively isolated from how the deterministic part is calculated (which right now is trivial, but which could become more complex when time-dependent systems are implemented). However, it also gives all the flexibility needed in the rhs function, and these deterministic rhs functions do not need to be used if it is not suitable in a particular stochastic rhs implementation. . I've added the changes to the rhs behavior to the https://github.com/qutip/qutip/tree/sme-rhs-restructuring and updated the gist with the variant of your notebook. http://nbviewer.ipython.org/6153688. Note that a few other things, like the rhs function signature, had to change in the process. I hope that this updated API will be flexible enough to let you implement implicit solver. Regards rhs implementation and d1,d2 function: Yes, I understand that not all possible rhs schemes might be compatible with the parameterization with d1 and d2 functions, but when it is possible it has the great advantage that the user do not need to worry about how the rhs is implemented, only define the SDE in terms of d1 and d2, and then possibly select a rhs solver using the solver argument to smesolve. This will not work in general for solvers like the milstein scheme, since it requires an analytical derivative (unless it can be evaluated numerically?), and in those cases it would be sufficient to implement problem specific rhs functions (like rhs_rho_milstein_homodyne etc). Regarding the use of expm: OK, I agree that it could be a nice method to have to be used on smallish system. However, since we are stepping with a small timestep dt, shouldn't it be sufficient to use an expansion of of expm as usual? Perhaps a second-order expansion would do if the first order isn't sufficient. Doing a full expm is fine too I guess, but if it can be avoided then the same method could be used on larger systems too. . Looking forward to seeing your new notebooks and the PR!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22156426:2749,avoid,avoided,2749,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22156426,1,['avoid'],['avoided']
Security," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4177,access,accessible,4177,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,3,['access'],"['access', 'accessible']"
Security," the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/nami",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11490,access,accessible,11490,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['access'],['accessible']
Security,", and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:5132,expose,expose,5132,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['expose'],['expose']
Security,"----------------------; >; > Best; > Boxi; >; > From: Nathan Shammah<mailto:notifications@github.com>; > Sent: Tuesday, February 25, 2020 8:36 AM; > To: qutip/qutip<mailto:qutip@noreply.github.com>; > Cc: Boxi Li<mailto:etamin1201@gmail.com>; Author<mailto:; > author@noreply.github.com>; > Subject: Re: [qutip/qutip] More detailed information for GSoC 2020 project; > (#1184); >; > Hi Boxi,; >; > Can you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wishes,; >; > Nathan; >; > Dr. Nathan Shammah; > Postdoctoral Research Scientist; > Theoretical Quantum Physics Laboratory; > RIKEN, Wako, Saitama, Japan; > www.nathanshammah.com; >; >; >; > On Sun, Feb 23, 2020 at 5:42 AM Boxi Li <notifications@github.com> wrote:; >; > > I have some detail information for the GSoC 2020 project ""Error; > mitigation; > > in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub; > > Wiki page. I post it here so if anyone finds it nice could copy it to the; > > Wiki page.; > >; > > I add some details based on the original description:; > > ------------------------------; > > 1. Error mitigation in QuTiP; > >; > > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > > quantum circuit simulator (which was a GSoC project) providing enhanced; > > features for a pulse-level description of quantum circuits and noise; > > models. A new class Processor and several subclasses are added to; > > represent different platforms for quantum computing. They can transfer a; > > quantum circuit into the corresponding control sequence and simulate the; > > dynamics with QuTiP solvers. Different noise models can be added to; > > qutip.qip.noise to simulate noise in a quantum device.; > >; > > This module is still young and many features can be improved, including; > > new device models, new noise models and integration with the existi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:4166,access,access,4166,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['access'],['access']
Security,"1. inside the ""Actions"" tab at the top of the GitHub page, you will only see workflows that are present in the code in the default git branch. `dev.major` isn't QuTiP's default branch, so the workflows won't appear immediately after this is merged, only when the `.github/workflows/build.yml` file also exists in `master`. 2. nothing prevents you from running the workflow on a fork, and there's no way and no reason to prevent this - it's also how I tested it. If you did run it on a fork, you'd be using your own GitHub Actions credits (it doesn't cost us anything because we're an open-source project). Only qutip/qutip knows the secret to publish to PyPI, so no fork can succeed on that. The branch check here serves two purposes: the first is that I needed some ""tickbox"" to let the admin decide at runtime whether they needed to publish the package or just build the wheels for personal download; the second is that we release off release branches, not master, so there needed to be an input to say _which_ branch should be built. 3. it's not 100% necessary, but it's the right thing to do. It decouples the project data from the setup code, which makes it much easier to modify both, and allows other tools to access the data. There are other PEPs in the works as well that will move all this data into `pyproject.toml`, rather than just `setup.cfg`. 4. oh, that's useful. I didn't really know or look into it, because it was only a temporary thing anyway. I might actually retire this PR and make it against `master` instead. It's functionally the same as this one, and most of the diff is the same, except that its `setup.py` is better organised, like Simon suggested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429#issuecomment-801289045:1217,access,access,1217,https://qutip.org,https://github.com/qutip/qutip/pull/1429#issuecomment-801289045,1,['access'],['access']
Security,"2018.0.3; conda install qutip=4.1.3. Now my programs calling steadystate work again but I also get 1 error related to mkl and steady when running the full test. Denis. De : zhang [mailto:notifications@github.com]; Envoyé : samedi 28 septembre 2019 09:33; À : qutip/qutip <qutip@noreply.github.com>; Cc : VION Denis <denis.vion@cea.fr>; Comment <comment@noreply.github.com>; Objet : Re: [qutip/qutip] Error with conda MKL2019.0 on Windows (#975). This was reported on the help group; https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU. (copying from there); the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well. If using mkl(2019.0), there will MKL read problems, like:. File ""C:\Users\ym24chen\Anaconda3\. x = lu.solve(b, verbose=verbose). File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve. np_x, np_error). OSError: exception: access violation reading 0x0000000000000008. envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve. Env info:. QuTiP Version: 4.3.1. Numpy Version: 1.15.4. Scipy Version: 1.1.0. Cython Version: 0.29.6. Matplotlib Version: 3.0.3. Python Version: 3.7.2. Number of CPUs: 8. BLAS Info: INTEL MKL. OPENMP Installed: False. INTEL MKL Ext: True. Platform Info: Windows (AMD64). Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip. ==============================================================================. How can I rollback it to mkl(2018.0.3)? I just use ""conda install mkl=2018"" but the test still return errors. —; You are receiving this because you commented.; Reply to this email directly, view it on GitHub<https://github.com/qutip/qutip/issues/975?email_source=notifications&email_token=ADBRKX2X6OKO5WY3XBOXMFLQL4CEJA5CNFSM4HFQJOJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD72TBSI#issuecomment-536162505>, or mute ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/975#issuecomment-536288655:1075,access,access,1075,https://qutip.org,https://github.com/qutip/qutip/issues/975#issuecomment-536288655,1,['access'],['access']
Security,"2dd4680 and b6dcc28 fix the occasional segfaults I was getting, I believe. The error in `reshape_csr` was probably the randomly appearing one - I assume that for it to cause a segfault, either the output CSR needed to have been allocated on the edge of allocated memory (and then I probably would have seen it in the stack trace with `faulthandler`), or it needed to be called on a sufficiently small matrix that `mem.PyMem_Malloc` allocated into Python stack memory such that the next byte after `out.row_index` pointed into freed Python memory, causing a checksum error on the next `PyMem_Malloc` that hit it, or `PyMem_Free` on a previously created object. I was able to track down where these were coming from by judicious use of `gcc -fsanitize`, although had we been using Cython's `typedmemoryview`, setting `boundscheck=True` would also have caught it. Likewise, the error in `permute.dimensions_csr` would have been caught by setting `cdivision=False`, but I just didn't think to try that. It's probably not worth swapping to memory views just because of this, though - I was able to find it easily enough with `AddressSanitizer`, and memory views have a very non-trivial overhead on initialisation for our use case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332#issuecomment-668847474:557,checksum,checksum,557,https://qutip.org,https://github.com/qutip/qutip/pull/1332#issuecomment-668847474,1,['checksum'],['checksum']
Security,"5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:12182,expose,expose,12182,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['expose'],['expose']
Security,": ???; ==54133== by 0x3FEFFFFFFFFFFFFF: ???; ```. Obviously I don't have the debugging symbols for MKL, so it's pretty hard to say where exactly it's coming from, but it is at least clearly inside that library. I ran `valgrind` on the `Malloc.py` file above, and get the exact same invalid write, which is promising. So the most likely public Python call is `scipy.linalg.eig`. ## Minimal reproducer. Ok, so now let me cut it down to a minimum `eig.py`:. ```python; import numpy as np; import scipy.linalg. x = np.random.rand(25, 25) + 1j*np.random.rand(25, 25); scipy.linalg.eig(x); ```. Note that this file does not even use `qutip`. You can run `PYTHONMALLOC=pymalloc_debug python -Xfaulthandler,tracemalloc eig.py`, and it will occasionally trigger a segfault (it happens to me about 1 in 5 times). It's not always the same message as above, e.g.:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler,tracemalloc eig.py; python(54517,0x10a5505c0) malloc: Incorrect checksum for freed object 0x7fe6cb4150e0: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(54517,0x10a5505c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ```. However if I run it within valgrind:; ```; jake@tauros$ valgrind --suppressions=valgrind-python.supp python -Xfaulthandler eig.py; ==54530== Memcheck, a memory error detector; ==54530== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.; ==54530== Using Valgrind-3.17.0.GIT-lbmacos and LibVEX; rerun with -h for copyright info; ==54530== Command: python -Xfaulthandler eig.py; ==54530==; ==54530== Invalid write of size 8; ==54530== at 0x10ABF7A8A: ??? (in /Users/jake/.anaconda3/envs/py38/lib/libmkl_intel_thread.dylib); ==54530== by 0xFFFFFFFF: ???; ==54530== by 0x103124AFF: ???; ==54530== by 0x10312376F: ???; ==54530== by 0x10550F0BF: ???; ==54530== by 0x3FEFFFFFFFFFFFFF: ???; ```; the exact same. ## Further steps. I'm now reasonably convinced that this isn't directly an i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:6951,checksum,checksum,6951,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['checksum'],['checksum']
Security,"; rhoss = steadystate(L); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\steadystate.py"", line 290, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\steadystate.py"", line 460, in _steadystate_direct_sparse; weighted_matching=ss_args['weighted_matching']); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 393, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 170, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000099EC80F8. ======================================================================; ERROR: MKL spsolve : Hermitian (real) solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_mkl.py"", line 230, in test_mkl_spsolve10; y = mkl_spsolve(A, b, hermitian=1); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 414, in mkl_spsolve; lu.delete(); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 208, in delete; byref(c_int(0)), np_error); OSError: exception: access violation reading 0x00000006FFFFFFEF. ======================================================================; ```; Enviroment:; ```; QuTiP Version: 4.4.0.dev0+73a27971; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 12; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\qutip-4.4.0.dev0+73a27971-py3.7-win-amd64.egg\qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/975#issuecomment-483000016:2042,access,access,2042,https://qutip.org,https://github.com/qutip/qutip/issues/975#issuecomment-483000016,1,['access'],['access']
Security,"> ; > ; > Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems.; > ; > Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook.; > ; > Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See [qutip/qutip-notebooks#100](https://github.com/qutip/qutip-notebooks/issues/100); > ; > One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in #1092, using [loky](https://loky.readthedocs.io).; > ; > In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence.; > ; > If the freeze is indeed caused by spawn-multiprocessing, the problem _should_ also show up on Windows. Is anyone running Windows able to reproduce this?. Windows doesn't have 'fork' at all, if we want to make parallel_map work under windows, we have to find ways to 'spawn' efficiently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416:466,inject,injected,466,https://qutip.org,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416,1,['inject'],['injected']
Security,"> > Instead of having three different measurement functions - `measurement_ket`, `measurement_density` and `measurement_comp_basis` why not have a single `measure` function that has the same signature as `qutip.measurement.measure`, i.e., measure(op, state) where internally you check if the state is a ket or dm and just apply the operation internally? You could also have a `basis='computational`` keyword if you need to specify the basis. But I do not see why you make that distinction?; > ; > In the GSoC meeting we discussed. There may be some efficiency benefits of specific functions for certain tasks. There could be some advantage of an overarching func too. So maybe both is the best approach.; > ; > As far as it makes sense the measurement stuff should go it the main package. Anything that is specific to circuits could go in qip. We have suggested @sarsid and @hodgestar discuss and come up with a design. I have ""proposed"" a preliminary design that basically works by adding a dispatch function that appropriately calls either of the two types of measurements. The new concern is writing good documentation for the same. I am wondering if both kinds of measurements should both have their own api-exposed function (or only one function which dispatches to both types, as is right now)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-643730550:1212,expose,exposed,1212,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-643730550,1,['expose'],['exposed']
Security,"> Does anyone know how we would give some kind of deprecation warning when `from qutip import *` is made to say that only core functions will be imported from v5 onwards?. @ajgpitch . I know I'm resurrecting a dead thread, but I have a way of detecting star imports if you can cope with a fairly gross hack. The only internal difference in `from qutip import *` (that I know about) from `import qutip` is that in the former, the import system access the `qutip.__all__` list to see which names it should import. This is intended to be a list of names, so the star import doesn't _have_ to import every single name, i.e. so you can manually set what's public to a module; the star import is designed for use within packages, and the user importing a package like that is strongly recommended against (though in scientific code, I'm 100% sure that's a losing battle). So, what if we make `__all__` _look_ like a list, but a list that injects a warning whenever anyone tries to see what items it has? An example:; ```python; import warnings as _warnings. x = 2. class _all_wrapper(list):; def __iter__(self, *args, **kwargs):; _warnings.warn(""You star-imported!""); return super().__iter__(*args, **kwargs). __all__ = _all_wrapper(['x']); ```; I put that in a package called ""test"".; ```python; >>> from test import x; >>> x; 2; ```; or; ```python; >>> from test import *; /Users/jake/code/tmp/test/__init__.py:7: UserWarning: You star-imported!; _warnings.warn(""You star-imported!""); >>> x; 2; ```. I won't complain if you want to scream after that...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925:443,access,access,443,https://qutip.org,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925,2,"['access', 'inject']","['access', 'injects']"
Security,"> It doesn't look robust enough to be user facing as it is, but as a private function, if you get a 3.5x, I'd say we want it. I'll rename it to `_from_csr_blocks` and add some more checks on the ordering and shape of the ops if those aren't too expensive and add some tests. We can expose it publicly if that's ever useful. > Technically, just give a type to `i` and it's all running in c code. Thanks! Adding the type to `i` did make it a little faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388:282,expose,expose,282,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388,1,['expose'],['expose']
Security,"> So my guess here is that pyximport keeps appending args like -O2 -fPIC etc to the call to gcc until it breaks. Not sure if it is a qutip thing or Cython. Why theory needs to be validated as a first step. I don't understand the point ""Why theory needs to validated as a first step"" in relation to your hypothesis on the issue. Otherwise, I will take a closer look at the qutip and Cython source codes to see if I can track something down.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-511643800:179,validat,validated,179,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-511643800,2,['validat'],['validated']
Security,"> Thanks @ajgpitch for the comments. I agree that there should be the specific functions but I think for simplifying user experience there should be a simple overarching function. E.g, when you plot Wigner functions in QuTiP you can send it kets or dms or operators and it just works.; > ; > Internally, it still calls specific functions to compute the Wigner function based on efficient methods specific to the inputs. But it is just a small convenience to the average user to have a simpler clean overarching function to do the same. I have now made it so that the measure and measurement_statistics function precisely do this. Should we keep either mode (one mode is of the ""observable"" type and the other with the ""projective"" type) also as a api-exposed function? If that is not the case, what would be the correct way to write doc_strings ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-643730389:751,expose,exposed,751,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-643730389,1,['expose'],['exposed']
Security,"> Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:464,access,accessed,464,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041,1,['access'],['accessed']
Security,"> This was reported on the help group; > https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU; > ; > (copying from there); > the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well.; > ; > If using mkl(2019.0), there will MKL read problems, like:; > ; > ```; > File ""C:\Users\ym24chen\Anaconda3\; > x = lu.solve(b, verbose=verbose); > File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; > np_x, np_error); > OSError: exception: access violation reading 0x0000000000000008; > envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; > ```; > ; > Env info:; > ; > ```; > QuTiP Version: 4.3.1; > Numpy Version: 1.15.4; > Scipy Version: 1.1.0; > Cython Version: 0.29.6; > Matplotlib Version: 3.0.3; > Python Version: 3.7.2; > Number of CPUs: 8; > BLAS Info: INTEL MKL; > OPENMP Installed: False; > INTEL MKL Ext: True; > Platform Info: Windows (AMD64); > Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; > ==============================================================================; > ```. How can I rollback it to mkl(2018.0.3)? I just use ""conda install mkl=2018"" but the test still return errors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/975#issuecomment-536162505:583,access,access,583,https://qutip.org,https://github.com/qutip/qutip/issues/975#issuecomment-536162505,1,['access'],['access']
Security,"@AGaliciaMartinez The `.elements` are intentionally only accessible from Cython (it's not safe to modify the list from Python because the QobjEvo element lists are meant to be immutable). If you have an idea for a cleaner implementation of this though, maybe just write the idea here and then we can all look at it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808:57,access,accessible,57,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808,1,['access'],['accessible']
Security,"@Ericgig @hodgestar, Eric and Simon: unless there's anything else that springs to mind, I'll pencil in the 4.6 release for later this week/weekend after this is merged to `master`?. Simon in particular: there's a couple of accessible places in `correlation` that make deprecated `ode2es` calls. That particular functionality of the solvers isn't being removed in 5.0 (though maybe it should - `mesolve` is faster and better in almost every way), so they aren't themselves deprecated. Right now they don't trigger `DeprecationWarning` popups if a user calls them (since the stacklevel is 2). Despite that, should I _also_ wrap them in a warning filter to catch it? I don't really know best practices here. I kept postponing doing the 4.6 release because I'd keep thinking of little bits and bobs that I thought should go in, but at this point Boxi's (@BoxiLi) new pulse scheduler stuff is in and ready, the packaging and distribution methods are updated, and we'll have issued deprecation warnings for the things that we know are being removed. Anything beyond this can start to form the basis of a 4.7 release in a few months' time, with the Floquet changes (they might be waiting on me at the moment) and possibly some new stuff out of GSoC. Possibly that'll also include some deprecation warnings and other bits and bobs to do with packages getting moved out of qutip/qutip, and the changes to how the data-layer is going to work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1480#issuecomment-814937234:223,access,accessible,223,https://qutip.org,https://github.com/qutip/qutip/pull/1480#issuecomment-814937234,1,['access'],['accessible']
Security,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:343,access,accessing,343,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187,2,['access'],"['access', 'accessing']"
Security,"@Ericgig I think it's unavoidable to have some sort of global state that tells the C compiler which type to choose, and I think passing it as a compilation option is a simple and straight forward solution. Using macros won't change the need for a compilation flag and will make fetching the correct numpy type trickier. If cython does eventually provide a nicer option, I am happy to use it, but they are still having long discussions about the right direction to take. One thing that would make things nicer would be to expose the compilation options used in, for example, `qutip.utilities` so that compilation becomes `compile_time_env=qutip.utilities.compile_time_env()`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1727#issuecomment-1104929052:521,expose,expose,521,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104929052,1,['expose'],['expose']
Security,"@Ericgig Ready for review again. I haven't implemented anything for detecting whether an .e_op returns a number that can be averaged, and I'd like to leave that for a later PR because it's really about a better implementation of the MultiTrajResult and MultiTrajResultAveraged classes and that feels quite separate (even if it tweaks the Result class a bit more). In the `HEOMResult` class in #1869 I override `_store_state`, `_store_final_state`, `_pre_copy` and `_e_op_func` which gives quite a lot of flexibility and might be sufficient to implement `MultiTrajResult` as a sub-class of `Result`. There is also a question of whether there should be a way to supply processors directly -- either in e_ops or a separate lists. Processors are almost identical to e_ops except their values are not stored in `.expect` or `.e_data` and they don't appear in `.e_ops`. I'd like to leave that for a later (maybe never) PR too -- currently I don't have an immediate use case for it, and I don't want to expose the extra feature directly until we do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664:996,expose,expose,996,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664,1,['expose'],['expose']
Security,"@Ericgig When I read the description of this PR I thought you might have implemented something that might be even faster. Instead of having the numpy proxy have dynamic access via `__getattr__` we could do either of the following:. * When the numpy backend is set, actually copy the attributes across to the proxy objects so that they are looked up in `__dict__` in the ordinary way without having to fall back to `__getattr__`.; * Do the same as the above but define the attributes as slots so that the `__dict__` lookup is avoided.; * Or implement `__getattribute__` so that the original `__dict__` lookup is never checked.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618:169,access,access,169,https://qutip.org,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618,1,['access'],['access']
Security,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:644,access,accessing,644,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408,1,['access'],['accessing']
Security,@jakelishman I would vote for not wrapping them right now. We should stop using `ode2es` from the correlation functions (or continue to use it but no longer expose it to users). The DeprecationWarnings will hopefully help remind us to do that.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1480#issuecomment-815311257:157,expose,expose,157,https://qutip.org,https://github.com/qutip/qutip/pull/1480#issuecomment-815311257,1,['expose'],['expose']
Security,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:965,expose,exposed,965,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,1,['expose'],['exposed']
Security,"@jrjohansson Thanks for comments, and I am happy you like it!. I will fix things (also, there is some internal stuff). With respect to plots - still I learnt them how to _make_ plots instead of just _using_ them, so after I make fixes I would appreciate . `complex_array_to_rgb` I am exposing it on purpose, not by an accident (see `__init__.py`).; The rationale is following: in QM one works with complex numbers, be it in wave functions, density matrices or other operators. However, I am not aware of cmap-like functions for complex numbers in Scipy (except for some dedicated packages; see also: [my answer to this StackOverflow question](http://stackoverflow.com/questions/15207255/is-there-any-way-to-use-bivariate-colormaps-in-matplotlib/17113417#17113417)). If you do know a more standard/supported/general/canonical method of mapping complex numbers to colors, I would be happy to use it (instead of `complex_array_to_rgb`). Otherwise, having `complex_array_to_rgb` exposed allows plotting other kinds of things.; For example:. ```; imshow(complex_array_to_rgb(a_density_matrix.full()), interpolation='none'); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/105#issuecomment-41377018:975,expose,exposed,975,https://qutip.org,https://github.com/qutip/qutip/pull/105#issuecomment-41377018,1,['expose'],['exposed']
Security,"@nonhermitian please have a look at this when you have time. it is a quite major restructuring of module imports and globally exposed symbols. With this PR qutip no longer put np, numpy, scipy, plt, cython modules, and numerous symbols from those packages in qutips namespace. So doing. ```; import qutip; dir(qutip); help(qutip); ```. should now only give qutip related information.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/233#issuecomment-55978208:126,expose,exposed,126,https://qutip.org,https://github.com/qutip/qutip/pull/233#issuecomment-55978208,1,['expose'],['exposed']
Security,"@nwlambert Would you mind giving this a try with some bigger realistic HEOM examples you have lying around? Eric's recent improvements to CSR `mul` and `imul` also help HEOM RHS construction since there is a lot of `c * op` happening. The 3.5x improvement from this branch is on top of that. @Ericgig Would you mind giving your thoughts on the Cython interface both from a ""is this good from a technical point of view"" and from a ""do we want this point of view"". I guess we could also name it `_from_csr_blocks` if we don't want to expose it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2128#issuecomment-1476648533:532,expose,expose,532,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1476648533,1,['expose'],['expose']
Security,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:1024,expose,expose,1024,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354,4,['expose'],"['expose', 'exposed']"
Security,"Are you running on OSX? If so, this could be a known bug between multiprocessing and matplotlib for matplotlib 3.2. You can downgrade to 3.1 or upgrade to 3.3 (haven't personally validated 3.3 yet).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1326#issuecomment-664716642:179,validat,validated,179,https://qutip.org,https://github.com/qutip/qutip/issues/1326#issuecomment-664716642,1,['validat'],['validated']
Security,"As a note: `qutip.vector_to_operator` is part of the implementation of superoperators. The ""vector"" in the name refers to the idea that a superoperator in a Hilbert space can be represented as a vector on a different Hilbert space which comprises of two copies of the original space tensor-producted together. It doesn't refer to a ""vector"" in the sense of a ""ket"". The difference was introduced in c62a8e9, which is the amalgamated commit encompassing all the discussion in #1098. `qutip.vector_to_operator` expects to receive an argument whose `dims` parameter is of the form `[operator_dims , [1]]`, where `operator_dims` is the dimensions of a regular operator (for example `[[2], [2]]` for a single qubit Hilbert space, or `[[2, 2], [2, 2]]` for an operator acting on a Hilbert space with two qubits in. The exception occurs because `vector_to_operator` attempts to access the two elements of the `operator_dims` array to discover the output shape. Since there is an insufficient number of lists for it to access, it just ends up reading the dimensions of the first two elements of the tensor product, and `np.prod` (used to calculate the output shape) doesn't complain when passed scalars. Notice that running the code with `nb_qubits = 1` will cause an `IndexError`, as there are insufficient tensor-product elements. The immediate solution for your code is to use `qutip.ket2dm`, which converts a ket into a density matrix. I think this is what you're actually trying to do. For a fix, there are two points:; 1. The fix is simply to test that the input dimensions are of the correct form, rather than assuming; this will allow us to provide a more descriptive error.; 2. Perhaps worth considering is moving the super-operator functionality in a sub-module `qutip.super`, and not importing all the functions into the main namespace. This might help reduce user confusion going forwards, especially since most people aren't using the superoperator formalism.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1204#issuecomment-600792011:871,access,access,871,https://qutip.org,https://github.com/qutip/qutip/issues/1204#issuecomment-600792011,2,['access'],['access']
Security,"Assuming you have Anaconda 2.5 installed (so that you can use the Intel MKL on all platforms), the default number of threads is one. Therefore, you don't get much benefit. To change the number of threads used you can do:. ``` python; import mkl; mkl.set_num_threads(N); ```. or in QuTiP it is easy to set using:. ``` python; n_threads = hardware_info()['cpus']; mkl.set_num_threads(n_threads); ```. One can not access the spare MKL routines directly as there is no support in the scipy.sparse library. However, you can get to all of the functions using ctypes. An example of complex SpMV is here:. https://gist.github.com/nonhermitian/74c3ddbbd006b2f8d306. The only issue with the attached method, is that finding the MKL runtime library is platform dependent (maybe should file an issue with the Anaconda people?). Therefore, it is a bit cumbersome to work with. Moreover, it is not possible to access these routines via Cython as they do not have any of the development stuff available. That may not really be an issue at the end of the day though as one needs quite a large system to get any benefit, and at large Hilbert dimensions, the overhead from calling Python funcs. directly is not an issue. I will be chatting with the [Intel Python](https://software.intel.com/en-us/python-distribution) people tomorrow to give them some suggestions and talk about our project. Hopefully we can hash out some plan to make our life a bit easier, and take advantage of the MKL tools. Their parallel direct sparse solver may also be of interest.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/438#issuecomment-186864518:411,access,access,411,https://qutip.org,https://github.com/qutip/qutip/issues/438#issuecomment-186864518,3,"['access', 'hash']","['access', 'hash']"
Security,"Bumping an old topic with two major new considerations. Number one: Travis is [changing its pricing model for open source software](https://blog.travis-ci.com/2020-11-02-travis-ci-new-billing), and generally it seems like [it's going to become unfeasible for us](https://www.jeffgeerling.com/blog/2020/travis-cis-new-pricing-plan-threw-wrench-my-open-source-works). Over the past month or so, queue times on Linux builds have increased massively (from near-instant to up to 90 minutes), and the number of allowed concurrent builds has already limited the amount of testing we are able to do - we don't even have Windows tests because we couldn't fit them in. In around March 2021 we expect the old travis-ci.org that QuTiP is grandfathered onto to shut down completely, forcing us onto the new model on travis-ci.com. Number two: in November 2019, GitHub released their own CI, GitHub Actions. This is (as best as I can tell) completely free for open source, public repositories like QuTiP, and offers access to a large number of Linux, macOS and Windows containers. This completely free period of GitHub Actions might not last forever (you can imagine maybe they're just trying to drive adoption before increasing the cost), but especially with the new time pressure from Travis, this seems like the right choice for now. Our testing set up is fairly straightforward, so migrating to a new CI shouldn't be too difficult. I just wrote (#1429) a GitHub Actions workflow to build and distribute binary releases of QuTiP on Linux/Mac/Windows, and I'm pretty convinced by the power of their CI. It's got an awful lot of flexibility with a _lot_ of customisation so its initial learning curve is a little steep (or maybe I'm just not used to CI tools), but I'm impressed by what's available. I believe it comes with a degree of reusability as well; I think we can define a test as a single ""action"", and then reuse that in the PR-push workflow and the make-distribution workflow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/959#issuecomment-770455542:1002,access,access,1002,https://qutip.org,https://github.com/qutip/qutip/issues/959#issuecomment-770455542,1,['access'],['access']
Security,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:427,access,access,427,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847,1,['access'],['access']
Security,Do you have any plans to continue working on `qutip/cy/blas_funcs.pyx` or would it be sufficient to access blas through `scipy.linalg.blas.get_blas_funcs`? In that case I think `qutip/cy/blas_funcs.pyx` should be removed and this issue could be closed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-48557119:100,access,access,100,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-48557119,1,['access'],['access']
Security,"Early thought:. The `solver.add_feedback` approach doesn't look too bad, but it does seem a bit odd because on does to specify the state parameters when constructing the operators that the define the system -- i.e. H, c_ops, etc. Could we not expose the feedback on the QobjEvo itself so that users can then do:. ```python; H = QobjEvo([op, lambda t, ket: bra @ ket], feedback={""ket"": ""qobj""}); ...; ```. or; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); H.add_feedback(ket=""qobj""); ...; ```. or even; ```python; H = QobjEvo([op, lambda t, ket: bra @ ket]); solver = Solver(...); solver.rhs.add_feedback(ket=""qobj""); ```. Thoughts?. It will get a bit trickier for the feedback that is less easily available from the state, but perhaps solvers can just check whether the ops they're using need the special feedback?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538:243,expose,expose,243,https://qutip.org,https://github.com/qutip/qutip/pull/2210#issuecomment-1663061538,1,['expose'],['expose']
Security,"Example: `binary_search`; If the function is in fact not public, then precede with `_`, e.g. `_binary_search`,; then it does not need a docstring. ; In this specific example, if it is private, then still better to have the opening comment as a docstring.; As for what is private and public, then this is kind of up to you to decide. The rule of thumb that I go by is if you don't expect any user of the library (other than library developers) to access it, then it's private.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/815#issuecomment-443201886:446,access,access,446,https://qutip.org,https://github.com/qutip/qutip/pull/815#issuecomment-443201886,1,['access'],['access']
Security,"Following up, even if an option for drawing matrix elements with a border is added, the thresholded version of Hinton diagrams is much more common, especially in the ML community where it first originated. For example:. - https://matplotlib.org/stable/gallery/specialty_plots/hinton_demo.html; - https://www.mathworks.com/help/deeplearning/ref/plotwb.html (NB: not accessible for red–green color blindness, but thresholded nonetheless); - https://tex.stackexchange.com/questions/155291/generate-a-hinton-diagram-using-pgfplots; - https://mathematica.stackexchange.com/questions/194212/how-to-make-hinton-diagrams. Given those examples, I definitely agree that a border option could be really helpful, but it'd still be nice to be able to generate more traditional Hinton diagrams as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1595#issuecomment-922114051:365,access,accessible,365,https://qutip.org,https://github.com/qutip/qutip/issues/1595#issuecomment-922114051,1,['access'],['accessible']
Security,"For a constant Liouvillian, it seems very reasonable that an eigenseries-based solution would be faster? In the end, that massively reduces the number of matrix-matrix operations to be done. I'm not at all familiar with Matlab, but I wouldn't be shocked if that's what your toolbox there is doing too. Looking at your code, you seem to have 16 cores available. QuTiP at present can't make too much use of multiple cores in `mesolve` or `essolve` (though it can in `correlation`), whereas Matlab may well have some fancy parallelised methods for solving eigenvector problems (if doing that method) - we rely on Scipy for our eigenvector calculations, and I'm pretty sure there's no parallelisation in there. There could also be large timing disparities if you're not being linked to good BLAS/LAPACK/ARPACK implementations in Python space. I'm sure that any distributed version of Matlab will come stuffed with lovely libraries compiled specifically for your processor's instruction set, but Scipy may only be able to find Netlib BLAS or (even worse) Accelerate - if so, they probably won't be making good use of vectorised instructions in your processor, and may not be well-optimised for memory access.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1591#issuecomment-871031472:1196,access,access,1196,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-871031472,1,['access'],['access']
Security,"Hey @Ericgig.This is a great feature! I wanted to suggest a slightly different implementation that would work also for non constant cases. We could do checking that the f(t) value is real and that all elements are hermitian. However, the following does not seem to work for me (on a jupyter noteebok with latest dev.major):; ```python; qutip.QobjEvo(qt.sigmax()).elements; ```; are elements only accessible from cython?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2000#issuecomment-1256990030:396,access,accessible,396,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1256990030,1,['access'],['accessible']
Security,"Hi Boxi,. Can you please modify the projects of the Wiki page as you deem best?; All: we can also think of changing the order of them. It may be that; project #3 is deemed the most important. Best wishes,. Nathan. Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com. On Sun, Feb 23, 2020 at 5:42 AM Boxi Li <notifications@github.com> wrote:. > I have some detail information for the GSoC 2020 project ""Error mitigation; > in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub; > Wiki page. I post it here so if anyone finds it nice could copy it to the; > Wiki page.; >; > I add some details based on the original description:; > ------------------------------; > 1. Error mitigation in QuTiP; >; > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > quantum circuit simulator (which was a GSoC project) providing enhanced; > features for a pulse-level description of quantum circuits and noise; > models. A new class Processor and several subclasses are added to; > represent different platforms for quantum computing. They can transfer a; > quantum circuit into the corresponding control sequence and simulate the; > dynamics with QuTiP solvers. Different noise models can be added to; > qutip.qip.noise to simulate noise in a quantum device.; >; > This module is still young and many features can be improved, including; > new device models, new noise models and integration with the existing; > general framework for quantum circuits (qutip.qip.circuit). There are; > also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Request",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:561,access,access,561,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,1,['access'],['access']
Security,"Hi Eric, thanks for your comment. > You should remove the options from `solver_options` instead. It contain every valid options keys, just removing the key from it would makes setting it an error. Unfortunately it is not so easy, since `MCSolver` relies on the option being present in `self.options`: https://github.com/qutip/qutip/blob/48df19ceeb1f07dd60659ccdc2fe61d8df159e78/qutip/solver/mcsolve.py#L474; We could try overriding every method of MCSolver that accesses this option, but that seems easy to break accidentally again with future changes in MCSolver. > Also I would suggest to overwrite the `options` property to add the `completeness_rtol`, etc. to it's docsting. Done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2234#issuecomment-1750005892:462,access,accesses,462,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1750005892,1,['access'],['accesses']
Security,"Hi Paul,; How do you use openblas from python? I found that some blas routines are exposed in numpy but not all of them. Are there some examples of sparse blas calls from python? ; EPD and Anaconda python include MKL so I would like to play a bit with sparse blas routines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/55#issuecomment-25367184:83,expose,exposed,83,https://qutip.org,https://github.com/qutip/qutip/issues/55#issuecomment-25367184,1,['expose'],['exposed']
Security,"Hi. OK, I see. For implicit SDE solvers there is and advantage in having the rhs function calculating the state at the next time-step. I hesitated doing it like that, because I didn't want to mix up the definition of the stochastic SDE contribution with the deterministic part, which sometime in the future should use qutip's existing framework for time-dependent hamiltonian and collapse operators. Having the stochastic rhs function exposed to all that is a bit unnecessary and makes things more complicated than it needs to be. However, I think I found a reasonable compromise in that I created new _rhs_psi_deterministic and _rhs_rho_deterministic where the current deterministic contributions are calculated. These functions can now be called from a stochastic rhs implementation, like this. ```; dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args); ```. In this way the implementation of a stochastic rhs function is relatively isolated from how the deterministic part is calculated (which right now is trivial, but which could become more complex when time-dependent systems are implemented). However, it also gives all the flexibility needed in the rhs function, and these deterministic rhs functions do not need to be used if it is not suitable in a particular stochastic rhs implementation. . I've added the changes to the rhs behavior to the https://github.com/qutip/qutip/tree/sme-rhs-restructuring and updated the gist with the variant of your notebook. http://nbviewer.ipython.org/6153688. Note that a few other things, like the rhs function signature, had to change in the process. I hope that this updated API will be flexible enough to let you implement implicit solver. Regards rhs implementation and d1,d2 function: Yes, I understand that not all possible rhs schemes might be compatible with the parameterization with d1 and d2 functions, but when it is possible it has the great advantage that the user do not need to worry about how the rhs is implemented, only define the SDE",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22156426:435,expose,exposed,435,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22156426,1,['expose'],['exposed']
Security,"I actually have a question about this automatic normalization. Do we really need this to hide the numerical errors? Wouldn't it be better to just expose the error since it will be proportional to `atol` anyway (and if not, something went wrong)? Which group of users will this auto-normalization benefit?. Sometimes an unnormalised state at the ends can also indicate that there is something wrong with the Hamiltonian, e.g., it is not hermitian due to some typos.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018:146,expose,expose,146,https://qutip.org,https://github.com/qutip/qutip/pull/2427#issuecomment-2115886018,1,['expose'],['expose']
Security,"I agree that is is getting a bit unwieldy with all the options to the steadystate function, many of which only have meaning for specific solvers. We should do something about that. I wouldn't favor getting rid of the steadystate function though.. It might break a lot of old code and I think it is nice to have a high-level API that is decoupled from the specific implementation (direct, interative, or something else). Currently steadystate is only dispatching to other functions, and I think that is how it is supposed to be. To solve the problem with diverging options requirements for different solvers I would suggest changing the function signature to. ```; def steadystate(A, c_ops=[], method='direct', **kwargs):; ...; if method == 'direct'; steadystate_direct(A, c_ops, **kwargs); ```. and defer all the specifics about kwargs to specific solvers (including docstrings). That would bring the default values of those options closer to where they are used and reduce duplication. It would also allow us more flexibility in maintaining a backwards compatible api, and future maintainability. It's fine with me to make _steadystate_direct and _steadystate_iterative publicly accessible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/108#issuecomment-41362284:1180,access,accessible,1180,https://qutip.org,https://github.com/qutip/qutip/issues/108#issuecomment-41362284,1,['access'],['accessible']
Security,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:589,expose,expose,589,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874,2,['expose'],"['expose', 'exposed']"
Security,"I also get no error. The user already has access to Q.data, so if this is what they want, then it is already available. I do not see any benefit of changing the display output.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/432#issuecomment-184881219:42,access,access,42,https://qutip.org,https://github.com/qutip/qutip/issues/432#issuecomment-184881219,1,['access'],['access']
Security,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:593,access,accessible,593,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462,2,"['access', 'expose']","['accessible', 'expose']"
Security,"I don't think it breaks the functional API at all - in fact it almost makes it stronger, since everything is a ""function"" at every stage. This kind of partial application is classic part of functional programming. Perhaps I don't understand _why_ you want to move to a class-based API? I'd be quite strongly against having the user have to instantiate classes to do very simple parts like creating operators. Certainly in Python programming, I don't think a class-based interface is de facto the right sort to aim for, and procedural is much more ""Pythonic"". For one, it's a lot of unnecessary boilerplate for simple operations. It adds cognitive complexity for the advanced user to decide ""should I use `displace` or `Displacer`?"", and in the strong majority of use-cases, the operator creation is not a computational bottleneck so we'd be adding it for no gain. A lot of operators have no meaningful reason to live in a class, like `sigmax` and so on, so now you have a split between operators that need a class and operators that don't, or you do something really crazy like requiring the user to do; ```python; sx_builder = qutip.operators.SigmaX(); sx = sx_builder.get_operator(); sy_builder = qutip.operators.SigmaY(); sy = sy_builder.get_operator(); sz_builder = qutip.operators.SigmaZ(); sz = sz_builder.get_operator(); ```; when all they wanted was `qutip.sigmax(), qutip.sigmay(), qutip.sigmaz()`. Obviously that example is a bit facetious, but what benefit does the user derive from having to write boilerplate to access simple functionality?. All the operators already share a class in `Qobj`, and things like `displace` and `sigmax` are factory methods of `Qobj`. What shared functionality do the factory methods possess that means they should be classes?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293#issuecomment-646631332:1525,access,access,1525,https://qutip.org,https://github.com/qutip/qutip/issues/1293#issuecomment-646631332,1,['access'],['access']
Security,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:963,expose,expose,963,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515,1,['expose'],['expose']
Security,I get the following error when trying to use the ip_parallel_map:. ```; FileNotFoundError: [Errno 2] No such file or directory: '/home/paul/.ipython/profile_default/security/ipcontroller-client.json'; ```. Everything else works as expected.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66558727:165,secur,security,165,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66558727,1,['secur'],['security']
Security,"I guess not. But my original motivation was to try to do the mcsolver in; cython. Perhaps the scipy blas calls work just as good in cython. I; already ran into these blas difficulties on the mac. You would think the; calling structure would be uniform by now.; On Aug 10, 2013 6:08 PM, ""Robert Johansson"" notifications@github.com; wrote:. > Now with a8b79f7https://github.com/qutip/qutip/commit/a8b79f7bd2ad58713e9ed7b104e204b155fcdc20it works again on my machine. Is there a big difference in performance; > between accessing the blas stuff through scipy instead of directly from a; > cython module? If not it would be good to let the scipy ppl worry about the; > linking to blas and not have to deal with that in qutip.; > ; > —; > Reply to this email directly or view it on GitHubhttps://github.com/qutip/qutip/issues/39#issuecomment-22436635; > .",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-22436693:517,access,accessing,517,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-22436693,1,['access'],['accessing']
Security,"I had a bit more success by switching as much as possible in the setup of the testing environment to pip:; ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y numpy scipy cython; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install -e .; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install nose ipython; ~~~; I also added a `unittest.skipIf` decorator to `qutip/tests/test_stochastic_se.py:test_smesolve_homodyne_methods`, which is the only test that consistently fails on `master`. With this, the test suite runs through about 50% of the time. The other 50% it crashes with the following:; ~~~; ...; PIQS: Test the warning for diagonal Hamiltonians to use internal solver. ... ok; Propagator: HO ('single mode') ... ok; Propagator: HO ('batch mode') ... ok; Propagator: HO parallel ... ok; Propagator: str td format ... ok; Propagator: func td format ... ok; Propagator: steady state ... python(52709,0x10fc1f5c0) malloc: Incorrect checksum for freed object 0x7fcbf338af10: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(52709,0x10fc1f5c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ~~~",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378:1063,checksum,checksum,1063,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378,1,['checksum'],['checksum']
Security,I have had a bit of a read around 'incorrect checksum for freed object'. I don't think there's anything wrong with our stuff. This must be an issue with Python on MacOS. I suggest just merge the PRs and hopefully someone will fix the underlying issue at some point,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458656776:45,checksum,checksum,45,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458656776,1,['checksum'],['checksum']
Security,"I have just installed qutip using the master branch. When running the tests script test_steadystate.py, I receive a similar violation as above. . ```python; packages\qutip\qutip\steadystate.py:275: in steadystate; return _steadystate_direct_sparse(A, ss_args); packages\qutip\qutip\steadystate.py:442: in _steadystate_direct_sparse; v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; packages\qutip\qutip\_mkl\spsolve.py:393: in mkl_spsolve; x = lu.solve(b, verbose=verbose); OSError: exception: access violation reading 0x00000000000000C4; packages\qutip\qutip\_mkl\spsolve.py:167: OSError; ```; Is this a known bug with windows, or is there a fix?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1077#issuecomment-653144199:510,access,access,510,https://qutip.org,https://github.com/qutip/qutip/issues/1077#issuecomment-653144199,1,['access'],['access']
Security,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:160,access,access,160,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663,1,['access'],['access']
Security,"I made some benchmarks timing different way to call matmul and contouring the dispatcher is worth it. ; For 10x10, CRS x Dense, it's 4x slowdown for matmul and 2x for expect.; For 1000 x 1000, it's 10% and 5%, reasonable but still felt. The easiest would be having `matmul(self, Dense in, Dense out)` method for Data layer. There is no need for all pairs of layer types to be supported by this, states in scipy's solver are always Dense. But it's a little late for that. Not having that, since 99% of users will use our data type and we only really need it for `matmul` and `expect`, we can so a manual disptach for just those. The way I did it was quite ugly, I wanted to limit the calls to `isinstance` which are not proper cython so did it once moving the type. I did not think of `type`...; `type(op) is CSR` is 15x faster than `isinstance(op, CSR)` and about as fast as comparing for enums, making have `layer_type` useless. Renamed it to `matmul_data_dense_dense` in matmul.pyx.; Still short of a c dispatcher for function pointers, but I am not attacking this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1407#issuecomment-747703407:1052,attack,attacking,1052,https://qutip.org,https://github.com/qutip/qutip/pull/1407#issuecomment-747703407,1,['attack'],['attacking']
Security,"I re-launched the Travis tests on all platforms. They pass for all besides Mac OS (similar error as for other PR). With `python setup.py install`, with `install` instead of `develop`, things seem to work. What it is unclear to me is why it reads that the QuTiP Version is `4.4.0.dev0+1a639d7a`, when I could not find this hash in here (or maybe I am confused). Now, after some tries with install and develop, I am on that version of qutip-dev. . To begin with, I am running the contents of the [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). Some comments below are relevant to the PR of the notebooks, https://github.com/qutip/qutip-notebooks/pull/71. * `development-qobjevo.ipynb`: Runs fine. ; * `development-qobjevo-adv.ipynb`: Runs fine. ; * `development-qobjevo-timing.ipynb`: Runs fine. * The notebook [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb) could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:322,hash,hash,322,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['hash'],['hash']
Security,"I report local tests failing on my MacOS 10.13.6 by running qutip.testing.run(). Tests fail for python 3.7 and 3.6 environments, if QuTiP 4.4. is installed in develop mode (openmp = True). ; Tests fail also for QuTiP 4.3.1 installed with conda. . ### py36; Broken test for python 3.6 with: (1) QuTiP 4.4-dev, with openmp =True and (2) conda install qutip, QuTiP 4.3.1: ; Error Message below: ; ``` ; Metrics: Trace dist. & Fidelity mixed/pure inequality ... ok ; Metrics: Check avg gate fidelities for random ... ; python(35852,0x7fff9757f380) malloc: *** error for object 0x7fe189168a10: incorrect checksum for freed object - object was probably modified after being freed. *** ; set a breakpoint in malloc_error_break to debug ; Abort trap: 6 ---------------------------------------------- ; ``` . Building the dev environment: ; ``` conda create --name qutip-dev-44-py36 ; source activate qutip-dev-44-py36 ; conda install python=3.6 cython numpy scipy nose jupyter matplotlib; python setup.py develop --with-openmp; ``` . ### py37; Broken test for python 3.7 with: (1) QuTiP 4.4-dev, with openmp =True and (2) conda install qutip, QuTiP 4.3.1. Error Message below: ; ``` ; qutip.tests.test_qobj.test_expect_exception ... ok Qobj data ... ok Qobj type ... ok Qobj Hermicity ... ok ; Qobj unitarity ... ok ; Qobj shape ... ok ; Qobj: multiplication w/ non-square qobj.dims ... ok ; Qobj addition ... ok ; Qobj subtraction ... ok ; Qobj multiplication ... ok ; Qobj division ... ok ; Qobj power ... ; python(35379,0x7fff9757f380) malloc: *** error for object 0x7fbf1089fa90: incorrect checksum for freed object - object was probably modified after being freed. *** ; set a breakpoint in malloc_error_break to debug ; Abort trap: 6 ; ``` . Building the dev environment: ; ``` conda create --name qutip-dev-44-py37 ; source activate qutip-dev-44-py37 ; conda install python=3.7 cython numpy scipy nose jupyter matplotlib; python setup.py develop --with-openmp```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-473772867:599,checksum,checksum,599,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-473772867,2,['checksum'],['checksum']
Security,"I think it should be possible to do this within the pytest framework without touching the package `setup.py` or `MANIFEST`. [`pytest.fixture`](https://docs.pytest.org/en/stable/fixture.html#sharing-test-data) seems a natural choice for loading data. For file accessibility, [this](https://stackoverflow.com/questions/46019170/how-do-you-properly-integrate-unit-tests-for-file-parsing-with-pytest) might help. Porbably @jakelishman knows more about the natural way of doing this with pytest?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-655970508:259,access,accessibility,259,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-655970508,1,['access'],['accessibility']
Security,"I think it would be reasonable to change ""from numpy import *"" to ""import numpy as np"" in the generated cython code. Then if a user wants a numpy function that is overloaded by the new definitions that you've added, or wants a function that is not included in that list, it can be accessed by explicly including the namespace, like 'np.exp(...)'",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/251#issuecomment-61604751:281,access,accessed,281,https://qutip.org,https://github.com/qutip/qutip/pull/251#issuecomment-61604751,1,['access'],['accessed']
Security,"I think we can get rid of it for the moment. It might be useful to call these via Cython at some point, but for now this can be removed. On Jul 10, 2014, at 10:55 AM, Robert Johansson notifications@github.com wrote:. > Do you have any plans to continue working on qutip/cy/blas_funcs.pyx or would it be sufficient to access blas through scipy.linalg.blas.get_blas_funcs? In that case I think qutip/cy/blas_funcs.pyx should be removed and this issue could be closed.; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-48557254:317,access,access,317,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-48557254,1,['access'],['access']
Security,"I would like to try to build the solution for this. **Task 1:** For chrome, the error seems to be due to the CORS (Cross-origin Resource Sharing) policy of google chrome.; `Access to XMLHttpRequest at 'file:///C:/Users/Sid/Desktop/qutip-doc/QuTiP_tree_plot/d3_data/qutip.json' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.`. To fix this, I created a local server (on port 8080) from the `../qutip-doc/QuTiP_tree_plot` folder and then ran the URL `http://localhost:8082/qutip_org.html` on chrome.; Egde doesn't seemed to have any problem in running `qutip-doc.html`. **Task 2:** ; Clarification - We would right a new script to generate `qutip.json` from `apidoc/functions.rst`, just like `QuTiP_tree_plot/qutip-structure.py`. Am I right?. **Task 4:** ; Can you please elaborate on task 4 as to link to which API docs. **Task 5:**; The script written in Task 2 can be made to run for `classes.rst` and a json file would be created which would be used to generate a tree, right?; Where would we put it in the docs? guide-overview?. PS: I'm sorry if I've asked or stated an obvious thing, I am new to this community and am still trying to fimiliarize myself. Thanks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1525#issuecomment-469209588:173,Access,Access,173,https://qutip.org,https://github.com/qutip/qutip/issues/1525#issuecomment-469209588,1,['Access'],['Access']
Security,"I'm glad that it's useful! We wanted this work to be accessible, so I thought it made sense to contribute the definition. If the current design is acceptable, then I'll go on and finish the test cases and add a corresponding PR to qutip/qutip-notebooks demonstrating the new function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/357#issuecomment-125965058:53,access,accessible,53,https://qutip.org,https://github.com/qutip/qutip/pull/357#issuecomment-125965058,1,['access'],['accessible']
Security,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:375,inject,inject,375,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355,1,['inject'],['inject']
Security,"I'm not entirely sure what's being asked of us here, because the code numba supports is to do with the numba developers, not us? numba is a compiler for Python code accessing NumPy arrays in ways other than internal NumPy compiled C code. The benefit to QuTiP users even if numba _were_ to add support would be minor, because a) we use custom sparse matrices which numba couldn't currently target to a GPU efficiently and b) almost all of our heavy code is compiled C, which is already as the same target as standard numba. We aren't going to convert (e.g.) `Qobj` to a numba `jitclass` because our entire library is written in Cython, and besides, the speed-ups come from the internal `Qobj.data` attributes, which we are already low-level. GPU-based sparse matrix routines are an interesting side-note, but will require very specialised data structures and accesses. This is more possible in the new data-layer added in 5.0, but still would require a huge amount of work. We're not likely to achieve this by using numba, but instead to use specialised GPU-enabled data structures like cupy instead, since that fits into our data model better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/900#issuecomment-809667000:165,access,accessing,165,https://qutip.org,https://github.com/qutip/qutip/issues/900#issuecomment-809667000,2,['access'],"['accesses', 'accessing']"
Security,"I'm not sure solution 3 will work as easily as this - if the user's `scipy.linalg.eigh` is broken, then calling it doesn't help, surely?. Also, I can reproduce the segfaults with both `np.ascontiguousarray` and `np.asfortranarray` on my machine, but it is a size of 64 that seems to reliably do me in. Script to reproduce:; ```python; import numpy as np; from scipy.linalg import eigh. def random_hermitian(n):; h = np.random.rand(n, n) + 1j*np.random.rand(n, n); return h + np.conj(h.T). for n in range(1, 101):; print(n); for _ in [None]*100:; x = eigh(np.ascontiguousarray(random_hermitian(n))); ```; and this segfaults on `n=64` reliably with the `pip` version of `scipy` (linked against OpenBLAS 0.3.7), and always succeeds with the `conda` version (linked against MKL 2019.4). Both `scipy` versions are 1.4.1 here. I did the most bare-bones install to test this:; ```; $ conda create -n blastest python; $ conda activate blastest; $ pip install scipy; $ python blas.py; ```; where `blas.py` is the repro script above. Doing this, `pip` pulls me OpenBLAS 0.3.7. Looking at the source of OpenBLAS, the whole heavy-lifting implementation is in Fortran - there's the classic LAPACKe C wrapper around the core Fortran LAPACK, but everything eventually goes down to the Fortran. If it helps, it's an out-of-bounds access error that causes the segfault for me, and the address it's trying to access doesn't look like dummy nonsense (`0x101b95010`). I'm pretty sure it's a nasty Mac/OpenBLAS bug. If the problem is particularly in `zheevr` we could swap the call to `eig` (instead of `eigh`) for Mac only, which should hopefully sidestep the problem, because it'll call `zgeev` instead. All recent pip installs of `scipy` link against OpenBLAS, so there's not much that can sidestep it there, other than mandating `conda` usage, because you can't relink `scipy` to decent libraries without compiling from source.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628780955:1314,access,access,1314,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628780955,2,['access'],['access']
Security,"Idea: We could perhaps pass one extra argument called, e.g., ""context"" or ""ctxt"", that allows access to various strange things like the state. The ""ctxt"" object could then have properties or methods that returned the state upon request.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/947#issuecomment-1142171064:94,access,access,94,https://qutip.org,https://github.com/qutip/qutip/issues/947#issuecomment-1142171064,1,['access'],['access']
Security,"If we don't do `del numpy` in qutip's `__init__.py`, then doing this works:. ```; from import qutip *; numpy.func(...); ```. because numpy was imported but not deleted before the end of qutips init file, and it will be exported form qutip as a global symbol in qutips namespace (which is the callers global name space if called as above). However, this is not a desired behaviour of a module to do like this: importing qutip shouldn't impose that numpy is imported in any particular way (even though qutip uses numpy internally). For example, if a user prefer to import numpy as `np`, then it is pointless that qutip exposes numpy as `numpy` as well. It because even weirder when an import pattern like `import qutip as q` is used, because as it is now then numpy is available through `q.numpy`, which is unnecessary and causes problem with for example nose unit testing of qutip module (because it finds numpy and run all numpy tests as well) and also with module autocompletion in for example spyder and ipython. For these and many other similar reasons, it is neatest if qutip only exports its own symbols, and if a users requires any symbols of other packages they should be explicitly imported from those packages. I hope this explains why I want to eliminate qutips currently excessive namespace populating.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/233#issuecomment-56176673:617,expose,exposes,617,https://qutip.org,https://github.com/qutip/qutip/pull/233#issuecomment-56176673,1,['expose'],['exposes']
Security,"In development version 4.4: . - For Python 3.6, when running `qutip.testing.run()`. ```; uTiP Version: 4.4.0.dev0+0bf3e05e; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.6.8; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```; I obtain an error at ; ```; Propagator: steady state ... Segmentation fault: 11; ```. - For Python 3.7 with ; ```; QuTiP Version: 4.4.0.dev0+0bf3e05e; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/miniconda3/envs/py37/lib/python3.7/site-packages/qutip-4.4.0.dev0+0bf3e05e-py3.7-macosx-10.7-x86_64.egg/qutip; ```; the error occurs at . ```; Metrics: Check avg gate fidelities for random ... python(42424,0x7fffa34a8380) malloc: *** error for object 0x7fc74f258880: incorrect checksum for freed object - object was probably modified after being freed.; *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-482116179:1071,checksum,checksum,1071,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-482116179,1,['checksum'],['checksum']
Security,Issue with setting phase_option #400 resolved by using property setter rather than set_phase_option; Took the opportunity to replace all get_ and set_ functions with property accessors.; Full list of function and attrib name changes provided in 'qtrl-v3_2-release_notes.txt'; These should only affect customised sub-classes. Deprecation warnings given.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/397#issuecomment-159366015:175,access,accessors,175,https://qutip.org,https://github.com/qutip/qutip/pull/397#issuecomment-159366015,1,['access'],['accessors']
Security,"It *should* also affect Windows, even with Python 3.7: Windows has always (I think) used ""spawn"" for multiprocessing. Thus, if there's a workaround in place that makes `mcsolve` work on Windows, it should also be applicable to macOS/Python 3.8. Alas, I don't have easy access to a Windows system, so I haven't tested this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-598855427:269,access,access,269,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-598855427,1,['access'],['access']
Security,"It looks like the loop on line 64 https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/qobjevo_codegen.py#L64 completes on the first try, but doesn't manage to import any objects, so the import_list remains empty. Could you use pdb to access local variables?. ---; P.S. You can use Markdown to format the traceback in a user-friendly way:; e.g. ; \`\`\`python-traceback; /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext; \`\`\`. Renders to:; ```python-traceback; /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196#issuecomment-595050108:265,access,access,265,https://qutip.org,https://github.com/qutip/qutip/issues/1196#issuecomment-595050108,1,['access'],['access']
Security,"It seems like this routine is geared toward a specific problem, rather than a general input. Regardless, I think a notebook explaining this method is required, including better examples on the usage. This can be added to the documentation once it is converted to IPython notebooks. A few things I noticed are given below:; - The output is not a list, but a Result class object.; - Why is it not possible to directly calculate expectation values other than the coupling term?; - Why are the default input values what they are?; - The print statement at the end should be optional depending on the setting of the debugger.; - The call to Odeoptions in mesolve needs to be user accessible.; - tlist should not be the last input argument and should probably not be a kwarg.; - The call to eigenstates should also have an optional argument to call the sparse eigenstates solver if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-103712771:675,access,accessible,675,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-103712771,1,['access'],['accessible']
Security,"It's interesting to see how my style of writing tests changes and matures. It's being particularly influenced at the moment, because on Qiskit we use a fairly thin wrapper around raw `unittest`, rather than `pytest`, so I'm being exposed to writing in other styles as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1614#issuecomment-882516763:230,expose,exposed,230,https://qutip.org,https://github.com/qutip/qutip/pull/1614#issuecomment-882516763,1,['expose'],['exposed']
Security,"Just found what may have been the cause of the segfault. Incorrect indexing in `data.csr.Accumulator.gather` led to uninitialised memory being exposed if it encountered a zero value which in the current PR would only have been exposed by `Qobj.ptrace` on CSR to CSR, but by no fault of its own. This PR is ready for review - these last couple of patches I've just been sending could equally have gone to the next PR I'm preparing which is waiting for this one to be merged so I can rebase it on top of the new `dev.major`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338#issuecomment-678399544:143,expose,exposed,143,https://qutip.org,https://github.com/qutip/qutip/pull/1338#issuecomment-678399544,2,['expose'],['exposed']
Security,"My computer is a Mac, by the way - I don't have direct access to a Windows machine at the moment.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605290310:55,access,access,55,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605290310,1,['access'],['access']
Security,Note that 5.0 is already a lot better about what it exposes via `from qutip import *`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1071#issuecomment-1427874263:52,expose,exposes,52,https://qutip.org,https://github.com/qutip/qutip/issues/1071#issuecomment-1427874263,1,['expose'],['exposes']
Security,"Nothing too clever here. As in cached flag cleared whenever unitarity threatened; The check could probably be more efficient, but as not expected to be used intensively, then this would seem acceptable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/817#issuecomment-364163769:70,threat,threatened,70,https://qutip.org,https://github.com/qutip/qutip/pull/817#issuecomment-364163769,1,['threat'],['threatened']
Security,Now with a8b79f7bd2ad58713e9ed7b104e204b155fcdc20 it works again on my machine. Is there a big difference in performance between accessing the blas stuff through scipy instead of directly from a cython module? If not it would be good to let the scipy ppl worry about the linking to blas and not have to deal with that in qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-22436635:129,access,accessing,129,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-22436635,1,['access'],['accessing']
Security,"Oh sorry, I thought you were reporting the sys gcc, not the conda one. Conda-forge and QuTiP are tested heavily against Ubuntu 14.04, so if any; platform works, it should be that one. As I originally suspected, the problem comes from the Cython code.; Specifically for the sparse matrix math. The fact that you can build it; yourself suggests a binary incompatibility. However, again, we test; against 14.04, so I am hard pressed to think about what the issue could be.; gdb might be able to hunt down where the dump occurs. On Mar 25, 2017 18:27, ""Michael Goerz"" <notifications@github.com> wrote:. Since it's the python from the conda package, I'm assuming that's because; Continuum created the linux package on a Redhat system. GCC is identified; like that on both of the workstations. But yeah, my guess would be that; there is some shared library that's compiled in a way that's incompatible; with the rest of the system. Is there any linux utility that would allow to; determine which library is being accessed at the moment of the crash? Some; invocation of ldd?. —; You are receiving this because you commented. Reply to this email directly, view it on GitHub; <https://github.com/qutip/qutip/issues/674#issuecomment-289249308>, or mute; the thread; <https://github.com/notifications/unsubscribe-auth/ABMPqT0F1WSzbd-hOyso9XQM0K5ldiiwks5rpbEBgaJpZM4MpI4Z>; .",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-289250540:1007,access,accessed,1007,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-289250540,1,['access'],['accessed']
Security,"Ok, I think I understand now. The QObjEvo class is well documented. The `cqobjevo` classes are not really exposed to the user, and so they don't need full documentation.; I would suggest that any new files added by this PR have a short file level docstring that explains the purpose of the classes / functions that it defines. Consider these as messages to developers rather than users.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/815#issuecomment-454724726:106,expose,exposed,106,https://qutip.org,https://github.com/qutip/qutip/pull/815#issuecomment-454724726,1,['expose'],['exposed']
Security,"Parallel map function having different behaviour on different OS is not new, it's quite annoying.; I am quite surprised (and sad) that it Mac that is going fine for this one. Most cluster are using linux, so I would be fine to just run the test once on linux... I understand that you are developing with a mpi enable cluster, not just your local machine. Do you use `mpiexec` when running the tests? Maybe not using it with pytest could have side effects. Maybe mpi4py's [discussions board](https://github.com/mpi4py/mpi4py/discussions) could help? They also have a google group, but it seems full of spam... I have access to a cluster and I will try it later this week. I will come back to you if I find something interesting. But I have little experience with mpi in python.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182:616,access,access,616,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1906562182,1,['access'],['access']
Security,"QuTiP 4.5.3 doesn't support M1 Macs, sorry. None of us has access to one to test, and our CI didn't support them for quite a while. This will be fixed in the next release of QuTiP. In the meantime, you can either build the package from the current source code here, or you can go into your QuTiP installation folder and comment out lines 48 and 49 of `qutip/hardware_info.py` to work around it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1473#issuecomment-808873718:59,access,access,59,https://qutip.org,https://github.com/qutip/qutip/issues/1473#issuecomment-808873718,1,['access'],['access']
Security,"Since it's the python from the conda package, I'm assuming that's because Continuum created the linux package on a Redhat system. GCC is identified like that on both of the workstations. But yeah, my guess would be that there is some shared library that's compiled in a way that's incompatible with the rest of the system. Is there any linux utility that would allow to determine which library is being accessed at the moment of the crash? Some invocation of `ldd`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-289249308:403,access,accessed,403,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-289249308,1,['access'],['accessed']
Security,So my guess here is that pyximport keeps appending args like -O2 -fPIC etc to the call to gcc until it breaks. Not sure if it is a qutip thing or Cython. Why theory needs to be validated as a first step.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-511388484:177,validat,validated,177,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-511388484,1,['validat'],['validated']
Security,"Solvers: absolutely the solvers should always be packaged with the main `qutip`. I had sort of envisaged that we'd put them in a `solve` package, which would be exported into the main namespace just like `core` is. This way is more just for greater separation, so that the full core isn't entangled with the solvers themselves - I think separating them like this will help us ensure that we specify the data layer API much more cleanly if the solvers aren't referenced within it. (i.e. there's no reference to any solver within `core`, but the API is built sufficiently cleanly that they can still access all the internals). OpenMP check: I think there's two neater ways:; 1. perhaps `settings` should just be in `core` too? I avoided putting the check in `core/__init__.py` because I'm really trying to avoid bi-directional dependencies between the packages, but moving `settings.py` into `core` would solve that.; 2. alternatively, we could just write `settings.py` as part of `setup.py` - determine whether we built against OpenMP/MKL at compile-time, and then just write it in? We can still choose whether or not to use it in various runtime situations. As for the current test - yeah, the comparative complexity is kind of indicative that this isn't the right way to do it. It's a relatively straightforward use of `importlib`, but still it's more difficult. (By the way: are you and @ajgpitch getting notified when I post in [the discussion board](https://github.com/orgs/qutip/teams/data-layer-devs)?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1282#issuecomment-638730654:598,access,access,598,https://qutip.org,https://github.com/qutip/qutip/pull/1282#issuecomment-638730654,1,['access'],['access']
Security,Something is way off about that test failure again... Is it possible Travis isn't cleaning up properly? I can't reproduce the failure (it's also clearly nothing to do with this change) and the error message doesn't match up. If anything it looks like the error message is coming from a hash collision inside QobjEvo _maybe_?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1221#issuecomment-605533672:286,hash,hash,286,https://qutip.org,https://github.com/qutip/qutip/pull/1221#issuecomment-605533672,1,['hash'],['hash']
Security,"Sounds good, I'll add superoperator support to `hinton()`, then. I had used the mpltools version for the rough writeup partially for accessibility reasons: those plots were originally for presenting to colorblind users, and so I couldn't use the red/blue colormap. ddf9ae3 should enable this, then. Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/268#issuecomment-65416492:133,access,accessibility,133,https://qutip.org,https://github.com/qutip/qutip/pull/268#issuecomment-65416492,1,['access'],['accessibility']
Security,"Thank you @christian512, pdf seems to be build without error.; Could you add an upload step so we can access it after the job finished?; The mirror of the ""Upload built HTML files"" step.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1883#issuecomment-1109695548:102,access,access,102,https://qutip.org,https://github.com/qutip/qutip/pull/1883#issuecomment-1109695548,1,['access'],['access']
Security,"Thank you for your answer @Ericgig !. So, even though we are not using any quotes in our code, this internally maps to the string approach ?; I am trying to understand how to do what I want using callbacks instead, I could use a bit of help.; This is what the original code I shared here reads:. ```; # list of variational parameters ""a[]""; a=[]; for i in range(numite):; a.append(0.01*i). # define energy function by using variational parameters; def energy(a):; psi = initial_H.eigenstates(sparse=False)[1][0]; t = np.linspace(0, 1, timesteps+1); for i in range(numite):; 	H=[[initial_H,1-a[i]*t],[final_H,a[i]*t]]; 	result= qt.mesolve(H, psi, t, [], []); 	psi=result.states[timesteps]. E = qt.expect(final_H,psi); return E; ```. I tried to understand the documentation here: http://qutip.org/docs/latest/modules/qutip/mesolve.html; What I think I need to do is the following:. - I need to just pass callbacks instead of formulas / strings for the coefficients when defining the operators.; - these callbacks must have a signature with the format `(t, *args)` and should return an np.array; - `t` and `args` values are passed as arguments to mesolve. . I am a bit unclear whether or not ""args"" is a list or a dictionary and how I can access it inside my callbacks. I made an attempt but it returns errors: maybe it would be easy for you to fix some lines of this example and tell me if I am on the right track? Or do you have a link to an example, maybe ?; I am just targeting the innermost portion of the code, here:. ```; mesolve_args = ... # a dictionary ? a list? Something that lets me access the variable ""a""; def h_t1(t, *args):; return np.array(1-a[i]*t) # how do I retrieve a[i] by accessing args?; def h_t2(t, *args):; return np.array(a[i]*t) # same. H=[ [initial_H, h_t1], [final_H, h_t2] ]; result= qt.mesolve(H, psi, t, c_ops=[], e_ops=[], args=mesolve_args) # is this correct ?; psi=result.states[timesteps]; ```. Thank you for your help !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-474154477:1236,access,access,1236,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-474154477,3,['access'],"['access', 'accessing']"
Security,"Thanks @BoxiLi ; Okay, embarrassingly, I was still in my `update-4,x` branch, so hence didn't find the file. Still, I did try a lot of stuff like `from qutip import hadamard_transform` (in other envs) that didn't work, before I found (with some help) that `from qutip import gates` is a good option. It seems like there was a deliberate choice not to expose the function names individually. A search for ""hadamard_transform"" or ""gates"" does not return anything helpful. Does it need pointing at in the docs build?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2389#issuecomment-2046653469:351,expose,expose,351,https://qutip.org,https://github.com/qutip/qutip/issues/2389#issuecomment-2046653469,1,['expose'],['expose']
Security,Thanks @fmayo96. Question: Should the `einsum` function be in `dimensions.py`? And should it be internal or exposed via the public API? It looks generically useful but what specific use cases do we have in mind?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2545#issuecomment-2415262480:108,expose,exposed,108,https://qutip.org,https://github.com/qutip/qutip/pull/2545#issuecomment-2415262480,1,['expose'],['exposed']
Security,"Thanks @fromage88 for the bug report and @mmensing for the proposed work around. I could also reproduce the bug and confirm that the work around works. An alternative work around until this is fixed is directly access the underlying matplotlib figure instance:. ```; import numpy as np; from qutip import *. b = Bloch(). for i in range(5):; b.add_vectors([np.sin(i),0,np.cos(i)]); b.render(); b.fig.savefig(""bloch_sf%d.png"" % i); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/304#issuecomment-71307382:211,access,access,211,https://qutip.org,https://github.com/qutip/qutip/issues/304#issuecomment-71307382,1,['access'],['access']
Security,"Thanks for reporting this - it's an important bug that's snuck in. Right now, there's a few errors in your code that you can fix to get on your way again, but we need to fix the error on our side. You're using `sigmap()` which is the Pauli excitation operator and is only defined for a Hilbert space with dimension 2. You actually are working with a Hilbert space of dimension `nmax * nmax` (a tensor-product space), so your `e_ops` argument to `sesolve` is wrong - it's difficult to know exactly what you meant here. `destroy(2)` is equivalent to `sigmap()`, so it's possible you intended to have `e_ops` be `[qutip.tensor(a1, a2)]`?. ---. Maintainers: The error is actually a segfault, because QuTiP 4.5 (probably 4.4 too) does not do sufficient error checking on`e_ops` arguments - probably they're missing in the conversion to `CQobjEvo`. When the expectation is called, it has already sidestepped `Qobj`'s dimensions check and there is no matrix size check, so it simply segfaults on OOB access. The fix for the 4.x branch is to have a very loud Python-space error due to mismatched `Qobj` dimensions on entry to the solvers, or insert a size check within `CQobjEvo`. High priority: there's no reason we should be segfaulting here. Partially fixed in the 5.x branch; all matrix multiplications that take place in C-space have a size check and throw a Python exception, however the solvers still sidestep the `Qobj` dimension check so a tensor-product-space mismatch will not be detected.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1374#issuecomment-717495492:993,access,access,993,https://qutip.org,https://github.com/qutip/qutip/issues/1374#issuecomment-717495492,1,['access'],['access']
Security,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:82,access,access,82,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681,2,['access'],"['access', 'accessing']"
Security,"That's very odd, it looks like the test was killed the test midway through, but I have no idea why. I'd guess that rerunning the build may work, but answers to [a question on StackOverflow](http://stackoverflow.com/questions/17606874/trigger-a-travis-ci-rebuild-without-pushing-a-commit) claim that you must have write access to the repo in order to trigger a new build.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/358#issuecomment-128689363:319,access,access,319,https://qutip.org,https://github.com/qutip/qutip/pull/358#issuecomment-128689363,1,['access'],['access']
Security,"The `_hashable_without_global_phase` made the tests nice and easy to read, but honestly it was just a timebomb waiting to go off and break the tests. Floats can't reasonably be hashed as an equality test, because they should always include a delta in the comparison. This technically makes the tests slower, but as long as we're just testing the single-qubit Clifford group, it's only a fraction of a second (because there's 24 of them ignoring global phase and 24^2 is only 576).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626317467:177,hash,hashed,177,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626317467,1,['hash'],['hashed']
Security,"The main function of the `Options` class is to hold the documentation of the options supported by solver, mostly integrator related ones are an issue. Since sub-packages can add new integration methods, it should be somewhere dynamic that can fetch them at runtime. We can't have them in the description of the function interface directly, but it must be clear from that documentation where to find them.; We can't have them in the documentation of the solver class. It could be in a solver instance, but that too late: needing to initialize a `BrSolver` or `HEOMSolver` just to know which options `bsmesolve` and `heomsolve` support is not user friendly.; The Integrator class is useless for the users: if they want to solve ODE, they should use `scipy.integrate`, for quantum systems evolution, `mesolve` etc. So we should not ask them to look there. `SolverOptions(name)` make it reasonably easy to check the supported options and their default before using the solver. Another approach I see is to fix the integrator when using the functions interface, this way we could properly document the function with all items from both the solver and integrator. When using the class interface, we keep both options separated (and make the choice of integrator it's own keyword):; ```; solver = SeSolver(H, integrator_method='adams', options=solver_options, ode_options=ode_options); solver.options # Solver options only. solver.set_integrator('vern7', ode_options); help(solver.ode_options) # See description of integrator options; ```. That way the function calls is very close to v4 and easy to use, and the class interface give access to new features. ; This also makes `krylovsolve` fit more. Since `method` is used by the solver, not the integrator, it should not be under the `options.ode`, but it seems confusing to have it with the normal options, so having it as an independent parameter could make it clearer.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897:1627,access,access,1627,https://qutip.org,https://github.com/qutip/qutip/pull/1947#issuecomment-1174438897,1,['access'],['access']
Security,"The problem is recognising what a true 0 is from a small value. In your example on the new data layer, there will already be exactly 0 items explicitly stored (and `data.add_csr` is going to get faster and smarter in another PR, too) without `tidyup`, but much more concerningly `1e-15 * qutip.rand_herm(5)` will end up in a zero matrix, which is clearly absolutely wrong. The argument from Liouvillian doesn't work here - even before the new data layer, `liouvillian` never called the `tidyup` code because it accessed the `Qobj.data` field directly, rather than used `Qobj`. Since it then goes into `CQobjEvo` in most of the solvers, which also don't touch the `tidyup` code, it doesn't get called. I don't think there's any safe way to know if small values should actually be zero, or if they're just small values. It makes sense that we want to maintain as much sparsity as possible when values are truly zero, but I think having the QuTiP default be to attempt to tidy up after every addition, multiplication and matrix multiplication is quite unsafe, and for people who aren't doing very very sparse calculations, it's actually a slow down.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-680011384:511,access,accessed,511,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-680011384,1,['access'],['accessed']
Security,"The problem with windows has been that there was/is no free 64 bit compiler, and because of that it has been way easier to just install anaconda 32 and use mingw32 on windows (even on windows 64). . In principle is should be possible build and install qutip 64-bit version on windows with a commercial 64-bit compiler (e.g. Visual Studio), but since few people has access to such a compiler we have not tested this option. Perhaps mingw64 is now a viable option, but I'm not sure how useful it is now. Would be great if someone could test it. . Binary builds for 32 and 64 conda packages for windows would be highly desirable in my opinion. I have once created a conda package for qutip (https://github.com/conda/conda-recipes/tree/master/qutip) ; so if someone got the development environment with the required compilers setup for windows it should be straightforward to build the packages.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-145857462:365,access,access,365,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-145857462,1,['access'],['access']
Security,"There are no test code for progress bars yet.; You will need to create a new test file: `qutip/tests/test_progressbar.py`. The test can be as simple as creating the bar, call `update`, call `finished` and check that the total time is a sensible value.; You could also use pytest to catch print with [capsys](https://docs.pytest.org/en/7.1.x/how-to/capture-stdout-stderr.html#accessing-captured-output-from-a-test-function) and confirm that something was printed when `update` / `finished` is called.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520:375,access,accessing-captured-output-from-a-test-function,375,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471949520,1,['access'],['accessing-captured-output-from-a-test-function']
Security,"This fails for python2.7 and it might also be related to older scipy version. I could not even install it locally in my python2.7 conda environment with scipy 0.15 as I get some compile errors for the `cy/brtools` module. One more reason to move to Python 3 and update scipy perhaps. @ajgpitch . If you have seen this error before with a conda env clashing with the Python GIL, please let me know,; ```; qutip/cy/brtools.pyx:98:51: Converting to Python object not allowed without gil; Traceback (most recent call last):; ```; The conda environment is as follows:; ```; # packages in environment at /Users/shahnawaz/miniconda3/envs/python2:; #; # Name Version Build Channel; blas 1.0 mkl; ca-certificates 2018.4.16 0 conda-forge; certifi 2018.4.16 py27_0 conda-forge; cython 0.28.3 py27_0 conda-forge; intel-openmp 2018.0.3 0; libgfortran 3.0.1 h93005f0_2; mkl 2018.0.3 1; ncurses 5.9 10 conda-forge; numpy 1.9.3 py27hb3dd696_3; numpy-base 1.14.3 py27ha9ae307_2; openblas 0.2.20 8 conda-forge; openssl 1.0.2o 0 conda-forge; pip 9.0.3 py27_0 conda-forge; python 2.7.15 0 conda-forge; qutip 4.3.0.dev0+2a849f2e <pip>; readline 7.0 0 conda-forge; scipy 0.15.1 np19py27_0; setuptools 39.2.0 py27_0 conda-forge; sqlite 3.20.1 2 conda-forge; tk 8.6.7 0 conda-forge; wheel 0.31.0 py27_0 conda-forge; zlib 1.2.11 h470a237_3 conda-forge; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/861#issuecomment-396111344:691,certificate,certificates,691,https://qutip.org,https://github.com/qutip/qutip/pull/861#issuecomment-396111344,1,['certificate'],['certificates']
Security,"This is just a test. ; Since many failed Travis builds had a malloc error, also according to [this StackOverflow thread](https://stackoverflow.com/questions/19840671/malloc-error-incorrect-checksum-for-freed-object-object-was-probably-mod/19841133) it seemed that XCode was the source of the problem. . I added as osx environment in the travis configuration file xcode 10.2 (should be on osx 10.14 Mojave, not sure though). Build still fails, now at ; ```; Qobj subtraction ... python(2491,0x1192585c0) malloc: Incorrect checksum for freed object 0x7ffe6ff1ad50: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(2491,0x1192585c0) malloc: *** set a breakpoint in malloc_error_break to debug; /Users/travis/.travis/functions: line 104: 2491 Abort trap: 6 nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; The command ""nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip"" exited with 134.; ```; which seems a pretty basic test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/985#issuecomment-485054530:189,checksum,checksum-for-freed-object-object-was-probably-mod,189,https://qutip.org,https://github.com/qutip/qutip/pull/985#issuecomment-485054530,2,['checksum'],"['checksum', 'checksum-for-freed-object-object-was-probably-mod']"
Security,"This latest commit 77c21f8 fixes several bugs in the testing of `qutip.qip.operations.gates` - see the commit message for more details. (Force-pushed a new version of it to increase the commit hash references by one character, so GitHub would pick them up and link them.). We should also add tests that the explicit forms of the gates are correct (comparing to hard-coded arrays) in their base forms. These tests should never really fail, but they should be there as a fail-safe sanity check against somebody changing things in that module in the future.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-593333553:193,hash,hash,193,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-593333553,1,['hash'],['hash']
Security,"We can't implement `__hash__` for `Qobj`, sorry - it's just not possible while following the [Python data model](https://docs.python.org/3/reference/datamodel.html#object.__hash__). The two principle points that a hash function must follow from there are; 1. objects which compare equal with `__eq__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs an",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:214,hash,hash,214,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,6,['hash'],"['hash', 'hashable', 'hashing']"
Security,"We have decided not to continue to maintain the Ubuntu channel. Please; install from source to using qutip 3.2.; Alternatively you can use the conda-forge channel if you are able to work; with qutip 3.1. On 9 May 2016 at 02:52, Qi notifications@github.com wrote:. > There doesn't seem to be the package released under Ubuntu 16.04 channel.; > After I added the Ubuntu PPA for QuTiP, I got the following error/warning:; > ; > qxd@ubuntu1604$: sudo apt-get update; > ...; > W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; > N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; > N: See apt-secure(8) manpage for repository creation and user configuration details.; > E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; > E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; > ; > Thanks for maintaining it :); > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/472",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/472#issuecomment-218122293:639,authenticat,authenticated,639,https://qutip.org,https://github.com/qutip/qutip/issues/472#issuecomment-218122293,2,"['authenticat', 'secur']","['authenticated', 'secure']"
Security,"Yeah, Google will just update itself over time, I think - the http links aren't dead, they just redirect through to the https ones (or at least they will when I force https access from tomorrow). There's a similar PR on the website (qutip/qutip.github.io#145) to fix links there as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1555#issuecomment-840558024:173,access,access,173,https://qutip.org,https://github.com/qutip/qutip/pull/1555#issuecomment-840558024,1,['access'],['access']
Security,"Yeah, this is a ""true"" merge of the qutip-doc repository with this one. Technically all the commits have been rewritten (you'll find that the hashes won't match between the repositories), but they'll all be credited to the same authors on GitHub. Everyone will actually get the credit ""twice"" - once for the archived qutip/qutip-doc repo, and once for the new commit object in here. If anybody was in the habit of signing their commits with a private key, that will have been lost, but the only people that's likely to have affected are me and the GitHub merge bot. It doesn't mean anything in the greater scheme of things, because I've signed the merge commit. (signing is mostly just a way of verifying that the author really was who it says it was). *edit:* I checked, the only two types of signed commits in qutip/qutip-doc are those from me and those from the GitHub bot. Answers:; - I'll migrate all open issues on qutip-doc into the qutip/qutip repository, and tag them with a ""docs"" tag. GitHub has a built-in mechanism to migrate issues.; - We'll archive it, posting a message on the front page of it (or the README if GitHub doesn't have a separate mechanism). We need to leave the repository up and available on the web, because old documentation refers to it in links.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1513#issuecomment-830106458:142,hash,hashes,142,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-830106458,1,['hash'],['hashes']
Security,"`namedtuple` is not a bad idea, although it's a bit odd because `e_ops` is never a namedtuple and it doesn't solve the problem of what type `.e_ops` has. And `namedtuple` forbids attributes which aren't identifiers, which is also problematic. I guess we could write our own type, `Expect`, that acts enough like a list for numpy, etc but still allows item and attribute access. That feels a bit crazy, but maybe it is worth it?. I still feel that all of these options are overly complicated. `e_ops` is not a list conceptually. Lists are typically ordered, but unstructured. The `e_ops` are clearly not ordered because `e_ops[0]` doesn't ""come before"" `e_ops[1]` in any meaningful way. The order of the indexes in a list `e_ops` are meaningless -- they exist only because that is how Python lists work. *Sometimes* there may be a natural ordering to e_ops -- e.g. if they happen to be the projectors onto a complete set of basis elements -- but this a small subset of the more general situation where e_ops might be any set of operators and functions. I do see that you feel lists are the most important case though, so it would be good to support them well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1142339185:370,access,access,370,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1142339185,1,['access'],['access']
Security,"`traj_states` property added to result object. This is just `states` unless `average_states` is used. When `average_states` is used then it is the original trajectory states. Sometimes it can be useful to access the original trajectory states. . `avg_states` property added to result object. This is the same as `states` when `average_states` is used, otherwise it is `None`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547751565:205,access,access,205,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547751565,1,['access'],['access']
Security,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:3520,expose,expose,3520,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742,1,['expose'],['expose']
Security,"building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_ext; > customize UnixCCompiler; > customize UnixCCompiler using build_ext; > building 'qutip.cy.spmatfuncs' extension; > compiling C sources; > C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2; > -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; >; > compile options:; > '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c'; > extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; > gcc: qutip/cy/src/zspmv.c; > qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or; > directory; > #include <complex.h>; > ^; > compilation terminated.; > qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or; > directory; > #include <complex.h>; > ^; > compilation terminated.; > error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectoriz",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:4561,secur,security,4561,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['secur'],['security']
Security,"da3/include/python3.5m/Python.h:11, from; > qutip/cy/spmatfuncs.c:27:; > /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61:; > fatal error: limits.h: No such file or directory #include_next; > <limits.h> /* recurse down to the real one */ ^ compilation; > terminated. In file included from; > /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; > from; > /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; > from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11, from; > qutip/cy/spmatfuncs.c:27:; > /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61:; > fatal error: limits.h: No such file or directory #include_next; > <limits.h> /* recurse down to the real one */ ^ compilation; > terminated. error: Setup script exited with error: Command ""gcc; > -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes; > -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC; > -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c; > qutip/cy/spmatfuncs.c -o; > build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3; > -march=native -funroll-loops"" failed with exit status 1|; >; > Then, I cloned the qutip/qutip repository, and tried to build a wheel; > with |python setup.py bdist_wheel| under the qutip directory. Which; > gave me the following log:; >; > `running bdist_wheel; > running build; > running config_cc; > unifing config_cc, config, build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:2260,secur,security,2260,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['secur'],['security']
Security,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:3150,encrypt,encrypt,3150,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563,1,['encrypt'],['encrypt']
Security,"ers of files, doing different work before and after will all cause the segfault to change, and may mask it.; - As annoying as they are, segfaults are actually the _good_ case of the bug - the worst is when we have invalid memory writes but _no_ segfault, because then we have memory corruption that's gone undetected. ## Thoughts about #1120. This issue is still present using Andrew's `Malloc.py` file as of the current master branch (commit 624405e7), and is in QuTiP 4.6.0 and most previous versions. I have been able to reproduce the segfaults with Python 3.7, but not Python 3.8, and I can reproduce it with all allowable values of `PYTHONMALLOC`. The most telling is `pymalloc_debug`, where the entire operation completes (it prints ""500""), and _then_ the fault occurs. This along with the error message should hopefully make it clear that an out-of-bounds write occurs occasionally, and it is temperamental where exactly this happens. This is typically not detected until the object is freed, when the Python allocators do a little bit of checksumming. I think that in _all_ cases we're seeing the failure come from the garbage collection, but I can't be 100% certain - note that this almost certainly means the failure is somewhere completely different, and it's only _detected_ at garbage collection. Here is the output of a Python 3.8 crash on the `Malloc.py` file with some additional debugging enabled. This is with Python 3.8.8, Numpy 1.19.2, Scipy 1.6.2 and MKL:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler Malloc.py; 500; Debug memory block at address p=0x7fa2e02de610: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7fa2e02ed64f are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:2325,checksum,checksumming,2325,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['checksum'],['checksumming']
Security,functools_lru_cache; - blas; - bleach; - bwidget; - bzip2; - c-ares; - ca-certificates; - cairo; - certifi; - cffi; - chardet; - cloudpickle; - compiler-rt; - constantly; - cryptography; - curl; - cycler; - cython; - dbus; - decorator; - defusedxml; - docutils; - entrypoints; - expat; - fastcache; - flake8; - fontconfig; - freetype; - fribidi; - gast; - gettext; - glib; - gmp; - gmpy2; - graphite2; - grpcio; - gsl; - h5py; - harfbuzz; - hdf5; - html5lib; - icu; - idna; - imagesize; - intel-openmp; - ipykernel; - ipython; - ipython_genutils; - isort; - jbig; - jedi; - jinja2; - jpeg; - jsonschema; - jupyter_client; - jupyter_contrib_core; - jupyter_contrib_nbextensions; - jupyter_core; - jupyter_highlight_selected_word; - jupyter_latex_envs; - jupyter_nbextensions_configurator; - keras-applications; - keras-preprocessing; - keyring; - krb5; - lazy-object-proxy; - libcurl; - libcxx; - libcxxabi; - libedit; - libffi; - libgcc; - libgfortran; - libiconv; - libopenblas; - libpng; - libprotobuf; - libsodium; - libssh2; - libtiff; - libxml2; - libxslt; - llvm; - llvm-openmp; - lxml; - make; - markdown; - markupsafe; - matplotlib; - mccabe; - mistune; - mkl; - mkl_fft; - mkl_random; - mock; - mpc; - mpfr; - mpmath; - nbconvert; - nbformat; - ncurses; - nomkl; - notebook; - numpy; - numpy-base; - numpydoc; - olefile; - openblas; - openblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python;,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:338,certificate,certificates,338,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563,1,['certificate'],['certificates']
Security,"g propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatev",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8552,access,accessible,8552,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['access'],"['access', 'accessible']"
Security,"ixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object tha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5588,access,access,5588,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['access'],['access']
Security,"mainly developed for users with issues compiling; (i.e. on Windows). Though things have moved on so much since we started; trying that as a solution. On 26 March 2017 at 02:01, Paul Nation <notifications@github.com> wrote:. > Oh sorry, I thought you were reporting the sys gcc, not the conda one.; >; > Conda-forge and QuTiP are tested heavily against Ubuntu 14.04, so if any; > platform works, it should be that one.; >; > As I originally suspected, the problem comes from the Cython code.; > Specifically for the sparse matrix math. The fact that you can build it; > yourself suggests a binary incompatibility. However, again, we test; > against 14.04, so I am hard pressed to think about what the issue could be.; > gdb might be able to hunt down where the dump occurs.; >; > On Mar 25, 2017 18:27, ""Michael Goerz"" <notifications@github.com> wrote:; >; > Since it's the python from the conda package, I'm assuming that's because; > Continuum created the linux package on a Redhat system. GCC is identified; > like that on both of the workstations. But yeah, my guess would be that; > there is some shared library that's compiled in a way that's incompatible; > with the rest of the system. Is there any linux utility that would allow to; > determine which library is being accessed at the moment of the crash? Some; > invocation of ldd?; >; > —; > You are receiving this because you commented.; >; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/674#issuecomment-289249308>, or; > mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/ABMPqT0F1WSzbd-; > hOyso9XQM0K5ldiiwks5rpbEBgaJpZM4MpI4Z>; > .; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/674#issuecomment-289250540>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AIxX7avUu3PEQJN5JidXFS1DT4HHW3g_ks5rpbjngaJpZM4MpI4Z>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-289852411:1504,access,accessed,1504,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-289852411,1,['access'],['accessed']
Security,"me out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the under",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:9849,access,accessible,9849,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,1,['access'],['accessible']
Security,"ns; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; >; > compile options:; > '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c'; > extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; > gcc: qutip/cy/src/zspmv.c; > qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or; > directory; > #include <complex.h>; > ^; > compilation terminated.; > qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or; > directory; > #include <complex.h>; > ^; > compilation terminated.; > error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2; > -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c; > qutip/cy/src/zspmv.c -o; > build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3; > -march=native -funroll-loops"" failed with exit status 1`; >; > Well, all of them seem to fail with a similar issue. Whatever is exit; > status 1. (This; > <http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c> ; >; > is the SO solution I followed, it claims that error code is related to; > operation not permitted or setuptools not being installed. I upgraded; > the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:5627,secur,security,5627,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['secur'],['security']
Security,"rator we're looking for. `G` is anti-Hermitian, and so it shares its eigensystem (up to scaling of the eigenvalues) with the Hermitian `i G` and consequently is diagonalised by a unitary formed of its eigenvectors. Now `S = i G / abs(alpha)` is a tridiagonal Hermitian, and with a similarity transformation we can find a _real-symmetric_ tridiagonal `T = P^-1 . S . P` for some diagonal unitary `P` (which is easy to calculate). The reason for scaling out `alpha` here should become clear at the end. The main diagonal of `T` is all zeros, and the first sub- and super-diagonals look like; ```[sqrt(1), -sqrt(2), sqrt(3), -sqrt(4), ...]```; and the diagonal of `P` looks like; ```[i, e^(-1i arg(alpha)), i e^(-2i arg(alpha)), e^(-3i arg(alpha)), ...]```. Now this real-symmetric tridiagonal form is the basis of Hermitian eigenvalue solvers, and has direct entry points in LAPACK (e.g. `?stemr`), which allow us to pass only the main diagonal and the first subdiagonal. Scipy provides convenient wrapped access in Python by `scipy.linalg.eigh_tridiagonal`. This lets us get the full eigensystem of `T`, which is related to that of `G` by dividing the eigenvalues by the scaling factor, and multiplying the eigenvectors by `P` to transform them into the correct basis. We now have a diagonalised matrix `G = Q^-1 . D . Q`, so `exp(G) = Q^-1 . exp(D) . Q`, which is now trivial because `D` is diagonal. Putting all this together allows us to use our knowledge of the problem domain to convert the matrix exponentiation problem into a much simpler real-symmetric tridiagonal eigensystem problem, which gets us a nice big speed up, and it's equivalent up to the tolerance of the eigenvalue solver (~1e-14). Even better for you, a lot of the hard work is done in the eigensystem solver, and I scaled out `alpha` at the start, so we can do a good chunk _without fixing alpha_. That means we can pay the computational cost only once at the start, and then get faster calculations from then on. If I make a t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293#issuecomment-645685030:1361,access,access,1361,https://qutip.org,https://github.com/qutip/qutip/issues/1293#issuecomment-645685030,1,['access'],['access']
Security,"rds, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:3387,access,access,3387,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,1,['access'],['access']
Security,"tate, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. For users who don't need all this low-level behaviour, there'll still be the convenient `mesolve`, which just keeps working the same way it does now. For users (like you) who need more, we'll expose all the inner logic of the `mesolve` loop as separate components, so you'll still get all the nice set-up utilities if you want them, but you'll also then just be able to run the inner loop yourself. Since everything is modular, you'll have access to modify _everything_ that `mesolve` can access, so we won't need to define a specific, awkward API, and you can change it in whatever programming style you like, and is appropriate for your use case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:3515,expose,expose,3515,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,3,"['access', 'expose']","['access', 'expose']"
Security,"urrent noise in a DQD model; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_countstat.py"", line 73, in test_dqd_current; rhoss = steadystate(L); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\steadystate.py"", line 290, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\steadystate.py"", line 460, in _steadystate_direct_sparse; weighted_matching=ss_args['weighted_matching']); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 393, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 170, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000099EC80F8. ======================================================================; ERROR: MKL spsolve : Hermitian (real) solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_mkl.py"", line 230, in test_mkl_spsolve10; y = mkl_spsolve(A, b, hermitian=1); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 414, in mkl_spsolve; lu.delete(); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 208, in delete; byref(c_int(0)), np_error); OSError: exception: access violation reading 0x00000006FFFFFFEF. ======================================================================; ```; Enviroment:; ```; QuTiP Version: 4.4.0.dev0+73a27",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/975#issuecomment-483000016:1222,access,access,1222,https://qutip.org,https://github.com/qutip/qutip/issues/975#issuecomment-483000016,1,['access'],['access']
Testability," (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1703,log,logger,1703,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['log'],['logger']
Testability," + N = int(N); > + rho = np.zeros((2**N, 2**N)); > + for i in range(0, 2**N):; > + rho[i, i] = 1; > +; > + spin_dim = [2 for i in range(0, N)]; > + spins_dims = list((spin_dim, spin_dim)); > + identity = Qobj(rho, dims = spins_dims); > +; > + return identity; > +; > +# Uncoupled states in the full Hilbert space.; >; > Some of these 'uncoupled' functions are defined as internal others; > external. It's not clear to me why; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168801755>:; >; > > @@ -0,0 +1,309 @@; > +""""""; >; > why not put this file in qutip/tests. Will this file still be picked up by; > nose?; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802341>:; >; > > @@ -0,0 +1,1325 @@; > +""""""; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802444>:; >; > > @@ -0,0 +1,309 @@; > +""""""; > +Tests for Permutation Invariance methods; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802965>:; >; > > + num_ladders = _num_dicke_ladders(N); > + jm_operator = dok_matrix((nds, nds)); > +; > + s = 0; > + for k in range(0, num_ladders):; > + j = 0.5 * N - k; > + mmax = int(2 * j + 1); > + for i in range(0, mmax):; > + m = j - i; > + if (s - 1) in range(0,nds):; > + jm_operator[s,s-1] = am(j,m+1); > + s = s + 1; > +; > + return Qobj(jm_operator); > +; > +def ap( j, m):; >; > no space before j; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#di",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-366305610:8034,test,tests,8034,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-366305610,1,['test'],['tests']
Testability," -----------; >; > heading. It formats nicely in the docs; > see:; > http://qutip.org/docs/latest/apidoc/functions.html#quantum-states; > file qutip.states.py; > for example; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168800674>:; >; > > + -------; > + identity: Qobj matrix (QuTiP class); > + With the correct dimensions (dims); > + """"""; > + N = int(N); > + rho = np.zeros((2**N, 2**N)); > + for i in range(0, 2**N):; > + rho[i, i] = 1; > +; > + spin_dim = [2 for i in range(0, N)]; > + spins_dims = list((spin_dim, spin_dim)); > + identity = Qobj(rho, dims = spins_dims); > +; > + return identity; > +; > +# Uncoupled states in the full Hilbert space.; >; > Some of these 'uncoupled' functions are defined as internal others; > external. It's not clear to me why; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168801755>:; >; > > @@ -0,0 +1,309 @@; > +""""""; >; > why not put this file in qutip/tests. Will this file still be picked up by; > nose?; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802341>:; >; > > @@ -0,0 +1,1325 @@; > +""""""; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802444>:; >; > > @@ -0,0 +1,309 @@; > +""""""; > +Tests for Permutation Invariance methods; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802965>:; >; > > + num_ladders = _num_dicke_ladders(N); > + jm_operator = dok_matrix((nds, nds)); > +; ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-366305610:7621,test,tests,7621,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-366305610,1,['test'],['tests']
Testability," -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25360,test,tests,25360,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability," ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sparse.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_spinchain.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_spmath.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_states.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_steadystate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_stochastic_me.py - AttributeError: module 'qutip' has no ...; ERROR ../tests/test_stochastic_se.py - AttributeError: module 'qutip' has no ...; ERROR ../tests/test_subsys_apply.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_superop_reps.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_superoper.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_td_formats.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_tensor.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_three_level.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_utilities.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_wigner.py - AttributeError: module 'qutip' has no attribu...; !!!!!!!!!!!!!!!!!!! Interrupted: 65 errors during collection !!!!!!!!!!!!!!!!!!!; ======================== 2 warnings, 65 errors in 2.53s ========================; The command ""pytest --verbosity=1 --d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:55249,test,tests,55249,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability," ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sparse.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_spinchain.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_spmath.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_states.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_steadystate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_stochastic_me.py - AttributeError: module 'qutip' has no ...; ERROR ../tests/test_stochastic_se.py - AttributeError: module 'qutip' has no ...; ERROR ../tests/test_subsys_apply.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_superop_reps.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_superoper.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_td_formats.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_tensor.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_three_level.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_utilities.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_wigner.py - AttributeError: module 'qutip' has no attribu...; !!!!!!!!!!!!!!!!!!! Interrupted: 65 errors during collection !!!!!!!!!!!!!!!!!!!; ======================== 2 warnings, 65 errors in 2.53s ========================; The command ""pytest --verbosity=1 --disable-pytest-warnings --cov=qutip --pyargs qutip"" exited with 2.; Done. Your buil",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:55331,test,tests,55331,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability, /opt/local/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/qutip-4.5.0.dev0+3421bc5c-py3.8-macosx-10.15-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_op,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:1929,log,logger,1929,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,1,['log'],['logger']
Testability, 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_expect.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_fastsparse.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_fileio.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_floquet.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_gates.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_graph.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_heom_solver.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - Att,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:51477,test,tests,51477,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability," 50-branch `if/elif` (in the bad cases) based on the name. `QubitCircuit` shouldn't need the million `_gate_resolved` functions - if there's a `Gate` class, instances of that (whether done by subclass or composition) should be supplying it (though the lookup table is a good choice under the circumstances). Given how `circuit.py` currently organises its data, it feels like you have to introduce some seemingly arbitrary splits to keep CodeClimate happy, but I'd argue the problem is the data structure, and CodeClimate is right to complain about the complexity. In stuff like compilers, there's a reason code compilers do parsing->verification->optimisation, with several passes in the last one, and transform things internally into a very strict intermediate representation at every step. `Qobj._repr_latex_` was like this - the `master` version is claimed to be like ""78"" complexity, but I'd be prepared to bet CodeClimate would have the `dev.major` version less than 10 and I think the output is near byte-for-byte identical. The change is that the `master` version basically reimplements the same algorithm 4 times with complex, split up for loops (not to mention that for some reason the alignment and new-line characters are considered part of formatting a number?). The `dev.major` version first decides if it's going to truncate the rows and/or columns, then it just calls a formatter on each row it decided it wants rendering with a special value to say when it should output a truncation character, and then joins the rows together. Obviously it's not _always_ the data structure - e.g. in `propagator` the branching to choose an evaluation method is fine, but once it's chosen, it should delegate to specialised methods. That way, the maintainer can verify the branching paths with a nice top-down overview without 50 lines of specialised logic inbetween each one, then you can verify each specialised path independently. If you did that, I'm sure the ""complexity"" would drop to like 10.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-782249555:3302,log,logic,3302,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-782249555,1,['log'],['logic']
Testability," = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1544,test,tested,1544,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,1,['test'],['tested']
Testability," = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25814,test,tests,25814,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability," = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25898,Test,TestJCModelEvolution,25898,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['Test'],['TestJCModelEvolution']
Testability," AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_brmesolve_td.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_brtools.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_control_pulseoptim.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_correlation.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:2577,test,tests,2577,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_dimensions.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_eigenstates.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_enr_state_operator.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_entropy.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:5888,test,tests,5888,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_operators.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_parallel.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ____________ ERROR collecting qutip/tests/test_partial_transpose.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_piqs.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:13930,test,tests,13930,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1612,log,logger,1612,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['log'],['logger']
Testability," Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Checks that mul and tensor of skew-Hermitian operators report `isherm = True`. ... ok; > > > Tensor: Checks that super_tensor correctly tensors on underlying spaces. ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... ok; > > > Steady state: Thermal harmonic oscillator ... ok; > > > Steady state: Driven cavity ... ok; > > > Stochastic: smesolve: photo-current ... ok; > > > Stochastic: smesolve: homodyne ... ok; > > > Stochastic: smesolve: heterodyne ... ok; > > > Stochastic: ssesolve: photo-current ..",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:8822,Test,Test,8822,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['Test'],['Test']
Testability," Could this issue perhaps be broken into sub-tasks in some way, perhaps, in order to enable work starting on it a bit more feasible?. Also, I can see it's been labelled as a ""good first issue"" but it seems to me the definition of done (i.e., what would a PR - or a set of PRs - that would successfully address the problem entail?), with respect to the entire issue, could be clarified a bit further, and the breakdown into sub-tasks (which itself might result organically from some further discussion) might help a bit in that direction. Regarding possible approaches for handling randomness - I have to admit I've started looking into QuTiP only very recently, and I'm yet to start familiarising myself with its more intricate details and get to run the full set of tests, and investigate what kind of test failures occur. In the meantime, I'll generally share some (what I _think_ is) relevant experience in the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on tho",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:967,test,tests,967,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,['test'],"['testing', 'tests']"
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_control_pulseoptim.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_correlation.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_countstat.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_cqed.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:3528,test,tests,3528,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ____________ ERROR collecting qutip/tests/test_partial_transpose.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_piqs.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_propagator.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_ptrace.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:14879,test,tests,14879,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_me.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_se.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_subsys_apply.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_superop_reps.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:25284,test,tests,25284,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_se.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_subsys_apply.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_superop_reps.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_superoper.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:25757,test,tests,25757,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_subsys_apply.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_superop_reps.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_superoper.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_td_formats.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:26232,test,tests,26232,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_superop_reps.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_superoper.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_td_formats.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_tensor.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:26704,test,tests,26704,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_cy_structs.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_dimensions.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_eigenstates.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_enr_state_operator.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:5419,test,tests,5419,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_td_formats.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_tensor.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_three_level.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_utilities.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:27650,test,tests,27650,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_countstat.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_cqed.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_cy_structs.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_dimensions.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:4473,test,tests,4473,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_brtools.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_control_pulseoptim.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_correlation.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_countstat.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:3054,test,tests,3054,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_entropy.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_expect.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_fastsparse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_fileio.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:7311,test,tests,7311,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_random.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_rhs_reuse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_scattering.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:20555,test,tests,20555,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sp_eigs.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sparse.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_spinchain.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_spmath.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:22448,test,tests,22448,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_spmath.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_states.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_steadystate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_me.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:23866,test,tests,23866,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_tensor.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_three_level.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_utilities.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_wigner.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; !!!!!!!!!!!!!!!!!!! Interrupted: 60 errors du",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:28124,test,tests,28124,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_cqed.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_cy_structs.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_dimensions.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_eigenstates.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:4946,test,tests,4946,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_gates.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_graph.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_heom_solver.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_interpolate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:9676,test,tests,9676,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_graph.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_heom_solver.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_interpolate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mcsolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:10149,test,tests,10149,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_rand.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_random.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_rhs_reuse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_scattering.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:20083,test,tests,20083,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_mkl.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_openmp.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_operators.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_parallel.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ____________ ERROR collecting qutip/tests/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:12988,test,tests,12988,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_qpt.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _____________ ERROR collecting qutip/tests/test_qubit_evolution.py _____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_qubitcircuit.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_qubits.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:18189,test,tests,18189,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1297,test,test,1297,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075,7,"['log', 'test']","['logic', 'test', 'tests']"
Testability," corr., H td (fn td format) ... ok; correlation: comparing 3LS emission corr., c_ops td (str-list td format) ... ok; correlation: comparing 3LS emission corr., c_ops td (np-list td format) ... ok; correlation: comparing 3LS emission corr., c_ops td (fn-list td format) ... ok; correlation: comparing TLS emission corr. (str-list td format) ... ok; correlation: comparing TLS emission corr. (np-list td format) ... ok; correlation: comparing TLS emission corr. (fn-list td format) ... ok; Counting statistics: current and current noise in a DQD model ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; Cython structs : COO to CSR ... ok; Cython structs : sort CSR indices inplace ... ok; Cython structs : COO to CSR inplace (no sort) ... ok; Cython structs : COO to CSR inplace (sorted) ... ok; Cython structs : CSR to COO ... ok; qutip.tests.test_dimensions.test_flatten ... ok; qutip.tests.test_dimensions.test_enumerate_flat ... ok; qutip.tests.test_dimensions.test_deep_remove ... ok; qutip.tests.test_dimensions.test_unflatten ... ok; qutip.tests.test_dimensions.test_dims_idxs_to_tensor_idxs ... ok; qutip.tests.test_dimensions.test_dims_to_tensor_shape ... ok; qutip.tests.test_dimensions.test_type_from_dims ... ok; qutip.tests.test_dimensions.test_collapse ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:6511,test,tests,6511,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['test'],['tests']
Testability," could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being performed. . * I wonder whether `qobjevo_codegen.py` should stay there. It stands out from all other modules, also because in the other cases the title are self-explanatory. ; Regarding this comment:; ```; Function to build cython code from str, compile and import it.; Used by cQobjEvo.; cy/codegen.py does the same thing for specific solver; ```; could then this file by moved to `qutip/cy/`?. * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), block 24 online has a printed error `TypeError: __call__() got an unexpected keyword argument 'args'`, yet on my machine runs fine, it can be replaced. I opened a PR, also running the last blocks and qutip.about(), https://github.com/qutip/qutip-notebooks/pull/72. . * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), `Time ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:2002,test,tests,2002,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['test'],['tests']
Testability," excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Entropy: Conditional entropy ... ok; Entropy: Entangling power ... ok; expect: operator list and state list ... ok; expect: operator and density matrix ... ok; expect: operator and ket ... ok; expect: operator list and state ... ok; expect: operator list and state list ... ok; expect: operator and state list ... ok; fastsparse: fast_csr_matrix operations ... ok; fastsparse: transpose operations ... ok; fastsparse: adjoint operations ... ok; Read and write complex valued decimal formatted data ... ok; Read and write complex valued default formatted data ... ok; Read and write complex valued exp formatted data ... ok; Read and write real valued decimal formatted data ... ok; Read and write real valued default formatted data ... ok; Read and write real valued exp formatted data ... ok; Read and write with automatic separator detection ... ok; qsave/qload ... ok; Floquet: test unitary evolution of time-dependent two-level system ... ok; gates: expand 1 to N ... ok; gates: expand 2 to N (using cnot, iswap, sqrtswap) ... ok; gates: expand 2 to N (using swap) ... ok; gates: expand 3 to N (using toffoli, fredkin, and random 3 qubit gate) ... ok; gates: expand 3 to 3 with permuTation (using toffoli) ... ok; gates: swap gate ... ok; qutip.tests.test_gates.TestGates.test_are_cliffords ... ok; qutip.tests.test_gates.TestGates.test_clifford_group_len ... ok; Graph: Graph Degree ... ok; Graph: Breadth-First Search ... ok; Graph: Reverse Cuthill-McKee Ordering (simple) ... ok; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:8501,test,test,8501,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,5,"['Test', 'test']","['TestGates', 'test', 'tests']"
Testability, grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1137,test,tests,1137,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165,1,['test'],['tests']
Testability," line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 190, in test_04_1_state_with_list_str_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 64, in check_evolution; args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 191, in build_module; reload_support=pyxargs.reload_support); File ""C:\Users\MTS-144\Anaconda3\li",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:9122,test,tests,9122,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability," line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 245, in test_05_2_unitary_with_interp_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 67, in check_evolution; output = sesolve(H, U0, tlist, args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 191, in build_module; reload_support=pyxargs.reload_support); File",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:22678,test,tests,22678,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability," many many things in the same test function.; > ; > The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up.; > ; > With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead.; > ; > I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them.; > ; > Minor things that _may_ speed up - check the profiling!; > ; > 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; > 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements internally is effectively `tensor(...(tensor(tensor(els[0], els[1]), els[2]), ...), els[-1])`. Excellent Suggestions ! I already added some of the speed-ups you suggested, just haven't pushed them yet ! However, I think it might just be a better idea to go with Boxi's idea of removing the need for way too many runs in the first place !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273:1705,test,test,1705,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273,1,['test'],['test']
Testability," no attribute 'settings'; !!!!!!!!!!!!!!!!!!! Interrupted: 60 errors during collection !!!!!!!!!!!!!!!!!!!; =========================== 60 error in 1.85 seconds ===========================; (base) cln-232-18:qutip nathanshammah$; ```; this on the 4.4.0 release version. ; On the dev version, ; ```; (qdev) cln-232-18:qutip nathanshammah$ pytest; ============================= test session starts ==============================; platform darwin -- Python 3.7.3, pytest-5.0.1, py-1.8.0, pluggy-0.12.0; rootdir: /Users/nathanshammah/github/qutip; collected 561 items. qutip/tests/test_basis_transformation.py ........ [ 1%]; qutip/tests/test_brmesolve.py Fatal Python error: Fatal Python error: Segmentation fault: 11; (qdev) cln-232-18:qutip nathanshammah$ pytest; ============================= test session starts ==============================; platform darwin -- Python 3.7.3, pytest-5.0.1, py-1.8.0, pluggy-0.12.0; rootdir: /Users/nathanshammah/github/qutip; collected 561 items. qutip/tests/test_basis_transformation.py ........ [ 1%]; qutip/tests/test_brmesolve.py Fatal Python error: Segmentation fault: 11; ```; and with nosetests; ```; (qdev) cln-232-18:qutip nathanshammah$ nosetests; /miniconda3/envs/qdev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjCte size changed, may indicate binary incompatibility. Expected 344 from C header, got 352 from PyObject; return f(*args, **kwds); /miniconda3/envs/qdev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjEvoTd size changed, may indicate binary incompatibility. Expected 560 from C header, got 568 from PyObject; return f(*args, **kwds); /miniconda3/envs/qdev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjEvoTdMatched size changed, may indicate binary incompatibility. Expected 1344 from C header, got 1352 from PyObject; return f(*args, **kwds); /miniconda3/envs/qdev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:29992,test,tests,29992,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability," not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for picking this up. Me might be able to do a truly time-dependent test by running with a memory-less bath and comparing with mesolve, but I'd also like to leave that as future work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:1482,test,test,1482,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845,6,"['log', 'test']","['logic', 'test', 'tested', 'tests']"
Testability, qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content): Merge conflict in qutip/solve/countstat.py; CONFLICT (content): Merge conflict in qutip/solve/correlation.py; CONFLICT (content): Merge conflict in qutip/solve/_brtools.pyx; CONFLICT (content): Merge conflict in qutip/random_objects.py; CONFLICT (modify/delete): qutip/qobjevo.py delete,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1428,test,tests,1428,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165,1,['test'],['tests']
Testability," really getting annoying. I copied the error message from Travis bellow:; > ; > ```; > =================================== FAILURES ===================================; > ___________________________ test_MCSimpleConstStates ___________________________; > @pytest.mark.slow; > def test_MCSimpleConstStates():; > ""Monte-carlo: Constant H with constant collapse (states)""; > N = 10 # number of basis states to consider; > a = destroy(N); > H = a.dag() * a; > psi0 = basis(N, 9) # initial state; > kappa = 0.2 # coupling to oscillator; > c_op_list = [np.sqrt(kappa) * a]; > tlist = np.linspace(0, 10, 100); > mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; > options=Options(average_states=True)); > assert_(len(mcdata.states) == len(tlist)); > assert_(isinstance(mcdata.states[0], Qobj)); > expt = expect(a.dag() * a, mcdata.states); > actual_answer = 9.0 * np.exp(-kappa * tlist); > avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > > assert_equal(avg_diff < mc_error, True); > E AssertionError: ; > E Items are not equal:; > E ACTUAL: False; > E DESIRED: True; > ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; > ----------------------------- Captured stdout call -----------------------------; > 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; > 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; > 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; > 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; > 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; > 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; > 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; > 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; > 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; > 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; > Total run time: 20.34s; > ---------- coverage: platform darwin, python 3.7.7-final-0 -------",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896:1056,Assert,AssertionError,1056,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896,1,['Assert'],['AssertionError']
Testability," run the full set of tests, and investigate what kind of test failures occur. In the meantime, I'll generally share some (what I _think_ is) relevant experience in the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landsc",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:1781,mock,mock,1781,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,1,['mock'],['mock']
Testability," search_path, dry_run=dry_run); 37 elif os.name == 'nt':. ~/opt/anaconda3/lib/python3.7/distutils/spawn.py in _spawn_posix(cmd, search_path, verbose, dry_run); 148 ""command %r terminated by signal %d""; --> 149 % (cmd, os.WTERMSIG(status))); 150 elif os.WIFEXITED(status):. DistutilsExecError: command 'gcc' terminated by signal 6. During handling of the above exception, another exception occurred:. CompileError Traceback (most recent call last); ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 215 inplace=build_inplace, language_level=language_level); 216 mod = imp.load_dynamic(name, so_path). ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 190 inplace=inplace,; --> 191 reload_support=pyxargs.reload_support); 192 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. ~/opt/anaconda3/lib/python3.7/distutils/dist.py in run_commands(self); 965 for cmd in self.commands:; --> 966 self.run_command(cmd); 967 . ~/opt/anaconda3/lib/python3.7/distutils/dist.py in run_command(self, command); 984 cmd_obj.ensure_finalized(); --> 985 cmd_obj.run(); 986 self.have_run[command] = 1. ~/opt/anaconda3/lib/python3.7/site-packages/Cython/Distutils/old_build_ext.py in run(self); 185 ; --> 186 _build_ext.build_ext.run(self); 187 . ~/opt/anaconda3/lib/python3.7/distutils/command/build_ext.py in run(self); 339 # Now actually compile and link everything.; --> 340 self.build_extensions(); 341 . ~/opt/anaconda3",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1326#issuecomment-664714290:2636,assert,assert,2636,https://qutip.org,https://github.com/qutip/qutip/issues/1326#issuecomment-664714290,1,['assert'],['assert']
Testability," self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_rhs_reuse.py"", line 53, in test_rhs_reuse; out1 = qt.mesolve(H, psi0,tlist, e_ops=e_ops); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\mesolve.py"", line 336, in mesolve; e_ops, args, options, progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 191, in build_module; reload_support=pyxargs.reload_support); File ""C:\Use",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:4565,test,tests,4565,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability, test_sesolve.py::TestSESolve::test_04_1_state_with_list_str_H; 5.36s call test_mesolve.py::TestMESolveSuperInit::testSuperJC; 5.23s call test_parallel.py::test_serial_map; 5.11s call test_sesolve.py::TestSESolve::test_06_2_compare_state_and_unitary_func; 5.05s call test_partial_transpose.py::test_partial_transpose_comparison; 5.05s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Ising state-to-state-Qobj propagation]; 5.01s call test_qobj.py::test_dual_channel[sub_dimensions3]; 4.84s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsArray; 4.79s call test_parallel.py::test_parallel_map; 4.27s call test_spinchain.py::TestSpinChain::test_analytical_evo; 3.92s call test_stochastic_se.py::test_ssesolve_homodyne; 3.86s call test_correlation.py::TestTimeDependence::test_hamiltonian_from_function_2ls; 3.25s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsPartFuncList; 3.23s call test_control_pulseoptim.py::TestOptimization::test_unitarity_via_dump; 3.03s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[QFT-Qobj propagation]; 2.65s call test_control_pulseoptim.py::TestOptimization::test_crab[Qobj propagation]; 2.57s call test_wigner.py::test_wigner_compare_methods_dm; 2.46s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[Symplectic coupled oscillators-Qobj propagation]; 2.31s call test_parallel.py::test_parfor1; 2.11s call test_wigner.py::test_wigner_bell1_su2parity; 1.90s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[Ising state-to-state-Qobj propagation]; 1.86s call test_sparse.py::test_sp_profile; 1.66s call test_correlation.py::test_correlation_solver_equivalence[es-legacy]; 1.65s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Lindbladian amplitude damping channel-Qobj propagation]; 1.56s call test_correlation.py::test_correlation_solver_equivalence[es]; 1.43s call test_mesolve.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373:3321,Test,TestOptimization,3321,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373,1,['Test'],['TestOptimization']
Testability," use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a pa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:5333,log,logic,5333,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,1,['log'],['logic']
Testability," we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:995,Assert,Assertion,995,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,1,['Assert'],['Assertion']
Testability," ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyximport.py in load_module(self, fullname); 461 build_inplace=self.inplace,; --> 462 language_level=self.language_level); 463 return module. ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 if sys.version_info[0] >= 3:; --> 231 raise exc.with_traceback(tb); 232 else:. ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 215 inplace=build_inplace, language_level=language_level); 216 mod = imp.load_dynamic(name, so_path). ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 190 inplace=inplace,; --> 191 reload_support=pyxargs.reload_support); 192 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. ~/opt/anaconda3/lib/python3.7/site-packages/pyximport/pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. ~/opt/anaconda3/lib/python3.7/distutils/dist.py in run_commands(self); 965 for cmd in self.commands:; --> 966 self.run_command(cmd); 967 . ~/opt/anaconda3/lib/python3.7/distutils/dist.py in run_command(self, command); 984 cmd_obj.ensure_finalized(); --> 985 cmd_obj.run(); 986 self.have_run[command] = 1. ~/opt/anaconda3/lib/python3.7/site-packages/Cython/Distutils/old_build_ext.py in run(self); 185 ; --> 186 _build_ext.build_ext.run(self); 187 . ~/opt/anaconda3/lib/python3.7/distutils/command/build_ext.py in run(self); 339 # Now actually compile and link everything.; --> 340 self.build_extensions(); 341 . ~/opt/anaconda3",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1326#issuecomment-664714290:6228,assert,assert,6228,https://qutip.org,https://github.com/qutip/qutip/issues/1326#issuecomment-664714290,1,['assert'],['assert']
Testability,"""""""; .................................................................................................................................../Users/nathanshammah/github/qutip/qutip/control/optimizer.py:1070: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working; elif not isinstance(self.pulse_generator, collections.Iterable):; ..............................................................................................................................................................SSSSSS.......................................................................................................................Segmentation fault: 11. kills nosetests, which do not even start doing QuTiP's tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-496380658:780,test,tests,780,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-496380658,1,['test'],['tests']
Testability,"# Projects. Another option is to use the Projects section on GitHub, which I am testing for a couple of ongoing projects. The downside of this option is that only organization members / owners can add or edit projects. https://github.com/qutip/qutip/projects",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1132#issuecomment-563696592:80,test,testing,80,https://qutip.org,https://github.com/qutip/qutip/issues/1132#issuecomment-563696592,1,['test'],['testing']
Testability,"### New changelog. #### <code>test_krylovsolve.py</code>. * [x] We have <code>qutip.rand_herm</code> for a random hamiltonian. --> **Changed**; * [x] Isn't <code>h_sho</code> equivalent to <code>U=qutip.rand_unitary_haar(dim) \ return U* (qutip.num(dim)+0.5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:289,test,test,289,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,1,['test'],['test']
Testability,"#1212 . > > Thank you. Can you please add tests for this? I'm leaving to @BoxiLi a closer review.; > . By ""add tests"" we mean include tests in `qutip/tests'. See #1212 for example. @mlaguna10 please don't do this just now. We will give @MartinSandeCosta opportunity to do this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-605883973:42,test,tests,42,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-605883973,4,['test'],['tests']
Testability,"#1249 should be reviewed and merged before this (because if it needs changed, then this PR has to be rebased on top of it), but also I'm going to change the Clifford group tests a little, and rebase the typo fix commit into the general refactor before this one should be merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626315063:172,test,tests,172,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626315063,1,['test'],['tests']
Testability,"#1651 has been merged into dev.major and I've merged that back into this branch. Tests should still fail, but this branch is at least up to date again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1727#issuecomment-1017280259:81,Test,Tests,81,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1017280259,1,['Test'],['Tests']
Testability,"$ nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... ok; BR Tools : dense operator to eigenbasis ... ok; BR Tools : vector to eigenbasis ... ok; BR Tools : eigvector to fockbasis ... ok; BR Tools : vector roundtrip transform ... ok; BR Tools : Diagonal liouvillian mult ... ok; BR Tools : cop_super_mult ... ok; BR Tools : br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; co",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576:1176,test,tests,1176,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576,1,['test'],['tests']
Testability,"'s an example output:; ```; jake@tauros$ pytest tests/test_superop_reps.py; =========================================================================================== test session starts ============================================================================================; platform darwin -- Python 3.8.8, pytest-6.2.3, py-1.10.0, pluggy-0.13.1; rootdir: /Users/jake/code/qutip/qutip/qutip/tests, configfile: pytest.ini; plugins: rerunfailures-9.1.1; collected 15 items. tests/test_superop_reps.py ..F............ [100%]. ================================================================================================= FAILURES =================================================================================================; ____________________________________________________________________________________ TestSuperopReps.test_ChoiKrausChoi ____________________________________________________________________________________. self = <qutip.tests.test_superop_reps.TestSuperopReps object at 0x11f1140d0>. Fatal Python error: Segmentation fault. Current thread 0x000000010c77b5c0 (most recent call first):; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 312 in _optimize_charset; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 120 in _compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 607 in _code; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 768 in compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/re.py"", line 304 in _compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/re.py"", line 252 in compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pygments/lexer.py"", line 424 in _process_regex; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pygments/lexer.py"", line 495 in _process_state; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:1244,Test,TestSuperopReps,1244,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,1,['Test'],['TestSuperopReps']
Testability,(add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content): Merge conflict in qutip/solve/countstat.py; CONFLICT (content): Merge co,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1210,test,tests,1210,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165,1,['test'],['tests']
Testability,"(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24694,test,tests,24694,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,"):; else qeye(state.dims[0][j]); for j in range(len(state.dims[0]))]; full_oper = tensor(list(map(Qobj, op_iter_list))); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filena",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:22729,test,tests,22729,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,"); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:22825,test,tests,22825,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,"**Benchmarking**; The results of [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). * development-smesolve-milstein-speed-test.ipynb; * development-smesolver-new-methods.ipynb; * development-smesolve-tests.ipynb; * development-ssesolver-new-methods. all seem consistent with previous notebook results. **Time Benchmarking**; All the stochastic solvers in those notebooks now run much faster: between a factor 2 and 30 in speedup from last time I ran them, which was consistent with times obtained by @Ericgig and saved in the folder. . I am on Python 3.7.3, I recently updated OS from High Sierra to Mojave, plus some other updates in scipy and numpy, and reinstalled conda, so I am curious to see if these speedups are machine independent, which would be great. My specs; ```; Software	Version; QuTiP	4.4.0.dev0+e1639f73; Numpy	1.16.4; SciPy	1.2.1; matplotlib	3.1.0; Cython	0.29.8; Number of CPUs	2; BLAS Info	INTEL MKL; IPython	7.5.0; Python	3.7.3 (default, Mar 27 2019, 16:54:48) [Clang 4.0.1 (tags/RELEASE_401/final)]; OS	posix [darwin]; Mon Jun 10 21:16:02 2019 JST; ```; Some details:; In cell 6 of development-ssesolver-new-methods, the running time went from over 160 seconds to 6 seconds (x25 speedup). Total run time in cell 21 is now down to 14.22s from 79.46s, cell 24/25 of is now 1.4 seconds down from 14.22s in `smesolve`. `ssesolve` in cell 4 is down from 164.50s to 11.06s. Cell 6 is down to 11.48s from 250s. The next cell checking all solver methods in `ssesolve` is down from 80s to 24s. In the notebook with new smesolve methods, cell 11 with multiple time dependence in sc_ops now runs in 69s instead of 171s. . Also, the benchmarking of the different methods now reads; ```; {'solver': 'euler-maruyama'}; Total run time: 0.21s; Total run time: 0.25s; Total run time: 0.30s; Total run time: 0.38s; Total run time: 0.45s; Total run time: 0.55s; Total run time: 0.67s; Total run time: 0.81s; {'solver': 'platen'}; Total run time: 0.70s; Tota",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990#issuecomment-500396003:2,Benchmark,Benchmarking,2,https://qutip.org,https://github.com/qutip/qutip/pull/990#issuecomment-500396003,4,"['Benchmark', 'test']","['Benchmarking', 'test', 'tests']"
Testability,"**Summary of what was done:**. - Changes in floquet_master_equation_rates to make it faster.; - Corrected transposition errors in _floquet_master_equation_tensor_ and changes to make it faster. I also removed a line so that the ME is solved in the interaction picture, this implies a different basis change in the _floquet_markov_mesolve_ function.; - Correction in _floquet_markov_mesolve_. As explained in the point above, the Floquet-Markov ME was not being solved in the interaction picture, therefore I modified _floquet_master_equation_tensor_ and modified the basis change in _floquet_markov_mesolve_. This modification requires an additional variable in the entry of _floquet_markov_mesolve_ which can not be chosen by default. For the moment, if this variable is not given and _floquet_basis=False_, then the density matrix or expectation values are returned in the interaction picture, in the computational basis, and a warning message is sent. ; - Added integration options in: _floquet_modes, floquet_modes_t, floquet_modes_table, floquet_states_t, floquet_modes_t, floquet_wavefunction_t, fsesolve, floquet_master_equation_rates, fmmesolve_; - Added test functions to verify the dissipative dynamics:; a) Compare _fmmesolve_ and _mesolve_ for the cases: (NO drive but dissipation) and (Drive but NO dissipation); b) Compare numerical and analytical matrix elements for a driven-dissipative TLS with RWA. There are some places where the code could be modified to optimize the running time, especially in the basis change in _floquet_markov_mesolve_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949:1163,test,test,1163,https://qutip.org,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949,1,['test'],['test']
Testability,"+ identity = Qobj(rho, dims = spins_dims); > +; > + return identity; > +; > +# Uncoupled states in the full Hilbert space.; >; > Some of these 'uncoupled' functions are defined as internal others; > external. It's not clear to me why; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168801755>:; >; > > @@ -0,0 +1,309 @@; > +""""""; >; > why not put this file in qutip/tests. Will this file still be picked up by; > nose?; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802341>:; >; > > @@ -0,0 +1,1325 @@; > +""""""; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802444>:; >; > > @@ -0,0 +1,309 @@; > +""""""; > +Tests for Permutation Invariance methods; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168802965>:; >; > > + num_ladders = _num_dicke_ladders(N); > + jm_operator = dok_matrix((nds, nds)); > +; > + s = 0; > + for k in range(0, num_ladders):; > + j = 0.5 * N - k; > + mmax = int(2 * j + 1); > + for i in range(0, mmax):; > + m = j - i; > + if (s - 1) in range(0,nds):; > + jm_operator[s,s-1] = am(j,m+1); > + s = s + 1; > +; > + return Qobj(jm_operator); > +; > +def ap( j, m):; >; > no space before j; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168803599>:; >; > > +; > + if collective_emission != 0:; > + c_ops.append(np.sqrt(collective_emission) * jm); > +; > + if collective_dephasing != 0:; > + c_ops.append(np.sqrt(colle",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-366305610:8160,Test,Tests,8160,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-366305610,1,['Test'],['Tests']
Testability,"+1. Container-based testing on travis is the way to go, and qutip should make use of it as soon as possible. The speed issue could probably be fixed later, if necessary, but might also very well be fixed upstream. . BTW: Great work on this and other recent PRs!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/360#issuecomment-130548492:20,test,testing,20,https://qutip.org,https://github.com/qutip/qutip/pull/360#issuecomment-130548492,1,['test'],['testing']
Testability,"+1. This looks like a good PR to me. Just a quick note: We have had some side-effect issues when changing how isherm and other cached attributes are handled in the past, in particular with respect to performance. I used to monitor the performance over time with the continous-benchmarking suite in one of the respositories in the project, and that was sometimes useful to find unexpected performance hits. . Hopefully this PR will only improve performance, but it could still be worthwhile to check that for example the unit test suite does not take longer time on this branch than on master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130549106:276,benchmark,benchmarking,276,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130549106,2,"['benchmark', 'test']","['benchmarking', 'test']"
Testability,"+= c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23270,test,tests,23270,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,", -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25325,test,tests,25325,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,", ; > line 566, in sparse_reverse_permute; > A.indptr, nrows, ncols, rperm, cperm, flag); > File ""sparse_utils.pyx"", line 266, in ; > qutip.cy.sparse_utils./sparse/reverse_permute_complex ; > (qutip/cy/sparse_utils.c:5740); > ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; > ; > ```; > ERROR: Sparse: Nonsymmetric Reverse Permute; > ```; > ; > Traceback (most recent call last):; > File ; > ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", ; > line 198, in runTest; > self.test(*self.arg); > File ; > ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", ; > line 89, in test_sparse_nonsymmetric_reverse_permute; > B=sparse_reverse_permute(x,rperm,cperm); > File ; > ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", ; > line 566, in sparse_reverse_permute; > A.indptr, nrows, ncols, rperm, cperm, flag); > File ""sparse_utils.pyx"", line 266, in ; > qutip.cy.sparse_utils./sparse/reverse_permute_complex ; > (qutip/cy/sparse_utils.c:5740); > ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; > ; > ```; > ERROR: Sparse: Bandwidth; > ```; > ; > Traceback (most recent call last):; > File ; > ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", ; > line 198, in runTest; > self.test(*self.arg); > File ; > ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", ; > line 144, in test_sparse_bandwidth; > out2=sparse_bandwidth(B); > File ; > ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", ; > line 603, in sparse_bandwidth; > return /sparse/bandwidth(A.indices, A.indptr, nrows); > File ""sparse_utils.pyx"", line 42, in ; > qutip.cy.sparse_utils./sparse/bandwidth (qutip/cy/sparse_utils.c:1458); > ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; > ; > —; > Reply to this email directly or view it on GitHub ; > https://github.com/qutip/qutip/issues/73.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/73#issuecomment-35583331:2318,test,test,2318,https://qutip.org,https://github.com/qutip/qutip/issues/73#issuecomment-35583331,2,['test'],"['test', 'tests']"
Testability,", dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25849,test,tests,25849,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 226, in test_05_1_state_with_interp_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 64, in check_evolution; args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 191, in build_module; reload_support=pyxargs.reload_support); File ""C:\Users\MTS-144\Anaconda3\lib",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:18167,test,tests,18167,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability,"- 1, 2: Solvers expect list, not tuple. In a few places, we do not explicitly test for list but only extract the elements, so tuple should behave the same, but it's untested. In my tries with `mesolve` they seems to behave the same or raise error. - 3: `c_ops=[C_0, C_1, [(\hat{a}, f(t)), (\hat{b}, c(t))]]` should work in `mesolve` with `[(\hat{a}, f(t)), (\hat{b}, c(t))]` as the third collapse operator.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2065#issuecomment-1408604158:78,test,test,78,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1408604158,1,['test'],['test']
Testability,- All builds fail a test regarding optimal control in `` fails with `AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'`.; - The MacOs build still exits with an error once it encounters `ptrace`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/972#issuecomment-484364190:20,test,test,20,https://qutip.org,https://github.com/qutip/qutip/pull/972#issuecomment-484364190,2,"['Test', 'test']","['TestPulseOptim', 'test']"
Testability,- QuTiP already has some interpolation functions that can be compiled down into Cython. Is there some reason we need new ones? Does the new solver support the current interp functions?. - I don't see any changes / additions to unit tests. Are these still coming?. - The new `td_qobj` objects should be able to be passed to all the solvers. This is most easily done by just looking for a `td_qobj` instance and then grabbing the `Q_object` from it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/774#issuecomment-344648478:232,test,tests,232,https://qutip.org,https://github.com/qutip/qutip/pull/774#issuecomment-344648478,1,['test'],['tests']
Testability,"--- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26311,test,tests,26311,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,----------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_expect.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_fastsparse.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_fileio.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_floquet.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_gates.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_graph.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_heom_solver.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mcsolve.py - Att,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:51559,test,tests,51559,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,--------------------------------------------------; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py 150 97 35%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/tes,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:49918,test,test-environment,49918,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,---------; Name Stmts Miss Cover; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py 150 97 35%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ====================,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:49763,test,test-environment,49763,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,---------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_expect.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_fastsparse.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_fileio.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_floquet.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_gates.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_graph.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_heom_solver.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mcsolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mesolve.py - Attribu,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:51641,test,tests,51641,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_expect.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_fastsparse.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_fileio.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_floquet.py - At,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:51067,test,tests,51067,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,-linux-x86_64.egg/qutip/__init__.py 150 97 35%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:50073,test,test-environment,50073,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,"-linux-x86_64.egg/qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined; During handling of the above exception, another exception occurred:; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ---------- coverage: platform linux, python 3.6.10-final-0 -----------; Name Stmts Miss Cover; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py 150 97 35%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:49142,test,test-environment,49142,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,"... ok; correlation: comparing 3LS emission corr., c_ops td (np-list td format) ... ok; correlation: comparing 3LS emission corr., c_ops td (fn-list td format) ... ok; correlation: comparing TLS emission corr. (str-list td format) ... ok; correlation: comparing TLS emission corr. (np-list td format) ... ok; correlation: comparing TLS emission corr. (fn-list td format) ... ok; Counting statistics: current and current noise in a DQD model ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; Cython structs : COO to CSR ... ok; Cython structs : sort CSR indices inplace ... ok; Cython structs : COO to CSR inplace (no sort) ... ok; Cython structs : COO to CSR inplace (sorted) ... ok; Cython structs : CSR to COO ... ok; qutip.tests.test_dimensions.test_flatten ... ok; qutip.tests.test_dimensions.test_enumerate_flat ... ok; qutip.tests.test_dimensions.test_deep_remove ... ok; qutip.tests.test_dimensions.test_unflatten ... ok; qutip.tests.test_dimensions.test_dims_idxs_to_tensor_idxs ... ok; qutip.tests.test_dimensions.test_dims_to_tensor_shape ... ok; qutip.tests.test_dimensions.test_type_from_dims ... ok; qutip.tests.test_dimensions.test_collapse ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Ent",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:6620,test,tests,6620,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['test'],['tests']
Testability,../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sparse.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_spinchain.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_spmath.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_states.py - Attrib,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:54101,test,tests,54101,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,./tests/test_gates.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_graph.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_heom_solver.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mcsolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_metrics.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mkl.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_noise.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_openmp.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py ,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:53117,test,tests,53117,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,./tests/test_heom_solver.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mcsolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_metrics.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mkl.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_noise.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_openmp.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - Attribu,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:53281,test,tests,53281,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,".36s; Total run time: 5.51s; Total run time: 6.58s; Total run time: 9.64s; Total run time: 10.74s; Total run time: 12.29s; {'solver': 'pc-euler-2'}; Total run time: 1.54s; Total run time: 1.86s; Total run time: 2.50s; Total run time: 2.79s; Total run time: 3.36s; Total run time: 4.03s; Total run time: 4.98s; Total run time: 6.56s; {'solver': 'explicit1.5'}; Total run time: 5.28s; Total run time: 6.35s; Total run time: 7.74s; Total run time: 8.99s; Total run time: 10.34s; Total run time: 12.41s; Total run time: 15.40s; Total run time: 21.40s; {'solver': 'taylor1.5'}; Total run time: 3.30s; Total run time: 3.85s; Total run time: 4.52s; Total run time: 5.63s; Total run time: 7.22s; Total run time: 8.72s; Total run time: 9.51s; Total run time: 11.84s; {'solver': 'taylor1.5-imp'}; Total run time: 5.43s; Total run time: 6.81s; Total run time: 7.60s; Total run time: 10.05s; Total run time: 11.88s; Total run time: 12.88s; Total run time: 15.63s; Total run time: 22.31s. ```; ; **Minor issue: plots breaking notebook rendering**; Jupyter Notebooks have a broken rendering when cells with plots are run; refreshing the notebook sometimes works fine. This is sometimes fixed in the first place by adding; ```; plt.show(); plt.close(); ```; but not always. Maybe we can have a look at this minor issue in the development notebooks. . **Documentation**; It would really increase the adoption rate if the API doc and User Guide could be updated to highlight the stochastic solvers and new methods. The development notebooks are so well written that drawing from their examples should be simple. . Congratulations @Ericgig for this refurbishment, improvement, optimization and thorough benchmarking investigations of the stochastic solvers, which I hope will be widely tested by @nwlambert @ajgpitch @quantshah (and @fminga) for robustness once merged in the development master branch. I am merging this and the montecarlo split PR, hoping there are no incompatibility issues (#990 --> #991 --> #969).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990#issuecomment-500396003:6267,benchmark,benchmarking,6267,https://qutip.org,https://github.com/qutip/qutip/pull/990#issuecomment-500396003,2,"['benchmark', 'test']","['benchmarking', 'tested']"
Testability,.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:50776,test,tests,50776,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,".py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjEvoTd size changed, may indicate binary incompatibility. Expected 560 from C header, got 568 from PyObject; return f(*args, **kwds); /Users/nathanshammah/miniconda3/envs/qutip44/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjEvoTdMatched size changed, may indicate binary incompatibility. Expected 1344 from C header, got 1352 from PyObject; return f(*args, **kwds); /Users/nathanshammah/miniconda3/envs/qutip44/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo_factor.CoeffFunc size changed, may indicate binary incompatibility. Expected 32 from C header, got 40 from PyObject; return f(*args, **kwds); /Users/nathanshammah/miniconda3/envs/qutip44/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo_factor.StrCoeff size changed, may indicate binary incompatibility. Expected 40 from C header, got 488 from PyObject; return f(*args, **kwds); /Users/nathanshammah/miniconda3/envs/qutip44/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjEvo size changed, may indicate binary incompatibility. Expected 288 from C header, got 296 from PyObject; return f(*args, **kwds); /Users/nathanshammah/miniconda3/envs/qutip44/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjCteDense size changed, may indicate binary incompatibility. Expected 496 from C header, got 504 from PyObject; return f(*args, **kwds); /Users/nathanshammah/miniconda3/envs/qutip44/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: qutip.cy.cqobjevo.CQobjEvoTdDense size changed, may indicate binary incompatibility. Expected 920 from C header, got 928 from PyObject; return f(*args, **kwds); /Users/nathanshammah/github/qutip/qutip/tests/test_metrics.py:300: DeprecationWarning: invalid escape sequence \o; """"""; .................................................................................................; ```; cc @Ericgig.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-496378866:2227,test,tests,2227,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-496378866,1,['test'],['tests']
Testability,/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_expect.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_fastsparse.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_fileio.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_floquet.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_gates.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_graph.py - Attri,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:51231,test,tests,51231,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,"1 second was meant to be the order of magnitude rather than a hard limit, but it's a good rule of thumb for testing one piece of functionality. [Here's a (slightly out-dated) list of our current longest tests](https://github.com/qutip/qutip/issues/1217#issuecomment-604116373), bearing in mind that some of those ones actually test many many things in the same test function. The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up. With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead. I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them. Minor things that _may_ speed up - check the profiling!; 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements internally is effectively `tensor(...(tenso",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640127213:108,test,testing,108,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640127213,6,['test'],"['test', 'testing', 'tests']"
Testability,"1. Don't worry, those aren't problems. A problem would just say ""FAIL"". ""XFAIL"" means ""expected to fail"", which in this case is because those tests were written for an older testing framework and haven't been updated yet.; 2. No, you don't need to worry. If it's installed, you'll get a message at the end which says something like; ```====== 1000 passed, 50 skipped, 10 xfailed in 120s ======```; where the numbers and times will be different, but there won't be any red text saying ""10 failed"" (""xfailed"" is fine). If you've installed `qutip` from `conda` following the [recommended instructions here](http://qutip.org/docs/latest/installation.html#platform-independent-installation), then you should have a valid installation without any issues, and Cython should have sorted itself out. The general principle is that installing `qutip` is as easy as running; ```conda install qutip```; if you've got the `conda-forge` channel activated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1222#issuecomment-606166596:142,test,tests,142,https://qutip.org,https://github.com/qutip/qutip/issues/1222#issuecomment-606166596,2,['test'],"['testing', 'tests']"
Testability,"1. inside the ""Actions"" tab at the top of the GitHub page, you will only see workflows that are present in the code in the default git branch. `dev.major` isn't QuTiP's default branch, so the workflows won't appear immediately after this is merged, only when the `.github/workflows/build.yml` file also exists in `master`. 2. nothing prevents you from running the workflow on a fork, and there's no way and no reason to prevent this - it's also how I tested it. If you did run it on a fork, you'd be using your own GitHub Actions credits (it doesn't cost us anything because we're an open-source project). Only qutip/qutip knows the secret to publish to PyPI, so no fork can succeed on that. The branch check here serves two purposes: the first is that I needed some ""tickbox"" to let the admin decide at runtime whether they needed to publish the package or just build the wheels for personal download; the second is that we release off release branches, not master, so there needed to be an input to say _which_ branch should be built. 3. it's not 100% necessary, but it's the right thing to do. It decouples the project data from the setup code, which makes it much easier to modify both, and allows other tools to access the data. There are other PEPs in the works as well that will move all this data into `pyproject.toml`, rather than just `setup.cfg`. 4. oh, that's useful. I didn't really know or look into it, because it was only a temporary thing anyway. I might actually retire this PR and make it against `master` instead. It's functionally the same as this one, and most of the diff is the same, except that its `setup.py` is better organised, like Simon suggested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429#issuecomment-801289045:451,test,tested,451,https://qutip.org,https://github.com/qutip/qutip/pull/1429#issuecomment-801289045,1,['test'],['tested']
Testability,1s call test_qobjevo.py::test_QobjEvo_with_state; 7.79s call test_scattering.py::TestScattering::testScatteringProbability; 7.69s call test_brtools.py::test_diag_liou_mult; 7.48s call test_qobjevo.py::test_QobjEvo_mul_vec; 6.89s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Symplectic coupled oscillators-Qobj propagation]; 6.04s call test_qubit_evolution.py::test_MCSolverCase1; 5.90s call test_brmesolve_td.py::test_time_dependent_spline_in_c_ops; 5.71s call test_control_pulseoptim.py::TestFileIO::test_dumping_to_files; 5.67s call test_sesolve.py::TestSESolve::test_04_1_state_with_list_str_H; 5.36s call test_mesolve.py::TestMESolveSuperInit::testSuperJC; 5.23s call test_parallel.py::test_serial_map; 5.11s call test_sesolve.py::TestSESolve::test_06_2_compare_state_and_unitary_func; 5.05s call test_partial_transpose.py::test_partial_transpose_comparison; 5.05s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Ising state-to-state-Qobj propagation]; 5.01s call test_qobj.py::test_dual_channel[sub_dimensions3]; 4.84s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsArray; 4.79s call test_parallel.py::test_parallel_map; 4.27s call test_spinchain.py::TestSpinChain::test_analytical_evo; 3.92s call test_stochastic_se.py::test_ssesolve_homodyne; 3.86s call test_correlation.py::TestTimeDependence::test_hamiltonian_from_function_2ls; 3.25s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsPartFuncList; 3.23s call test_control_pulseoptim.py::TestOptimization::test_unitarity_via_dump; 3.03s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[QFT-Qobj propagation]; 2.65s call test_control_pulseoptim.py::TestOptimization::test_crab[Qobj propagation]; 2.57s call test_wigner.py::test_wigner_compare_methods_dm; 2.46s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[Symplectic coupled oscillators-Qobj propagation]; 2.31s call test,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373:2709,Test,TestOptimization,2709,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373,1,['Test'],['TestOptimization']
Testability,"2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24493,test,test,24493,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,2,['test'],"['test', 'tests']"
Testability,"2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; - print(""Cython Version: %s"" % cython_ver); + print(""Cython Version: %s%s"" % (cython_ver,; + """" if cython_ver == 'None' or qutip.settings.has_cython else ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2533,assert,assert,2533,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543,1,['assert'],['assert']
Testability,"2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install(); + del _pyxbuilder, _Cython, _version2int; + qutip.settings.has_cython = True; ; ; # -----------------------------------------------------------------------------; Index: qutip/qutip/tests/test_brmesolve_td.py; ===================================================================; --- qutip.orig/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/tests/test_brmesolve_td.py	2024-01-16 03:52:59.780085342 +0100; @@ -148,7 +148,8 @@; brme = qutip.brmesolve(H, psi0, times, a_ops, e_ops=[a.dag()*a]); assert np.mean(np.abs(brme.expect[0] - exact) / exact) < 1e-5; ; -; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); def test_time_dependent_spline_in_c_ops():; N = 10; a = qutip.destroy(N); @@ -232,6 +233,8 @@; [(a, a.dag()), (spectrum, '1', '1')]]); ; ; +@pytest.mark.skipif(not qutip.settings.has_cython,; + reason=""cython support is not available""); @pytest.mark.parametrize(""collapse_operators"", [; _2_tuple_split,; pytest.param(_4_tuple_split, marks=pytest.mark.slow),; Index: qutip/qutip/about.py; ===================================================================; --- qutip.orig/qutip/about.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/about.py	2024-01-16 03:54:39.029027082 +0100; @@ -44,7 +44,8 @@; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None';",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:2382,test,tests,2382,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543,1,['test'],['tests']
Testability,3 test runs successful and 4th started.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2013#issuecomment-1318447588:2,test,test,2,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1318447588,1,['test'],['test']
Testability,"5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1237,test,tested,1237,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,2,"['assert', 'test']","['assert', 'tested']"
Testability,"5, in run_command; cmd_obj.run(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 186, in run; _build_ext.build_ext.run(self); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 339, in run; self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module rhs278052 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']. ======================================================================; ERROR: Steady state: Driven cavity - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_steadystate.py"", line 490, in test_driven_cavity_power_gmres; use_precond=1); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\steadystate.py"", line 306, in steadystate; return _steadystate_power(A, ss_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\steadystate.py"", line 938, in _steadystate_power; check)); Exception: power-gmres failed to find solution in 1000 iterations. ----------------------------------------------------------------------; Ran 564 tests in 898.617s. FAILED (SKIP=9, errors=57)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:29892,test,test,29892,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,3,['test'],"['test', 'tests']"
Testability,5.75s call test_stochastic_me.py::test_ssesolve_feedback; 33.73s call test_stochastic_se.py::test_ssesolve_feedback; 25.80s call test_sesolve.py::TestSESolve::test_06_4_compare_state_and_unitary_list_str; 24.41s call test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[string]; 21.83s call test_propagator.py::testPropHOStrTd; 19.95s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsStrList; 17.73s call test_qobjevo.py::test_QobjEvo_expect_rho; 16.52s call test_stochastic_me.py::test_smesolve_homodyne; 15.79s call test_qobjevo.py::test_QobjEvo_call; 12.67s call test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[numpy]; 12.37s call test_mesolve.py::TestMESolveStepFuncCoeff::test_array_str_coeff; 11.43s call test_qobjevo.py::test_QobjEvo_mul_mat; 10.89s call test_spmath.py::test_csr_kron; 10.83s call test_qobjevo.py::test_QobjEvo_expect_psi; 9.89s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[QFT-Qobj propagation]; 9.40s call test_mesolve.py::TestMESolverConstDecay::testMEDecayAsStrList; 9.32s call test_sesolve.py::TestSESolve::test_04_2_unitary_with_list_func_H; 8.74s call test_brmesolve_td.py::test_split_operators_maintain_answer[_2_tuple_split]; 8.38s call test_qobjevo.py::test_QobjEvo_call_args; 8.37s call test_mesolve.py::TestMESolveTDDecay::testMETDDecayAsStrList; 8.34s call test_qobjevo.py::test_QobjEvo_pickle; 8.21s call test_qobjevo.py::test_QobjEvo_safepickle; 8.11s call test_qobjevo.py::test_QobjEvo_with_state; 7.79s call test_scattering.py::TestScattering::testScatteringProbability; 7.69s call test_brtools.py::test_diag_liou_mult; 7.48s call test_qobjevo.py::test_QobjEvo_mul_vec; 6.89s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Symplectic coupled oscillators-Qobj propagation]; 6.04s call test_qubit_evolution.py::test_MCSolverCase1; 5.90s call test_brmesolve_td.py::test_time_dependent_spline_i,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373:1207,Test,TestOptimization,1207,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373,1,['Test'],['TestOptimization']
Testability,6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' h,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:50222,test,test-environment,50222,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,"61341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > ​. The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution to the overall matrix can't be ignored. If I've explained this poorly, which I suspect is the case since I'm not sure how to add equations here or if that's possible, I can email you with a more thorough explanation. . I haven't included tests for the latter case yet mostly due to my only dealing with systems heavily dictated by their primary frequency, so far. I'm working on a system now that should show different behavior for different secular approximations, but my results look slightly different from the published results such that I'm not sure I'm very confident in what I've done, yet. I'll try to update with a test for this when I can, however.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:2238,test,tests,2238,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788,2,['test'],"['test', 'tests']"
Testability,"644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23829,test,tests,23829,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,7-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/version.py 3 0 100%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 427 241 44%; =========================== short test summary info ============================; ERROR ../tests/test_basis_transformation.py; ERROR ../tests/test_brmesolve.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_brmesolve_td.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_brtools.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_cavityqed.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_control_pulseoptim.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_correlation.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_countstat.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_cy_structs.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_dimensions.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_eigenstates.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_enr_state_operator.py - AttributeError: module 'qutip' ha...; ERROR ../tests/test_entropy.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_expect.py - Att,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:50821,test,tests,50821,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,"739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/83c8cac0-f12e-4af4-96df-4be972b485d4 width=30% height=30%>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1818,test,tests,1818,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617,1,['test'],['tests']
Testability,89s call test_spmath.py::test_csr_kron; 10.83s call test_qobjevo.py::test_QobjEvo_expect_psi; 9.89s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[QFT-Qobj propagation]; 9.40s call test_mesolve.py::TestMESolverConstDecay::testMEDecayAsStrList; 9.32s call test_sesolve.py::TestSESolve::test_04_2_unitary_with_list_func_H; 8.74s call test_brmesolve_td.py::test_split_operators_maintain_answer[_2_tuple_split]; 8.38s call test_qobjevo.py::test_QobjEvo_call_args; 8.37s call test_mesolve.py::TestMESolveTDDecay::testMETDDecayAsStrList; 8.34s call test_qobjevo.py::test_QobjEvo_pickle; 8.21s call test_qobjevo.py::test_QobjEvo_safepickle; 8.11s call test_qobjevo.py::test_QobjEvo_with_state; 7.79s call test_scattering.py::TestScattering::testScatteringProbability; 7.69s call test_brtools.py::test_diag_liou_mult; 7.48s call test_qobjevo.py::test_QobjEvo_mul_vec; 6.89s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Symplectic coupled oscillators-Qobj propagation]; 6.04s call test_qubit_evolution.py::test_MCSolverCase1; 5.90s call test_brmesolve_td.py::test_time_dependent_spline_in_c_ops; 5.71s call test_control_pulseoptim.py::TestFileIO::test_dumping_to_files; 5.67s call test_sesolve.py::TestSESolve::test_04_1_state_with_list_str_H; 5.36s call test_mesolve.py::TestMESolveSuperInit::testSuperJC; 5.23s call test_parallel.py::test_serial_map; 5.11s call test_sesolve.py::TestSESolve::test_06_2_compare_state_and_unitary_func; 5.05s call test_partial_transpose.py::test_partial_transpose_comparison; 5.05s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Ising state-to-state-Qobj propagation]; 5.01s call test_qobj.py::test_dual_channel[sub_dimensions3]; 4.84s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsArray; 4.79s call test_parallel.py::test_parallel_map; 4.27s call test_spinchain.py::TestSpinChain::test_analytical_evo; 3.92s call test_st,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373:2020,Test,TestOptimization,2020,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373,1,['Test'],['TestOptimization']
Testability,": comparing TLS emission corr. (str-list td format) ... ok; correlation: comparing TLS emission corr. (np-list td format) ... ok; correlation: comparing TLS emission corr. (fn-list td format) ... ok; Counting statistics: current and current noise in a DQD model ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; Cython structs : COO to CSR ... ok; Cython structs : sort CSR indices inplace ... ok; Cython structs : COO to CSR inplace (no sort) ... ok; Cython structs : COO to CSR inplace (sorted) ... ok; Cython structs : CSR to COO ... ok; qutip.tests.test_dimensions.test_flatten ... ok; qutip.tests.test_dimensions.test_enumerate_flat ... ok; qutip.tests.test_dimensions.test_deep_remove ... ok; qutip.tests.test_dimensions.test_unflatten ... ok; qutip.tests.test_dimensions.test_dims_idxs_to_tensor_idxs ... ok; qutip.tests.test_dimensions.test_dims_to_tensor_shape ... ok; qutip.tests.test_dimensions.test_type_from_dims ... ok; qutip.tests.test_dimensions.test_collapse ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Entropy: Conditional entropy ... ok; Entropy: Entangling power ... ok; expect: operator list and state list ... ok; expect: operator and density matrix ... ok; expect: operator and k",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:6799,test,tests,6799,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['test'],['tests']
Testability,":laughing: Well, technically we still need to wait for the test. Glad to see 4.6.0 online!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1496#issuecomment-817381396:59,test,test,59,https://qutip.org,https://github.com/qutip/qutip/pull/1496#issuecomment-817381396,1,['test'],['test']
Testability,"; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ---------- coverage: platform linux, python 3.6.10-final-0 -----------; Name Stmts Miss Cover; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py 150 97 35%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 11 39%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/hardware_info.py 72 32 56%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/settings.py 24 2 92%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/utilities.py 117 83 29%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:49452,test,test-environment,49452,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,; 5.71s call test_control_pulseoptim.py::TestFileIO::test_dumping_to_files; 5.67s call test_sesolve.py::TestSESolve::test_04_1_state_with_list_str_H; 5.36s call test_mesolve.py::TestMESolveSuperInit::testSuperJC; 5.23s call test_parallel.py::test_serial_map; 5.11s call test_sesolve.py::TestSESolve::test_06_2_compare_state_and_unitary_func; 5.05s call test_partial_transpose.py::test_partial_transpose_comparison; 5.05s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Ising state-to-state-Qobj propagation]; 5.01s call test_qobj.py::test_dual_channel[sub_dimensions3]; 4.84s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsArray; 4.79s call test_parallel.py::test_parallel_map; 4.27s call test_spinchain.py::TestSpinChain::test_analytical_evo; 3.92s call test_stochastic_se.py::test_ssesolve_homodyne; 3.86s call test_correlation.py::TestTimeDependence::test_hamiltonian_from_function_2ls; 3.25s call test_mesolve.py::TestMESolveSuperInit::testMETDDecayAsPartFuncList; 3.23s call test_control_pulseoptim.py::TestOptimization::test_unitarity_via_dump; 3.03s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[QFT-Qobj propagation]; 2.65s call test_control_pulseoptim.py::TestOptimization::test_crab[Qobj propagation]; 2.57s call test_wigner.py::test_wigner_compare_methods_dm; 2.46s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[Symplectic coupled oscillators-Qobj propagation]; 2.31s call test_parallel.py::test_parfor1; 2.11s call test_wigner.py::test_wigner_bell1_su2parity; 1.90s call test_control_pulseoptim.py::TestOptimization::test_basic_optimization[Ising state-to-state-Qobj propagation]; 1.86s call test_sparse.py::test_sp_profile; 1.66s call test_correlation.py::test_correlation_solver_equivalence[es-legacy]; 1.65s call test_control_pulseoptim.py::TestOptimization::test_object_oriented_approach_and_gradient[Lindbladian amplitude damping channel-Qobj propagation]; 1.56s call ,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373:3231,Test,TestMESolveSuperInit,3231,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604116373,2,"['Test', 'test']","['TestMESolveSuperInit', 'testMETDDecayAsPartFuncList']"
Testability,"; > + s = s + 1; > +; > + return Qobj(jm_operator); > +; > +def ap( j, m):; >; > no space before j; > ------------------------------; >; > In qutip/models/dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168803599>:; >; > > +; > + if collective_emission != 0:; > + c_ops.append(np.sqrt(collective_emission) * jm); > +; > + if collective_dephasing != 0:; > + c_ops.append(np.sqrt(collective_dephasing) * jz); > +; > + if collective_pumping != 0:; > + c_ops.append(np.sqrt(collective_pumping) * jp); > +; > + return c_ops; > +; > +# ============================================================================; > +# State definitions in the Dicke basis with an option for basis transformation; > +# ============================================================================; > +def dicke_basis(N, jmm1 = None, basis = ""dicke""):; >; > pep8: no spaces in kwargs jmm1 = None should be jmm1=None.; > There are lots of examples in this file. I'll not mark them all; > ------------------------------; >; > In qutip/models/tests/test_dicke.py; > <https://github.com/qutip/qutip/pull/753#discussion_r168803988>:; >; > > + assert_equal(d3, d3_correct); > + assert_equal(d4, d4_correct); > +; > + def test_lindbladian(self):; > + """"""; > + Test the generation of the Lindbladian matrix; > + """"""; > + N = 1; > + gCE = 0.5; > + gCD = 0.5; > + gCP = 0.5; > + gE = 0.1; > + gD = 0.1; > + gP = 0.1; > +; > + system = Piqs(N = N, emission = gE, pumping = gP, dephasing = gD,; >; > spaces in kwargs. Quite a few other examples too, which I will not mark; > all of them; > ------------------------------; >; > In qutip/cy/dicke.pyx; > <https://github.com/qutip/qutip/pull/753#discussion_r168804323>:; >; > > @@ -0,0 +1,645 @@; > +""""""; >; > QuTiP license stuff needs to be included at the top of the file. You can; > add yourselves to the list of authors for these files; > ------------------------------; >; > In qutip/cy/dicke.pyx; > <https://github.com/qutip/qutip/pull/753#discussion_r168807920>:; >; ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-366305610:9804,test,tests,9804,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-366305610,1,['test'],['tests']
Testability,"; > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.67361738e-19j]; > [ 0.00000000e+00+0.00000000e+00j -1.11022302e-16-8.67361738e-19j; > 2.22044605e-16+0.00000000e+00j]]; > ```; > ; > So I think the problem is not in the `steadystate` function but it must be in `countstat_current_noise`. Can someone tell me how to fix this? because I am also using mac M1, and this is the only test that keeps failing: test_countstat.py::test_dqd_current - AssertionError",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:2323,test,test,2323,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100,2,"['Assert', 'test']","['AssertionError', 'test']"
Testability,"; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 1.0.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1344,log,logger,1344,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['log'],['logger']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_enr_state_operator.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_entropy.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_expect.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_fastsparse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:6840,test,tests,6840,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _____________ ERROR collecting qutip/tests/test_qubit_evolution.py _____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_qubitcircuit.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_qubits.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_rand.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:18665,test,tests,18665,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_eigenstates.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________ ERROR collecting qutip/tests/test_enr_state_operator.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_entropy.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_expect.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:6367,test,tests,6367,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_fastsparse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_fileio.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_floquet.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_gates.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:8259,test,tests,8259,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_heom_solver.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_interpolate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mcsolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:10624,test,tests,10624,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_interpolate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mcsolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_metrics.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:11097,test,tests,11097,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_scattering.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sp_eigs.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sparse.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:21503,test,tests,21503,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_three_level.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_utilities.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_wigner.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; !!!!!!!!!!!!!!!!!!! Interrupted: 60 errors during collection !!!!!!!!!!!!!!!!!!!; =========================== 60 error in 1.85 seconds ===========================; (base) cln-232-18:qutip nathanshammah$; ```; this on the 4.4.0 release version. ; On the dev version, ; ```; (qdev) cln-232-18:qutip nathanshammah$ pytest; ============================= test session starts ==============================; platform darwin -- Python 3.7.3, pytest-5.0.1, py-1.8.0, pluggy-0.12.0; rootdir: /Users/nathanshammah/github/qutip;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:28598,test,tests,28598,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_rhs_reuse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_scattering.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sp_eigs.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:21030,test,tests,21030,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_spinchain.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_spmath.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_states.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_steadystate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:23395,test,tests,23395,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_superoper.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_td_formats.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_tensor.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_three_level.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:27179,test,tests,27179,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_expect.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_fastsparse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_fileio.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_floquet.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:7786,test,tests,7786,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_fileio.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_floquet.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_gates.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_graph.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:8733,test,tests,8733,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_floquet.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_gates.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_graph.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_heom_solver.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:9206,test,tests,9206,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mcsolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_mesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_metrics.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_mkl.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:11570,test,tests,11570,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_metrics.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_mkl.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_openmp.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_operators.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:12516,test,tests,12516,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_openmp.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_operators.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_parallel.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ____________ ERROR collecting qutip/tests/test_partial_transpose.py ____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:13461,test,tests,13461,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_qubits.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_rand.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_random.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_rhs_reuse.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:19611,test,tests,19611,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sesolve.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sp_eigs.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sparse.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_spinchain.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:21976,test,tests,21976,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_sparse.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ________________ ERROR collecting qutip/tests/test_spinchain.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_spmath.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_states.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:22922,test,tests,22922,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_piqs.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_propagator.py ________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_ptrace.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_qft.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:15354,test,tests,15354,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_qft.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; __________________ ERROR collecting qutip/tests/test_qobj.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_qobjevo.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_qpt.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _____________ ERROR collecting qutip/tests/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:16773,test,tests,16773,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"; ```; Map(Space(Map(Space, Space)), Space(Map(Space, Space))); ```; to; ```; Super(Space(Map(Space, Space)), Space(Map(Space, Space)), rep='super'); ```; and I definitely like having the superop rep included in it. The user is never ever meant to write any of this themselves, so the literal length shouldn't be too much of a problem. You'd still specify dimensions using the exact same list syntax that we currently use, it's just we'd immediately parse it into this internal representation and internally operate on this, because it's much faster. Essentially what I'm describing here is an abstract syntax tree for relevant linear algebra structures. We _could_ even have the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. Y",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:1591,test,test,1591,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,1,['test'],['test']
Testability,"; rhoss = steadystate(L); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\steadystate.py"", line 290, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\steadystate.py"", line 460, in _steadystate_direct_sparse; weighted_matching=ss_args['weighted_matching']); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 393, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 170, in solve; np_x, np_error); OSError: exception: access violation reading 0x0000000099EC80F8. ======================================================================; ERROR: MKL spsolve : Hermitian (real) solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\tests\test_mkl.py"", line 230, in test_mkl_spsolve10; y = mkl_spsolve(A, b, hermitian=1); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 414, in mkl_spsolve; lu.delete(); File ""C:\Users\Boxi\OneDrive\Studium\qutip-project\qutip\qutip\_mkl\spsolve.py"", line 208, in delete; byref(c_int(0)), np_error); OSError: exception: access violation reading 0x00000006FFFFFFEF. ======================================================================; ```; Enviroment:; ```; QuTiP Version: 4.4.0.dev0+73a27971; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 12; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\Users\Boxi\Miniconda3\envs\qutip-dev-py3\lib\site-packages\qutip-4.4.0.dev0+73a27971-py3.7-win-amd64.egg\qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/975#issuecomment-483000016:1603,test,test,1603,https://qutip.org,https://github.com/qutip/qutip/issues/975#issuecomment-483000016,2,['test'],"['test', 'tests']"
Testability,"; self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 190, in test_04_1_state_with_list_str_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 64, in check_evolution; args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyx",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:8977,test,tests,8977,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability,"; self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 207, in test_04_2_unitary_with_list_func_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 67, in check_evolution; output = sesolve(H, U0, tlist, args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anacond",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:13490,test,tests,13490,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability,"; self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 226, in test_05_1_state_with_interp_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 64, in check_evolution; args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyxim",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:18024,test,tests,18024,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability,"; self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 245, in test_05_2_unitary_with_interp_H; td_args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 67, in check_evolution; output = sesolve(H, U0, tlist, args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\MTS-144\Anaconda3\",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:22533,test,tests,22533,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability,"; self.build_extensions(); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py"", line 194, in build_extensions; self.build_extension(ext); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\command\build_ext.py"", line 533, in build_extension; depends=ext.depends); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 345, in compile; self.initialize(); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 238, in initialize; vc_env = _get_vc_env(plat_spec); File ""C:\Users\MTS-144\Anaconda3\lib\distutils\_msvccompiler.py"", line 134, in _get_vc_env; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 354, in test_06_4_compare_state_and_unitary_list_str; normalize=False, td_args=td_args, tol=5e-5); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\tests\test_sesolve.py"", line 255, in compare_evolution; options=options,args=td_args); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 185, in sesolve; progress_bar); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\qutip\sesolve.py"", line 520, in _sesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 462, in load_module; language_level=self.language_level); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 231, in load_module; raise exc.with_traceback(tb); File ""C:\Users\MTS-144\Anaconda3\lib\site-packages\pyximport\pyximport.py"", line 215, in load_module; inplace=build_inplace, language_level=language_level); File ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467317662:27094,test,tests,27094,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467317662,1,['test'],['tests']
Testability,"===================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:2108,log,logger,2108,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,1,['log'],['logger']
Testability,"> #1212; > ; > > > Thank you. Can you please add tests for this? I'm leaving to @BoxiLi a closer review.; > ; > By ""add tests"" we mean include tests in `qutip/tests'. See #1212 for example. @mlaguna10 please don't do this just now. We will give @MartinSandeCosta opportunity to do this. Hi Alex! I thought 'adding test' means creating a notebook using the new features, but great that Martin can have the chance to do it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-606060551:49,test,tests,49,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-606060551,5,['test'],"['test', 'tests']"
Testability,"> * What is the reason that the time-dependent weights are still part of the trajectory result? That seems a bit inconsistent to me and I wonder if the `TrajectoryResult` class could perhaps just be removed?. The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I will look into it this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851:482,log,logic,482,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2296372851,1,['log'],['logic']
Testability,"> 1 second was meant to be the order of magnitude rather than a hard limit, but it's a good rule of thumb for testing one piece of functionality. [Here's a (slightly out-dated) list of our current longest tests](https://github.com/qutip/qutip/issues/1217#issuecomment-604116373), bearing in mind that some of those ones actually test many many things in the same test function.; > ; > The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up.; > ; > With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead.; > ; > I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them.; > ; > Minor things that _may_ speed up - check the profiling!; > ; > 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; > 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements inter",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273:110,test,testing,110,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273,6,['test'],"['test', 'testing', 'tests']"
Testability,"> ; > ; > Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems.; > ; > Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook.; > ; > Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See [qutip/qutip-notebooks#100](https://github.com/qutip/qutip-notebooks/issues/100); > ; > One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in #1092, using [loky](https://loky.readthedocs.io).; > ; > In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence.; > ; > If the freeze is indeed caused by spawn-multiprocessing, the problem _should_ also show up on Windows. Is anyone running Windows able to reproduce this?. Windows doesn't have 'fork' at all, if we want to make parallel_map work under windows, we have to find ways to 'spawn' efficiently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416:1304,test,tests,1304,https://qutip.org,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416,1,['test'],['tests']
Testability,"> ; > ; > I have been trying out pytest for the last couple of days and we can start by using it for the testing as it is now. We need to replace installation [lines](https://github.com/qutip/qutip/blob/master/.travis.yml#L23) like this in the .travis.yml file to install pytest:; > ; > ```; > conda install mkl blas=*=mkl numpy scipy pytest cython coveralls pytest-cov; > ```; > ; > and then change the runner script to use pytest instead of `nose` by changing:; > ; > ```; > nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; > ```; > ; > to; > ; > ```; > pytest --verbosity=1 --cov=qutip qutip; > ```. I have submitted a pull request with these changes. Travis build fails with error ""file not found: qutip"". I suspect it is a problem with pytest, and I am investigating.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/958#issuecomment-481026053:105,test,testing,105,https://qutip.org,https://github.com/qutip/qutip/issues/958#issuecomment-481026053,1,['test'],['testing']
Testability,> ; > ; > Seems interesting but tests are failing... Hi Ericgig!. Thank you very much for looking into this! I haven't been able to figure out why the build is failing; the error messages quote parts of the code that I didn't even modify. Could you assist me in finding out why?. Thanks a bunch!; Nithin,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/912#issuecomment-466180105:32,test,tests,32,https://qutip.org,https://github.com/qutip/qutip/pull/912#issuecomment-466180105,1,['test'],['tests']
Testability,"> ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. @AGaliciaMartinez Hey Asier, issue #1616 refers to a similar problem. Following it, I tried `plt.show()` and it works. But `b.show()` doesn't work. So, please suggest what to do? Now that `plt.show()` works, I can remove my minor addition in the `show()`, but still I would like to have `b.show()` working. Looking forward to your response.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059:219,test,test,219,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059,1,['test'],['test']
Testability,"> > I added the teleportation circuit because it seemed like a simple enough example to test both classically controlled gates and measurements. I have some separate (non-circuit based) examples in the other file. Maybe the run_statistics test can be not on the teleportation circuit and something even simpler ?; > ; > Maybe, but I find teleportation already a very short circuit, isn't it?; > ; > > Re: the idea for run_statistics, do you mean tracking the various probability elements during each measurement (along with the state) ?; > ; > Yes, if we have n qubit measurements, we will have 2^n possible final state. One can calculate the state for each of them along with its probability and then get the exact statistics. I have changed the run_statistics function to now do this method in place of running it a number of times. This solves the problem of slow testing of the function as well !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-643730645:88,test,test,88,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-643730645,3,['test'],"['test', 'testing']"
Testability,"> > I am not sure why it is only failing in the Python 3.8 case.; > ; > Well, it's a statistical average, so it can deviate. I don't think it has anything to do with Python 3.8. But probably it can be avoided? I guess its the same question as #1268; > ; > I'm thinking, what about adding a `targets` parameters to `QubitCircuit.run_statistics`. Usually, people don't interested in the full output state of the circuit because many of them are ancillary qubits. They can use `targets` to specify what is the qubits they want to look at. In the function, we can use `ptrace(state, targets)` to trace out the ancilla. Seems like a good idea, maybe we can add it as optional parameter to both `QubitCircuit.run_statistics` and `QubitCircuit.run`. Also, regarding Python 3.8, I was saying because both times it only failed in that test run, also never failed in any of my runs. Should I make tolerance higher ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640006594:826,test,test,826,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640006594,1,['test'],['test']
Testability,"> > Tried a few more options, looks good.; > > Yeah, I know it is from a linter. Personally, I'm fine since the change is not massive. If others think this might mess up the code history, please speak up.; > > Please add a Towncrier file for the change log.; > > I'll wait for one or two days, if no one comments, will merge.; > ; > Sounds good,; Ha, Def will ; I will add the Towncrier file shortly and open an issue for the new bug",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2442#issuecomment-2147402235:253,log,log,253,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2147402235,1,['log'],['log']
Testability,"> > _**Other minor changes**_; > > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > > ```; > > if self.fig:; > > plt.show(self.fig); > > ```; > ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. So, I found that the value of `self._shown` is false when it tries to execute `show()', and therefore, the Bloch sphere is not displayed. ; I use the following code to play around with the Bloch sphere, please let me know if I need to add something:; ```; b= Bloch(fig=None); b.xlabel = ['$\\left|+\\right>$',' ']; b.ylabel = ['$\\left|+i \\right> (r_8)$',' ']; b.xlpos = [1.1,-1.1]; b.zlabel = [' $\\left|0\\right> (r_7)$','$\\left|1\\right> $']; b.zlpos = [1.075,-1.08]. <b.add_other_stuff>. b.view=[-20,20,0]; b.show(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485:466,test,test,466,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485,1,['test'],['test']
Testability,> > mesolve: simple time-dependence as partial function list ... ok; > > > mesolve: simple time-dependence as string list ... ok; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ok; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > Metrics: Checks that average gate fidelities are sensible for random ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > Qobj data ... ok; > > > Qobj type ... ok; > > > Qobj Hermicity ... ok; > > > Qobj shape ... ok; > > > Qobj addition ... ok; > > > Qobj subtraction ... ok; > > > Qobj multiplication ... ok; > > > Qobj division ... ok; > > > Qobj power ... ok; > > > Qobj negation ... ok; > > > Qobj equals ... ok; > > > Qobj getitem ... ok; > > > Qobj multiplication type ... ok; > > > Qobj conjugate ... ok; > > > Qobj adjoint (dagger) ... ok; > > > Qobj diagonals ... ok; > > > Qobj eigenenergies ... ok; > > > Qobj eigenstates ... ok; > > > Qobj expm ... ok; > > > Qobj full ... ok; > > > Qobj norm ... ok; > > > Qobj permute ... ok; > > > Qobj ket type ... ok; > > > Qobj bra type ... ok; > > > Qobj operator type ... ok; > > > Qobj superoperator type ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks that binary ops preserve 'superrep'. ... ok; > > > Superoperator arithmetic: Checks ,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:6428,test,tests,6428,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['test'],['tests']
Testability,"> @Ericgig Tests added for the type changes.; > ; > Note that `QobjEvo.__rmatmul__` is not currently callable. Calling `qobj @ qevo` will call `QobjEvo.__matmul__(qobj, qevo)` first, which will return the result. If I am not missing a case where `__rmatmul__` is called, I vote that we simply delete the implementation of `__rmatmul__` (in a separate PR). @Ericgig Explained that in Cython 3 `__rmatmul__` will be called, so we can keep it for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1152371837:11,Test,Tests,11,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1152371837,1,['Test'],['Tests']
Testability,"> @hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. Definitely leave for later. > There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I don't think we need to pin to a particular version to benefit from the pip caching, but let's see later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551#issuecomment-839773306:184,test,tests,184,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839773306,2,['test'],['tests']
Testability,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:33,test,tests,33,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143,2,['test'],"['test', 'tests']"
Testability,"> @sarsid thank you for the detailed description of the PR. Some tests are failing at [` TestQubitCircuit.test_user_gate`](https://travis-ci.org/github/qutip/qutip/jobs/699177830#L3017), ""NameError: name 'isfunction' is not defined"".; > ; > This is still in draft mode, however I wonder whether you think it makes sense to provide the user the option to choose from OpenQasm 2.0 and Qasm, with the same function, e.g., `read_qasm`, but with an attribute.; > ; > This is a draft, but please remember to add Numpy docstrings to functions.; > ; > It would be great to have read/write capabilities with QASM, looking forward to this PR. @nathanshammah I was wondering if functions only meant for internal class use should have returns and parameters specified?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-653818309:65,test,tests,65,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-653818309,2,"['Test', 'test']","['TestQubitCircuit', 'tests']"
Testability,"> A possible addition could be to check the trace condition of the steady-state solution and throw a warning if it is violated more than some epsilon. But for now, everything looks good. @davidschlegel That's a good idea, so I added some assertions to all the tests where it was simple to do so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689:238,assert,assertions,238,https://qutip.org,https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689,2,"['assert', 'test']","['assertions', 'tests']"
Testability,"> Also, how does this PR fit relative to #1491? They appear to make many conflicting changes with each other. Hi Jake with respect to this. The apparent conflicting changes are only in the test file, if I am not mistaken. Ideally I would like this one to get approved, and then I will rebase #1491 from master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-820364728:189,test,test,189,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-820364728,1,['test'],['test']
Testability,"> Also, once you're done, leave this PR without merging and I'll tidy up the commit history. We shouldn't have things like 374debd (a wrong-way merge) because they really mess with the mainline of the history, and make things harder to traceback, and I can collapse all your changes into one ""logical"" change once it's working. . Ok. But what would be the better way to merge master here then?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-878190588:293,log,logical,293,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878190588,1,['log'],['logical']
Testability,"> Also, regarding Python 3.8, I was saying because both times it only failed in that test run, also never failed in any of my runs. Should I make tolerance higher ?. Ok.... Let me try restart the CI test once",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640007551:85,test,test,85,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640007551,2,['test'],['test']
Testability,> An unrelated test fails after this is merged. It doesn't make sense to me...; > https://github.com/qutip/qutip/runs/3008054620. I am very confused too. Could we try re-run it and see what happens?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1603#issuecomment-875538184:15,test,test,15,https://qutip.org,https://github.com/qutip/qutip/pull/1603#issuecomment-875538184,1,['test'],['test']
Testability,"> As I understand it, the only way to avoid needing to touch `MANIFEST.in` is to not have files distributed with the test suite (or to have the temporary files by `*.py`, since `setup.py` automatically recognises them). That's not really a pytest thing, it's a `setuptools` one.; > ; > I don't think there's a problem distributing files as part of the tests. You can add a line which says; > ; > ```; > recursive-include qutip/tests/qasm_files *.qasm; > ```; > ; > to `MANIFEST.in`, and that should hopefully fix the problem. You won't have the problem locally, because you'll be running `./setup.py develop`, which ""installs"" in-place, so you don't notice the fact that you've missed files from the manifest. In the tests, it runs `./setup.py install`, which does the copy, missing files which aren't in the manifest.; > ; > Boxi: I'm not certain what more you'd like to do with fixtures here. Fixtures are good for setup and tear down, parametrisation and sharing resources (like network connections), but I'm not certain what further benefit you get for a test function which is testing whether it can open a known file, read it, and construct the expected output. I think Sidhant is already doing some nice parametrisation of his tests, from what I see.; > ; > Sidhant: I added a comment on the exception test, since pytest gives us an easier-to-read context manager you can use. It's also typically better practice to handle file paths like I did in that (using the overloaded `/` operator with `pathlib.Path`, or `os.path.join`) rather than manually putting in slashes. Windows _usually_ will do the right thing now with slashes, but it's better to let Python handle it for us. Thanks for this information, it seems to work ! I was wondering if the following statement is still needed (at all) in `PACKAGE_DATA` in setup.py? ; `'qutip/tests/qasm_files': ['*.qasm'],`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-656450639:117,test,test,117,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-656450639,9,['test'],"['test', 'testing', 'tests']"
Testability,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:1399,benchmark,benchmark,1399,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248,1,['benchmark'],['benchmark']
Testability,"> Consider what you're doing from a statistical sense here. If everything works correctly, then you're effectively trying a two-tail hypothesis test that your test binomial distribution has a probability of 0.25, given you made `n` observations of it. The analytic success rate of your test is then; > ; > ```python; > import scipy.stats; > def success(n, p, tol):; > dist = scipy.stats.binom(n, p); > return dist.cdf(n * (p+tol)) - dist.cdf(n * (p-tol)); > ```; > ; > where `success(4096, 0.25, 0.02)` is 99.67%. Since there are 5 independent runs on Travis, that's equivalent to a failure rate of 1.6% on every single CI run, which is several orders of magnitude too high. It's probably just luck that it was Python 3.8 on both occasions - it's a one-in-five chance that in two failing CI runs, it was the same setup both times.; > ; > You have to consider what is most appropriate to fix the test, and what you can reasonably test in ~1 second of runtime. You don't want to increase the tolerance too much, because then you can get a lot of false positives even if something is broken.; > ; > If you can bump the number of runs up to 100,000 and set the tolerance at 0.01, you'll have a per-test failure rate of ~3e-13, which is more like what we'd want. If you keep it at 4096, the tolerance should be more like 0.05 (which is pretty big tbh). Thanks for the excellent analysis. I don't think it's feasible to do 100,000 given the current. efficiency. It did give me incentive to make it somewhat faster. What is a good guideline for the maximum time a test can take. It seems like I can maybe do 150 runs in ~ 1s. In any case, it doesnt seem feasible to do even 4096 claims without taking quite a bit of time. Any ideas on how to structure the test differently ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640087689:144,test,test,144,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640087689,8,['test'],['test']
Testability,"> Could you send the equation for the case where `time_sense` is not `0`.; > ; > When I try it with a period of `1.0` it give extra term with very low frequencies:; > ; > ```; > dict_keys([0.0, 4.304872064735899e-09, 1.0157988986038049e-08, 1.1379302858450767e-08, -2.9820390185456766e-09, -4.304872064735899e-09, 5.8531169213021495e-09, 7.074430793714867e-09, -7.286911083281576e-09, -1.0157988986038049e-08, -5.8531169213021495e-09, 1.2213138724127176e-09, -1.3140028004583725e-08, -1.1379302858450767e-08, -7.074430793714867e-09, -1.2213138724127176e-09, -1.4361341876996443e-08, 2.9820390185456766e-09, 7.286911083281576e-09, 1.3140028004583725e-08, 1.4361341876996443e-08]); > ```; > ; > Is it normal? You did not include any test using `time_sense`.; > ; > ​. The relaxation of the secular approximation isn't by direct time-dependence. It was originally, but this was later changed to relax the secular approximation according to the ""importance"" of each term, which is dictated by a quotient. The numerator of the quotient is the product of the FFT coefficients that make up a certain element of the rate matrix super operator, and the denominator is the difference of frequencies between the two elements multiplied by the system frequency omega. When `time_sense` is `0`, the rate matrix is constructed using only the product of FFT coefficients for which the frequency arguments completely cancel. When `timesense` isn't `0`, however, is when that quotient comes into play. In a nutshell, this ends up dividing the rate at which a certain element changes the system by the frequency at which that rate rotates in the Floquet Basis. If the result of the quotient is small, the frequency is much higher than the collapse operator elements actually affect the system, such that it averages out on longer timescales. If the result of the quotient is large, then the collapse operator elements appreciably change the system on a shorter timescale than they rotate, such that their contribution t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788:731,test,test,731,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631503788,1,['test'],['test']
Testability,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:17,test,tests,17,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214,6,"['log', 'test']","['logic', 'tests']"
Testability,"> Does anyone know how we would give some kind of deprecation warning when `from qutip import *` is made to say that only core functions will be imported from v5 onwards?. @ajgpitch . I know I'm resurrecting a dead thread, but I have a way of detecting star imports if you can cope with a fairly gross hack. The only internal difference in `from qutip import *` (that I know about) from `import qutip` is that in the former, the import system access the `qutip.__all__` list to see which names it should import. This is intended to be a list of names, so the star import doesn't _have_ to import every single name, i.e. so you can manually set what's public to a module; the star import is designed for use within packages, and the user importing a package like that is strongly recommended against (though in scientific code, I'm 100% sure that's a losing battle). So, what if we make `__all__` _look_ like a list, but a list that injects a warning whenever anyone tries to see what items it has? An example:; ```python; import warnings as _warnings. x = 2. class _all_wrapper(list):; def __iter__(self, *args, **kwargs):; _warnings.warn(""You star-imported!""); return super().__iter__(*args, **kwargs). __all__ = _all_wrapper(['x']); ```; I put that in a package called ""test"".; ```python; >>> from test import x; >>> x; 2; ```; or; ```python; >>> from test import *; /Users/jake/code/tmp/test/__init__.py:7: UserWarning: You star-imported!; _warnings.warn(""You star-imported!""); >>> x; 2; ```. I won't complain if you want to scream after that...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925:1272,test,test,1272,https://qutip.org,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925,4,['test'],['test']
Testability,"> From what I understand, on intel, brmesolve seems to work correctly, but not on M1. This look like an issue with the eigensolver. Exactly. > Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Yes it is failing these (and some others), but in particular it does fail everything in test_brmesolve.py and test_brmesolve_td.py. All failures I find seem to be related to the `Exception: ODE integration error` as mentioned in the original post.; On an emulated Intel terminal, the tests are all passing as expected.; This is strange, since I seem to find way more tests failing than reported in #1755.; Perhaps this is an issue with my installation, rather than qutip itself. I installed it in the standard way using conda (using the Apple Silicon version at 4.13). > Also could you look at the tensor directly:; > ; > ```; > R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); > ```; > ; > If the tensor is wrong on M1, this would explain the error. Actually, that looks fine surprisingly enough (agrees with the Intel version). Thanks for the quick response. If I figure anything out, i'll let you know.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063:161,test,test,161,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203341063,6,"['Test', 'test']","['Tests', 'test', 'tests']"
Testability,"> Given that this PR is to fix a particular bug in `correlation`, please could you also add a reproduction for the bug in #1460 in order to ensure that it truly is fixed (I see no reason it shouldn't be from this), and to make sure that we catch any possible regressions in the future?. I modified test_correlation.py to catch this error. It was previously using a non-Hermitian expectation operator which is why it did not raise an error. I changed it to use an Hermitian operator. This means it would fail the test without the fix in mesolve. . However, I wonder now if the test should check for both Hermitian and non-Hermitian expectation operators. I did not add both tests because I did not want to make it slower. Should I make it to cover both cases?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1478#issuecomment-812849410:512,test,test,512,https://qutip.org,https://github.com/qutip/qutip/pull/1478#issuecomment-812849410,3,['test'],"['test', 'tests']"
Testability,"> Here are some tests of the proposed modifications. Thank you! I actually meant ""unit tests"" -- as in, adding the tests to `qutip/tests/test_steadystate.py`. It's also not clear to me from your examples how we should see the difference. > This may change the final steady state in some circumstances, but I could not rapidly find a situation where this is actually important. In this example, the two steady states are the same even though the weights are very different. I agree it would be good for the sparse and dense algorithms to align where its sensible to, but it's a bit tricky to evaluate the code if we don't have a concrete idea of the kind of situation in which the new code should be better (and in which situations it might be worse). > The current version gives:; > ; > ```; > Ldense = L.data.todense(); > Ldense[0, :] = np.diag(weight*np.ones(n)).reshape((1, n ** 2)); > np.linalg.solve(Ldense, b); > >> array([0.+0.j, 0.-0.j, 0.-0.j, 1.+0.j]); > ```; > ; > The proposed modification gives:; > ; > ```; > Ldense = L.data.todense(); > Ldense[0, :] += np.diag(weight*np.ones(n)).reshape((1, n ** 2)); > np.linalg.solve(Ldense, b); > >> array([1.e-16+0.j, 0.e+00-0.j, 0.e+00-0.j, 1.e+00+0.j]); > ```; >; > This is a better result than the one obtained with the current version. I can't see any difference between the old and new results other than that the floating point numbers are formatted a bit differently? Perhaps I am missing something.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1275#issuecomment-988058511:16,test,tests,16,https://qutip.org,https://github.com/qutip/qutip/pull/1275#issuecomment-988058511,4,['test'],['tests']
Testability,"> Hi,; > ; > I installed qutip on my windows system and tried the testing codes and faced the problem (as the figure shows):; > ; > TypeError: Cannot convert _UnitedFuncCaller to qutip.cy.cqobjevo_factor.CoeffFunc; > ; > ![image](https://user-images.githubusercontent.com/13745165/60830800-9a9e5e00-a1ea-11e9-99d7-2ec24390083e.png); > ; > Here is the about() information:; > ; > QuTiP: Quantum Toolbox in Python; > Copyright (c) 2011 and later.; > A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade; > ; > QuTiP Version: 4.4.0.dev0; > Numpy Version: 1.16.4; > Scipy Version: 1.2.1; > Cython Version: 0.29.11; > Matplotlib Version: 3.1.0; > Python Version: 3.7.3; > Number of CPUs: 8; > BLAS Info: INTEL MKL; > OPENMP Installed: True; > INTEL MKL Ext: True; > Platform Info: Windows (AMD64); > Installation path: C:\Anaconda\envs\qutip\lib\site-packages\qutip-4.4.0.dev0-py3.7-win-amd64.egg\qutip; > ; > I would appreciate it if you can give me some advice to help me pass the testing codes!. Hi,; Has this problem been solved? I met this same error when installing qutip-4.4.0.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1039#issuecomment-519833092:66,test,testing,66,https://qutip.org,https://github.com/qutip/qutip/issues/1039#issuecomment-519833092,2,['test'],['testing']
Testability,"> Hmmm... 4000/150~25 second. That's not very short actually. The total time for a whole round of qutip CI test costs 15min~20min on Travis.; > ; > Just ideas. Tests here seem to be two-folded:; > ; > * Test classical controlled gates in a circuit; > * Test the measurement functions; > ; > So maybe we can split it. The teleportation circuit test can be done without measurement. Just check the final state tracing out the ancillary qubits. The test for measurement can probably be done for single or two `Qobj` along without circuit. But `run_circuit_statistics`... Probably we then only need to check if the number of elements in the result is correct after some 50 runs?; > ; > On a different matter, I'm wondering if running the statistics takes so long, for such a small teleportation circuit, is it still advantageous in any case? Since we are doing simulation and have the full quantum state, one can actually calculate all 4 possible final states, classically mix them into a density matrix with the corresponding measurement probability and calculate the exact statistics distribution. I doubt that will be slower than 25s, although coding will be harder I suppose. I added the teleportation circuit because it seemed like a simple enough example to test both classically controlled gates and measurements. I have some separate (non-circuit based) examples in the other file. Maybe the run_statistics test can be not on the teleportation circuit and something even simpler ? . Re: the idea for run_statistics, do you mean tracking the various probability elements during each measurement (along with the state) ? Seems like a decent idea !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640107253:107,test,test,107,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640107253,8,"['Test', 'test']","['Test', 'Tests', 'test']"
Testability,"> How did you install QuTiP?. In the FreeBSD, after QuTiP has been built, I run ```python -c ""import qutip.testing as qt; qt.run();""```, and it fails.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/891#issuecomment-403715589:107,test,testing,107,https://qutip.org,https://github.com/qutip/qutip/issues/891#issuecomment-403715589,1,['test'],['testing']
Testability,"> I added a test that compares `correlation_2op_1t` to its analytical solution. I was trying to match the `c_ops` of this new test to the ones appearing in `test_correlation_solver_equivalence`, which are:; > ` c_ops = [np.sqrt(G1 * (n_th+1)) * a, np.sqrt(G1 * n_th) * a.dag()]`; > However, the analytical solution I obtained for this case did not work unless I used a very small value for `n_th = 0.1`. I was wondering whether the analytical solution I got was wrong or whether this actually makes sense. I was thinking that the difference probably comes from the cut we use for the number of states (`N = 20`). I did a quick test and it seemed ok upto about n_th = 1 for N=20 and an atol of 2e-5. ; as an aside, I guess some minimal condition here is that the thermal occupation of the cut-off state should be smaller than the tolerance, which i guess you can get out of the analytic expression for the thermal state. maybe.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1478#issuecomment-813959317:12,test,test,12,https://qutip.org,https://github.com/qutip/qutip/pull/1478#issuecomment-813959317,3,['test'],['test']
Testability,"> I added ipython to the testing workflow. Let me know if it should have been included somewhere else. Hmm. I don't like adding random dependencies into the workflow config. On the other hand, this is specific to IPython. Maybe we can add an ""ipython"" section in `setup.cfg` and add that to `full`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238:25,test,testing,25,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238,1,['test'],['testing']
Testability,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:76,test,tests,76,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451,1,['test'],['tests']
Testability,"> I believe that `MultiTrajSolverImprovedSampling` and `MultiTrajResultImprovedSampling`. We only need one new class for the solver and result, not 2 each. It would even be nice if it could be inserted into `MCSolver` without making the code to messy...; >; Agreed ; > I believe that a scaling should be applied in to the `McResult.photocurrent` method. Could you check. It's an histogram of the jumps times.; > ; Yes you're right, sorry I missed that. Should be fixed now.; > The last issue is whether to make a new function or not. I feel it belong as an options in the existing mscolve, but it would be easy to overlook by users. As a new function it will get more attention. I also don't have a strong opinion on the matter.; >; I think you are right. I added it as an option to options and updated tests, docs accordingly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2218#issuecomment-1692317449:803,test,tests,803,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1692317449,1,['test'],['tests']
Testability,"> I did the pycodestyle on my code, but it is highlighting errors that were there in the original code. It returned lines that have >linespace errors and more, should I edit them too?. I am going to leave this up to you. It is not required as long as the lines you modified follow PEP8. Although, fixing the output of pycodestyle in the same file would be very much welcome :smile:. > The issue was to add __repr__ function to QobjEvo class. Do I need to add a test? If so, can someone help me with it?. We will indeed need a test for repr. It does not need to be very complicated and in fact, something similar to what you show in the description of this pr should work. In this case, we would create a few different `QobjEvo` that cover most of the cases and we would check that `qobjevo.__rerp__()` returns the expected string. This test should go in `qutip/tests/core/test_qobjevo.py`. You can take a look there to see example of how the tests are written. If this is your first time writing tests you may want to take a look at [our documentation](https://qutip.readthedocs.io/en/master/development/contributing.html#testing) and also at pytests documentation. > If the behavior of the code has changed or new feature has been added, please also update the documentation in the doc folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure. This will not be necessary this time. > Include the changelog in a file named: doc/changes/<PR number>.<type> 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). `feature` should work here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838:461,test,test,461,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1455087838,7,['test'],"['test', 'testing', 'tests']"
Testability,"> I saw that you added some tests although I must admit I am not sure how useful they will be in the future as they pretty much use the same code to generate the ref figure an the test figure. That being said, I do not know what alternative could be used for testing these cases, so lets just keep them as they are. I agree that the implementations are perhaps a bit too similar, but I'm happy that:. * they show that the code can at least be run, and; * matplotlib saves the plots to `result_images` when the tests are run so that one can look at the output if one wants to, and so; * I am pretty sure the reference implementations look correct and those won't change when the code changes (woot). So if one wants to introduce a bug one will have to change the code, then code change the reference code in the tests and not look at the images matplotlib produces, which is substantially better than the current situation. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987:28,test,tests,28,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987,5,['test'],"['test', 'testing', 'tests']"
Testability,> I see the tests for the last commit as both passing and failing...; > Could you merge dev.major to rerun the tests. Merged.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1633#issuecomment-921738684:12,test,tests,12,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-921738684,2,['test'],['tests']
Testability,"> I suspect the method of using QobjEvo that was suggested above only use two time steps (initial and final time) in evolving the Hamiltonian as the seed and interpolate the Hamiltonian at the time between the initial and final time using some interpolation function. This is not the case. The answer to your question is to use `QobjEvo` as suggested. For example, here is a simple example using a fast-oscillating array function in a `QobjEvo` and a much shorter `tlist` in `mesolve`. You may need to set the solver options `nsteps`, `atol` and `rtol` to suitable values, as I have done here. ```python; import qutip; import numpy as np. fast_ts = np.linspace(0, 1, 1001); fast_xs = 2.9e3*np.pi * np.cos(2*np.pi * 2.91e2 * fast_ts); # This is the behaviour you were suggesting is happening.; bad_interpolation_xs = np.array([fast_xs[0], fast_xs[-1]]). H = qutip.QobjEvo([[qutip.sigmax(), fast_xs]], tlist=fast_ts); H_bad = [[qutip.sigmax(), bad_interpolation_xs]]; rho = qutip.basis(2, 0).proj(); times = np.array([0., 1]); e_ops = [qutip.sigmay()]; options = qutip.Options(nsteps=10_000_000, atol=1e-14, rtol=1e-12). two_times = qutip.mesolve(H, rho, times, e_ops=e_ops, options=options); many_times = qutip.mesolve(H, rho, fast_ts, e_ops=e_ops, options=options); bad_times = qutip.mesolve(H_bad, rho, times, e_ops=e_ops, options=options). assert len(two_times.expect[0]) == 2; assert len(many_times.expect[0]) == 1001. print(two_times.expect[0][-1]) # -0.59736575; print(many_times.expect[0][-1]) # -0.59736575; print(bad_times.expect[0][-1]) # -4.5466086e-08; ```. You can see that I was able to do a successful integration with only 2 times in `mesolve`, but many in a fast-oscillating Hamiltonian. Clearly the `bad_times` version (which only has the start and end points so misses all the fast oscillation behaviour) is completely different to the other two versions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-810246525:1342,assert,assert,1342,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-810246525,2,['assert'],['assert']
Testability,> I think I still needed to change the test workflow. Lets see if this works but let me know if you prefer another approach to include ipython in testing. The current approach looks good to me.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1918#issuecomment-1152412952:39,test,test,39,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1152412952,2,['test'],"['test', 'testing']"
Testability,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1447,log,logic,1447,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667,1,['log'],['logic']
Testability,"> I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things. Huh, that's surprising. Share some example code and I'll have a look?. > I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes`above) and liking the idea of not have to unpack`a`and`b`inside the test, and of being able to supply the shapes for`a`and`b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together). 👍 sounds good, carry on then!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1207510876:502,test,test,502,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207510876,1,['test'],['test']
Testability,"> I'm going to change the Clifford group tests a little, and rebase the typo fix commit into the general refactor before this one should be merged. Sure",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626315402:41,test,tests,41,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626315402,1,['test'],['tests']
Testability,"> I'm not sure the `Qobj permute` failing test is related, by the way. Yeah we actually figured this one out. It's a numerical round off error. `Qobj permute` uses `tidyup`, with the same numerical tolerance as is used when the equality of two `Qobj`s are compared in the test. Kind of lucky that it didn't fail before. We either have to change the test to use a larger tolerance in the comparison, or give an argument to `Qobj permute` to not use `tidyup`. This is not really related to this PR but I'll implement the change once we decide on the best solution. Does anyone have thoughts on why `Qobj permute` uses `tidyup` by default in the first place? I don't know how `permute` actually implements the permutation, but naively I would have thought that a permutation could be done without any numerical error",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-571353111:42,test,test,42,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-571353111,3,['test'],['test']
Testability,"> I've just spotted a bug in `isherm` on the new data layer, which is my fault for not getting the tests for that written yet. That may also be having some impact on the test fragility. Actually, I _didn't_ introduce a bug in `isherm`! It's just also present in the release version of QuTiP, but _masked_ by the `auto_tidyup`. In ""unrelated"" news: I discovered a dumb bug in `tidyup_dense`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1348#issuecomment-680059767:99,test,tests,99,https://qutip.org,https://github.com/qutip/qutip/pull/1348#issuecomment-680059767,2,['test'],"['test', 'tests']"
Testability,"> If I understand correctly it refers to line 300 in test_metrics, which has a new hellinger metric test by @wrzadkow . Could it be that using ""for _ in range(10):"" is a problem?. The following observations:; - `for _ in range(10)` is already in [line 128](https://github.com/qutip/qutip/blob/master/qutip/tests/test_metrics.py#L128) in `test_metrics.py` ; - [line 300](https://github.com/qutip/qutip/blob/master/qutip/tests/test_metrics.py#L300) is the end of docstring of `test_hellinger_monotonicity()` ; - the presence of `invalid escape sequence \o` in the error message; - this thread https://stackoverflow.com/questions/52335970/how-to-fix-string-deprecationwarning-invalid-escape-sequence-in-python. make me think that the issue may be caused by `\otimes` that I used in the docstring explanations. Don't have a Mac to reproduce and check whether removing this will help, though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-496497028:100,test,test,100,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-496497028,3,['test'],"['test', 'tests']"
Testability,"> Including a dimension of 8 makes the tests very slow to run. There's no real need to expand the dimensions of the test to such massive sizes - testing the stability of `eigh` should be done using a minimal test in a more specific location, such as in our general eigensystem tests.; > ; > In this case, you're constructing several 4096x4096 matrices using a sparse format, but they're all 100% dense so you spend ~30 seconds just handling sparse overhead that's nothing to do with the function call. You need to think about what a test is actually trying to test, and how long it _should_ take. When your changes are increasing the runtime by a factor of ~100, that's something you need to consider - are you actually increasing our test coverage, or just spinning the CI for longer? What is your change meant to catch? Could it be done faster in a different place? Take your time when you're changing the code, and really think about what you're trying to achieve. Good point I did not realize it was taking this long on the last mac test. . The thing is after testing thoroughly the issue starts to show itself at `2000X2000` matrices. This is less time consuming than `4096x4096` but still big. In any case `2000X2000` is something an user will probably probe, it is the size of aproximately an 11 qubit hamiltonian.; Regarding puting it with eigensystem tests there is one main issue: the eigenvalues are calculated as well as eigenstates which make running that test on the CI totally unfeasible. We could add a test for eigenenergies there but it seems unnatural. Other options are:; - Adding a test for eigenenergies vals on `test_sp_energies` [ Which I much prefer]; - Having a separate test file where we can include tests for all the nasty numeric instabilities.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-820522699:39,test,tests,39,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-820522699,16,['test'],"['test', 'testing', 'tests']"
Testability,"> Interesting, so doctest will also test docs in the code? How can I try it?. This are tested when you run `make doctest` as well. You can basically write the code example (like some already do) in the docstring of the function or class. For an example please check follow my other comment. It is indicated by the `>>>` and is tested unless skipped explicitly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1344#issuecomment-676207593:36,test,test,36,https://qutip.org,https://github.com/qutip/qutip/pull/1344#issuecomment-676207593,3,['test'],"['test', 'tested']"
Testability,"> It doesn't look robust enough to be user facing as it is, but as a private function, if you get a 3.5x, I'd say we want it. I'll rename it to `_from_csr_blocks` and add some more checks on the ordering and shape of the ops if those aren't too expensive and add some tests. We can expose it publicly if that's ever useful. > Technically, just give a type to `i` and it's all running in c code. Thanks! Adding the type to `i` did make it a little faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388:268,test,tests,268,https://qutip.org,https://github.com/qutip/qutip/pull/2128#issuecomment-1477071388,1,['test'],['tests']
Testability,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:350,test,tests,350,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390,1,['test'],['tests']
Testability,"> Looks good in general. Will have a closer test later today. There are some unnecessary style changes to other parts of the code. Especially `'` to `""` was quite unnecessary... It is not massive but it makes it a bit hard to identify which is the essential change. How hard is it to revert the changes of `'` to `""`? Other styling updates like removing unused importations are fine. it was done by a linter ,I can remove it but it was done to make it consistent with the other areas, I can revert it. the main part is the 2 function change and the ones inside the loop",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2442#issuecomment-2145360068:44,test,test,44,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2145360068,1,['test'],['test']
Testability,"> Looks great. I suggested some changes, mainly to docstring. I wonder what is the meaning of the filename qelib1.inc? Could we find a more explicit name if relevant? Should it be added to the Manifest file? It looks fine to me, looking forward to test it and having a section in the documentation would certainly help, under QIP. Ping for review of the notebook when ready and re-request this PR review. Regarding ""qelib1.inc"", it is a ""header"" file that contains some QASM gate definitions. It is available in the OpenQASM repository (as a standard file) and I think it's always included in QASM exports (atleast by QISKIT). It's useful because we don't need to write our own definitions and can just define QuTiP gates by mapping them to ""qelib1.inc"" gates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1318#issuecomment-663824413:248,test,test,248,https://qutip.org,https://github.com/qutip/qutip/pull/1318#issuecomment-663824413,1,['test'],['test']
Testability,"> Looks like I did mess up with the floquet.py versus flimesolve.py. I think; > I forgot at some point that I was to include all my new stuff in just the; > flimesolve.py, and then forgot about that script altogether. I apologize; > for this, and I'll fix it.; >; > I'll also go back through and fix style issues. As with above, I think I; > forgot to keep the proper styling at a certain point.; >; > I tried to keep my changes to correlation.py to a minimum, and contained; > to simply adding in the new solver in the make_solver function, as well as; > adding in some inputs as options to that solver, but I'll go through and; > review to see what's wrong.; >; > Thanks for your feedback, and I'll try to get this all fixed up as soon as; > I can.; >; >; > On Mon, Jun 26, 2023, 4:49 PM Eric Giguère ***@***.***>; > wrote:; >; >> ***@***.**** requested changes on this pull request.; >>; >> Something is strange in floquet.py, did you include change not meant to; >> be here?; >> Both floquet.py and flimesolve.py have the original fmesolve and the new; >> flimesolve...; >>; >> Tests should pass.; >> Right now, scipy 1.11 breaks cvxpy which we use so this breaks a few; >> tests, but the changes you made to correlation.py also break the tests.; >> We will want tests for the new solver.; >>; >> Could you also review the style (pep8).; >>; >> - There are some very long line, we use the official 80 characters; >> width.; >> - space are not uniform, sometime they are doubled, other time; >> missing.; >> - There are rules for empty lines, there should not be 3 empty lines; >> in a function.; >>; >> —; >> Reply to this email directly, view it on GitHub; >> <https://github.com/qutip/qutip/pull/2140#pullrequestreview-1499406717>,; >> or unsubscribe; >> <https://github.com/notifications/unsubscribe-auth/AV5WL5EA3UU23BHDUONIEN3XNHYVNANCNFSM6AAAAAAWLGP4AU>; >> .; >> You are receiving this because you authored the thread.Message ID:; >> ***@***.***>; >>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805:2410,Test,Tests,2410,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610056805,4,"['Test', 'test']","['Tests', 'tests']"
Testability,"> Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. > I also wouldn't mind a quick check of `qobj_shared_shapes`. Is this a good thing to be doing with shared strategies?. It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240:722,test,test,722,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207464240,2,['test'],"['test', 'tests']"
Testability,"> Nice work!; > ; > > I have removed self.gates as well as self.gates_and_measurements. The replacement is the more ""general"" (and less of a mouthful) self.circuit_ops which contains both.; > ; > I like this merge of to attributes. However, we shouldn't change the attribute name `gates`, at least not in this PR here. It's an open attribute API and as you see we used it a lot in tests. It's very likely that others are using it too.; > ; > Personally, I would keep the attribute `gates` since even for measurement operations, people still usually say ""measurement gates"". `circuit_ops` is certainly more accurate, but might be hard to remember and thus makes the learning curve steeper. Rolled back to self.gates",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-647834648:381,test,tests,381,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-647834648,1,['test'],['tests']
Testability,> Not a huge amount to be done about that CodeClimate failure to be honest. These complexity checking tools were all written with business software application logic in mind and don't cater well to cases where a single conceptual unit can be quite complex. Perhaps when we move to GitHub actions we can run our own linting tools directly there and get rid of CodeClimate.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1506#issuecomment-824625785:160,log,logic,160,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-824625785,1,['log'],['logic']
Testability,"> Not sure how to make a test for this. The file name is random and it's not always reliable when the `__del__` is called which is where the file is erased. You could create a coefficient and check that the last entry of `coeff_files.file_list` looks correct and exists. The wouldn't check the deletion but would check that the filename is correct. You can do `del qutip.qobjevo.coeff_files` to trigger the clean-up of the object, but that is a bit GC dependent and implementing it properly would require calling `gc.collect()`. Not sure if that is worth the hassle.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773:25,test,test,25,https://qutip.org,https://github.com/qutip/qutip/pull/2251#issuecomment-1781948773,1,['test'],['test']
Testability,"> On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below.; > ; > I defined a function that returns the values for a given value of `eps`:; > ; > ```python; > def current_noise_eps(eps):; > H = (eps/2 * sz + tc * sx); > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.673617",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:30,test,test,30,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100,3,"['assert', 'test']","['assert', 'test']"
Testability,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:307,log,log,307,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502,1,['log'],['log']
Testability,"> Please just use a single pyproject.toml with oldest-supported-numpy. You don't need to copy them around, the build you get is fine for docs & users. You can disable build isolation if you need to have a special newer NumPy for the compile (which is very rare). Thank you for taking a look here. As I explained before, we can't just use oldest-supported-numpy directly because we also require numpy >= 1.16.6 for our own code. The pypi-pyproject.toml file contains a copy of oldest-supported-numpy but with everything less that 1.16.6 replaced with 1.16.6. Overly specific build-system.requires can also cause failures with conda-forges build system -- e.g. this one for building this project with Python 3.10 on Windows 64 -- https://dev.azure.com/conda-forge/feedstock-builds/_build/results?buildId=407213&view=logs&jobId=00f5923e-fdef-5026-5091-0d5a0b3d5a2c&j=00f5923e-fdef-5026-5091-0d5a0b3d5a2c&t=3cc4a9ed-60e1-5810-6eb3-5f9cd4a26dba (maybe there is some separate way around that).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1735#issuecomment-989950888:814,log,logs,814,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989950888,1,['log'],['logs']
Testability,"> Quick disclaimer, I can't seem to install `cvxpy` on my machine without using anaconda, so I haven't run the qutip tests personally. I assume these run automatically in the pipeline. That's fine. The CI pipeline does test with cvxpy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396:117,test,tests,117,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2094924396,2,['test'],"['test', 'tests']"
Testability,"> Thank you for the PR. It look as it should work, but could you add a test to ensure it does.; > ; > Most codeclimat issues should be solved if you make a functions to read `(N, dims)`.; > ; > For super operator you can use: `N**2 = np.prod(qutip.dimensions.flatten(dims[0]))` Ideally, we should also check `type_from_dims(dims) == 'super'`. Hi, @Ericgig! Thank you for the comments.; I will:. [ ] add a test; [ ] create a function to implement the check on `N`, `dims`.; [ ] add a check for the superoperator functions: using `N**2 = np.prod(qutip.dimensions.flatten(dims[0]))`; [ ] add a check for the superoperator functions: check `type_from_dims(dims) == 'super'`. Hi, @AGaliciaMartinez! Thanks for your comments. The plan for `dev.major` is to substitute both `N` and `dims` in favour of `dimensions`, just as you described. I'll start working on that, as soon as I finish the current PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1846#issuecomment-1090664850:71,test,test,71,https://qutip.org,https://github.com/qutip/qutip/pull/1846#issuecomment-1090664850,2,['test'],['test']
Testability,"> Thank you. Can you please add tests for this? I'm leaving to @BoxiLi a closer review. Hello, Nathan! I already submitted a PR for a notebook testing the new functions under the branch ; https://github.com/qutip/qutip-notebooks/pull/106. If you want to see the notebook, here it's at my fork of the repo (latex equations display well in Jupyter): . https://github.com/mlaguna10/qutip-notebooks/blob/master/examples/Pauli-X%2C%20Y%2C%20Z%20and%20S%2CT%20Quantum%20Gates%20using%20QuTiP%20(Test%20under%20%231208).ipynb",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-602757325:32,test,tests,32,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-602757325,3,"['Test', 'test']","['Test', 'testing', 'tests']"
Testability,"> Thanks @eendebakpt. This is a great improvement for a small change. I left one suggestion for adding a bit more of a description to the change log, but I think it looks good to merge. Are there any more changes you'd like to make?. I am creating a similar PR against dev.major. Perhaps there are more optimizations to be done (have not checked yet), but I think it is better to put it in a seperate PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615:145,log,log,145,https://qutip.org,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615,1,['log'],['log']
Testability,"> Thanks @jakobjakobson13. A few modules' tests fail, on all operating systems, https://travis-ci.org/github/qutip/qutip/jobs/746708587. I wonder why.; > ; I think I went a bit to far. Perhaps I will close this pull request and cut it down into smaller chunks. > By the way, what software did you use, `autoflake`?; >; No, `deepcode.ai` but I don't know really know how good or bad it performs in contrast to other static code checkers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1394#issuecomment-735719114:42,test,tests,42,https://qutip.org,https://github.com/qutip/qutip/pull/1394#issuecomment-735719114,1,['test'],['tests']
Testability,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:21,test,tests,21,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695,8,"['assert', 'test']","['assert', 'test', 'tested', 'tests']"
Testability,"> The time-dependent weights are available as the `trace` attribute for each trajectories, so I though them as an (indirectly?) physical property of each trajectories. Since they are per trajectories, if feels normal to belong to the single trajectory result. But moving the logic to `NmmcResult` would simplify `MultiTrajResult` a lot and allow to remove `TrajectoryResult`. I do think it would be good to keep the `trace` property on the trajectories, but for the purpose of calculating the weighted averages, it could perhaps be treated like the other types of weights that we have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958:275,log,logic,275,https://qutip.org,https://github.com/qutip/qutip/pull/2502#issuecomment-2297864958,1,['log'],['logic']
Testability,"> Then out about removing dict expect? Dictionary support was not tested and supported only for some solver for a long time. It ; > would be strange to have it become the default. Well, this is v5 -- we are trying to make things nicer. The issue with lists of e_ops is that often the e_ops have no sensible ordering. E.g. if the e_ops are, say, the number operator and projectors on to two different bases of interest then `[qutip.num(N), proj1, proj2]` are later accessed as `.expect[0]`, `.expect[1]` and `.expect[2]` which are then unreadable and fairly arbitrary and unmemorable numbers. Having `.expect[""num""]`, `.expect[""proj1""]` and `.expect[""proj2""]` is much more readable and will result in fewer mistakes. I *really* like the dict interface because it gives this readability to results. I'm happy to accept that others may prefer lists, but providing multiple interfaces creates a problem for any code working with results. So it is a bit of tricky question to resolve. > For MC result, it has little impact, dict are a little more annoying to work with compared to list, but it need the expect as ndarray; not list or dict anyway. The MC result classes already have to work around these things in awkward ways, and probably need to be a lot more careful -- e.g. e_ops functions can return strange things like Qobjs or perhaps even stranger things like strings or dicts which can't be averaged over. > There are a some differences for the user. Code using `np.array(result.expect)` or `for expect in result.expect:` will break. Agreed, although unless `result.expect` contains a uniform set of things, this are probably not sensible things to be doing. I have some other ideas but I think they make more of a mess -- e.g. keep `.expect` a list but provide `.expect_d` which is a dict. If one needs to write v4 compatible code one can always pass a list of e_ops and then work with `.expect` a bit carefully (i.e. as a dict). Thoughts?. I have added tests now, so it's just the `.expect` issu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041:66,test,tested,66,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1141326041,1,['test'],['tested']
Testability,"> There are already test for `clebsch` in `test_utilities`. Could you move your new test there?. Yes sorry I didn't realise that was there, I put something together quickly because I was asked to include a test. I'll write something that fits better with the existing test and include it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1177#issuecomment-583730951:20,test,test,20,https://qutip.org,https://github.com/qutip/qutip/pull/1177#issuecomment-583730951,4,['test'],['test']
Testability,"> There are shims to make Pulse and qip tests work since they used QobjEvo.tlist and QobjEvo.ops.coeff.; @BoxiLi, the new QobjEvo can be added even if coefficient's tlist are different, but you cannot get back the tlist and the array from them. Also for _step_func_coeff, before the first time, Coefficient return the first value of the array, not 0 as expected in pulse.py. Thanks @Ericgig ! This is very useful!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1336#issuecomment-672712550:40,test,tests,40,https://qutip.org,https://github.com/qutip/qutip/pull/1336#issuecomment-672712550,1,['test'],['tests']
Testability,"> This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup. This is intentional -- we want to support installing from pre-built packages without a compiler or Cython installed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1735#issuecomment-990032654:19,log,log,19,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990032654,1,['log'],['log']
Testability,"> This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this.; > ; > To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button. Completely up to you, of course! If you choose to drop the optional dependency for now, I can also just put those changes on another PR to be merged when the time is right.; I'll stand by for your decision regarding the CI tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930:138,test,test,138,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147629930,4,"['log', 'test']","['log', 'test', 'tests']"
Testability,"> This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. @BoxiLi I did this and it worked, thank you! The issue was that I had originally installed it with the `build` package instead of with the setuptools build. Also, the code now passes both my new tests and existing tests in `qutip.tests.core.test_operators.py`. Additionally, I ran the `pytest qutip/tests -k` command on `f_op`, `fcreate`, and `fdestroy` to run all the tests associated with the new functions, and they pass as well. Lastly, regarding the circular import problem, I did as you suggested and moved the import inside the `f_op` function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987:312,test,tests,312,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565769987,5,['test'],['tests']
Testability,"> This randomly failing test appears again. It is really getting annoying. I copied the error message from Travis bellow:; > ; > ```; > =================================== FAILURES ===================================; > ___________________________ test_MCSimpleConstStates ___________________________; > @pytest.mark.slow; > def test_MCSimpleConstStates():; > ""Monte-carlo: Constant H with constant collapse (states)""; > N = 10 # number of basis states to consider; > a = destroy(N); > H = a.dag() * a; > psi0 = basis(N, 9) # initial state; > kappa = 0.2 # coupling to oscillator; > c_op_list = [np.sqrt(kappa) * a]; > tlist = np.linspace(0, 10, 100); > mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; > options=Options(average_states=True)); > assert_(len(mcdata.states) == len(tlist)); > assert_(isinstance(mcdata.states[0], Qobj)); > expt = expect(a.dag() * a, mcdata.states); > actual_answer = 9.0 * np.exp(-kappa * tlist); > avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > > assert_equal(avg_diff < mc_error, True); > E AssertionError: ; > E Items are not equal:; > E ACTUAL: False; > E DESIRED: True; > ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; > ----------------------------- Captured stdout call -----------------------------; > 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; > 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; > 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; > 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; > 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; > 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; > 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; > 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; > 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; > 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; > Total run time: 20.34s; > ---------- covera",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896:24,test,test,24,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896,1,['test'],['test']
Testability,"> This was reported on the help group; > https://groups.google.com/forum/#!topic/qutip/L-MIFFwK0xU; > ; > (copying from there); > the newest mkl(Math library for intel) version(2019) can not work on QuTiP 4.3.1. I rollback it to mkl(2018.0.3), the qutip.testing then work well.; > ; > If using mkl(2019.0), there will MKL read problems, like:; > ; > ```; > File ""C:\Users\ym24chen\Anaconda3\; > x = lu.solve(b, verbose=verbose); > File ""C:\Users\ym24chen\Anaconda3\envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 164, in solve; > np_x, np_error); > OSError: exception: access violation reading 0x0000000000000008; > envs\qutip-env\lib\site-packages\qutip\_mkl\spsolve.py"", line 384, in mkl_spsolve; > ```; > ; > Env info:; > ; > ```; > QuTiP Version: 4.3.1; > Numpy Version: 1.15.4; > Scipy Version: 1.1.0; > Cython Version: 0.29.6; > Matplotlib Version: 3.0.3; > Python Version: 3.7.2; > Number of CPUs: 8; > BLAS Info: INTEL MKL; > OPENMP Installed: False; > INTEL MKL Ext: True; > Platform Info: Windows (AMD64); > Installation path: C:\Users\canwa\AppData\Local\conda\conda\envs\qutipenv\lib\site-packages\qutip; > ==============================================================================; > ```. How can I rollback it to mkl(2018.0.3)? I just use ""conda install mkl=2018"" but the test still return errors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/975#issuecomment-536162505:254,test,testing,254,https://qutip.org,https://github.com/qutip/qutip/issues/975#issuecomment-536162505,2,['test'],"['test', 'testing']"
Testability,"> Tried a few more options, looks good.; > ; > Yeah, I know it is from a linter. Personally, I'm fine since the change is not massive. If others think this might mess up the code history, please speak up.; > ; > Please add a Towncrier file for the change log.; > ; > I'll wait for one or two days, if no one comments, will merge. Sounds good, I will add the Towncrier file shortly and open an issue for the new bug",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2442#issuecomment-2147354527:255,log,log,255,https://qutip.org,https://github.com/qutip/qutip/pull/2442#issuecomment-2147354527,1,['log'],['log']
Testability,"> We allow the user to supply the `QobjEvo` class to use as an option, and allow them to specify either the class itself or a name for the class. E.g. `qobjevo_cls=QobjEvoHerm` or `qobjevo_cls=herm`. I would prefer the user not needing to know how we do it, just that there an option that speed up the simulation by 40 % in normal cases. Knowing that we forced it in an alternative qobjevo class is not useful and I hope we won't be forced to add many kinds of qobjevo. > Perhaps we should also not allow users to switch the class later by changing options? That might simplify the logic because we wouldn't need to modify the RHS when options are updated. Since changing options does not change the physic, I would like them to be changeable. But the `rhs`, and `_rhs` is certainly not great. I will rethink the way to do it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203:582,log,logic,582,https://qutip.org,https://github.com/qutip/qutip/pull/2173#issuecomment-1664483203,1,['log'],['logic']
Testability,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:19,test,tests,19,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207,4,['test'],['tests']
Testability,"> What is the main difference between `expect` and `measure`? That's the main thing that comes up ; > to my mind. What different question are you answering? I also wonder if `expect` could be called. . `expect` returns the expectation value (i.e. probability weighted average of the measurements). `measure` returns a *single* measurement (i.e. an eigenvalue and an eigenstate, selected randomly with weighted probabilities). > The description of the `measure` function is a bit general maybe with this regard. But I might have ; > missed the point completely (my bad). Open to suggestions. I will also re-read it and see if I can think of something clearer.; ; > Somehow `smesolve` tests fail with Travis CI, not sure how this PR could have affected it. I'll dig a bit and see if the failure is related somehow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-536753408:683,test,tests,683,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-536753408,1,['test'],['tests']
Testability,> What made you trip over this?. I was using this function with N=13 for some testing code I have and realised it took too long to create the matrix.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1688#issuecomment-942163402:78,test,testing,78,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942163402,1,['test'],['testing']
Testability,"> Which qutip-tensorflow tests are affected? All of them?. Yes, as this warning is raised when qutip is imported. > Do you know why qutip's own tests are not affected?. To be honest, I am not sure. I think at this moment the tests in `dev.major` do not treat warnings as errors (see [this commit](https://github.com/qutip/qutip/commit/c446e4acd0e4b87a7993a9861440debe5436023b)). Although I am not sure if prior to this commit qutip's own tests were affected. However, I have just realised that this is not the first time the deprecation warning from `pyximport` is silenced. In particular, in PR #1506 @jakelishman also silenced this warning in the master branch: ; https://github.com/qutip/qutip/blob/3432bfeb19ba14f1ef51e9e775588e33db17349c/qutip/cy/pyxbuilder.py#L39-L47; I can add the same comment and the `module=pyximport`. Was there any reason to not merge this change in dev.major?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889:25,test,tests,25,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889,4,['test'],['tests']
Testability,"> Yes, you should use [`mutually_broadcastable_shapes(signature=)`](https://hypothesis.readthedocs.io/en/latest/numpy.html#hypothesis.extra.numpy.mutually_broadcastable_shapes) for that. The signature syntax is a little different, since Numpy does it with strings, but we already support named dimensions, constant-size dimensions, and optional dims. Should be a bit more efficient too. I tried with `signature=` quite a bit but `(m, k), (k, n)` always produced thing like `(1, 1, 1), (1, 1)` despite setting `max_dims` and `min_dims` to various things.; ; > It does technically work? But in such a situation I'd probably just use `st.data()` and draw in the body of the test; see `hypothesis write numpy.matmul` for an example. If you expected to use it in many tests maybe a custom strategy, but for just `test_data_matmul_operator` that doesn't seem worth it. I expected there to be other use cases. I started with the output of `write numpy.matmul` but ended up playing around with my own strategy (see difficulties with mutually_broadcastable_shapes` above) and liking the idea of not have to unpack `a` and `b` inside the test, and of being able to supply the shapes for `a` and `b` to other strategies (e.g. maybe we will have a strategy for Qobj and QobjEvo objects and want to try various combinations of multiplying things together)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361:671,test,test,671,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207475361,3,['test'],"['test', 'tests']"
Testability,"> [![Coverage Status](https://camo.githubusercontent.com/5b95d685d6392d8f3beccad1e575f46ea5187ccd/68747470733a2f2f636f766572616c6c732e696f2f6275696c64732f33323635363130332f6261646765)](https://coveralls.io/builds/32656103); > ; > Coverage decreased (-10.2%) to 60.763% when pulling **[3b09002](https://github.com/qutip/qutip/commit/3b090027a58ee842c419244920d65623d70ee4a2) on jakelishman:core-replace-fast_csr_matrix** into **[0740a04](https://github.com/qutip/qutip/commit/0740a04cf0b9286b5e13cb0bcf026de6b284c011) on qutip:dev.major**. It should be noted that the coverage drop is so large here because large tracts of tested Python source files were removed and replaced by _Cython_ source files, which Coveralls does not handle correctly. These files typically are tested (albeit not yet completely), but Coveralls reports `.pyx` files as having 7 lines of code, of which all 7 are missed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332#issuecomment-672831585:622,test,tested,622,https://qutip.org,https://github.com/qutip/qutip/pull/1332#issuecomment-672831585,2,['test'],['tested']
Testability,"> _**Other minor changes**_; > ; > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > ; > ```; > if self.fig:; > plt.show(self.fig); > ```; This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935:456,test,test,456,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935,1,['test'],['test']
Testability,"> `ProcessPoolExecutor` being enough to fix most windows tests is surprising. I have a feeling this has something to do with processes spawned not still being running after the function exits. > Now we just need to speed up correlation tests. Any idea how to speed up the correlation tests, or should I just skip those again in this PR and we can fix them in a follow up PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442:57,test,tests,57,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171235442,3,['test'],['tests']
Testability,"> can you add some cases that test N is calculated correctly including implicit tensor structure in dims, because that's what this is meant to be most useful for, right?. @jakelishman I have added 2 more functions to test N and tensor shape. I was a bit confused about how to check for tensor structure in dims. So, I check if the shape of output matches to what it is supposed to be. . Would you prefer these functions be combined into one ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1509#issuecomment-831499015:30,test,test,30,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-831499015,2,['test'],['test']
Testability,"> does this floquet formalism supports any hamiltonian or just it works for two level systems?. It should support any hamiltonian. I have simulations test cases with harmonic oscillators for instance. However, you should have a look at the code from #766 since the code currently in QuTiP repository seems to have been tested only with two-level systems and contains some bugs. > Also the code uploaded is not working, how to plot this wigner function?. I'm sorry, I have no idea what you are talking about. > Floquet formalism is totally not working fro me. plz help. I think you should first try to make it work with simple two-level systems. See http://qutip.org/docs/latest/guide/dynamics/dynamics-floquet.html and https://gitlab.inria.fr/lverney/qutip_floquet_example/blob/master/Example.ipynb. Note that there are some bugs in the current QuTiP code which are fixed by #766 but this one is not yet merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/772#issuecomment-355973074:150,test,test,150,https://qutip.org,https://github.com/qutip/qutip/issues/772#issuecomment-355973074,2,['test'],"['test', 'tested']"
Testability,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:105,test,tests,105,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005,4,['test'],"['test', 'testing', 'tests']"
Testability,"> thanks, looks good to me! not sure why tests are failing. Definitely not related to this change, but weird. Had a brief look but couldn't make much sense of it :/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2550#issuecomment-2439085075:41,test,tests,41,https://qutip.org,https://github.com/qutip/qutip/pull/2550#issuecomment-2439085075,1,['test'],['tests']
Testability,"> though that's a whole other can of worms, because that's GPL'd. Yes, if it is GPL then it should be removed. That license can be construed to mean that all other pieces of code that use it must be under the same license; One can read the license as all derivative works must be GPL. So I would revert that PR ASAP. > legality of asserting copyright ""2011 and onwards"" in general. Yeah putting years I think is the correct thing. Didn't know that at the time. > I'm starting at IBM in Lev Bishop's team on the 5th of July. Look forward to talking to you in July!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-864049973:331,assert,asserting,331,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864049973,1,['assert'],['asserting']
Testability,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:334,test,tests,334,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165,10,['test'],['tests']
Testability,"> you can see that when it runs conda uninstall cython, it downgrades numpy to 1.14.2. This is really strange. > This would not be a problem in a conda-forge release build, because the numpy API dependency is pinned in the feedstock, but it is a potential problem on pip source builds. I was setting up a GitHub Action test for `qutip_qip` https://github.com/qutip/qutip-qip/pull/6. `pip installation` works well there, but it could be that I don't use any run-time compiling.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1448#issuecomment-782174452:319,test,test,319,https://qutip.org,https://github.com/qutip/qutip/pull/1448#issuecomment-782174452,1,['test'],['test']
Testability,">I added the teleportation circuit because it seemed like a simple enough example to test both classically controlled gates and measurements. I have some separate (non-circuit based) examples in the other file. Maybe the run_statistics test can be not on the teleportation circuit and something even simpler ?. Maybe, but I find teleportation already a very short circuit, isn't it?. >Re: the idea for run_statistics, do you mean tracking the various probability elements during each measurement (along with the state) ?. Yes, if we have n qubit measurements, we will have 2^n possible final state. One can calculate the state for each of them along with its probability and then get the exact statistics.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640113087:85,test,test,85,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640113087,2,['test'],['test']
Testability,">The compound assignment operators have different semantics,. I suggest to reconsider such a wording a bit more. :thought_balloon: I imagine that the discussed assignment variants should logically be equivalent. >which may change the behaviour of the code. Some differences are documented. :thought_balloon: Would you find any “effects” on the software run time characteristics desirable?. >… certain operations that need to perform a copy no longer do. How would you like to identify (and eventually mark) the source code places where in-place data modifications should be excluded? :thinking:. >We already do use compound assignments in many places where we absolutely want the operation to be in-place. Thanks for such a background information. >For immutable types on the left, …, the compound assignment has no difference (other than evaluating subscripts only once). :thought_balloon: Can this information trigger any further development considerations?. >…, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. How do you think about to clarify evolving development views any further by corresponding test cases? :thinking:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708:187,log,logically,187,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708,2,"['log', 'test']","['logically', 'test']"
Testability,"@@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, Tru",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25257,test,tests,25257,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['test'],['tests']
Testability,"@AGaliciaMartinez @gaurav-iiser Since you are looking at the Bloch sphere code too, I'd appreciate some more eyes / trying out of these changes if you have time. We don't have great tests for these plotting functions and the behaviour is rather environment dependent (Python console vs IPython console vs Jupyter notebook vs Spyder).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1619#issuecomment-950309855:182,test,tests,182,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-950309855,1,['test'],['tests']
Testability,"@AGaliciaMartinez Hello, I have made the required changes in the __repr__() of QobjEvo. . Output of the new code:; ```; >>> import qutip; >>> qutip.QobjEvo([qutip.qeye(2), lambda t: t]); <QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=False, num_elements=1>; ```; _In your suggestion, there wasnt a ""<"" before QobjEvo, so I added that._. I have also edited the page according to the `pycodestyle`. Kindly check the test too. This is my first test, so do suggest changes, if required. I could not think of different cases, so I write 4 cases, and checked them according to the expected result.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2111#issuecomment-1458446395:445,test,test,445,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1458446395,2,['test'],['test']
Testability,"@AGaliciaMartinez I applied your suggestions, updated the docstrings and added some tests. Would you mind having a quick last review?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-1057408459:84,test,tests,84,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1057408459,1,['test'],['tests']
Testability,"@AGaliciaMartinez Thank you!; I have removed both `<` and `>` from the `repr()`. Now it looks like this:; ```; >>> import qutip; >>> qutip.QobjEvo([qutip.qeye(2), lambda t: t]); QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=False, num_elements=1; ```. I have added many tests according to your suggestions. Now there are 7 cases to check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2111#issuecomment-1464940552:301,test,tests,301,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1464940552,1,['test'],['tests']
Testability,@AGaliciaMartinez Thanks for the review and the good suggestions. I've applied them so I'll merge once tests pass.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1818#issuecomment-1060998181:103,test,tests,103,https://qutip.org,https://github.com/qutip/qutip/pull/1818#issuecomment-1060998181,1,['test'],['tests']
Testability,"@AGaliciaMartinez This doesn't look terrible to me, but we've avoided silencing warnings like this in qutip so far and it would be nice to keep it that way. Some questions:. * Do you know why qutip's own tests are not affected?; * Which qutip-tensorflow tests are affected? All of them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142:204,test,tests,204,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142,2,['test'],['tests']
Testability,@AGaliciaMartinez Would you mind updating this branch to the latest master branch? (I am trying to understand the broken test),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1692#issuecomment-947715265:121,test,test,121,https://qutip.org,https://github.com/qutip/qutip/pull/1692#issuecomment-947715265,1,['test'],['test']
Testability,"@ArchieB151 I've now run the notebook myself using QuTiP 4.7.0 and it produces the expected plots. However, it has numerous small things that need to be fixed because it was originally written for an older version of QuTiP. We are almost ready to release a completely updated set of notebooks that updates all of these old notebooks. These notebooks are tested automatically regularly. You can find the updated version of the Jaynes-Cummings lecture at https://qutip.org/qutip-tutorials/tutorials-v4/lectures/Lecture-1-Jaynes-Cumming-model.ipynb and the full set of notebooks at https://qutip.org/qutip-tutorials/ (the page is very plain HTML, but it will be prettified soon). Could you try the updated notebook with 4.7.0 and see if it works for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791:354,test,tested,354,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229167791,1,['test'],['tested']
Testability,@Babalion Thank you for tyring.; Please let us know if you meet any bug. I am keeping both for version of `mcsolve` for now for benchmarks.; The new version has more features but it's slower than the previous.; The new version will replace the main one before we release in v5.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1710#issuecomment-974489887:128,benchmark,benchmarks,128,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-974489887,1,['benchmark'],['benchmarks']
Testability,"@BoxiLi . Yes, how to include gates in qutip is not clear to me. Many of them seems specialized so I don't think we should keep them all. Keeping only some of them could be fine but I am not well placed to choose a subset of commonly used gates and the `target` made them quite specialized. It also means that some gates will be defined in both qutip and qutip-qip. I also want all function that create `Qobj` in qutip the follow an common interface (they should all support `dtype`) and if we want these functions to also follow the qip signature, it could get somewhat complex. I think removing them and having the private functions for tests will make it easier for us on the long run. I see the use of `expand_operator` now that you explain it. I would prefer to have it in dimension.py and having users call it manually than being included in the `Qobj` creation function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262:639,test,tests,639,https://qutip.org,https://github.com/qutip/qutip/pull/1890#issuecomment-1121155262,1,['test'],['tests']
Testability,@BoxiLi ; ![tests](https://user-images.githubusercontent.com/15188655/78184791-ae03f000-742f-11ea-8736-03e929654bf2.png),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607480527:12,test,tests,12,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607480527,1,['test'],['tests']
Testability,"@BoxiLi I am happy with the code in this PR now. Great work.; Can you resolve the merge conflicts? I am guessing this is why we don't see the Travis test results. I am not concerned about the CodeClimate test failures. Might be worth commenting on this:; 'Function adjacent_gates has a Cognitive Complexity of 142 (exceeds 5 allowed).' ; though, as it's an order of magnitude beyond the rest :-). Thanks, Alex.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1065#issuecomment-537843702:149,test,test,149,https://qutip.org,https://github.com/qutip/qutip/pull/1065#issuecomment-537843702,2,['test'],['test']
Testability,@BoxiLi I believe this is already solved in QuTiP 5 (or at least I haven't seen it in the Windows tests easily). Do you have an easy way to check?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1190#issuecomment-1171589413:98,test,tests,98,https://qutip.org,https://github.com/qutip/qutip/issues/1190#issuecomment-1171589413,1,['test'],['tests']
Testability,"@BoxiLi I guess; https://github.com/qutip/qutip/blob/4f9b04b149734a7d81cb25ff25a844e4ee41a6ea/qutip/tests/test_processor.py#L333-L345; didn't successfully add a check for this?. I'll try get the unit tests running locally so I can add to this, but feel free to fix this up on my behalf if it's obvious to you :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1322#issuecomment-658689372:100,test,tests,100,https://qutip.org,https://github.com/qutip/qutip/pull/1322#issuecomment-658689372,2,['test'],['tests']
Testability,"@BoxiLi I'd like you to approve to since this is a very important link to `qutip_qip`. Once we have Boxi's approval and the tests pass, I think we can consider this done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1920#issuecomment-1150044489:124,test,tests,124,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1150044489,1,['test'],['tests']
Testability,"@BoxiLi Sure, the tests looks not too complex. I'm working on it. I'm grouping the gates for better error handling. @jakelishman Thanks. Sorry, I was just too lazy to set up the tests on my machine, LOL. I simply create the pull request and see if the code pass. That's why there are always one or two minor fixes here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629843104:18,test,tests,18,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629843104,2,['test'],['tests']
Testability,"@BoxiLi Would you be happy to apply this to `qutip-qip` too?. @drew-parsons Could you check that this works for you and that I haven't missed any other cases? The entire test suite passed for me, but one never knows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1648#issuecomment-909203229:170,test,test,170,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909203229,1,['test'],['test']
Testability,"@BoxiLi also, quite interestingly it seems that the tests don't fail all the times. This is another run of the tests:. ```; FAILED tests/test_countstat.py::test_dqd_current - AssertionError: ; ======================================================== 1 failed, 2872 passed, 119 skipped, 67 deselected, 67 warnings in 132.32s (0:02:12) ========================================================; ```. I actually think it only happens if I use `qutip.testing.run()` more than once in the same python shell. And by running pytest directly they don't seem to fail. . `test_countstat.py::test_dqd_current` is the only one that fails consistently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315:52,test,tests,52,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315,5,"['Assert', 'test']","['AssertionError', 'testing', 'tests']"
Testability,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:120,test,tests,120,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898,2,['test'],['tests']
Testability,@ElieGouzien the new QuTiP release solves this. See the [change log](http://qutip.org/docs/latest/changelog.html) for more information on new features.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1019#issuecomment-510892254:64,log,log,64,https://qutip.org,https://github.com/qutip/qutip/issues/1019#issuecomment-510892254,1,['log'],['log']
Testability,"@EricGig thank you for the extensive investigation. What do you think of; adding (even with a temporarily note) this information in the QuTiP Docs? I; feel like the fix may take long and having something written up under some; official section on the website may help for future reference. On Wed, 13 May 2020 at 23:38, Eric Giguère <notifications@github.com> wrote:. > I did some tests and; > 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian; > matrices) (c's version Ok); > 2 - It happen when installing the scipy stack with pip but not when; > installing it with conda.; > 3 - It depend on the problem size, 64 seems particularly bad, usually it; > fails on the second call.; > 4 - I only got it in zheevr which is only used in brmesolve. But Nathan; > got it in other tests which use scipy's eigh.; > 4 - It happen in scipy in the fortan version of lapack:; >; > import numpy as np; > from scipy.linalg import eigh; > H = random_hermitian(64); > eigh(H) # Work fine; > eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; >; > Possible solutions (for zheevr):; >; > - Installing scipy with conda, the easiest solution, but not in our; > control.; > - Finding a way to link clapack from cython. Linking scipy's one would; > require good knowledge of scipy internals since only one cython interface; > is provided. Linking to another installation of lapack, but it would; > require the user to install lapack or install it with qutip. Both seems; > wrong to me.; > - For mac user, call scipy's eigh from cython i zheevr, slower but; > better than risking segfault.; > - Have the code directly in qutip. We can adapt it from OpenBlas:; > https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1197#issuecomment-628259492>, or; > unsubscribe; > <",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264:381,test,tests,381,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264,2,['test'],['tests']
Testability,"@Ericgig . - docstrings should be fixed. - coveraged increased with . `e_ops = [callable, qobj]; e_ops = [callable, callable]; e_ops = [qobj, qobj]`. - added a more efficient and clear pytest parametrization; - fixed the repeated sparse test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157:237,test,test,237,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157,1,['test'],['test']
Testability,"@Ericgig ; > Is there a way to set towncrier to not require the PR number? Otherwise we need to open a PR without the changelog, which will fail the towncrier test, to modify it to add the change log... It would a lot better if we could add it when developing or have a towncrier read it from the Changelog section of PR description. Yes, I think we could use the issue number that the change is for, if this workflow makes sense for QuTiP (I don't know, I'm a first-time contributor). This is what [pytest does](https://github.com/pytest-dev/pytest/blob/main/CONTRIBUTING.rst#preparing-pull-requests).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927#issuecomment-1154193144:159,test,test,159,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1154193144,2,"['log', 'test']","['log', 'test']"
Testability,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:194,test,testing,194,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169,2,['test'],['testing']
Testability,@Ericgig All tests except Mac are passing. Can we merge now?; @nonhermitian Would you want to my Wigner function to be renamed?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/912#issuecomment-475860332:13,test,tests,13,https://qutip.org,https://github.com/qutip/qutip/pull/912#issuecomment-475860332,1,['test'],['tests']
Testability,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:34,test,tests,34,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801,3,['test'],['tests']
Testability,@Ericgig Can you help me with this one? I am considering adding tests for progressbar.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2112#issuecomment-1471891250:64,test,tests,64,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1471891250,1,['test'],['tests']
Testability,@Ericgig Can you please guide me through (step-by-step developing test function or test classes) writing tests for progressbar? I don't have much experience with writing python tests? But I am a quick learner and can easily grasp the fundamentals.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220:66,test,test,66,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1474760220,4,['test'],"['test', 'tests']"
Testability,@Ericgig Happy for this to be merged as soon as the tests finish.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1778#issuecomment-1017835823:52,test,tests,52,https://qutip.org,https://github.com/qutip/qutip/pull/1778#issuecomment-1017835823,1,['test'],['tests']
Testability,"@Ericgig Hey Eric, I fixed the test script issues last week, but wasn't sure if you wanted me to ping you again. I'm pinging you again now, but if this isn't what you would like, please let me know!. That is, I'm _pretty sure_ everything should be working now. The test_flimesolve.py script, flimesolve (with your changes made - without the fixing of the step method yet), and correlation.py (where I added options for FLiMESolve to be used) should all be working now. Let me know if there's anything else that needs fixed. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693:31,test,test,31,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2082770693,1,['test'],['test']
Testability,"@Ericgig Hey Eric, added your changes to the test, fixed the documentation error as well. I also added a steady state solver, would you want me to make a test for that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518:45,test,test,45,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2094417518,2,['test'],['test']
Testability,@Ericgig Hi. I added `lsqr` and all tests succeeded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2120#issuecomment-1470193242:36,test,tests,36,https://qutip.org,https://github.com/qutip/qutip/pull/2120#issuecomment-1470193242,1,['test'],['tests']
Testability,@Ericgig Hi. I added tests. Could you review the code?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2203#issuecomment-1682090307:21,test,tests,21,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1682090307,1,['test'],['tests']
Testability,@Ericgig Hi. I prefer the latter. I am adding tests in #2193 now.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2192#issuecomment-1637065595:46,test,tests,46,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1637065595,1,['test'],['tests']
Testability,"@Ericgig Hi. The Github test fails because of plot_spin_distribution. ```plot_spin_distribution``` plots color at (x, y), but the correct way to use ```pcolor``` is plotting color in rectangles made by four matrix elements ([the link](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.pcolor.html)). It may be difficult to fix this warning and hence we can not add pytests for it.; https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.pcolor.html",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2192#issuecomment-1634286008:24,test,test,24,https://qutip.org,https://github.com/qutip/qutip/pull/2192#issuecomment-1634286008,1,['test'],['test']
Testability,"@Ericgig I added tests for storing the final state without storing the state and for normalization of kets, dms and unitaries in sesolve. Worryingly, the normalization test passes regardless of whether we have `state.shape[1] == 1` or `data.shape[1] == 1` so I am not sure if both are correct, or if there is something else wrong.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1148785670:17,test,tests,17,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148785670,2,['test'],"['test', 'tests']"
Testability,"@Ericgig I am now trying to use pytest's parametrize feature which allows us to parametrize input to test functions variable by variable. I was able to successfully rewrite some tests which use `yield`, but this one (`test_trunc_neg`) in particular throws an error. Could you please run the following self sufficient snippet locally and inform me if there is anything wrong with the values in this example?? Thanks for the tip about yield, that might indeed be what is wrong. ```; from qutip import *; import numpy as np; import pytest; from numpy.testing import (assert_equal, assert_, assert_almost_equal,; run_module_suite). @pytest.mark.parametrize(""method"", ['clip', 'sgs']); @pytest.mark.parametrize(""qobj"", [rand_dm(5), Qobj(np.diag([1.1, -0.1])),; rand_unitary(3)*Qobj(np.diag([1.1, 0, -0.1]))*rand_unitary(3).dag()]); @pytest.mark.parametrize(""expected"", [None, Qobj(np.diag([1.0, 0.0])),; rand_unitary(3)*Qobj(np.diag([1.0, 0.0, 0.0]))*rand_unitary(3).dag()]); def test_trunc_neg(method, qobj, expected):; ""Checks trunc_neg in several different cases.""; pos_qobj = qobj.trunc_neg(method=method); assert(all([energy > -1e-8 for energy in pos_qobj.eigenenergies()])); assert_almost_equal(pos_qobj.tr(), 1); if expected is not None:; assert_almost_equal(pos_qobj.data.todense(), expected.data.todense()); ```. Also, I would like to rewrite all the tests which use `yield` in this format, would that be okay?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-571008013:101,test,test,101,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-571008013,5,"['assert', 'test']","['assert', 'test', 'testing', 'tests']"
Testability,@Ericgig I chose ```anim_wigner_sphere```. I will add test tomorrow.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2203#issuecomment-1680562161:54,test,test,54,https://qutip.org,https://github.com/qutip/qutip/pull/2203#issuecomment-1680562161,1,['test'],['test']
Testability,"@Ericgig I fixed the typos you mentioned and added a test in for nonzero timesense values and for the correlation functions. I also fixed the typo you mentioned and added a short descriptor for FLiMESolve above the ""parameters"" in documentation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-2090845530:53,test,test,53,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-2090845530,1,['test'],['test']
Testability,"@Ericgig I have added the color option for add_points also. For the single-color method, a single color with be passed. And for the multi-color method, a list of colors will be passed. I have tested it in https://github.com/rajathshetty20/misc/blob/master/qutip%20%231292.ipynb",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1315#issuecomment-665487867:192,test,tested,192,https://qutip.org,https://github.com/qutip/qutip/pull/1315#issuecomment-665487867,1,['test'],['tested']
Testability,"@Ericgig I have completed all the testing now. Everything looks good.; This truly looks like an awesome piece of work. The `QobjEvo` looks like it has great potential in many applications.; On behalf of all qutip users, thank you very much for taking on this mammoth task and doing such an excellent job. It is probably best if you squash and merge this yourself, as you can then edit the merged commit message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/815#issuecomment-459375419:34,test,testing,34,https://qutip.org,https://github.com/qutip/qutip/pull/815#issuecomment-459375419,1,['test'],['testing']
Testability,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:83,test,test,83,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877,4,['test'],"['test', 'tests']"
Testability,"@Ericgig I re-triggered the builds. If that doesn't fix the tests, could you merge dev.major into this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1657#issuecomment-920075921:60,test,tests,60,https://qutip.org,https://github.com/qutip/qutip/pull/1657#issuecomment-920075921,1,['test'],['tests']
Testability,@Ericgig I tested it on Windows. All tests pass.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1313#issuecomment-655083091:11,test,tested,11,https://qutip.org,https://github.com/qutip/qutip/pull/1313#issuecomment-655083091,2,['test'],"['tested', 'tests']"
Testability,@Ericgig I'm happy to leave this open until a new numpy is released and we can update the version of numpy used in CI tests. Probably also good to have an issue open in case users encounter this in the wild.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1694#issuecomment-979433765:118,test,tests,118,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-979433765,1,['test'],['tests']
Testability,@Ericgig I'm not sure why my changes make one test `tests/test_brtools.py::test_diag_liou_mult` fail.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1401#issuecomment-751561367:46,test,test,46,https://qutip.org,https://github.com/qutip/qutip/pull/1401#issuecomment-751561367,2,['test'],"['test', 'tests']"
Testability,"@Ericgig I've expanded the tests and reworked this so that it's less of a WIP. I've also documented the expected behaviour of the data layer in the presence of `nans`, etc in the description of the PR. I'll find somewhere in the docs to add that before merging the PR. Would you mind taking another look and letting me know what you think?. P.S. I also haven't had a clean test run on GitHub Actions yet, but they pass consistently on my machine now. I think I cleaned up most of the issues from the recent GitHub Actions runs in my recent commits, but I'll know in the morning. Obviously CI needs to pass consistently before merging could happen.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1506031688:27,test,tests,27,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1506031688,2,['test'],"['test', 'tests']"
Testability,"@Ericgig I've kept the WIP label, but this is ready for a first review. I think I'm made the HEOM look as much like the base solver as I can without having to modify the base solver a bit. Perhaps we can meet up tomorrow on Discord to discuss options. I'm also happy to merge this as is and adapt the solver more in another PR (assuming tests still pass and documentation still builds with my latest commits).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887:337,test,tests,337,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887,1,['test'],['tests']
Testability,@Ericgig I've started this branch specifically to tackle the strange steadystate (and other) test failures.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1694#issuecomment-948435607:93,test,test,93,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-948435607,1,['test'],['test']
Testability,"@Ericgig Not sure if it's directly related to this PR, but the Travis build failed on `test_diag_liou_mult` with the following tolerance error:; ```; > np.testing.assert_allclose(target, calculated, atol=1e-12); E AssertionError: ; E Not equal to tolerance rtol=1e-07, atol=1e-12; E ; E Mismatched elements: 2 / 6724 (0.0297%); E Max absolute difference: 3.36667153e-12; E Max relative difference: 1.85567862e-08; ```; Not sure if we should relax the tolerance slightly now (maybe 1e-11?), or in a separate PR later, or if there is something real to fix.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-853030860:155,test,testing,155,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-853030860,2,"['Assert', 'test']","['AssertionError', 'testing']"
Testability,"@Ericgig Ok, I'm happy with all your comments. Let me know when you its ready for me to test functionally.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/815#issuecomment-458516006:88,test,test,88,https://qutip.org,https://github.com/qutip/qutip/pull/815#issuecomment-458516006,1,['test'],['test']
Testability,"@Ericgig Should now be passing all tests, and essentially be ready",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2303#issuecomment-1925702584:35,test,tests,35,https://qutip.org,https://github.com/qutip/qutip/pull/2303#issuecomment-1925702584,1,['test'],['tests']
Testability,"@Ericgig Tests added for the type changes. Note that `QobjEvo.__rmatmul__` is not currently callable. Calling `qobj @ qevo` will call `QobjEvo.__matmul__(qobj, qevo)` first, which will return the result. If I am not missing a case where `__rmatmul__` is called, I vote that we simply delete the implementation of `__rmatmul__` (in a separate PR).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1149772678:9,Test,Tests,9,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1149772678,1,['Test'],['Tests']
Testability,@Ericgig Tests changed to use non-hermitian H.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1148925787:9,Test,Tests,9,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148925787,1,['Test'],['Tests']
Testability,"@Ericgig Tests passed and we both approved, so I've clicked the merge button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1590#issuecomment-876733923:9,Test,Tests,9,https://qutip.org,https://github.com/qutip/qutip/pull/1590#issuecomment-876733923,1,['Test'],['Tests']
Testability,"@Ericgig Thanks for finding that -- I obviously missed a last round of testing in Jupyter notebooks. I've added a special case for the inline backed in Jupyter notebook and even more comments. The downside is that the whole situation with matplotlib is crazy and the current Bloch implementation is not making things any more sane. The upside is that things now seem to work fairly nicely for me in practice. Holding thumbs that they work nicely for you too. P.S. As a bonus, `b.show()` now works for displaying the colormap and the `b.fig` special case is no longer needed (although it still works too).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1619#issuecomment-989293761:71,test,testing,71,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-989293761,1,['test'],['testing']
Testability,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:270,test,test,270,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156,1,['test'],['test']
Testability,"@Ericgig Thanks for the review and comments. I'll make some improvement accordingly. 1. About the test, I think the very last test I added in `test_mesolve`, the case of ""mixed callable"", uses the `scipy.interpolate.interp1d`. But I agree with you that there should be a separate test in `test_qobjevo` for calling the coefficients. I'll add a test similar to `test_QobjEvo_call` for the step coefficient case.; 2. About that ""move out"", I mean move out the `_binary_search` inside functions as `_spline_complex_t_second`. . To be more concrete, for example, in `InterCoeffT` we have the following:; ```; cdef void _call_core(self, double t, complex* coeff):; cdef int i; for i in range(self._num_ops):; coeff[i] = _spline_complex_t_second(t, self.tlist,; self.y[i,:], self.M[i,:], self.n_t); ```; For the same time `t` and `tlist`, we call `_spline_complex_t_second` multiple times. Each time we call it, it will have to do a `_binary_search` for `t` in `tlist`, which has complexity log(`len(tlist)`). But since `t` and `tlist` does not change in the function, it's enough to do it only once outside the loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1050#issuecomment-513900719:98,test,test,98,https://qutip.org,https://github.com/qutip/qutip/pull/1050#issuecomment-513900719,5,"['log', 'test']","['log', 'test']"
Testability,@Ericgig Thanks! Suggestions committed. I will merge if tests pass.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1149052416:56,test,tests,56,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1149052416,1,['test'],['tests']
Testability,"@Ericgig `.step(...)` looks like a great solution. We should definine more precisely what one is allowed to modify in between calls to `.step` and document that. Aside regarding things we have already implemented: I know -- my point is that there are many such things and we have only implemented one kind of each (for example, what kind of progress bar is appropriate is highly dependent on the environment the code is running in -- if the code is running on a server without a terminal it might be some kind of logging, inside a hypothetical QuTiP UI GUI application it might be a progress bar provided by the GUI toolkit being used, etc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859578358:513,log,logging,513,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859578358,1,['log'],['logging']
Testability,"@Ericgig b7cd10a creates a new `qutip.solve` package, and I moved all the solvers and most of their utilities into there. I put Cython utility modules into the same directory, and just prefixed their names with underscores to mark them as internal, rather than making another new `cy` directory. I also moved the tests of the solvers into their own `tests/solve` directory, so we can consider having `pytest` run the tests in order at some point as well. All the names are still imported properly into the `qutip` namespace, so you can still do `qutip.mesolve` and so on. This PR is already way too long. I could put the solver package commit into a different PR if it's helpful, but to be honest, I'm not sure entirely what benefit is derived - my commit messages are usually quite descriptive (please don't squash them!), so it's not like the history will be missing in `git log`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332#issuecomment-671526504:313,test,tests,313,https://qutip.org,https://github.com/qutip/qutip/pull/1332#issuecomment-671526504,4,"['log', 'test']","['log', 'tests']"
Testability,"@Ericgig good idea about the tests, I'll implement them in this way. now there seems to be some problem with continuous integration, it fails on. ```; ERROR: Failure: ImportError (libgfortran.so.1: cannot open shared object file: No such file or directory); ```. I attempted to fix it by installing `libgfortran` using `conda`, however it didn't fix the issue. https://github.com/travis-ci/travis-ci/issues/4816#issuecomment-148789525; https://github.com/menpo/landmarkerio-server/issues/23#issuecomment-278361601. I don't want to mess up too much with continous integration as it takes long time to rebuild it, any suggestions on that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-427726780:29,test,tests,29,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-427726780,1,['test'],['tests']
Testability,@Ericgig not in any huge hurry. Once there is a nice subset of tests that can be run to test installation I will update the nixpkgs package for qutip. Thanks for being so responsive! For now I'll just delete some of the tests and can always update the package once the ability to test only a subset is added to a release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1147#issuecomment-569797675:63,test,tests,63,https://qutip.org,https://github.com/qutip/qutip/issues/1147#issuecomment-569797675,4,['test'],"['test', 'tests']"
Testability,"@Ericgig sorry about that, I just added the argument, I'm also planning adding some tests but I haven't yet figured out what would be best way to do it, any suggestions welcome!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-427237099:84,test,tests,84,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-427237099,1,['test'],['tests']
Testability,"@Ericgig tests implemented and passing, please code review if you can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-429515766:9,test,tests,9,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-429515766,1,['test'],['tests']
Testability,"@Ericgig thanks for suggestion. weird, my local tests all passed, let me examine the problem",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-431253362:48,test,tests,48,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-431253362,1,['test'],['tests']
Testability,"@Ericgig, I have tested it myself. However, I need someone else to merge it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/922#issuecomment-428399661:17,test,tested,17,https://qutip.org,https://github.com/qutip/qutip/pull/922#issuecomment-428399661,1,['test'],['tested']
Testability,"@Ericgig: #1337 broke `mcsolve` seed reuse - it seems to be deliberate, since all the seed code has been explicitly cut. Is this something that `mcsolve` will no longer support? If so, we need to remove the tests of seeding, because they're failing the build, and if not we need to reinstate it quickly so we can have passing tests. Also options classes should probably throw an error when given an unknown key.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338#issuecomment-675463113:207,test,tests,207,https://qutip.org,https://github.com/qutip/qutip/pull/1338#issuecomment-675463113,2,['test'],['tests']
Testability,@Ericgig: another random failure in the CI here (errored test is unchanged in this PR).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-623953963:57,test,test,57,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-623953963,1,['test'],['test']
Testability,"@Francesco-Benfenati: can you tell us what the expected behaviour from your test case is? Are you intending to create a superoperator, or are you intending to create a a density matrix?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1204#issuecomment-600781981:76,test,test,76,https://qutip.org,https://github.com/qutip/qutip/issues/1204#issuecomment-600781981,1,['test'],['test']
Testability,@HarshKhilawala Would you be interested in adding some tests for the progress bars in another PR?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2112#issuecomment-1462010251:55,test,tests,55,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1462010251,1,['test'],['tests']
Testability,@Lala5th Thank you for the test fix.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1785#issuecomment-1027853795:27,test,test,27,https://qutip.org,https://github.com/qutip/qutip/pull/1785#issuecomment-1027853795,1,['test'],['test']
Testability,@Lala5th Would you mind merging master into this so that the test suite can run again (I had to pin coverage to version 6.2 while coverage 6.3 is being fixed).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1783#issuecomment-1027885014:61,test,test,61,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1027885014,1,['test'],['test']
Testability,"@Leo-am @Ericgig I originally marked this PR for inclusion in 4.7, but I'd like to suggest we skip this PR and clean things up for QuTiP 5. My reasoning is as follows:. - To be included in 4.7.X this PR would have to be included in 4.7.0 now and there is still quite a bit of work to do (writing tests, cleaning up _check_dims, handling some edges cases better) and I'd rather not rush those changes.; - If we make this change now, we will have to break user code *again* for 5.0 because the interface being introduced here is not the one proposed for 5.0 in #1838. Let's rather only break user code once.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1846#issuecomment-1092820030:296,test,tests,296,https://qutip.org,https://github.com/qutip/qutip/pull/1846#issuecomment-1092820030,1,['test'],['tests']
Testability,"@MartinSandeCosta, free feel to complete the tests in the way you want. However, maybe it is good to discuss a bit with @jakelishman? Since there is a refactoring of `qutip/tests/test_gates.py` in #1181. A lot of change in this test might make it hard to resolve two PRs later. Besides, it is better to leave a more detailed description in the PR. As the template indicated:; ```; **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607803156:45,test,tests,45,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607803156,4,"['log', 'test']","['log', 'test', 'tests']"
Testability,@MrRobot2211 Thank you for this! I did a small review just of general code-cleanliness issues and left some comments. I'm hoping someone else who knows this code a bit better will come along and review the actual implementation. Could you perhaps write a test for the new code? That would help illustrate the original problem and help ensure the problem doesn't crop up again if cvxpy or the dnorm implementation change in future. The test should go at the end of `qutip/tests/test_metrics.py` (you'll see a bunch of dnorm tests already there).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1463#issuecomment-801737359:255,test,test,255,https://qutip.org,https://github.com/qutip/qutip/pull/1463#issuecomment-801737359,4,['test'],"['test', 'tests']"
Testability,"@NS2LPS Apologies for the slow reviews. Would you be up for updating this PR and then we can review it properly? It would be good to somehow add tests to these cases, but I'm not sure how easy that is to do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1275#issuecomment-893440155:145,test,tests,145,https://qutip.org,https://github.com/qutip/qutip/pull/1275#issuecomment-893440155,1,['test'],['tests']
Testability,@NS2LPS Just checking whether you're still keen to write a test for this and finish off the PR?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1275#issuecomment-986833630:59,test,test,59,https://qutip.org,https://github.com/qutip/qutip/pull/1275#issuecomment-986833630,1,['test'],['test']
Testability,"@RunawayFancy Apologies, I'm not 100% sure which case you said worked and which didn't. Did ""import qutip.testing"" working in your terminal but fail in your Jupyter notebook?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1650#issuecomment-913454099:106,test,testing,106,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-913454099,1,['test'],['testing']
Testability,"@VolodyaCO I'd like to test these changes out locally, but they look good to me now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1707#issuecomment-990400800:23,test,test,23,https://qutip.org,https://github.com/qutip/qutip/pull/1707#issuecomment-990400800,1,['test'],['test']
Testability,"@Zac-HD Any suggestions for ways we could use hypothesis better? It all looks quite clean right now. Is there a way we can change what hypothesis prints when an example is found? E.g. we don't want the data layer object repr to include the contents of the array, but it would be nice to see that in the test failure output.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1186229765:303,test,test,303,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1186229765,1,['test'],['test']
Testability,@Zac-HD Would you mind doing a quick sanity check of my `MatrixShapesStrategy` class (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L15-L62)? Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. I also wouldn't mind a quick check of `qobj_shared_shapes` (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L113-L131). Is this a good thing to be doing with shared strategies?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602:169,test,tests,169,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602,2,['test'],['tests']
Testability,@ajgpitch @gautierronan I've updated this PR. I *think* it's ready to be merged (assuming tests pass in CI now) but a final look from you would be appreciated since this is not a part of QuTiP I know well yet.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1369#issuecomment-1058307269:90,test,tests,90,https://qutip.org,https://github.com/qutip/qutip/pull/1369#issuecomment-1058307269,1,['test'],['tests']
Testability,"@ajgpitch @nathanshammah ; I would like to make 4.5.1 from this. All test passes, there is only windows and mac 3.8 to check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1215#issuecomment-604030641:69,test,test,69,https://qutip.org,https://github.com/qutip/qutip/pull/1215#issuecomment-604030641,1,['test'],['test']
Testability,"@ajgpitch Do you have any detailed instructions on using the 3.2 develop branch in Jupyter notebook? I posted a thread in the [email list](https://groups.google.com/forum/#!topic/qutip/oh1t7xJg5x8) while having trouble to compile the examples in using Stochastic equation solvers. I have tried to compile the source and to call from Conda-forge virtual environment, but always fail despite all tests have been passed. Let me know if those examples are outdated. Thanks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/472#issuecomment-218226943:394,test,tests,394,https://qutip.org,https://github.com/qutip/qutip/issues/472#issuecomment-218226943,1,['test'],['tests']
Testability,"@ajgpitch Hi, this adds input and output states to the QubitCircuit class. The next bit is to get the latex circuit visualisation for this. I will get that working as soon as I can. I guess there is not testing for that and I have to check it by trying out different plots. The next bit will be to get a list of known states and create a map so that they can be converted to a proper `Qobj`. Finally, we should have a method in `QubitCircuit` to calculate the output states, given an initial input state and add it to the circuit. But, I guess I could work on that in a different PR. All this is dicussed in the orginal issue #678",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/679#issuecomment-291489226:203,test,testing,203,https://qutip.org,https://github.com/qutip/qutip/pull/679#issuecomment-291489226,1,['test'],['testing']
Testability,@ajgpitch I believe I fixed the pep8 issues. . There was also a cython issue where I was compiling tensor.pyx each time qutip starts (aka dev mode) rather than leaving it pre-compiled. I think this might be related to the travis test failures. We are about to find out.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-403663024:229,test,test,229,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-403663024,1,['test'],['test']
Testability,@ajgpitch Thanks for taking a look. I updated the docstring for the tests. The fancy docstrings are tested as the API docs are also up on piqs.readthedocs.io. We can also add a complete tutorial section with all the nice notebooks that @nathanshammah has compiled. I think this makes case for the long overdue 4.3 release? Should I open another thread for adding a warning for dropping python2 in QuTiP 5?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/861#issuecomment-396890968:68,test,tests,68,https://qutip.org,https://github.com/qutip/qutip/pull/861#issuecomment-396890968,2,['test'],"['tested', 'tests']"
Testability,"@ajgpitch yes, the solver does raise an error... but not always. I was able to get it to integrate a few times but it was very inconsistent. The other error it sometimes raises is ""too much accuracy was requested for the precision of the machine"". When I realized the issue, I was very surprised it even got that far and I still don't know how it could ever run the calculation with a bad `rho0`. @nonhermitian yes, I see the point in the code where `mesolve` digs down into various types of `H` input. I'll work on something for the easy Qobj cases first, and think about how to handle the function case. Should be able to test the size of what the function returns.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/479#issuecomment-221595850:624,test,test,624,https://qutip.org,https://github.com/qutip/qutip/issues/479#issuecomment-221595850,1,['test'],['test']
Testability,"@alexandrupaler Thank you for looking into this. You will have to download this branch and install it in order to find qutip.qip.icm. I think the following set of steps should do it. These are from this [stack overflow question](https://stackoverflow.com/questions/1911109/how-to-clone-a-specific-git-branch). 1. Clone my version of QuTiP using ; ```; git clone https://github.com/sahmed95/qutip.git; ```. 2. Checkout the icm branch in the cloned folder; ```; git checkout icm; ```; 3. Install QuTiP from that branch by going to cloned QuTiP folder; ```; python setup.py install; ```; Alternate way to do this is just copy paste the `qutip/qip/icm.py`, `qutip/qip/circuit.py` and `qutip/tests/test_qubitcircuit.py` files into your local installation of QuTiP. . There are examples in [`qutip/qip/tests/test_icm.py`](https://github.com/qutip/qutip/pull/603/files#diff-93808767f70729e7e757566e9a32b430) which may be useful to see how the code works. @ajgpitch @nonhermitian Suggestions on the recommended way of doing this ? There is this tool called [""hub""](https://hub.github.com) which allows you to directly checkout pull requests using `hub checkout https://github.com/qutip/qutip/pull/603`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-315378380:687,test,tests,687,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-315378380,2,['test'],['tests']
Testability,"@araza6 thank you. Tests in continuous integration are failing. There seem to be too many PEP8 changes (from `black`?) in this PR, unrelated to the changed files. I am not so sure about the constraints put on the use of the `fidelity` function. I had left it as this to keep as much freedom as possible and not spoon feed the user. It is basically a shortcut for Tr(x^2), not much else.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-613052212:19,Test,Tests,19,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-613052212,1,['Test'],['Tests']
Testability,@awkwardPotato812 Thanks for starting this PR. I did a partial review and activated the test run. I will leave a full review for Eric to do though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2114#issuecomment-1462413586:88,test,test,88,https://qutip.org,https://github.com/qutip/qutip/pull/2114#issuecomment-1462413586,1,['test'],['test']
Testability,"@bopardikarsoham It can definitely still be looked at, but the situation needs to be untangled before any code change is made:. - If one is using Lindblad operators (see the equation with `L_i` on https://en.wikipedia.org/wiki/Lindbladian) then `a` and `b` are the same and the code is currently correct.; - If one is using some other set of basis operators `A_n` for the bounder operators on `H`, then you will need to include terms for both `n, m` and `m, n` and the sum of the those two terms will again be the same for the current code and the proposed change. So the physics will not change from what it is now if we make the proposed change and it appears that how the terms are organized within the larger sum is a convention. So the question is whether there is a standard convention to follow or not, and I don't know the answer. Step 1 is probably to find some textbooks or canonical references which make the choice clear. Step 2 would be to write some tests for the behaviour in the case where `a != b`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1719#issuecomment-1062919358:964,test,tests,964,https://qutip.org,https://github.com/qutip/qutip/issues/1719#issuecomment-1062919358,1,['test'],['tests']
Testability,@cgranade did you test your PR #362 against dick-t example? If so what were the results?; It would seem that dick-t is comparing a method that works with states in general (mixed or pure) with one that assumes states are pure. Do we have some method in qutip that gives the fidelity when states are assumed pure? It would seem more efficient (and less numerical error risk) to compute the fidelity without the sqrtm (as dick-t did in the comparison) if we knew the states were pure.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134927300:18,test,test,18,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134927300,1,['test'],['test']
Testability,"@cgranade thanks, better unit test coverage would be highly appreciated. I'm about to add a few more tests before merging this PR, but there will be plenty of room for additional test after this PR is merged and it would be great if you could have a look at that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/95#issuecomment-39404287:30,test,test,30,https://qutip.org,https://github.com/qutip/qutip/pull/95#issuecomment-39404287,3,['test'],"['test', 'tests']"
Testability,@christian512 Thank you for adding the test and explaining the logic. I did a second mini-review.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1961#issuecomment-1200423623:39,test,test,39,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1200423623,2,"['log', 'test']","['logic', 'test']"
Testability,"@christian512, this looks great! I am happy with this being merged as it is. We could further improve tests by testing that all arguments work correctly but I believe that to be out of the scope of this PR. Since this PR already fixes a bug I would rather have it merged. @hodgestar, are you happy with this being merged after the changes?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1843#issuecomment-1106279748:102,test,tests,102,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1106279748,2,['test'],"['testing', 'tests']"
Testability,@cntnly Thanks for this PR. Any updates on the unit test?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/719#issuecomment-396797556:52,test,test,52,https://qutip.org,https://github.com/qutip/qutip/pull/719#issuecomment-396797556,1,['test'],['test']
Testability,"@drew-parsons I imagine `MPLBACKEND=agg` avoids the issue by not using X at all. I have used it in the past for matplotlib tests, and it's not a bad idea perhaps to switch the QuTiP visualization tests to the `agg` backend, but it's not something I'm going to tackle right now I don't think (too many other big QuTiP changes up in the air at the moment).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571:123,test,tests,123,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571,2,['test'],['tests']
Testability,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:245,test,tests,245,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682,4,['test'],"['test', 'testPlot', 'tests']"
Testability,@drew-parsons Is there a goal you are trying to achieve by running the tests headless on xvfb? Just curious about your use case.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909005031:71,test,tests,71,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909005031,1,['test'],['tests']
Testability,"@drew-parsons These tests pass in CI and `pytest qutip/tests/test_processor.py -v` passes for me locally on the master branch, so I'm not quite sure how to reproduce.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-908476483:20,test,tests,20,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908476483,2,['test'],['tests']
Testability,"@drew-parsons We don't usually run tests with `pytest-xvfb`, so perhaps that triggers the issue somehow?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-908478147:35,test,tests,35,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908478147,1,['test'],['tests']
Testability,"@ericgig you're right. I have added to this [pull request](https://github.com/qutip/qutip.github.io/pull/114) (114 in qutip.github.io) a new anchor next to the headings #supporting-organizations, and I then wanted to add a link to it here. It could also mention them (or a subset of those listed there) also here, without logos but in writing. . If someone can review that PR 114, I can then modify this one more easily.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1228#issuecomment-610412067:322,log,logos,322,https://qutip.org,https://github.com/qutip/qutip/pull/1228#issuecomment-610412067,1,['log'],['logos']
Testability,"@fhopfmueller Thank you for looking into these various issues! PRs would be very much appreciated. Perhaps lets do separate PRs for the tests, then `process_fidelity` and then `average_gate_fidelity`?. I would like to release 4.7 in the not too distance future, so one option is to target dev.major / 5 directly (in which case the tests are already fixed).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1703#issuecomment-957253538:136,test,tests,136,https://qutip.org,https://github.com/qutip/qutip/issues/1703#issuecomment-957253538,2,['test'],['tests']
Testability,@fhopfmueller Thanks for the help! I've added back the test. I also made a separate commit to remove skipping the tests on Mac OS. Let's see what happens.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1788#issuecomment-1172916163:55,test,test,55,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172916163,2,['test'],"['test', 'tests']"
Testability,@fpetiziol Thanks for checking. We should fix this for 4.7. It's probably not a very difficult fix (or at least we have logic for making eigenvectors orthogonal elsewhere in QuTiP that we can call or re-use).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1864#issuecomment-1103658061:120,log,logic,120,https://qutip.org,https://github.com/qutip/qutip/issues/1864#issuecomment-1103658061,1,['log'],['logic']
Testability,"@gaurav-iiser Would you mind also merging the master branch into this one? We recently merged some changes that fixed regular failures in test runs after the new version of numpy broke some tests, and it would be good to have those included in here so that test runs pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-950320006:138,test,test,138,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-950320006,3,['test'],"['test', 'tests']"
Testability,"@gautierronan Thanks Ronan for this useful contribution. It looks good to me. I was discussing something similar with a colleague back in October, so I am going to see if I can get them to test it too.; On the subject of testing... this will need tests to be added before it can be merged. Please see https://github.com/qutip/qutip/blob/master/qutip/tests/test_control_pulseoptim.py; Ideally it would also have an example notebook. See https://github.com/qutip/qutip-notebooks/blob/master/examples/control-pulseoptim-Hadamard.ipynb for example. It could either have new notebook, or one could be extended to show this feature.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1369#issuecomment-754707095:189,test,test,189,https://qutip.org,https://github.com/qutip/qutip/pull/1369#issuecomment-754707095,4,['test'],"['test', 'testing', 'tests']"
Testability,"@goerz we have been discussing encapsulating the matrix type to store qobj.data for some time, see #437 ; It definitely falls into the quite-a-bit-of-work category.; This is a legitimate concern though. I guess we should run some tests comparing times for indexes across arrays with int32 and int64 before we launch into anything.; Do we know whether scipy are already using int64 for the indexes of their sparse matrices?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-383849537:230,test,tests,230,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-383849537,1,['test'],['tests']
Testability,"@haoyudoingthings It looks from your error messages that they are caused not by the import cells, but by later cells, and are the result of having modified the notebook. For example, `H = qt.qobj_list_evaluate(h_t, tau, args)` is a modified line from cell 13 of the original notebook. I would suggest starting again from the original notebook and continuing from there. Some of the notebooks are out of date. We're setting up automated tests to correct that as part of this year's Google Summer of Code, but that has only just started so it might be a few months before we have everything set up. I'm closing this for now, but please feel free to update the issue if you encounter more problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964:436,test,tests,436,https://qutip.org,https://github.com/qutip/qutip/issues/1930#issuecomment-1153919964,1,['test'],['tests']
Testability,"@hodgestar , I think I responded to all your comments.; The tests for core/blochredfield.py are present, I think it has a 100% coverage.; I did little cut and paste, but stayed close to the original cython code when possible. The question I still have is about the `a_ops` format: I made breaking changes from v4, so I want to be sure the new way is clear. I think `matmul_var_data` should be available in `core/data` not implemented here, but I don't want to touch that part in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890:60,test,tests,60,https://qutip.org,https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890,1,['test'],['tests']
Testability,"@hodgestar ; I added default values to options and a default `mcstep`. I added a doc-string entry for `integrator_options`, but please check it. About `mcstep` optimization for scipy's `ode`, I tested both the methods and there can be a factor 2 in timing between both, but it can be in both ways depending on the conditions. So I used `mcsolve`'s method for `zvode` and the new method for `lsoda`. This way, the default will run like `v4`, but you have an alternative when it's not ideal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294:194,test,tested,194,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294,1,['test'],['tested']
Testability,"@hodgestar ; Sorry, I reran the test before reading your comment, here is the failing attempt:; https://github.com/qutip/qutip/actions/runs/2805431012/attempts/1",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1968#issuecomment-1208156789:32,test,test,32,https://qutip.org,https://github.com/qutip/qutip/pull/1968#issuecomment-1208156789,1,['test'],['test']
Testability,@hodgestar @Ericgig I think the failed tests are unrelated to this PR. Could you rerun the tests?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1626#issuecomment-891908560:39,test,tests,39,https://qutip.org,https://github.com/qutip/qutip/pull/1626#issuecomment-891908560,2,['test'],['tests']
Testability,@hodgestar Anything for reference? Any pre-existing test_code which I can use to write tests for progressbar? PTAL!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2112#issuecomment-1465168803:87,test,tests,87,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1465168803,1,['test'],['tests']
Testability,"@hodgestar Apologies for taking as long, but went on and rebased my PR to 5.0 and addressed some of your comments. In particular, factory methods have been moved out into ordinary functions, and I added a simple string-based format for outcome labels (leaving `Seq` and `Par` for more complex cases as needed). For the notebook, I ran into the slight issue that the qutip-notebooks repo uses a more copyleft license, but in the meantime I put together a notebook at https://gist.github.com/cgranade/7c2a5a0827dddc4281666ad45763b1ec that includes a few examples of the API in use, including for modeling a simple teleportation channel. I still need to address PEP8 issues and add tests, but I think it should be a bit further along; thanks for all your help and feedback! 💕",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128:679,test,tests,679,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128,1,['test'],['tests']
Testability,"@hodgestar Are you sure this was ready to be merged?; While the tests part look fine, have you checked that the wheels will build properly? Is there no need to tell the tools building the wheels were to find python 3.11? With 3.10 we skipped some build, (win32, etc.), don't we need to do the same for 3.11?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2041#issuecomment-1345571497:64,test,tests,64,https://qutip.org,https://github.com/qutip/qutip/pull/2041#issuecomment-1345571497,1,['test'],['tests']
Testability,"@hodgestar Good catch, I was testing this by plotting 2D images over theta and phi, but I was a bit careless because the top of the plot is theta=pi (for theta on the y-axis) which isn't the top of the Bloch sphere, but the bottom. So the result was what I expected, but for the wrong reason. I thought this looked like an easy fix; I believe the exponents are incorrect, where there is addition there should be subtraction, and vice versa. I fixed this and tested as follows:; ```python; j = 1/2; t,p = 0,0; for t in np.linspace(0, np.pi, 100):; for p in np.linspace(-np.pi, np.pi, 100):; psi = spin_coherent(j, t, p); h, _, _ = spin_q_function(psi, t, p); # assert(abs(h - 1/np.pi) < 1e-3) # This assertion fails for some theta and phi, it seems like the angle is incorrect; ```; But it doesn't work for all theta and phi. Moreover, I tried this test on the current qutip code 'as-is' but using @hodgestar fix `h, _, _ = spin_q_function(psi, np.pi - t, p)` but this fails in the exact same way. There might also be a numerical inaccuracy here, because the maximum does reach 1/pi, it's just at a slightly tilted angle. This is a good reference for Q function calculation here : https://arxiv.org/abs/1309.6346.; Although they don't provide the density matrix form, it should be easy enough to expand the Q = <theta, phi| rho |theta,phi> as the spin-coherent states using the calculations from the paper.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1195#issuecomment-893072105:29,test,testing,29,https://qutip.org,https://github.com/qutip/qutip/pull/1195#issuecomment-893072105,5,"['assert', 'test']","['assert', 'assertion', 'test', 'tested', 'testing']"
Testability,@hodgestar I am not much aware with writing tests. Can you help me write test for progressbar file? How to write a test? How to check coverage for the entire file? How to check coverage for each line of code as to know where and what to add test? From where can I learn more about testing? Any documentation for writing tests specifically for qutip repository?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603:44,test,tests,44,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1464861603,6,['test'],"['test', 'testing', 'tests']"
Testability,@hodgestar I decided to add the `spin_wigner` changes in which I've resolved the normalization issue and indexing problems that were also in the `spin_q_function`. I've added a simple test to check for normalization and real-ness of the spin Wigner.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1632#issuecomment-894939089:184,test,test,184,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-894939089,1,['test'],['test']
Testability,"@hodgestar I have implemented most of your suggested changes. I reduced the largest spin used in the spin Wigner tests, but left the spin Q function as-is because it was fast enough. I've removed the normalization from the functions themselves and described the normalization criterion in the docstrings.; The spin Wigner is now real.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1632#issuecomment-917315644:113,test,tests,113,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-917315644,1,['test'],['tests']
Testability,"@hodgestar I think I have found a fix, the problems were two-fold:; - The addition/subtraction for the cos/sin(theta/2) terms were swapped, which gives you a flipped result (high Q value on opposite side of sphere); - The phase factor for the diagonal terms of the density matrix were swapped, which gave you flipped result in the Y axis (high Q value for -Y if you give it +Y state). I can submit a new fix for this alongside some test code that does some basic verification (sorry -- I'm not sure what would be a good set of tests, the ones I have come up with are certainly not exhaustive.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1195#issuecomment-893157034:432,test,test,432,https://qutip.org,https://github.com/qutip/qutip/pull/1195#issuecomment-893157034,2,['test'],"['test', 'tests']"
Testability,"@hodgestar I will merge this as is since it block the tests from passing everywhere. The situation with `except * nogil` is not perfect, but it's not a bottleneck in our computations. If you look at the generated code, the issue is only when calling an `except * nogil` function returning complex or void within another `nogil` function. Therefore I removed the nogil from function that called other nogil functions, not those who did the work. If you see optimisation I missed, please open another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168:54,test,tests,54,https://qutip.org,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168,1,['test'],['tests']
Testability,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:27,test,tests,27,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617,8,"['Test', 'test']","['TestHusimiQ', 'test', 'tests']"
Testability,"@hodgestar Let's rerun the test a few times to see if it works.; If after ~5 tries, the windows tests always passes. I will approve.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2013#issuecomment-1317836479:27,test,test,27,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1317836479,2,['test'],"['test', 'tests']"
Testability,"@hodgestar Sure, do I need to be assigned another issue? Can I create new issue for writing tests for progress bar and get assigned to work on it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2112#issuecomment-1462049113:92,test,tests,92,https://qutip.org,https://github.com/qutip/qutip/pull/2112#issuecomment-1462049113,1,['test'],['tests']
Testability,"@hodgestar Thank you for your reply. I added `_data.Dense(V)`, but failed. The first code failed and the second code passed the test.; ```; def _solve(A, V):; try:; if settings.has_mkl:; return _data.solve(A, V, ""mkl_spsolve"", {""csc"": True}); else:; return _data.solve(A, V, ""splu""); except TypeError:; out = _data.solve(A,_data.Dense(V)); return out; ```; ```; def _solve(A, V):; try:; if settings.has_mkl:; return _data.solve(A, V, ""mkl_spsolve"", {""csc"": True}); else:; return _data.solve(A, V, ""splu""); except TypeError:; out = sp.linalg.lsqr(A, V)[0]; return out; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2109#issuecomment-1458484606:128,test,test,128,https://qutip.org,https://github.com/qutip/qutip/issues/2109#issuecomment-1458484606,1,['test'],['test']
Testability,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:556,test,tests,556,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548,4,"['assert', 'test']","['assert', 'tests']"
Testability,@hodgestar The test is now included. It turned out to be quite simple with monkeypatch. Thanks for the suggestion!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1636#issuecomment-939918060:15,test,test,15,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-939918060,1,['test'],['test']
Testability,@hodgestar Yes. I could import `qutip.testing` in my terminal but fail in Jupyter notebook. But I re-installed the qutip lib and now it could be imported successfully.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1650#issuecomment-913463573:38,test,testing,38,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-913463573,1,['test'],['testing']
Testability,"@hodgestar okay so I figured out some code. It's VERY close to getting the max frequency, but it's not perfect. . The method I'm using is very similar to how I pull the current frequency, but it's just different enough that it gives a different output. Basically what I'm doing is executing a bunch of `add` instructions through inline assembly multiple times (which will take it's sweet time based on CPU cycles), measuring the time it takes to finish, and doing some fun maths. The problem is that the output it still variates just a little bit. On my M1 Mac mini, 85% of the time I get `2.8 GHz`, and 15% of the time I get `3.1 GHz`...Still needs some fine tuning, but it's better than using `sysctl hw.tbfrequency` or a fixed value. The function is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/4590c2ef6080466df4bda18771f02dd1d2c2c1fd/osx-cpufreq/main.m#L53-L85), and the assembly it uses is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/4590c2ef6080466df4bda18771f02dd1d2c2c1fd/osx-cpufreq/main.m#L19). If anyone else with an Apple Silicon machine wants to test this new trick out, my binary is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/releases) (follow preparation and usage instructions from the projects readme, and make sure to run the binary with option `-x`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1754#issuecomment-1010398434:1091,test,test,1091,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1010398434,1,['test'],['test']
Testability,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:182,test,tests,182,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694,4,['test'],['tests']
Testability,"@hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally...; I you have time could you take a look.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1689#issuecomment-943619749:31,test,tests,31,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-943619749,1,['test'],['tests']
Testability,"@hodgestar the `.h` file imported from `base.pxd` makes is a lot simpler.; Changing the header file force recompilation, but the cythonization step is skipped.; If tests passes, it's ready for review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1874#issuecomment-1106675195:164,test,tests,164,https://qutip.org,https://github.com/qutip/qutip/pull/1874#issuecomment-1106675195,1,['test'],['tests']
Testability,"@hodgestar, one of the tests seems to have failed at the installation step, although not idea why. Nevertheless, I think it is not related to the changes in this PR. Could you rerun the test?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1636#issuecomment-940959780:23,test,tests,23,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-940959780,2,['test'],"['test', 'tests']"
Testability,"@hodgestar, tests are passing, can I merge?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1889#issuecomment-1197390147:12,test,tests,12,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1197390147,1,['test'],['tests']
Testability,"@hodgestar, to make it work with HEOM, I had to change `step` to return `rho` directly, (controlled by the `store_ados` options). Could you take a look and tell me if you are fine with this approach. Also, do you know a `Bath` configuration that would result in evolution similar to `mesolve` so we could use it in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120:315,test,tests,315,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120,1,['test'],['tests']
Testability,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:155,test,test,155,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408,1,['test'],['test']
Testability,"@hodgestar: those comments lines you've highlighted were a careless mistake - they shouldn't have been removed, but it's a function of how I implemented the automated removal. I didn't notice them when I checked it through. I've restored them. The `cython: language_level=3` lines in particular are especially important to maintain, so that was very careless of me. That said, utf-8 is the default encoding for Python 3, so those lines aren't actually necessary at all any more. That wasn't the case with Python 2 (which assumed ASCII), but it's no longer an issue. Regardless, I've restored them because this PR wasn't meant to remove that sort of thing. Similarly, since I had to go through everything anyway, I've excluded the whitespace-only changes within files (though I left the normalisation of whitespace specifically at the ends of files). Apologies, I've force-pushed it back rather than applying it as a new commit, so it probably won't render these changes as nicely in the GitHub interface - it was rather easier for me to modify the commit than to make a ""partial reversion"" commit (and it's better for the logs).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-867019111:1122,log,logs,1122,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-867019111,1,['log'],['logs']
Testability,"@jakelishman , I think it is ready for a review. . There a lot of `TODOs` in the code from the before times, and a general refactor is probably needed since most of the representations are working on the assumption that the channels admit equal right and left tensors:; ![formula](https://render.githubusercontent.com/render/math?math=A_{\alpha}%20=%20B_{\alpha}) . ; This PR at least allows for different left and right tensor in the Stinespring representation, thus completing the `FIXME` in the original tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-831514046:507,test,tests,507,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-831514046,1,['test'],['tests']
Testability,"@jakelishman @Ericgig I'm going to merge this so that I can run a test build easily and so that people who were experiencing issues on 3.10 can try it out easily. If you'd like changes, I can address them in a follow up PR. Hope you are both enjoying your holidays!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1747#issuecomment-1005593804:66,test,test,66,https://qutip.org,https://github.com/qutip/qutip/pull/1747#issuecomment-1005593804,1,['test'],['test']
Testability,"@jakelishman I'm somewhat against re-running flaky tests all the time. It's inelegant and hides other possible flakiness. An alternative approach is to set the random seed before generating the random states using a small fixture, e.g.:. ```python; import numpy; import random as rand. @pytest.fixture; def random():; rand.seed(0); numpy.random.seed(0); ```; (from https://github.com/pytest-dev/pytest/issues/667#issuecomment-112206152). potentially we could also run the tests with a few different random seeds (to cover more cases). If we add hypothesis (https://hypothesis.readthedocs.io/en/latest/) one day, we could generate a broader set of cases to solve and filter out bad cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815310190:51,test,tests,51,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815310190,2,['test'],['tests']
Testability,"@jakelishman I've approved this PR -- it's definitely worth getting rid of test flakiness right away. Re random seed: We wouldn't want to set the random seed for all tests, just those like the dnorm ones that are causing issues. But let's leave that for the future.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815592138:75,test,test,75,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815592138,2,['test'],"['test', 'tests']"
Testability,@jakelishman There were no issues on OpenBlas. I opened a separate PR with the changes you suggested and the failing test.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-819601408:117,test,test,117,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-819601408,1,['test'],['test']
Testability,"@jakelishman, thanks for the explanation! I forget the tests here belong to the circuit module. @Canoming Would you still like to add some tests to `tests\test_qubitcircuit.py` for `remove_gate` and `add_circuit`? Otherwise, I can also merge this and we will update the tests later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629800241:55,test,tests,55,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629800241,4,['test'],['tests']
Testability,@jonahpeter Do you perhaps have some specific `a` and `b` in mind that we could use to write a test case?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1719#issuecomment-979432001:95,test,test,95,https://qutip.org,https://github.com/qutip/qutip/issues/1719#issuecomment-979432001,1,['test'],['test']
Testability,@kcgthb have you tested this inside of a conda env on CentOS/RHEL? ; I ask because that is our supported platform.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/723#issuecomment-318011645:17,test,tested,17,https://qutip.org,https://github.com/qutip/qutip/issues/723#issuecomment-318011645,1,['test'],['tested']
Testability,@labay11 Thank you! I've approved the changes and marked them for inclusion in 4.7. I'll merge once the test runs have succeeded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1813#issuecomment-1047587729:104,test,test,104,https://qutip.org,https://github.com/qutip/qutip/pull/1813#issuecomment-1047587729,1,['test'],['test']
Testability,"@magnamancer I think part of the issue was that you merged `qutip-5.0.X` into `master` but that shouldn't have been done because `master` now contains the latest 5.X qutip code. Sorry to be a pain, but could you open a new new PR with just your changes? No need to be fancy -- just create a new branch from master, copy across the files you want to change, create PR. The `VERSION` file should not be changed. How hard would it be to add tests? I remember you have tests in a notebook somewhere. If you can point me at the latest versions, I can think about how to convert them into unit tests and add them to the new PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050:438,test,tests,438,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050,3,['test'],['tests']
Testability,"@maij @nathanshammah Do you remember how you tested `spin_q_function` when these changes were made? The changes were merged, but I only get the expected results if I invert the direction of theta:; ```python; psi = qutip.spin_coherent(spin, theta, phi); [[husimi_q]], _, _ = qutip.spin_q_function(psi, np.pi - theta, phi); # assert husimi_q == 1 / np.pi; ```; Without inverting theta, the bug persists for me (regardless of whether the spin is integer or half integer). I have a fix that works in my test cases, but I was wondering about the history of the changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1195#issuecomment-892768442:45,test,tested,45,https://qutip.org,https://github.com/qutip/qutip/pull/1195#issuecomment-892768442,3,"['assert', 'test']","['assert', 'test', 'tested']"
Testability,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:18,test,test,18,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408,7,['test'],"['test', 'tests']"
Testability,@manas7891 This is a question about usage of qutip. Please ask on help group and include full code snippet.; https://groups.google.com/forum/#!forum/qutip. You get the test errors because you don't have working C++ compiler,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-467351684:168,test,test,168,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-467351684,1,['test'],['test']
Testability,@matteoacrossi Thank you for checking! The value is meant to be in GHz (e.g. on my Linux machine QuTiP returns 4.8) but on Mac OS for some unknown reason the value was truncated by calling `int` on it. I've added some tests so that hopefully these sorts of issues are picked up by our robots in future.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1754#issuecomment-1006612560:218,test,tests,218,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1006612560,1,['test'],['tests']
Testability,"@matteoacrossi Thank you for running the tests and reporting these. I'm glad there are only four failing. I can't immediately guess the cause of any of them, so some digging is needed. If you're up to digging into them I'm happy to review and merge PRs. If not, no worries -- I will try think of another plan.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007278696:41,test,tests,41,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007278696,1,['test'],['tests']
Testability,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:112,test,tests,112,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325,2,['test'],"['test', 'tests']"
Testability,@mtreinish Thank you for the fix!; @AGaliciaMartinez Thank you for trying it out. I'll merge this now so that master isn't broken for numpy 1.22 and then we can add numpy 1.22 to the CI test matrix in a follow up PR.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1752#issuecomment-1006011287:186,test,test,186,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1006011287,1,['test'],['test']
Testability,"@nathanshammah ; I am keeping the release up to date adding merged PR to this one.; This version has most bug fix PR since 4.5.0 and some testing/travis one.; Idealy I would also like to add 2 more waiting approval:; #1219 : Bug on windows using int32; #1215: parallel_map run on mac in python 3.8.; I did not add the PR about gates, they are new feature.; The latex one (#1194 ), I am not sure, so I left it for now.; To be really happy about the release I would like the segfault to be fixed, but I don't have the error and travis test also does not. So I am blind for that one. It will have to wait.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1215#issuecomment-613039746:138,test,testing,138,https://qutip.org,https://github.com/qutip/qutip/pull/1215#issuecomment-613039746,2,['test'],"['test', 'testing']"
Testability,"@nathanshammah ; That was a lot more than 1 commit but it's now ready.; - I added a test suite without cython. It only skip brmesolve time dependent tests. ; - Error is raised when trying to use brmesolve without cython, but not at qutip import.; - Every other features works without cython. I tested without cython with both conda and pip. It work with both when done properly but conda is not as stable: uninstalling cython can change numpy, scipy, etc.'s versions which break qutip. So I am not sure if it will work properly we downloaded as binaries from conda. But this error should already be present for conda installation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1082#issuecomment-535188336:84,test,test,84,https://qutip.org,https://github.com/qutip/qutip/pull/1082#issuecomment-535188336,3,['test'],"['test', 'tested', 'tests']"
Testability,@nathanshammah @Ericgig all tests seem to pass. Please review. Also thanks for your fix @Ericgig.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-574189773:28,test,tests,28,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-574189773,1,['test'],['tests']
Testability,@nathanshammah All tests passed now,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1155#issuecomment-579661462:19,test,tests,19,https://qutip.org,https://github.com/qutip/qutip/pull/1155#issuecomment-579661462,1,['test'],['tests']
Testability,@nathanshammah I think @Ericgig is right because it doesn't fail tests locally. Should this be merged for now? If it causes problems we can create new issues later.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-562414356:65,test,tests,65,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-562414356,1,['test'],['tests']
Testability,"@nathanshammah I think it has nothing to do with this PR, I didn't change anything in `qobj.py` where the test failed before. I guess it might have something to do with Erig's commit ""mac without mkl"" and I simply merged it from master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1042#issuecomment-511355307:106,test,test,106,https://qutip.org,https://github.com/qutip/qutip/pull/1042#issuecomment-511355307,1,['test'],['test']
Testability,"@nathanshammah OK, my ""tests"" were just creating instances of `Bloch()` with and without `plt.figure()` instance passed in the constructor and then repeatedly executing the `show()` function. Now after I had a look at `qutip/tests` my small testing snippets indeed don't fit into that. Hence at this stage I don't see the benefit from adding these trivial ""tests"" I did to the repo. Thank you for the review and all the guidance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/989#issuecomment-494119661:23,test,tests,23,https://qutip.org,https://github.com/qutip/qutip/issues/989#issuecomment-494119661,4,['test'],"['testing', 'tests']"
Testability,"@nathanshammah Sure, I can add a test for it. Just I'm not sure what should I test against? If I compare the result matrix, I'm basically just copying the matrix from the code. Test on high dimension?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1028#issuecomment-505095971:33,test,test,33,https://qutip.org,https://github.com/qutip/qutip/pull/1028#issuecomment-505095971,3,"['Test', 'test']","['Test', 'test']"
Testability,@nathanshammah as soon as the tests finish if the usual tests pass.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1024#issuecomment-504556383:30,test,tests,30,https://qutip.org,https://github.com/qutip/qutip/pull/1024#issuecomment-504556383,2,['test'],['tests']
Testability,"@nathanshammah thanks! Submitted a PR that seems to be fixing the issue in the above mentioned way. Naturally I have brief tests for that, in a form of Jupyter notebook and in the form of `.py` file (the `.py` is just a copy of Jupyter but here we need to test both environments). Should I commit the `.py` file to `qutip/tests/` on this repo (add to my PR) and Jupyter test to `qutip-notebooks` or there is another standard way?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/989#issuecomment-493789773:123,test,tests,123,https://qutip.org,https://github.com/qutip/qutip/issues/989#issuecomment-493789773,4,['test'],"['test', 'tests']"
Testability,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:979,log,logical,979,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298,1,['log'],['logical']
Testability,"@nathanshammah: It seems that travis fails before it even gets to the testing, when calibrating openmp. I cannot replicate the error on my end, the calibration takes only about a second for me. I did make 535010d more similar to 5501b2e by no longer using numpy.testing.assert_raises, numpy.testing.assert_warns and a ResourceWarning. Instead I use a try-except construction now. That seems to have fixed things, so I suspect that importing/calling one of the functions or the warning makes openmp fail on the rig used by travis. As I'm pretty sure the reason for the previous failure is either a numpy or openmp issue and therefore a hard fix, I would propose to simply not use those functions, the try-except construction does well enough.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-567132755:70,test,testing,70,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-567132755,3,['test'],['testing']
Testability,"@nathanshammah: Sure. An assumption had previously been hard-coded into various conversion functions between super-operator representations that the input and output Hilbert spaces for the superoperator have the same dimension. An example is `_super_tofrom_choi` which converts between Liouville and Choi matrix representations, for example the line:. ``sqrt_shape = int(sqrt(data.shape[0]))``. This enhancement removes these assumptions and instead looks at the input and ouput dimensions of the `Qobj`s, which is stored in the `dims` attribute, to correctly convert in the case when the input and output dims are different. It's needed in all sorts of applications. Since the failing tests are unrelated to this pull request, it is merge ready.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-541953594:686,test,tests,686,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-541953594,1,['test'],['tests']
Testability,@nonhermitian Thanks for the fix. But the tests are failing for the older scipy version. Maybe we should bump up the min scipy requirement in the setup for the next version?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/865#issuecomment-392012683:42,test,tests,42,https://qutip.org,https://github.com/qutip/qutip/pull/865#issuecomment-392012683,1,['test'],['tests']
Testability,"@nonhermitian The test failure is with NOMKL=1 and OPENMP=0. Specifically, a solver is unavailable. This is not related to the addition of this function. Something else is breaking. ```; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/752#issuecomment-331760244:18,test,test,18,https://qutip.org,https://github.com/qutip/qutip/pull/752#issuecomment-331760244,1,['test'],['test']
Testability,@nonhermitian There is some BR test failing here. Do I need to worry about this? What are the two Travis tests now?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/721#issuecomment-316062715:31,test,test,31,https://qutip.org,https://github.com/qutip/qutip/pull/721#issuecomment-316062715,2,['test'],"['test', 'tests']"
Testability,"@nonhermitian could you please have a look at _pseudo_inverse_sparse when you have time, and see if you can think of any better way of doing this, from your experience with optimizing the steadystate solver? Would an iterative method make sense here? I basically run into memory problems quite quickly when using splu (which seems to be the most efficient method by far for this particular problem, according to my tests).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/272#issuecomment-67125235:415,test,tests,415,https://qutip.org,https://github.com/qutip/qutip/pull/272#issuecomment-67125235,1,['test'],['tests']
Testability,"@nonhermitian please review and test this PR. As far as I have seen it my test it works well, but it would be great if you could try this PR on some other mcsolve example. Perhaps paying special attention to possible performance regressions, although I think there shouldn't be any, but who knows.. With this PR mcsolve can also be used with the IPython.parallel framework. Here are some examples:. http://nbviewer.ipython.org/gist/jrjohansson/f37aa019080f8fb84c46",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66395472:32,test,test,32,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66395472,2,['test'],['test']
Testability,"@nonhermitian, I have fixed the import error but 2/4 testers fail. As far as I can tell this is unrelated to this PR. Is there anything that I should do before this can be merged?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/553#issuecomment-257148174:53,test,testers,53,https://qutip.org,https://github.com/qutip/qutip/pull/553#issuecomment-257148174,1,['test'],['testers']
Testability,"@nonhermitian: we haven't accept #1405 (and also I don't think we will soon, because it'll be part of larger changes), but yeah, if it is accepted, it would need to carry its entire licence with it in the file. We already do this somewhere with a vendored version of `Qcircuit.tex` though that's a whole other can of worms, because that's GPL'd, and I'm really not sure it's legally correct that we've done that. (also sidenote: thanks to you, I'm starting at IBM in Lev Bishop's team on the 5th of July - I've just put in the requisition for my computer!). On second thoughts, surely the more correct solution is to have the main licence read ""Copyright 2011-2021 Rob and Paul, 2021 onwards admin team""? That's more historically accurate, for sure. Another question: does anybody know about the legality of asserting copyright ""2011 and onwards"" in general? Numpy put in specific years, and bump the end year by commit. I'm mostly in favour of moving the licencing to the single `LICENSE.txt` file in order to make all these instances of separately licenced code easier to see and maintain. It also seems to be the way other large-scale open-source projects handle their licensing, it makes it much easier for us to manage the licensing of the entire project. I really don't want to rush this. I don't want to merge it without a proper discussion in a full admin meeting. I'm just trying to put it up ahead of time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-864038744:808,assert,asserting,808,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864038744,1,['assert'],['asserting']
Testability,"@nonhermitian: yeah, that's why I wasn't so keen on changing the code as it is - I can see from the git log that it went through a few iterations due to old versions of mac os breaking it, and I don't want to introduce regressive bugs. I didn't know why there was a difference, and I couldn't find what the output of `sysctl` was on mac 10.9 or whatever it was in 2013 (or when/if it changed).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1395#issuecomment-736688479:104,log,log,104,https://qutip.org,https://github.com/qutip/qutip/issues/1395#issuecomment-736688479,1,['log'],['log']
Testability,"@nwlambert ; Unable to run the test cases in (entropy.py) it show this error ; <img width=""850"" alt=""Screenshot 2024-03-20 at 2 48 54 AM"" src=""https://github.com/qutip/qutip/assets/147247481/710869a8-79e6-4941-b6d6-2ad0cf9fd76d"">; Can you please suggest me the solution to solve it ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2345#issuecomment-2008154917:31,test,test,31,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2008154917,1,['test'],['test']
Testability,"@nwlambert Neill, does this fix everything for you? I'd like to have a couple of people test it if possible, since I toughened up the exception throwing, which might have caused more previously hidden problems to surface.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1471#issuecomment-808877022:88,test,test,88,https://qutip.org,https://github.com/qutip/qutip/pull/1471#issuecomment-808877022,1,['test'],['test']
Testability,"@nwlambert: here's a thought - do you reckon it's worth implementing a test on the rank of the Hamiltonian/Liouvillian on input to `propagator`? If it's significantly less than full-rank (which it almost invariably will be), there's probably a really good speed-up to be had by evolving the system in a rotated frame.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1585#issuecomment-865913240:71,test,test,71,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865913240,1,['test'],['test']
Testability,@ozbenh @michkern @matteoacrossi I don't have an M1 to test with. Would you mind trying this out and letting me know if it works?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1754#issuecomment-1006439720:55,test,test,55,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1006439720,1,['test'],['test']
Testability,@ozbenh Thanks for reporting this!. Do you perhaps know what is causing this on your M1? Is it something Apple forgot to add to the platform? Or is it that they're deprecating `hw.cpufrequency` entirely?. What was your fix?. Unfortunately we have no way to test on M1 ourselves at the moment. Any suggestions welcome. :|. Perhaps the best we can do at the moment is harden QuTiP against these breakages so that it doesn't fail to import if some of the hardware information is missing on the M1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1606#issuecomment-879822914:257,test,test,257,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-879822914,1,['test'],['test']
Testability,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:78,test,tests,78,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354,8,"['assert', 'test']","['assertions', 'test', 'testing', 'tests']"
Testability,"@quantshah @BoxiLi @hodgestar I have wrapped up the two measurement functions in the `measure` and `measurement_statistics` function which calls the required functions based on whether `ops` is a `list of Qobjs` or a `Qobj`. Do we want the individual functions (especially POVM) to be more granular? Moreover, the docstring for the wrapper function is really clunky (given the case-wise output types). Any ideas on how to make that simpler ?(one idea is to not specify return types and only have parameters given it's bound to be clunky!). ps. I'll fix the tests all at once after we decide on the api",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-650337844:557,test,tests,557,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-650337844,1,['test'],['tests']
Testability,"@quantshah why did we close this? The tests are still failing. Did you close it because it only happens with the tests? If so, then maybe we should open another issue specifically about that.; I would be happy just to leave this open until the MacOS test are working again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-467256762:38,test,tests,38,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-467256762,3,['test'],"['test', 'tests']"
Testability,"@quantshah: Simon and I had temporarily stepped back from this one at the time, because we weren't entirely confident that the physics was being handled correctly - the initial version of the PR certainly had invalid physics, and it was hard to evaluate the new stuff from that perspective. It's changed since then, and it might be ok now, but it'll be easier to re-review now we've cleared the old context from our minds. About your Choi matrices - right now, `Qobj` doesn't have an `act` method, but that could well be a useful addition. It _does_ have `Qobj.__call__` which does a similar thing in a very few cases, so we could properly beef that up, but we might want to discuss exactly what spec it should have. @MrRobot2211: I very quickly glanced through the diff of this, but there still seem to be several points where I asked for changes that haven't been changed: things like removing unnecessary calls to `np.array`, and explaining _why_ dimensions needed to be changed in some tests. Can you go back through the PR and make sure you've addressed everything? Also, since you're trying to add new functionality, please make sure you add tests of explicit, analytically known cases against the whole matrix, in addition to the properties like the dimensions (also asked above). In a super ideal world it'd be great if you could find a published reference for those tests, but if the maths is simple enough that we can verify it by hand, then showing us would be ok. It could be good practice for the rest of GSoC if you try and go through the diff yourself to spot places that might want clarifying, and fix them ahead of review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-847759512:990,test,tests,990,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-847759512,3,['test'],['tests']
Testability,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:1616,test,tests,1616,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428,1,['test'],['tests']
Testability,@sahmed95 I am assuming that tests passed then? ; I can't find any Travis record of them having run.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/873#issuecomment-394270843:29,test,tests,29,https://qutip.org,https://github.com/qutip/qutip/pull/873#issuecomment-394270843,1,['test'],['tests']
Testability,@sahmed95 I assume that you still have a Mac for testing this locally?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458518424:49,test,testing,49,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458518424,1,['test'],['testing']
Testability,"@sahmed95 I like everything you are doing with this PR. Looks good to me.; I assume that you have tested all the fancy docstrings with the documentation build. I do think think it would be better if your test method docstrings started ""PIQS: "". Is there a reason not to do this?. Otherwise I think it is merge ready",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/861#issuecomment-396885841:98,test,tested,98,https://qutip.org,https://github.com/qutip/qutip/pull/861#issuecomment-396885841,2,['test'],"['test', 'tested']"
Testability,"@sahmed95 Thanks for this. ; Just restarted failed test. Fail not related to this change, so hopefully just a blip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/827#issuecomment-369642499:51,test,test,51,https://qutip.org,https://github.com/qutip/qutip/pull/827#issuecomment-369642499,1,['test'],['test']
Testability,@sahmed95 You'll see I have raised #881 to solve the py3 test issues. You can merge that (into the master and this) if the tests pass. On the py2 issues. I suggest you skip the tests (for Python 2.x) that are known to be failing. You can add something in the documentation that the PIQS module is only fully supported in Python >= 3.6. While your doing the skipping change ... would be good if the PIQS / Dicke tests had some docstring prefix to show they relate to the same module.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/861#issuecomment-396565673:57,test,test,57,https://qutip.org,https://github.com/qutip/qutip/pull/861#issuecomment-396565673,4,['test'],"['test', 'tests']"
Testability,@sahmed95 can you merge the new master into this.; I'll check it over when the tests are passing.; Thanks,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/861#issuecomment-395844451:79,test,tests,79,https://qutip.org,https://github.com/qutip/qutip/pull/861#issuecomment-395844451,1,['test'],['tests']
Testability,"@sahmed95 thank you very much. 2018-02-21 11:53 GMT+09:00 Shahnawaz Ahmed <notifications@github.com>:. > This is ready for a review. I incorporated the changes and the pep8 fixes.; > We still might go for a change in the name for the module as piqs and the; > class as Dicke to follow the naming in the paper. There are some more; > tests that we would like to add today.; >; > However, for the rest of it, things remain the same. Since the is_diagonal; > feature is more general, I could open a PR to include that as a Qobj; > property. Otherwise, this function will only be used once we add the; > enhancement diagonal_solver which can solve for some special classes of; > Hamiltonians. But that is for later.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/753#issuecomment-367197236>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AN5ffJy5kuOEnKCIxLH-GjbhKdmP8mHsks5tW4UrgaJpZM4PgbIo>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-367222920:333,test,tests,333,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-367222920,1,['test'],['tests']
Testability,@sahmed95 weird that the travis test still fails. I merged with master and it still does this.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398273615:32,test,test,32,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398273615,1,['test'],['test']
Testability,"@sarsid thank you for the detailed description of the PR. Some tests are failing at [` TestQubitCircuit.test_user_gate`](https://travis-ci.org/github/qutip/qutip/jobs/699177830#L3017), ""NameError: name 'isfunction' is not defined"". . This is still in draft mode, however I wonder whether you think it makes sense to provide the user the option to choose from OpenQasm 2.0 and Qasm, with the same function, e.g., `read_qasm`, but with an attribute. . This is a draft, but please remember to add Numpy docstrings to functions. . It would be great to have read/write capabilities with QASM, looking forward to this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-645411323:63,test,tests,63,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-645411323,2,"['Test', 'test']","['TestQubitCircuit', 'tests']"
Testability,"@sbisw002 can you do a small change so that we see if the tests fail also with `pytest`?; The current fail in OpenBLAS is due to a test in this new module. Please just scrap what is not working so that we can merge this soon. ; ```; FAIL: lattice: Test the methods of Lattice1d in a CROW model.; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python3.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+7dcd9be-py3.7-linux-x86_64.egg/qutip/tests/test_lattice.py"", line 580, in test_CROW; assert_(np.max(abs(val_kns-Ana_val_kns)) < 1.0E-13); File ""/home/travis/miniconda/envs/test-environment/lib/python3.7/site-packages/numpy/testing/_private/utils.py"", line 98, in assert_; raise AssertionError(smsg); AssertionError; ----------------------------------------------------------------------; Ran 663 tests in 1006.646s; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-575495617:58,test,tests,58,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-575495617,12,"['Assert', 'Test', 'test']","['AssertionError', 'Test', 'test', 'test-environment', 'testing', 'tests']"
Testability,@sbisw002 the tests by Travis CI are failing on all operating systems.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1053#issuecomment-513148589:14,test,tests,14,https://qutip.org,https://github.com/qutip/qutip/pull/1053#issuecomment-513148589,1,['test'],['tests']
Testability,"@tehruhn let's look into this together this week so that I can understand better also Eric comments. I would be happy to merge, and open a separate issue on the np-Cython bit. nose to pytest migration has been dragging on for ages. Also, please let's try to find a way to have the docstrings print to screen, the verbosity=2 thing does not seem to work. With `nose` and current development master now I get a segmentation fault on Mac 10.14 so I cannot test locally.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-563243088:453,test,test,453,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-563243088,1,['test'],['test']
Testability,@theodotk Apologies for the delay and thank you for the tests. I've incorporate them now and they look good. It would be nice to make the expected results match a little better. Supplying only `atol` is problematic when the values themselves are small and currently the relative differences are larger than `1`. Any suggestion for making these better without having the test take too long?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1446044347:56,test,tests,56,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1446044347,2,['test'],"['test', 'tests']"
Testability,"@theodotk Thank you for the bug report. I cherry-picked your fix into this PR. Any thoughts on a simple test case we could add? Ideally we could just pass in custom m_ops in something like `test_smesolve_heterodyne` but I don't know what the custom m_ops should be, how to calculate the expected result or how to be sure the right m_ops were used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1424035216:104,test,test,104,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424035216,1,['test'],['test']
Testability,"@tomohiro-soejima Thank you for a very well organized bug report and for suggesting a fix. I've opened PR #1818 that applies your suggestion and adds tests. The PR is a continuation of #1690 because I didn't want to generate merge conflicts, so it can only be easily reviewed and merged once #1690 lands. I've marked the fix for inclusion in 4.7 which should be released in the next couple of weeks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1817#issuecomment-1057931568:150,test,tests,150,https://qutip.org,https://github.com/qutip/qutip/issues/1817#issuecomment-1057931568,1,['test'],['tests']
Testability,@vikas-chaudhary-2802 It looks like something went wrong with the installation. Make sure that you really installed the master branch and are testing it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321:142,test,testing,142,https://qutip.org,https://github.com/qutip/qutip/issues/2345#issuecomment-2016856321,1,['test'],['testing']
Testability,"@vikas-chaudhary-2802 can you add the test to this PR? it can be very simple. if you feel like it will take some time, i can merge this and you can do a separate one later. @ytdHuang thanks for the suggestion, do you think it would be better to use that as the default method? in any case, lets do that in a separate issue/PR",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2371#issuecomment-2042114519:38,test,test,38,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042114519,1,['test'],['test']
Testability,"@wrzadkow I now read your last comment. I found no previous test for Bloch. If you want to add one that would be great but besides checking the environment I wouldn’t know how to do it. But you’re welcome to go ahead. I don’t think that there are tests in qutip-notebooks, Travis CI only looks into qutip/qutip. Thank you for the PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/989#issuecomment-494103447:60,test,test,60,https://qutip.org,https://github.com/qutip/qutip/issues/989#issuecomment-494103447,2,['test'],"['test', 'tests']"
Testability,@wrzadkow thank you. It sounds good to me. Could [detect](https://stackoverflow.com/questions/5376837/how-can-i-do-an-if-run-from-ipython-test-in-python) whether the environment is `IPython`. ; If you can write a test too for it to avoid environment-dependent errors that would be great.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/989#issuecomment-493725091:138,test,test-in-python,138,https://qutip.org,https://github.com/qutip/qutip/issues/989#issuecomment-493725091,2,['test'],"['test', 'test-in-python']"
Testability,"@yosefrajwulf Thanks for pointing out the bug. I got an unrelated error in MacOS so restarting the tests. Hopefully, they pass and we can merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/943#issuecomment-456054829:99,test,tests,99,https://qutip.org,https://github.com/qutip/qutip/pull/943#issuecomment-456054829,1,['test'],['tests']
Testability,"@ziofil, I just checked that updating the colab notebook to have the line; ```; !pip install scipy==1.2.1; !pip install qutip; ```; works for me, as @quantshah mentioned. ; QuTiP will find already the SciPy 1.2.1 requirement and will avoid keeping 1.3.; It is an issue with `IndexMixin` relocation in SciPy 1.3 (released this May 17), which has been changed from `scipy.sparse.sputils` to `scipy.sparse._index`.; I tested this also in My Binder and this works too, by setting in the `environment.yml` file, ; [in line 9,](https://github.com/nathanshammah/interactive-notebooks/blob/master/environment.yml#L9); from; ```; - scipy; ```; to ; ```; - scipy==1.2.1; ```; I will open a PR with this patch for `qutip-notebooks` for the time being. Once the next official version of QuTiP is released, this problem will not arise, as this issue has been taken care of by @Ericgig in PR #999 by updating scipy `IndexMixin`, now under private use, with scipy `get_index_dtype`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1008#issuecomment-499038616:415,test,tested,415,https://qutip.org,https://github.com/qutip/qutip/issues/1008#issuecomment-499038616,1,['test'],['tested']
Testability,"A bit surprisingly, all tests now pass on Windows on QuTiP 5. I'm not 100% sure the parallel map change fixed everything, or if everything was mostly working before. I would like to keep the parallel map change regardless, because it removes some of the management of making multiprocessing work and leaves it with the core Python developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1948#issuecomment-1170374439:24,test,tests,24,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1170374439,1,['test'],['tests']
Testability,"A large portion of the mcsolver runtime is concentrated in the calculation of expectation values for each time in tlist. For example:. ``` python; from qutip import *; from numpy import sqrt, linspace; N0 = 10; N1 = 10; N2 = 10; # damping rates; gamma0 = 0.1; gamma1 = 0.4; gamma2 = 0.1; alpha = sqrt(2) # initial coherent state param for mode 0; ntraj = 500 # number of trajectories; # define operators; a0 = tensor(destroy(N0), qeye(N1), qeye(N2)); a1 = tensor(qeye(N0), destroy(N1), qeye(N2)); a2 = tensor(qeye(N0), qeye(N1), destroy(N2)); # number operators for each mode; num0 = a0.dag() * a0; num1 = a1.dag() * a1; num2 = a2.dag() * a2; # dissipative operators for zero-temp. baths; C0 = sqrt(2.0 * gamma0) * a0; C1 = sqrt(2.0 * gamma1) * a1; C2 = sqrt(2.0 * gamma2) * a2; # initial state: coherent mode 0 & vacuum for modes #1 & #2; psi0 = tensor(coherent(N0, alpha), basis(N1, 0), basis(N2, 0)); # trilinear Hamiltonian; H = 1j * (a0 * a1.dag() * a2.dag() - a0.dag() * a1 * a2). tlist = linspace(0, 10, 100); data = mcsolve(H, psi0, tlist, [C0, C1, C2], [num0, num1, num2],ntraj=ntraj). tlist = linspace(0, 10, 10); data = mcsolve(H, psi0, tlist, [C0, C1, C2], [num0, num1, num2],ntraj=ntraj,; options=Options(seeds=data.seeds)); ```. The second run, where the seeds are the same as the first run to remove randomness in the tests, is nearly 3x faster (using 4 cores) than the first one. However, we are already calculating the expectation values using cython, so it is difficult to see how we can improve on this here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64517057:1333,test,tests,1333,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64517057,1,['test'],['tests']
Testability,A sticky situation given that Anaconda is MKL by default now. I agree that perhaps the tests can be skipped if MKL is present. This can easily be checked via the qutip.settings.has_mkl property,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/484#issuecomment-222047139:87,test,tests,87,https://qutip.org,https://github.com/qutip/qutip/issues/484#issuecomment-222047139,1,['test'],['tests']
Testability,"AILURES ===================================; > ___________________________ test_MCSimpleConstStates ___________________________; > @pytest.mark.slow; > def test_MCSimpleConstStates():; > ""Monte-carlo: Constant H with constant collapse (states)""; > N = 10 # number of basis states to consider; > a = destroy(N); > H = a.dag() * a; > psi0 = basis(N, 9) # initial state; > kappa = 0.2 # coupling to oscillator; > c_op_list = [np.sqrt(kappa) * a]; > tlist = np.linspace(0, 10, 100); > mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; > options=Options(average_states=True)); > assert_(len(mcdata.states) == len(tlist)); > assert_(isinstance(mcdata.states[0], Qobj)); > expt = expect(a.dag() * a, mcdata.states); > actual_answer = 9.0 * np.exp(-kappa * tlist); > avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > > assert_equal(avg_diff < mc_error, True); > E AssertionError: ; > E Items are not equal:; > E ACTUAL: False; > E DESIRED: True; > ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; > ----------------------------- Captured stdout call -----------------------------; > 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; > 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; > 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; > 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; > 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; > 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; > 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; > 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; > 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; > 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; > Total run time: 20.34s; > ---------- coverage: platform darwin, python 3.7.7-final-0 -----------; > Name ; > ```; > ; > Restart the tests. I agree with you, it's annoying. On my personal Travis CI dashboard, all the ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896:1167,test,test-environment,1167,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896,1,['test'],['test-environment']
Testability,"About pickling. `QobjEvo` doesn't contain any cython only data and cython autopickling is working fine.; There is a test for it. (But not for windows, there is still a risk there).; But function used in `linear_map` or in coefficient etc. may cause problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-815141272:116,test,test,116,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-815141272,1,['test'],['test']
Testability,"About tests being very slow, I saw the following notice when I open the details:; ```; Please be aware travis-ci.org will be shutting down in several weeks, with all accounts migrating to travis-ci.com. Please stay tuned here for more information.; ```; I think we are still on `travis-ci.org`? Is this related to us? Maybe ""switch CI to GitHub Actions"" is more pressing than we thought.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1465#issuecomment-805920788:6,test,tests,6,https://qutip.org,https://github.com/qutip/qutip/pull/1465#issuecomment-805920788,1,['test'],['tests']
Testability,Actually I am almost certain that they fixed the buffering issue (or at least one of the buffering issues if this happens to persist in your tests). It was discussed here: https://github.com/ipython/ipython/issues/5779,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63221901:141,test,tests,141,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63221901,1,['test'],['tests']
Testability,"Actually I'm going to close this for now pending further discussion on #1433. The failing tests are using the implicit array coercion, which we may or may not want, but regardless, there's a bigger decision to be made.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1434#issuecomment-772656180:90,test,tests,90,https://qutip.org,https://github.com/qutip/qutip/pull/1434#issuecomment-772656180,1,['test'],['tests']
Testability,"Actually let's also leave it open until I can determine if it is indeed scipy. After installing scipy with pip as the scipy folks suggested, the example I had in that issue is now working, but I get the same integration error with qutip and same tests failing. When I get time, i'll try to distill down the qutip error to a scipy error and post an update. Hopefully the main issue is just a scipy error, but would be good to confirm.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786:246,test,tests,246,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205435786,1,['test'],['tests']
Testability,"Actually this does not pass tests, so it is being reverted in #567.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/565#issuecomment-264031521:28,test,tests,28,https://qutip.org,https://github.com/qutip/qutip/pull/565#issuecomment-264031521,1,['test'],['tests']
Testability,"Actually, I suppose it's much easier than I was fearing - we don't actually need to test the degeneracy or anything. We know they're the eigenvectors of a Hermitian matrix, so taken all together they should span the Hilbert space. Testing that they're all linearly independent I think is a bit of an easier test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1299#issuecomment-649527490:84,test,test,84,https://qutip.org,https://github.com/qutip/qutip/issues/1299#issuecomment-649527490,3,"['Test', 'test']","['Testing', 'test']"
Testability,"Actually, with further testing it seems that the scipy method is better at larger sized matrices. Should probably stick with that one. The older qutip algorithm is closer to the matlab version per 3015b, and returns similar results. It seems the scipy one is a bit better behaved at larger sizes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/464#issuecomment-210640593:23,test,testing,23,https://qutip.org,https://github.com/qutip/qutip/pull/464#issuecomment-210640593,1,['test'],['testing']
Testability,Added by @Ericgig during 4.4.0 release. See https://test.pypi.org/project/qutip/. Closing it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/992#issuecomment-510879704:52,test,test,52,https://qutip.org,https://github.com/qutip/qutip/issues/992#issuecomment-510879704,1,['test'],['test']
Testability,"Added the function as discussed here, along with two new unit tests to ensure it agrees with either `tensor()` or `super_tensor()`, as appropriate for the input arguments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-57089321:62,test,tests,62,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-57089321,1,['test'],['tests']
Testability,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Giguère ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; > ⬇️ Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:562,test,tests,562,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839,1,['test'],['tests']
Testability,"After fixing the fortran issue here is the error:. # . ## ERROR: Test Qobj: trunc_neg works for non-diagonal opers. Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/travis/build/qutip/qutip/qutip/tests/test_qobj.py"", line 816, in case; pos_qobj = qobj.trunc_neg(method=method); File ""/home/travis/build/qutip/qutip/qutip/qobj.py"", line 1246, in trunc_neg; if eigvals[idx] + acc / (idx + 1) >= 0:; IndexError: index 2 is out of bounds for axis 0 with size 2",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/417#issuecomment-181509701:65,Test,Test,65,https://qutip.org,https://github.com/qutip/qutip/pull/417#issuecomment-181509701,4,"['Test', 'test']","['Test', 'test', 'test-environment', 'tests']"
Testability,"After investigating a bit more, I think this may be related to 3a5ab42200b3f1851343081614064e67be3b02bf, in that SCS and CVXOPT are not yet compatible with MKL, and require OpenBLAS instead. If I locally use pip to install SCS and CVXOPT with an MKL-enabled conda env, then importing cvxpy fails due to undefined symbols. On the other hand, if I use the Omnia conda channel to install cvxopt and scs, then `dnorm()` works, but the conda env switches to use OpenBLAS. To resolve the build failures, then, I'd suggest temporarily marking the tests as skipped if MKL is enabled.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/484#issuecomment-222046697:540,test,tests,540,https://qutip.org,https://github.com/qutip/qutip/issues/484#issuecomment-222046697,1,['test'],['tests']
Testability,"After merging #1097, the following error is given on a Linux machine from travis CI ; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; 1656Exception in thread Thread-546:; 1657Traceback (most recent call last):; 1658 File ""/Users/travis/miniconda/envs/test-environment/lib/python3.7/threading.py"", line 926, in _bootstrap_inner; 1659 self.run()",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1084#issuecomment-543262454:268,test,test-environment,268,https://qutip.org,https://github.com/qutip/qutip/issues/1084#issuecomment-543262454,1,['test'],['test-environment']
Testability,After shifting to `core` the tests have started interfering with each other. It would be better if we could keep the `numpy_backend` class to qutip not `core`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2490#issuecomment-2235671204:29,test,tests,29,https://qutip.org,https://github.com/qutip/qutip/pull/2490#issuecomment-2235671204,1,['test'],['tests']
Testability,"After you created a fork to work on #1242, a different PR (#1226) was merged into `master`. It so happens that #1242 and #1226 don't conflict so that merge succeeded, but the new changes you're now trying to make do. This is fundamentally a true merge conflict and so unfortunately there's no fancy way around it, though it could have been avoided if you'd matched the state of our `master` before beginning work here, and it would be a bit easier for you for future PRs to branch off before starting work (GitHub has [some nice material about this workflow](https://guides.github.com/introduction/flow/)). I've rebased your PR onto our `master` and fixed the resulting merge conflict for you. You should _immediately, without doing anything else_ reset your branch state to match mine, and then force-push your changes to GitHub to update the PR. To do this, do; ```bash; git remote add jakelishman https://www.github.com/jakelishman/qutip.git; git fetch jakelishman; git checkout master; git reset --hard jakelishman/Canoming-circuit-patch; git push --force; git remote remove jakelishman; ```; This will destroy anything on `master` that you may have but haven't yet pushed. You should do it anyway, because a lot of the underlying structure has changed from underneath you, and your changes aren't consistent with the current state of `circuit.py`. Please also note that the tests are failing after your modifications in (the current) 10e457e.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-630932121:1379,test,tests,1379,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-630932121,1,['test'],['tests']
Testability,"Again, I am not sure why some unrelated tests are failing !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-649089741:40,test,tests,40,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-649089741,1,['test'],['tests']
Testability,Agreed that it is tricky to test. I mostly wanted the tests because the nice error messages might contain bugs. Happy to let this slide for now though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742:28,test,test,28,https://qutip.org,https://github.com/qutip/qutip/pull/2304#issuecomment-1908915742,2,['test'],"['test', 'tests']"
Testability,"Agreed, it is a bit sticky. I'd guess that since the MKL switchover was relatively recent, they haven't had time to get things working. At any rate, I'll go on and make a PR that skips the relevant tests then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/484#issuecomment-222050661:198,test,tests,198,https://qutip.org,https://github.com/qutip/qutip/issues/484#issuecomment-222050661,1,['test'],['tests']
Testability,"Ah great! Thanks! So I probably used parameterization with the circuit in a non-recommended way. The source code is correct, there is just something wrong with the test. I'll try coming up with a solution for that test later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880:164,test,test,164,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880,2,['test'],['test']
Testability,"Ah yes, that constraint was there to prevent accidentally using `qutip-qip` with `qutip@dev.major` because the support was only added a few weeks ago. Only the master branch of `qutip-qip` support this. So this basically prevents installing the `qutip@dev.major` and the released `qutip-qip` at the same time. One has to install `qutip-qip@master` to test them. This also means that adding `qutip-qip` as an optional package right now does not make much sense. Probably we can drop this. To test it on GitHub action we need to install `qutip-qip@master` for now and test the importation. @hodgestar Is that ok? Otherwise, I can try to get out a new release of `qutip-qip` in a day or so. Just to update the change log and click the button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381:351,test,test,351,https://qutip.org,https://github.com/qutip/qutip/pull/1920#issuecomment-1147618381,4,"['log', 'test']","['log', 'test']"
Testability,"Ah, are you using an Apple M1?. SciPy support for Apple M1 is still rather unreliable (this is more a function of the lack of availability of Apple M1 VMs for open source projects to run tests on than any fault of SciPy's). Perhaps you are encountering one of these two recent bugs:. - https://github.com/scipy/scipy/issues/16767; - https://github.com/scipy/scipy/issues/16875. The bugs are closed but I don't know if new versions have been released. Various work arounds have been suggested in those issue reports. Hopefully one of them will work for your case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134:187,test,tests,187,https://qutip.org,https://github.com/qutip/qutip/issues/1987#issuecomment-1229182134,1,['test'],['tests']
Testability,"Ah, got it. Anyway, this PR is orthogonal to #332, it's just that I only noticed this problem in trying to write test cases and documentation for the new functionality in that PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/337#issuecomment-125637210:113,test,test,113,https://qutip.org,https://github.com/qutip/qutip/pull/337#issuecomment-125637210,1,['test'],['test']
Testability,"Ah, nice catch thanks, and thanks for the super clear repro. We're overhauling the solvers for QuTiP 5.0, which will include a lot more rigorous input checking on entry, but also it uses far safer low-level datatypes that would catch this shape mismatch in the C layer (even though the `dims` _should_ have been checked by `mesolve`). I'll check the other solvers and patch in a sanity test - probably after these lines: https://github.com/qutip/qutip/blob/d5e305513d9186df74beee4fd8da680e89f29d15/qutip/mesolve.py#L259-L261; we can just insert a test; ```python; if rho0.dims[0] != rho0.dims[1]:; raise ValueError(; ""input state must be a pure state or square density matrix""; ); ```. There may also be other segfaults lurking if you use a Python function to generate a time-dependent `Qobj` value in the Liouvillian or the expectation operators, but right now you're unlikely to use that form (because it's slow as anything). The bug slips through because we unsafely pass off a matrix down to C code (where we currently don't have sanity checks) without first verifying that it is a valid shape in Python space - the C code is working as designed, so there shouldn't be problems with correct inputs. Removing `c_ops` causes `mesolve` to delegate to `sesolve` which presumably is better at its type-checking, and I expect that a small dimension size working is likely just `malloc` having slack in the memory it gives us for small sizes or small requests being allocated into the special pre-allocated store.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1456#issuecomment-791925169:386,test,test,386,https://qutip.org,https://github.com/qutip/qutip/issues/1456#issuecomment-791925169,2,['test'],['test']
Testability,"Ah, the test does not fail because I forgot to make psi0 a density matrix before passing it to sesolve. Fixing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1148793484:8,test,test,8,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1148793484,1,['test'],['test']
Testability,"Ah, this test failure reminds me I need to merge up the 4.6.0 release to `dev.major`. Documentation fix is good, merging (though ironically there's a typo in your PR name!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1494#issuecomment-818721204:9,test,test,9,https://qutip.org,https://github.com/qutip/qutip/pull/1494#issuecomment-818721204,1,['test'],['test']
Testability,"Ah, we seem to have rediscovered #1202. We also see #1190, but that doesn't cause tests to fail.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1854#issuecomment-1097181695:82,test,tests,82,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1097181695,1,['test'],['tests']
Testability,"Ah, you are right! It seems to be all tests using the ODE solvers are failing.; Indeed mesolve and sesolve tests are also failing (with the same integration error).; There are lots of tests which fail, I think most likely every test that calls a solver... I just did some basic testing with scipy's integrate.ode and this seems to have the same kind of issues, so I think as you mention, the issue lies with the solver...meaning it probably isn't installed correctly.; Similar issues seem to have been raised for scipy previously (e.g. https://github.com/scipy/scipy/issues/15077), though I don't see any currently open. I also updated scipy today and it didn't change anything unfortunately. I guess this issue can be closed, if it's just a scipy problem?; Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858:38,test,tests,38,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1204170858,5,['test'],"['test', 'testing', 'tests']"
Testability,Ahh well then there is no more issues with this. Just waiting for the minor changes to the mcsolver tests to clear.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/300#issuecomment-68425710:100,test,tests,100,https://qutip.org,https://github.com/qutip/qutip/pull/300#issuecomment-68425710,1,['test'],['tests']
Testability,"Ahh, you're right. I never managed to get it to work right before now, but I just tried again and managed to get `DeprecationWarning` to show up in all of `python warn.py`, direct calls from the IPython terminal and from Jupyter notebooks. I think perhaps I learned about stacklevel _after_ the last time I tried to get that to work. My reading of the docs before that had always just ended up with me assuming that somebody using a library interactively was an ""end-user"", so `FutureWarning` was appropriate. I'll change this PR when I've got time - I needed to fix up a few warning controls in tests before it was ready anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1480#issuecomment-814036449:596,test,tests,596,https://qutip.org,https://github.com/qutip/qutip/pull/1480#issuecomment-814036449,1,['test'],['tests']
Testability,"All looks good to me. Thanks a lot for changing all of that - this is all clearly good stuff and should in principle be merged. We should the Linux tests again after #1381 is merged because there is Linux-specific code in the changes that needs to be tested (the tests fail for unrelated reasons at the moment). I can't see any reason why the changes here should cause any true test failures, though - it's more a formality.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1380#issuecomment-727103648:148,test,tests,148,https://qutip.org,https://github.com/qutip/qutip/pull/1380#issuecomment-727103648,4,['test'],"['test', 'tested', 'tests']"
Testability,All of the individual terms in the dense version of the time-dependent BR solver are now tested and working. Now I need to write the codegen module. A sparse version is just a simple extension once the codegen is done.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/676#issuecomment-295576774:89,test,tested,89,https://qutip.org,https://github.com/qutip/qutip/pull/676#issuecomment-295576774,1,['test'],['tested']
Testability,All test runs passed. @Ericgig I'm going to merge so that other PRs can merge this in. Should I also create a PR for dev.major?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2013#issuecomment-1318533244:4,test,test,4,https://qutip.org,https://github.com/qutip/qutip/pull/2013#issuecomment-1318533244,1,['test'],['test']
Testability,All tests passing again -- ready for another review!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1948#issuecomment-1171606033:4,test,tests,4,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171606033,1,['test'],['tests']
Testability,"All the documentation tests have passed, so merging.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940#issuecomment-1168835644:22,test,tests,22,https://qutip.org,https://github.com/qutip/qutip/pull/1940#issuecomment-1168835644,1,['test'],['tests']
Testability,"All the same, I'd very much like to further reduce warnings. I've literally had Firefox crash trying to load the entire Travis logs.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/433#issuecomment-185792948:127,log,logs,127,https://qutip.org,https://github.com/qutip/qutip/issues/433#issuecomment-185792948,1,['log'],['logs']
Testability,"Also fixed dense matmul to use `zgemv` for `oper@ket`.; In the `oper @ ket` [matmul scaling benchmarks](https://qutip.org/qutip-benchmark/s_matmul.html), `Dense` is slower than `numpy`. Our dense data layer used `zgemm` for both matrix @ matrix and matrix @ vector operations. By switching to `zgemv` we get closer to numpy's times: faster in `C` format but slower in `Fortran`.; `bra@oper` still use `zgemm`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2008#issuecomment-1297569831:92,benchmark,benchmarks,92,https://qutip.org,https://github.com/qutip/qutip/pull/2008#issuecomment-1297569831,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,Also to test fix for #672,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/746#issuecomment-323369260:8,test,test,8,https://qutip.org,https://github.com/qutip/qutip/pull/746#issuecomment-323369260,1,['test'],['test']
Testability,"Also, I run these codes on Jupyter notebook but on my PC's terminal, I could successfully import ``qubit.testing`` and ``qubit``.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1650#issuecomment-912900577:105,test,testing,105,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-912900577,1,['test'],['testing']
Testability,"Also, I was just quickly searching for a quick-and-dirty ""obviously correct"" method of doing the partial trace to use as the test case (rather than keeping around a legacy Cython version just to test against), and found [this StackOverflow answer](https://scicomp.stackexchange.com/questions/27496/calculating-partial-trace-of-array-in-numpy) which has like 3 people telling someone ""don't do it yourself, just use QuTiP""! Pretty neat!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1325#issuecomment-663126648:125,test,test,125,https://qutip.org,https://github.com/qutip/qutip/issues/1325#issuecomment-663126648,2,['test'],['test']
Testability,"Also, all tests are failing. The one I checked showed:; ```; ImportError: No module named dicke; ```; I assume that this will affect all the builds",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-370370268:10,test,tests,10,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-370370268,1,['test'],['tests']
Testability,"Also, never before, that I can recall, the tests were running on both the push and pull request. Hope this is working but not just by chance. Congrats @Ericgig on this too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-500649942:43,test,tests,43,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-500649942,1,['test'],['tests']
Testability,"Also, nonlinear functions, such as the Von Neumann entropy of the steadystate can be wrong. . Any test on expected values of collective spin operators the steadystate, compared with the steadystate calculated in the full basis, give correct results.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/993#issuecomment-500331700:98,test,test,98,https://qutip.org,https://github.com/qutip/qutip/issues/993#issuecomment-500331700,1,['test'],['test']
Testability,"Also, once you're done, leave this PR without merging and I'll tidy up the commit history. We shouldn't have things like 374debd (a wrong-way merge) because they really mess with the mainline of the history, and make things harder to traceback, and I can collapse all your changes into one ""logical"" change once it's working.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-878151587:291,log,logical,291,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878151587,1,['log'],['logical']
Testability,"Also, sorry for stepping on your toes on the `test_metrics` thing - that really wasn't intentional, and I was only looking at it more because there are a few historic problems with dnorm testing that I'd remembered later. I didn't mean to cut you off from what you were doing, and had you had more work done on it, I'd have worked with you to merge the two together rather than suggesting you throw yours out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815046001:187,test,testing,187,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815046001,1,['test'],['testing']
Testability,"Also, the code needs to work with both python 2 and 3. See the failing Travis tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44496711:78,test,tests,78,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44496711,1,['test'],['tests']
Testability,"Also, this added test runs in less than 1 second on my machine. Even an overloaded CI machine isn't going to take excessively long on it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-822691415:17,test,test,17,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-822691415,1,['test'],['test']
Testability,"Also, this change will duplicate all the tests in QuTiP for the same reason that you originally said you didn't want to import individual tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-976543231:41,test,tests,41,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976543231,2,['test'],['tests']
Testability,"Also, we can ""solve"" the testing issue by forcing the environment variable `QUTIP_NUM_PROCESSES=2` before importing QuTiP, I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1470#issuecomment-808299865:25,test,testing,25,https://qutip.org,https://github.com/qutip/qutip/issues/1470#issuecomment-808299865,1,['test'],['testing']
Testability,"Also, when you run `pytest` on the file (`pytest qutip/tests/test_qobj.py` from the git root), it moans a lot about `np.matrix` being essentially deprecated, and `Qobj` uses it as a data representation in some cases. I haven't touched that, but I also didn't want to hide the warning.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1161#issuecomment-576056391:55,test,tests,55,https://qutip.org,https://github.com/qutip/qutip/pull/1161#issuecomment-576056391,1,['test'],['tests']
Testability,"Also: I don't think CodeClimate actually supports skipping the tests when we call it as an action like this. We'd have to set it up to run on CI runner under our control (e.g. on GitHub Actions), and then configure a method of skipping tests within that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927:63,test,tests,63,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927,2,['test'],['tests']
Testability,An IPython notebook example should be provided for using this time-dependent option.; A test should also be added.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/396#issuecomment-155855645:88,test,test,88,https://qutip.org,https://github.com/qutip/qutip/pull/396#issuecomment-155855645,1,['test'],['test']
Testability,An example is given in this gist https://gist.github.com/nathanshammah/f96f6c1db5c323243a4729467cb7351f. ; Some performance benchmarking was done in PR #1024.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1032#issuecomment-533145168:124,benchmark,benchmarking,124,https://qutip.org,https://github.com/qutip/qutip/issues/1032#issuecomment-533145168,1,['benchmark'],['benchmarking']
Testability,An unrelated test fails after this is merged. It doesn't make sense to me...; https://github.com/qutip/qutip/runs/3008054620,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1603#issuecomment-875530358:13,test,test,13,https://qutip.org,https://github.com/qutip/qutip/pull/1603#issuecomment-875530358,1,['test'],['test']
Testability,Anaconda uploaded new packages.; spare eigs test now passing.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/871#issuecomment-394186354:44,test,test,44,https://qutip.org,https://github.com/qutip/qutip/issues/871#issuecomment-394186354,1,['test'],['test']
Testability,"And then the MacOS tests went and failed when this was merged in, so there is still an issue",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/957#issuecomment-469745755:19,test,tests,19,https://qutip.org,https://github.com/qutip/qutip/pull/957#issuecomment-469745755,1,['test'],['tests']
Testability,Any ideas?; - drop the NOMKL tests?. I'll try and raise with anaconda,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/871#issuecomment-393906852:29,test,tests,29,https://qutip.org,https://github.com/qutip/qutip/issues/871#issuecomment-393906852,1,['test'],['tests']
Testability,"Any reason why it was not seen in the tests earlier? . Also, I am working on the SS section of the docs tonight. Should be done before tomorrow. On Jul 16, 2014, at 9:29 PM, Robert Johansson notifications@github.com wrote:. > That's the hope. Still having some troubles with this though.; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/197#issuecomment-49158166:38,test,tests,38,https://qutip.org,https://github.com/qutip/qutip/pull/197#issuecomment-49158166,1,['test'],['tests']
Testability,"Any update on the failing tests, @araza6?; This is the print message from CI build:; ```; ==================================== ERRORS ====================================; _____________ ERROR collecting tests/test_basis_transformation.py ______________; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/_pytest/python.py:513: in _importtestmodule; mod = self.fspath.pyimport(ensuresyspath=importmode); ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:176: in <module>; from qutip.qobj import *; E File ""/home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/qobj.py"", line 2026; E """"""; E Checks whether qobj is a valid density matrix; E """"""; E ; E ; E ^; E IndentationError: expected an indented block; ___________________ ERROR collecting tests/test_brmesolve.py ___________________; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined; During handling of the above exception, another exception occurred:; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting tests/test_brmesolve_td.py __________________; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:46: in <module>; __I",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:26,test,tests,26,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,7,['test'],"['test-environment', 'tests']"
Testability,"Applied fixes for Python 3, and now the new unit tests run locally on both 2.7 and 3.4, so I expect that the CI checks should pass as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/358#issuecomment-128549325:49,test,tests,49,https://qutip.org,https://github.com/qutip/qutip/pull/358#issuecomment-128549325,1,['test'],['tests']
Testability,"Apply your squeeze operator to a state vector and check the norm of the; output. Is the operator really unitary?. -P. On Mar 13, 2017 11:48 AM, ""ziofil"" <notifications@github.com> wrote:. > When I tried to use the qutip.squeeze function for my simulations I; > noticed that something was off. Upon further investigation I found out that; > the output is not a truncated version of the single-mode squeezing unitary,; > but rather the matrix exponential of the truncated generator. These are; > *very* different things!; >; > Am I right in assuming that the most useful matrix would be the truncated; > unitary? If that's the case, the current method to compute it is wrong. To; > compute the right matrix one can use the disentangling formula for SU(1,1); > (formula (31) here <http://aip.scitation.org/doi/pdf/10.1063/1.3413923>):; >; > def squeeze(n,z):; > s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); > s1 = -2*np.log(np.cosh(abs(z))); > s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); >; > L = s0*0.5*(qt.create(n)*qt.create(n)); > K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); > R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); >; > return (L.expm())*(K.expm())*(R.expm()); >; > As you can see, this definition does *not* depend on the truncation; > parameter. Specifically, the upper-left portion of the matrix that; > qutip.squeeze outputs converges to my squeeze function for large n.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/661>, or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ABMPqdPPw6WOAYMpYw_kA9pRxVhgVyxIks5rlYF9gaJpZM4MbmLX>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286216795:917,log,log,917,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286216795,1,['log'],['log']
Testability,Are you still working on a test?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1177#issuecomment-600798812:27,test,test,27,https://qutip.org,https://github.com/qutip/qutip/pull/1177#issuecomment-600798812,1,['test'],['test']
Testability,"Arne,. Do you still have the code where the eigenvalue solver breaks down for the Liouvillian? I am starting to work on the matrix balancing functions and would like something known to cause trouble to test on. Cheers,. Paul",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/16#issuecomment-34325017:202,test,test,202,https://qutip.org,https://github.com/qutip/qutip/issues/16#issuecomment-34325017,1,['test'],['test']
Testability,"As @BoxiLi noted, Mac tests are passing for this PR. I ran them twice to check and they passed. This would solve issue #963.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1042#issuecomment-511349101:22,test,tests,22,https://qutip.org,https://github.com/qutip/qutip/pull/1042#issuecomment-511349101,1,['test'],['tests']
Testability,"As I understand it, the only way to avoid needing to touch `MANIFEST.in` is to not have files distributed with the test suite (or to have the temporary files by `*.py`, since `setup.py` automatically recognises them). That's not really a pytest thing, it's a `setuptools` one. I don't think there's a problem distributing files as part of the tests. You can add a line which says; ```; recursive-include qutip/tests/qasm_files *.qasm; ```; to `MANIFEST.in`, and that should hopefully fix the problem. You won't have the problem locally, because you'll be running `./setup.py develop`, which ""installs"" in-place, so you don't notice the fact that you've missed files from the manifest. In the tests, it runs `./setup.py install`, which does the copy, missing files which aren't in the manifest. Boxi: I'm not certain what more you'd like to do with fixtures here. Fixtures are good for setup and tear down, parametrisation and sharing resources (like network connections), but I'm not certain what further benefit you get for a test function which is testing whether it can open a known file, read it, and construct the expected output. I think Sidhant is already doing some nice parametrisation of his tests, from what I see. Sidhant: I added a comment on the exception test, since pytest gives us an easier-to-read context manager you can use. It's also typically better practice to handle file paths like I did in that (using the overloaded `/` operator with `pathlib.Path`, or `os.path.join`) rather than manually putting in slashes. Windows _usually_ will do the right thing now with slashes, but it's better to let Python handle it for us.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-656255156:115,test,test,115,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-656255156,8,['test'],"['test', 'testing', 'tests']"
Testability,"As a note: `qutip.vector_to_operator` is part of the implementation of superoperators. The ""vector"" in the name refers to the idea that a superoperator in a Hilbert space can be represented as a vector on a different Hilbert space which comprises of two copies of the original space tensor-producted together. It doesn't refer to a ""vector"" in the sense of a ""ket"". The difference was introduced in c62a8e9, which is the amalgamated commit encompassing all the discussion in #1098. `qutip.vector_to_operator` expects to receive an argument whose `dims` parameter is of the form `[operator_dims , [1]]`, where `operator_dims` is the dimensions of a regular operator (for example `[[2], [2]]` for a single qubit Hilbert space, or `[[2, 2], [2, 2]]` for an operator acting on a Hilbert space with two qubits in. The exception occurs because `vector_to_operator` attempts to access the two elements of the `operator_dims` array to discover the output shape. Since there is an insufficient number of lists for it to access, it just ends up reading the dimensions of the first two elements of the tensor product, and `np.prod` (used to calculate the output shape) doesn't complain when passed scalars. Notice that running the code with `nb_qubits = 1` will cause an `IndexError`, as there are insufficient tensor-product elements. The immediate solution for your code is to use `qutip.ket2dm`, which converts a ket into a density matrix. I think this is what you're actually trying to do. For a fix, there are two points:; 1. The fix is simply to test that the input dimensions are of the correct form, rather than assuming; this will allow us to provide a more descriptive error.; 2. Perhaps worth considering is moving the super-operator functionality in a sub-module `qutip.super`, and not importing all the functions into the main namespace. This might help reduce user confusion going forwards, especially since most people aren't using the superoperator formalism.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1204#issuecomment-600792011:1541,test,test,1541,https://qutip.org,https://github.com/qutip/qutip/issues/1204#issuecomment-600792011,1,['test'],['test']
Testability,"As a test, I've used this PR from the RTD build for [qinfer/python-qinfer](https://github.com/QInfer/python-qinfer), since the RTD virtualenv is by default rather restrictive. The modified setup.py works for that build process, which I think is a fairly good sign.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/489#issuecomment-224199565:5,test,test,5,https://qutip.org,https://github.com/qutip/qutip/pull/489#issuecomment-224199565,1,['test'],['test']
Testability,"As described in https://github.com/qutip/qutip/issues/723#issuecomment-318100070 I have tested this and it seems to fix #723, so I would suggest we merge this",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/731#issuecomment-318101980:88,test,tested,88,https://qutip.org,https://github.com/qutip/qutip/pull/731#issuecomment-318101980,1,['test'],['tested']
Testability,"As far as the ""known issues"" go, these are discussed in #484.; I don't think the issues I saw recently are the same as in that one.; ```; Intel MKL FATAL ERROR: Cannot load libmkl_avx.so or libmkl_def.so.; ```; I think this is just an MKL install problem.; It's difficult to test at the moment, as I don't seem to be able to create a conda env with mkl blas",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/872#issuecomment-394304854:275,test,test,275,https://qutip.org,https://github.com/qutip/qutip/issues/872#issuecomment-394304854,1,['test'],['test']
Testability,"As for the failing travis tests, don't use xrange since it is not python 3 compatible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/90#issuecomment-37786575:26,test,tests,26,https://qutip.org,https://github.com/qutip/qutip/pull/90#issuecomment-37786575,1,['test'],['tests']
Testability,"As it is quite a short (but efficient!) change, we can keep it both in qutip and in qutip-qip. Also, I remember this function is also used in the control module (also for testing I think). So we need it in qutip anyway. Eventually, I think it is best to keep these commonly used function in `qutip.operator` and import it to qutip-qip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1688#issuecomment-942198552:171,test,testing,171,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942198552,1,['test'],['testing']
Testability,"As long as we do some test runs without MPI, I think this is fine. Perhaps we could also document somewhere that `mpi` is needed -- maybe just by raising a nice exception if it needs to be imported but isn't available?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2319#issuecomment-1930820031:22,test,test,22,https://qutip.org,https://github.com/qutip/qutip/pull/2319#issuecomment-1930820031,1,['test'],['test']
Testability,As mentioned in #872 the MKL builds are currently installing with openblas numpy.; This implements the suggestion from; ContinuumIO/anaconda-issues#9519; Initial local tests look fine,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/876#issuecomment-394727727:168,test,tests,168,https://qutip.org,https://github.com/qutip/qutip/pull/876#issuecomment-394727727,1,['test'],['tests']
Testability,"As mentioned previous I have patched out the cython check and installs in **init** in the (windows, qutip-3.1.0) conda package that I built. I have put cython as a build requirement, but not a runtime requirement. I install in an environment without cython and then run tests:; 289 tests in 690s; 7 skip, 6 errors, 1 fail. Then I install cython and mingwpy and run tests again:; 320 tests 2371s; 7 skip, 10 errors, 1 fail. I think the time dependent string format tests fail. Not sure, and will not investigate further at the moment. Would only make if they also fail in GitHub version, for which I have not tested on Windows. At no point do the extensions in qutip/cy get built again. So I think it is not necessary to pyximport.install in the **init**.py; I think we should change the message to a warning, like we have for matplotlib, to say something like 'no Cython, string type time-dependent solvers will not run'. It seems to make sense to allow people to install and use parts of the library even if they can't get a C compiler working for them. I don't understand why some tests do not run without cython. For instance, no mcsolve tests run without cython installed. I can't see cython imported in the mcsolve file. I will look into this further.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/448#issuecomment-192570921:270,test,tests,270,https://qutip.org,https://github.com/qutip/qutip/issues/448#issuecomment-192570921,8,['test'],"['tested', 'tests']"
Testability,As there are comments on this I will merge now. ; I have tested extensively with the work I am doing on hsolve,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/446#issuecomment-192106154:57,test,tested,57,https://qutip.org,https://github.com/qutip/qutip/pull/446#issuecomment-192106154,1,['test'],['tested']
Testability,"As this was a simple bug fix and all tested passed, then merging now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/563#issuecomment-263523282:37,test,tested,37,https://qutip.org,https://github.com/qutip/qutip/pull/563#issuecomment-263523282,1,['test'],['tested']
Testability,"At least two tests have been observed to generate unrelated failures:; - `qutip.tests.test_subsys_apply`; - `qutip.tests.test_fidelity2`. I haven't seen any others recently (at least, not since resolving #425), but if we observe any, we should add them here so that we can be sure everything works for 3.2.0.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/430#issuecomment-184077054:13,test,tests,13,https://qutip.org,https://github.com/qutip/qutip/issues/430#issuecomment-184077054,3,['test'],['tests']
Testability,"Before:; <img width=""863"" alt=""Screen Shot 2022-11-03 at 4 19 25 PM"" src=""https://user-images.githubusercontent.com/113714002/199853312-2f6880df-09dc-43cc-9c0b-8e1daa15a49f.png"">. After:; <img width=""704"" alt=""Screen Shot 2022-11-03 at 4 17 55 PM"" src=""https://user-images.githubusercontent.com/113714002/199853348-0eb3e5b2-8f20-496f-96fe-d97d27860f93.png"">. Been playing around with the `$` placement but can't seem to get it right, it returns the output like the first picture. Help here is appreciated, it's very slow testing this having to recompile after small changes (noob here). Edit: <s>Also note I'm not quite getting the newline correct. Doesn't quite behave the way I would expect latex to behave.</s>. Edit 2: Was using a wrong version for the second picture, the correct one does respect the; <img width=""512"" alt=""Screen Shot 2022-11-03 at 4 49 01 PM"" src=""https://user-images.githubusercontent.com/113714002/199856352-825db071-fb7e-4567-b4db-c6d71b8a16df.png"">; newline; Also just read I should be using develop mode, so hopefully testing different things will be faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2017#issuecomment-1302788072:521,test,testing,521,https://qutip.org,https://github.com/qutip/qutip/pull/2017#issuecomment-1302788072,2,['test'],['testing']
Testability,Benchmarks:. http://nbviewer.ipython.org/gist/jrjohansson/b3212a496ec1651fca76,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/184#issuecomment-48688527:0,Benchmark,Benchmarks,0,https://qutip.org,https://github.com/qutip/qutip/pull/184#issuecomment-48688527,1,['Benchmark'],['Benchmarks']
Testability,Both scripts were tested on a fresh installation of 10.10 (no xcode or anything else). Both scripts installed fine and the new python and ipython versions are on the path and can be used immediately.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/279#issuecomment-65925409:18,test,tested,18,https://qutip.org,https://github.com/qutip/qutip/pull/279#issuecomment-65925409,1,['test'],['tested']
Testability,"Both this failure and the one before it are in unrelated tests. For instance, the most recent failure is in `qutip.tests.test_fidelity2`, which rather surprises me as I'd have thought that test case was quite stable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/428#issuecomment-183608615:57,test,tests,57,https://qutip.org,https://github.com/qutip/qutip/pull/428#issuecomment-183608615,3,['test'],"['test', 'tests']"
Testability,"Bumping an old topic with two major new considerations. Number one: Travis is [changing its pricing model for open source software](https://blog.travis-ci.com/2020-11-02-travis-ci-new-billing), and generally it seems like [it's going to become unfeasible for us](https://www.jeffgeerling.com/blog/2020/travis-cis-new-pricing-plan-threw-wrench-my-open-source-works). Over the past month or so, queue times on Linux builds have increased massively (from near-instant to up to 90 minutes), and the number of allowed concurrent builds has already limited the amount of testing we are able to do - we don't even have Windows tests because we couldn't fit them in. In around March 2021 we expect the old travis-ci.org that QuTiP is grandfathered onto to shut down completely, forcing us onto the new model on travis-ci.com. Number two: in November 2019, GitHub released their own CI, GitHub Actions. This is (as best as I can tell) completely free for open source, public repositories like QuTiP, and offers access to a large number of Linux, macOS and Windows containers. This completely free period of GitHub Actions might not last forever (you can imagine maybe they're just trying to drive adoption before increasing the cost), but especially with the new time pressure from Travis, this seems like the right choice for now. Our testing set up is fairly straightforward, so migrating to a new CI shouldn't be too difficult. I just wrote (#1429) a GitHub Actions workflow to build and distribute binary releases of QuTiP on Linux/Mac/Windows, and I'm pretty convinced by the power of their CI. It's got an awful lot of flexibility with a _lot_ of customisation so its initial learning curve is a little steep (or maybe I'm just not used to CI tools), but I'm impressed by what's available. I believe it comes with a degree of reusability as well; I think we can define a test as a single ""action"", and then reuse that in the PR-push workflow and the make-distribution workflow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/959#issuecomment-770455542:565,test,testing,565,https://qutip.org,https://github.com/qutip/qutip/issues/959#issuecomment-770455542,4,['test'],"['test', 'testing', 'tests']"
Testability,"Bumping this because I'm working on `test_metrics.py` and came across it. ## Attempting to isolate. With `cvxpy` and `cvxopt` from conda-forge, I can run all the `dnorm` tests, but as before (see #874, #880, #881) they fail too much of the time. By my rough tests, failure only occurs with any regularity when using `cvxpy` with operator inputs (not supers) of dimension 3 (not 2). I also find that using `dnorm(A, B)` with `A` and `B` drawn from `rand_unitary_haar` has a failure rate of 0.004(1), whereas drawing from `rand_unitary` instead has a failure rate about 3 times higher of 0.012(2). I'm sure if you have more (i.e. > 0) knowledge of the Haar measure than I do, that presumably gives you more information on what makes it likely for the optimisation to fail. Also, using `dnorm(A)` (i.e. taking `B` to be 0) produced no failures in 4000 tests of the same function. ## Testing strategy. Since each `dnorm` test is repeated 10 times and there's only one offending test, that's a current failure rate of about 4%. The offending test actually isn't even testing what it's supposed to test - it supposedly tests that special cases that are handled by QuTiP agree with the optimisations done by `cvxpy`, except that the offender isn't a handled special case. I'll remove that for now. I will also convert `dnorm` tests to quietly xfail if the optimisation fails, but cause a suite failure if they cause a proper `AssertionError`. ## Future. Since we have a new major version in the future, we do have the option to issue a `FutureWarning` and remove `dnorm` if we want to do so, but if so, we should get the warning out as soon as possible. It's probably worth mentioning that by-and-large, it seems like `dnorm` does actually work in most cases. > This has been the final straw. We have tried to keep dnorm supported. - @ajgpitch . Suspect Alex has some thoughts on this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/874#issuecomment-634292336:170,test,tests,170,https://qutip.org,https://github.com/qutip/qutip/issues/874#issuecomment-634292336,12,"['Assert', 'Test', 'test']","['AssertionError', 'Testing', 'test', 'testing', 'tests']"
Testability,"But again, the debug flag is not set at runtime so the logger will always be WARN using the above suggestions. It would have to be set inside of a function that is called to properly check the debug flag.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/261#issuecomment-64150730:55,log,logger,55,https://qutip.org,https://github.com/qutip/qutip/pull/261#issuecomment-64150730,1,['log'],['logger']
Testability,"But also, yeah, this is exactly the change I meant when I wrote that comment in the other issue. Unless something's broken in the interrim, it definitely works because I tested the swap fairly heavily when I wrote it, which is also why there's some particularly weird templated code in `core/data/src/matmul_csr_vector.{hpp,cpp}`: https://github.com/qutip/qutip/blob/fbb7fad5bc205910228db622d90601c82db45e4b/qutip/core/data/src/matmul_csr_vector.cpp#L114-L148",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1727#issuecomment-979886946:170,test,tested,170,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-979886946,1,['test'],['tested']
Testability,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:842,test,tests,842,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466,1,['test'],['tests']
Testability,"Can confirm that on running qutip.testing.run( ) locally, it prints a one line description of tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-574215718:34,test,testing,34,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-574215718,2,['test'],"['testing', 'tests']"
Testability,"Can you fully show your build process, and did this work with a previous version of QuTiP? It builds fine for me from pip sdist on all major platforms with a simple; ```; pip install qutip; ```; and the sdist of 4.5.2 seems to be missing the same file. Officially we don't support building with OpenMP from pip sdist (only git), but to be fair, it should have worked. In the interests of better semantics, can you change the new line in `MANIFEST.in` to; ```; graft qutip/**/src; ```; Technically there's only the one file that doesn't get tagged in (I hope), but logically the principle is that anything in a `src` directory should be distributed in the `sdist`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1449#issuecomment-782608343:564,log,logically,564,https://qutip.org,https://github.com/qutip/qutip/pull/1449#issuecomment-782608343,1,['log'],['logically']
Testability,"Can you use `Qobj.expm()` with the identity `n ** x == (exp(log(n)) ** x == exp(x * log(n))`, which is true for any positive real `n`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2370#issuecomment-2027673583:60,log,log,60,https://qutip.org,https://github.com/qutip/qutip/issues/2370#issuecomment-2027673583,2,['log'],['log']
Testability,"Certainly the `zheevr` segfaults on my machine with scipy < 1.5 and _doesn't_ with scipy 1.5, but that's hardly a perfect test - segfaults are pretty intermittent at the best of times. It's easy to test that all eigenvectors are mathematically actually eigenvectors with the correct eigenvalue, but the harder bit is ensuring that we've actually found _all_ the eigenvectors, especially when we're dealing with a lot of eigenvalues that look like `(0, 0, 0, 1e-17, -1.1e-17, ...)`. Degeneracy is a more annoying to check that we've got the full spanning set of the degenerate basis, and it's even harder when we've got eigenvalues like `1e-17` which is almost certainly actually degenerate with 0, but hasn't been detected as such. This is roughly what I was trying to get at with method 2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1299#issuecomment-649525934:122,test,test,122,https://qutip.org,https://github.com/qutip/qutip/issues/1299#issuecomment-649525934,2,['test'],['test']
Testability,"Changed the notation for `type=` comparisons to `issuper`, as suggested. All unit tests pass locally, so I suspect that the Travis build should work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-57070290:82,test,tests,82,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-57070290,1,['test'],['tests']
Testability,"Changes to the test:; ```; case_1= repr(QobjEvo([qeye(3), lambda t: t])); expected_repr_1= 'QobjEvo: dims=[[3], [3]], shape=(3, 3), type=oper, superrep=None, isconstant=False, num_elements=1'; assert case_1 == expected_repr_1. case_2= repr(QobjEvo(qeye(2))); expected_repr_2= 'QobjEvo: dims=[[2], [2]], shape=(2, 2), type=oper, superrep=None, isconstant=True, num_elements=1'; assert case_2 == expected_repr_2; ; case_3= repr(QobjEvo(basis(5, 2))); expected_repr_3= 'QobjEvo: dims=[[5], [1]], shape=(5, 1), type=ket, superrep=None, isconstant=True, num_elements=1'; assert case_3 == expected_repr_3. X = sigmax(); S = spre(X) * spost(X.dag()); case_4= repr(QobjEvo(to_choi(S))); expected_repr_4= 'QobjEvo: dims=[[[2], [2]], [[2], [2]]], shape=(4, 4), type=super, superrep=choi, isconstant=True, num_elements=1'; assert case_4 == expected_repr_4. case_5= repr(QobjEvo([[qeye(4), lambda t: t], [qeye(4), lambda t: t]], compress=False)); expected_repr_5= 'QobjEvo: dims=[[4], [4]], shape=(4, 4), type=oper, superrep=None, isconstant=False, num_elements=2'; assert case_5 == expected_repr_5; ```. Changes to the `cython` code have also been undone. @Ericgig @AGaliciaMartinez Kindly let me know if there are any more changes to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308:15,test,test,15,https://qutip.org,https://github.com/qutip/qutip/pull/2111#issuecomment-1472176308,6,"['assert', 'test']","['assert', 'test']"
Testability,"Cleaned up some minor things in `tests/test_meoslve.py`, like removing trailing white spaces etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/404#issuecomment-165446733:33,test,tests,33,https://qutip.org,https://github.com/qutip/qutip/pull/404#issuecomment-165446733,1,['test'],['tests']
Testability,"Come to think of it, neither `eseries` nor `essolve` have significant tests, and a quick `grep` through shows that `eseries` is completely untested, and `essolve` has only one very basic test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1262#issuecomment-628261967:70,test,tests,70,https://qutip.org,https://github.com/qutip/qutip/issues/1262#issuecomment-628261967,2,['test'],"['test', 'tests']"
Testability,"Commit #bea29a1 breaks some tests since it refactors some attribute names to follow PEP8 snake_case standard (i.e., qubit.qit.circuit.N ->qubit.qit.circuit.n_qubits )",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603441970:28,test,tests,28,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603441970,1,['test'],['tests']
Testability,"Computed error 1.08705544e-07, tol 1e-7... The initial ket in `rand_ket(2)`. I believe that with `nosetest`, the random seed was kept between test file. One of our early test would fix the seed and all following tests would be deterministic. With `pytest` the seed is probably reset at each file. We could loosen the tolerance. Ideally we would get the stats on the error first. Maybe `pytest` has a support for test that pass 99% of the time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-625283606:142,test,test,142,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-625283606,4,['test'],"['test', 'tests']"
Testability,"Concerning the failed test: I suspect this is because the test temporarily uses almost 1Gb of memory.; Can you confirm this as a potential issue? In that case, I could change the test to reduce memory usage.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-561549347:22,test,test,22,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-561549347,3,['test'],['test']
Testability,Confirming that the only tests that are failing currently are the `brmesolve` related tests. The previous commit fixed one failure in the coefficient tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793:25,test,tests,25,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793,3,['test'],['tests']
Testability,"Consider what you're doing from a statistical sense here. If everything works correctly, then you're effectively trying a two-tail hypothesis test that your test binomial distribution has a probability of 0.25, given you made `n` observations of it. The analytic success rate of your test is then; ```python; import scipy.stats; def success(n, p, tol):; dist = scipy.stats.binom(n, p); return dist.cdf(n * (p+tol)) - dist.cdf(n * (p-tol)); ```; where `success(4096, 0.25, 0.02)` is 99.67%. Since there are 5 independent runs on Travis, that's equivalent to a failure rate of 1.6% on every single CI run, which is several orders of magnitude too high. It's probably just luck that it was Python 3.8 on both occasions - it's a one-in-five chance that in two failing CI runs, it was the same setup both times. You have to consider what is most appropriate to fix the test, and what you can reasonably test in ~1 second of runtime. You don't want to increase the tolerance too much, because then you can get a lot of false positives even if something is broken. If you can bump the number of runs up to 100,000 and set the tolerance at 0.01, you'll have a per-test failure rate of ~3e-13, which is more like what we'd want. If you keep it at 4096, the tolerance should be more like 0.05 (which is pretty big tbh).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640043626:142,test,test,142,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640043626,6,['test'],['test']
Testability,"Copying here the message of the failed build, as I cannot find the message of the successful one in the build history (since it refers to the same PR, it looks like it was not kept). . ```; QuTiP Version: 4.4.0.dev0+109c09d; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.7; Matplotlib Version: None; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/travis/miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.4.0.dev0+109c09d-py3.7-macosx-10.7-x86_64.egg/qutip; ```; from https://travis-ci.org/qutip/qutip/builds/521534881",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/961#issuecomment-484740433:510,test,test-environment,510,https://qutip.org,https://github.com/qutip/qutip/pull/961#issuecomment-484740433,1,['test'],['test-environment']
Testability,Could add a test for `molmer_sorensen` and then we can merge I think.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1028#issuecomment-505095685:12,test,test,12,https://qutip.org,https://github.com/qutip/qutip/pull/1028#issuecomment-505095685,1,['test'],['test']
Testability,Could you fix the import in `test_entropy.py`. It would be better in we don't raise warning in our tests. Otherwise it seems good.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1074#issuecomment-572220880:99,test,tests,99,https://qutip.org,https://github.com/qutip/qutip/pull/1074#issuecomment-572220880,1,['test'],['tests']
Testability,"Could you make 2 changes:; `verbosity=1`, it looks a lot cleaner.; The tests that ""XFAIL"" use `yield` and are skipped as it is not supported by pytest. Could you rewrite them without it. (4 in `test_qobj`, not sure if there are more.) I will be looking at the failing tests in more detail next week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-570710549:71,test,tests,71,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-570710549,2,['test'],['tests']
Testability,"Could you post a list of the failing tests. If the tensor is right, then the eigensolver seems to work fine. So the ODE solver could be the issue, but in this case, `mesolve` tests should also fail.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965#issuecomment-1203966750:37,test,tests,37,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203966750,2,['test'],['tests']
Testability,Could you send me the code you are using for the test.; I find some of the timing strange.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1024#issuecomment-503667653:49,test,test,49,https://qutip.org,https://github.com/qutip/qutip/pull/1024#issuecomment-503667653,1,['test'],['test']
Testability,"Could you send the equation for the case where `time_sense` is not `0`. When I try it with a period of `1.0` it give extra term with very low frequencies:; ```; dict_keys([0.0, 4.304872064735899e-09, 1.0157988986038049e-08, 1.1379302858450767e-08, -2.9820390185456766e-09, -4.304872064735899e-09, 5.8531169213021495e-09, 7.074430793714867e-09, -7.286911083281576e-09, -1.0157988986038049e-08, -5.8531169213021495e-09, 1.2213138724127176e-09, -1.3140028004583725e-08, -1.1379302858450767e-08, -7.074430793714867e-09, -1.2213138724127176e-09, -1.4361341876996443e-08, 2.9820390185456766e-09, 7.286911083281576e-09, 1.3140028004583725e-08, 1.4361341876996443e-08]); ```. Is it normal? You did not include any test using `time_sense`. ​",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1631197945:706,test,test,706,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1631197945,1,['test'],['test']
Testability,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:91,test,tests,91,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847,2,['test'],"['testing', 'tests']"
Testability,"Cython error are quite vague, but there should not be any cython error here.; It could be errors inside a cython function. Could you send the log if it persist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346:142,log,log,142,https://qutip.org,https://github.com/qutip/qutip/pull/2351#issuecomment-2004022346,1,['log'],['log']
Testability,"Dear @abhisekupadhyaya, ; - test run fine; - could verify the functionality; https://gist.github.com/nathanshammah/6ad41ed5c88aec5f37e10eff16866d37; ![add-qcircuit](https://user-images.githubusercontent.com/14573436/57938271-cf84e780-7902-11e9-989a-6eb253e4f4b8.png); Congratulations for this nice feature and thank you for your contribution. Merging",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/979#issuecomment-493494455:28,test,test,28,https://qutip.org,https://github.com/qutip/qutip/pull/979#issuecomment-493494455,1,['test'],['test']
Testability,"Dear Alex, this can be reviwed by you. I implemented your single line; comments (I thought pep8 recommends wrapping top level functions with two; newlines but I understand that it's just for new classes). In addition, I; changed some bits and added some more tests to make the test coverage 92%. On Tue 6 Mar, 2018, 7:38 PM Alexander Pitchford, <notifications@github.com>; wrote:. > Are we ready for me to check this again?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/753#issuecomment-370738864>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AGpUBASWPWSKscWoJuJ4YyVn3xeC9jlrks5tbmcfgaJpZM4PgbIo>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-370741295:259,test,tests,259,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-370741295,2,['test'],"['test', 'tests']"
Testability,"Dear Jakelishman. Thank you for your answer. I have changed omega to 1 and still they do not give the same results. ```; import qutip; import numpy as np. fast_ts = np.linspace(0, 1, 1001); omegalist = 1; fast_xs = 2.9e3*np.pi * np.cos(2*np.pi * omegalist * fast_ts); bad_interpolation_xs = np.array([fast_xs[0], fast_xs[-1]]); Hanalytic = [[qutip.sigmax(),'2.9e3*pi*cos(2*pi*t)']] # New line; Hanalyticevo = qutip.QobjEvo([[qutip.sigmax(),'2.9e3*pi*cos(2*pi*t)']],tlist=fast_ts) # New line; H = qutip.QobjEvo([[qutip.sigmax(), fast_xs]], tlist=fast_ts); H_bad = [[qutip.sigmax(), bad_interpolation_xs]]; rho = qutip.basis(2, 0).proj(); times = np.array([0., 1]); e_ops = [qutip.sigmay()]; options = qutip.Options(nsteps=10_000_000, atol=1e-14, rtol=1e-12). two_times = qutip.mesolve(H, rho, times, e_ops=e_ops, options=options); many_times = qutip.mesolve(H, rho, fast_ts, e_ops=e_ops, options=options); bad_times = qutip.mesolve(H_bad, rho, times, e_ops=e_ops, options=options); analytics = qutip.mesolve(Hanalytic, rho, fast_ts, e_ops=e_ops, options=options) # New line; analyticsevo = qutip.mesolve(Hanalyticevo, rho, times, e_ops=e_ops, options=options) # New line; assert len(two_times.expect[0]) == 2; assert len(many_times.expect[0]) == 1001. print(two_times.expect[0][-1]) # 3.461676142752336e-05; print(many_times.expect[0][-1]) # 3.4618129999061035e-05; print(bad_times.expect[0][-1]) # -4.546608598637869e-08; print(analytics.expect[0][-1]) # 1.5660042880505376e-09; print(analyticsevo.expect[0][-1]) # -1.0166655253773804e-08",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-819549136:1171,assert,assert,1171,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-819549136,2,['assert'],['assert']
Testability,"Dear qutip admin,. If I wrote the Hamiltonian in terms of analytic function (Hanalytic and Hanayticevo as shown below), I got different answers from using the discretized Hamiltonian obtained by providing the list of Hamiltonian values at discrete times (the variable H) as used previously. May I know how to rectify this problem? Below is the code. ```; import qutip; import numpy as np. fast_ts = np.linspace(0, 1, 1001); omegalist = 2.91e2*fast_ts ; fast_xs = 2.9e3*np.pi * np.cos(2*np.pi * omegalist * fast_ts); bad_interpolation_xs = np.array([fast_xs[0], fast_xs[-1]]); Hanalytic = [[qutip.sigmax(),'2.9e3*pi*cos(2*pi*2.91e2*t**2)']] # New line; Hanalyticevo = qutip.QobjEvo([[qutip.sigmax(),'2.9e3*pi*cos(2*pi*2.91e2*t**2)']],tlist=fast_ts) # New line; H = qutip.QobjEvo([[qutip.sigmax(), fast_xs]], tlist=fast_ts); H_bad = [[qutip.sigmax(), bad_interpolation_xs]]; rho = qutip.basis(2, 0).proj(); times = np.array([0., 1]); e_ops = [qutip.sigmay()]; options = qutip.Options(nsteps=10_000_000, atol=1e-14, rtol=1e-12). two_times = qutip.mesolve(H, rho, times, e_ops=e_ops, options=options); many_times = qutip.mesolve(H, rho, fast_ts, e_ops=e_ops, options=options); bad_times = qutip.mesolve(H_bad, rho, times, e_ops=e_ops, options=options); analytics = qutip.mesolve(Hanalytic, rho, fast_ts, e_ops=e_ops, options=options) # New line; analyticsevo = qutip.mesolve(Hanalyticevo, rho, times, e_ops=e_ops, options=options) # New line; assert len(two_times.expect[0]) == 2; assert len(many_times.expect[0]) == 1001. print(two_times.expect[0][-1]) # -0.59736575; print(many_times.expect[0][-1]) # -0.59736575; print(bad_times.expect[0][-1]) # -4.5466086e-08; print(analytics.expect[0][-1]) # 0.00022501347976357222; print(analyticsevo.expect[0][-1]) # 0.0002250044242251665. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-819524720:1439,assert,assert,1439,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-819524720,2,['assert'],['assert']
Testability,"Denis, Good to hear from you again. It looks like a solid addition! Great to have finally squashed this issue. I ran your code through our unit tests in place of the iterative method and it passed. We can just add additional unit tests similar to the ones we have now for the iterative method.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/461#issuecomment-206692075:144,test,tests,144,https://qutip.org,https://github.com/qutip/qutip/pull/461#issuecomment-206692075,2,['test'],['tests']
Testability,"Did you install using --with-mcf90 ?. > On Nov 6, 2015, at 14:04, src10 notifications@github.com wrote:; > ; > Hello!!!; > ; > I installed python using anaconda on my mac and then installed qutip.; > ; > When I run the installation test I always get; > ; > Fortran mcsolver: False; > ; > How can I install the Fortran compiler needed.; > ; > Thanks; > ; > Regards!!; > ; > Sebastian; > ; > —; > Reply to this email directly or view it on GitHub.; > ; > Untracked with Trackbuster",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/391#issuecomment-154592986:232,test,test,232,https://qutip.org,https://github.com/qutip/qutip/issues/391#issuecomment-154592986,1,['test'],['test']
Testability,"Do worry about the failing python2.7 tests, it's a common error on all recent checks. Your pull should not affect them.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-428349067:37,test,tests,37,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-428349067,1,['test'],['tests']
Testability,"Do you get the same behaviour with QuTiP 4.5.0 in the same environment? The offending parts of `qutip/__init__.py` have been there since then, so it shouldn't be new in 4.5.2 at least. I can't reproduce the error unless `pyximport.install()` has already been run before QuTiP is imported (e.g. if I do `import pyximport; pyximport.install(); import qutip` or `importlib.reload(qutip)`). We have `qutip/__init__.py` organised so that we don't enable `pyximport` until after we've done the test for `qutip.cy.openmp.parfuncs`: first we do. https://github.com/qutip/qutip/blob/8e181cc44ceefc14ad0e4f4bcf78e1c8fcd2b291/qutip/__init__.py#L100-L105. and only after that do we. https://github.com/qutip/qutip/blob/8e181cc44ceefc14ad0e4f4bcf78e1c8fcd2b291/qutip/__init__.py#L124-L126. In your error it's trying to build `qutip.cy.openmp.parfuncs`, and the only line that ever attempts to import that (in Python space) is line 101 above in `__init__`. It can only attempt to Cythonize files if `pyximport` is activated, but `qutip` doesn't activate that til a few lines later. It's certainly still a bug that this error appears if you've manually activated `pyximport` before (which would definitely cause it), but I'm struggling to find any other reason that the error could appear. We're looking to simplify the handling of OpenMP in a later version, and this buggy check is certainly a good reason to expedite that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1334#issuecomment-670167290:488,test,test,488,https://qutip.org,https://github.com/qutip/qutip/issues/1334#issuecomment-670167290,1,['test'],['test']
Testability,Do you mean the issue with not being able to find `vcvarsall.bat`? mentioned in:; https://github.com/cython/cython/wiki/CythonExtensionsOnWindows. In my test project I used the workaround they suggest:; ```; try:; from setuptools import setup; from setuptools import Extension; except ImportError:; from distutils.core import setup; from distutils.extension import Extension; ```; And this seems to work. Is it more complicated than that for us?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/648#issuecomment-280616008:153,test,test,153,https://qutip.org,https://github.com/qutip/qutip/pull/648#issuecomment-280616008,1,['test'],['test']
Testability,Do you want me to restart the Travis tests? Or should we look into these random failing tests a bit before? Maybe @Ericgig knows something about it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1221#issuecomment-607079474:37,test,tests,37,https://qutip.org,https://github.com/qutip/qutip/pull/1221#issuecomment-607079474,2,['test'],['tests']
Testability,"Don't worry about the tests - progress on merging the refactor is slow (though if you want to review #1249 it'll help!). Besides, these tests would probably go in `test_qubitcircuit.py` which I haven't touched yet. Add the tests here, and I'll rebase #1251 onto `master` after this is merged if it's necessary to add them to the new style. Hopefully this will be the last time!. About the merge oddness: it comes about because this PR is built on a false version of the upstream (our) `master`. As long as you apply this merge as a squash, it will actually be ok and the history will be clean. Don't apply the merge as a history-preserving merge (i.e. a regular one), because it will make the commit history confusing (and defeats the purpose of having merged #1242 as a squash). ## Unnecessary detail. The exact reason is that this commit is build on top of #1242, but this is inconsistent with the upstream `master`; because #1242 was merged as a squash, `qutip/master` and `Canoming/master` diverged at fd13ae0 (i.e. before #1242), so `git` sees commits ea1c129 to b4f75cf as ""new"" (the first three commits of this PR). However, when those commits are taken together, they make the same changes as commit 4102b99 (the one which merged #1242) in `qutip/master`. The Github ""Files changed"" dialog is a pretty-printed version of the `git` command `git diff qutip/master...Canoming/master`, which means ""show all changes on either branch since `qutip/master` and `Canoming/master` diverged"". Because they diverged before #1242 was merged, it includes those changes. The merge completes without conflict, however, because `git` is clever and recognises that the changes introduced in the two branches `qutip/master` and `Canoming/master` are identical, even though the commits are different. As a consequence, however, merging this PR without squashing it would cause commits ea1c129 to b4f75cf to suddenly appear in our commit history, which we don't want. ### If Canoming wanted to fix this (not neces",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269:22,test,tests,22,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269,3,['test'],['tests']
Testability,"Done. If the tests pass, I hope we can merge this. Let me know if any more changes are necessary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-371002717:13,test,tests,13,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-371002717,1,['test'],['tests']
Testability,"Due to my exam collision, I was a little bit late. I apologize for that. Currently, I am working on a test case to check whether the negativity of a maximally entangled two-qubit state is close to 0.5, and I'm also verifying the operator, ket, and bra inputs. Once it's done, I will make a Seprate PR. Thank you for your help and support @nwlambert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2371#issuecomment-2041904800:102,test,test,102,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2041904800,1,['test'],['test']
Testability,"E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_steadystate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_me.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_se.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_subsys_apply.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:24811,test,tests,24811,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_qobjevo.py _________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ___________________ ERROR collecting qutip/tests/test_qpt.py ___________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _____________ ERROR collecting qutip/tests/test_qubit_evolution.py _____________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_qubitcircuit.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:17715,test,tests,17715,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,"E AttributeError: module 'qutip' has no attribute 'settings'; _________________ ERROR collecting qutip/tests/test_states.py __________________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; _______________ ERROR collecting qutip/tests/test_steadystate.py _______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_me.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/test_stochastic_se.py ______________; qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined. During handling of the above exception, another exception occurred:; /miniconda3/lib/python3.7/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ______________ ERROR collecting qutip/tests/te",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-514146533:24338,test,tests,24338,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-514146533,1,['test'],['tests']
Testability,ERROR ../tests/test_expect.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_fastsparse.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_fileio.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_floquet.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_gates.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_graph.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_heom_solver.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mcsolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_metrics.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mkl.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_noise.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_openmp.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - Att,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:52789,test,tests,52789,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,ERROR ../tests/test_interpolate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_lattice.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mcsolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_metrics.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_mkl.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_noise.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_openmp.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - Att,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:53363,test,tests,53363,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,ERROR ../tests/test_mkl.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_noise.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_openmp.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py -,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:53773,test,tests,53773,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,ERROR ../tests/test_noise.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_openmp.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sparse.py - A,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:53855,test,tests,53855,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,ERROR ../tests/test_operators.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_optpulseprocessor.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_parallel.py - AttributeError: module 'qutip' has no attri...; ERROR ../tests/test_partial_transpose.py - AttributeError: module 'qutip' has...; ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sparse.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_spinchain.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_spmath.py - ,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:54019,test,tests,54019,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,ERROR ../tests/test_piqs.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_processor.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_propagator.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_ptrace.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_pulse.py - AttributeError: module 'qutip' has no attribut...; ERROR ../tests/test_qft.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qobj.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_qobjevo.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_qpt.py - AttributeError: module 'qutip' has no attribute ...; ERROR ../tests/test_qubit_evolution.py - AttributeError: module 'qutip' has n...; ERROR ../tests/test_qubitcircuit.py - AttributeError: module 'qutip' has no a...; ERROR ../tests/test_qubits.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rand.py - AttributeError: module 'qutip' has no attribute...; ERROR ../tests/test_random.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_rhs_reuse.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_scattering.py - AttributeError: module 'qutip' has no att...; ERROR ../tests/test_sesolve.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sp_eigs.py - AttributeError: module 'qutip' has no attrib...; ERROR ../tests/test_sparse.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_spinchain.py - AttributeError: module 'qutip' has no attr...; ERROR ../tests/test_spmath.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_states.py - AttributeError: module 'qutip' has no attribu...; ERROR ../tests/test_steadystate.py - AttributeError: module 'qutip' has no at...; ERROR ../tests/test_stochastic_me.py - AttributeError: module 'qutip' has no ...; ERROR ../tests/test_stochastic_se,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:54347,test,tests,54347,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['tests']
Testability,"Every `Qobj` created by qutip have `dims[0]` and `dims[1]` being list. `dims=[2, 2]` is an error that we should catch. The main issue is that there is no clear documentation or tests that clearly says what is a valid dims format. . There are some strange dimension that are produced by our function that would raise an error with `np.stack` like; `tensor(operator_to_vector(oper), oper)` but I don't think we should accept these kind of `Qobj` in the first place, so I am fine failing there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366:177,test,tests,177,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366,1,['test'],['tests']
Testability,"Everyone: (@ajgpitch, @BoxiLi, @Ericgig, @nathanshammah). Apologies for bumping this again. It would be good to get a strategy in place to handle a review for this. Would it be easier if I close this PR and then make a whole series of new PRs with (say) 5 files in at a time?. I'm particularly keen to get the `test_gates.py` refactor merged in, because there's seemingly quite a lot of movement in the `qip` module. If I do split the PR, then I'll rebase onto `master` so that the new tests added in #1224 are included without a merge resolution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-609702252:486,test,tests,486,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-609702252,1,['test'],['tests']
Testability,"Excellent, thank you! I'll wait and see what happens with the travis tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/85#issuecomment-36420410:69,test,tests,69,https://qutip.org,https://github.com/qutip/qutip/pull/85#issuecomment-36420410,1,['test'],['tests']
Testability,"Failing windows tests are related to mkl, not this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2526#issuecomment-2334653751:16,test,tests,16,https://qutip.org,https://github.com/qutip/qutip/pull/2526#issuecomment-2334653751,1,['test'],['tests']
Testability,"False test failure again - we really have too many tests which fail probabilistically! This particular one should have been smoothed out by #1250, since the current test is rather convoluted and there's several imprecise floating-point literals in use.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1264#issuecomment-628910011:6,test,test,6,https://qutip.org,https://github.com/qutip/qutip/pull/1264#issuecomment-628910011,3,['test'],"['test', 'tests']"
Testability,"False; E AttributeError: module 'qutip' has no attribute 'settings'; ____________________ ERROR collecting tests/test_wigner.py _____________________; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:46: in <module>; __IPYTHON__; E NameError: name '__IPYTHON__' is not defined; During handling of the above exception, another exception occurred:; ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/py/_path/local.py:701: in pyimport; __import__(modname); ../../../../miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py:49: in <module>; qutip.settings.ipython = False; E AttributeError: module 'qutip' has no attribute 'settings'; ---------- coverage: platform linux, python 3.6.10-final-0 -----------; Name Stmts Miss Cover; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/__init__.py 150 97 35%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/__init__.py 3 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/_mkl/utilities.py 39 16 59%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/__init__.py 1 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/openmp/__init__.py 0 0 100%; /home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.5.1.dev1+0ffec37-py3.6-linux-x86_64.egg/qutip/cy/pyxbuilder.py 18 ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997:48991,test,test-environment,48991,https://qutip.org,https://github.com/qutip/qutip/pull/1232#issuecomment-619398997,1,['test'],['test-environment']
Testability,"Finally I settled on 5 tests sets: 3 linux and 2 MacOS. ; The test on python 3.6 use no-cython and openblas.; mkl and openmp run together on python 3.7 and python 3.8 use conda's default.; On Mac, tests use openblas, no openmp and cython, repeated for python 3.7 and 3.8.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1214#issuecomment-610534948:23,test,tests,23,https://qutip.org,https://github.com/qutip/qutip/pull/1214#issuecomment-610534948,3,['test'],"['test', 'tests']"
Testability,"First of all I'm glad you could get it to run under OSX. Which OpenCL environment are you using?; - Is the failure of `test_mcsolve_cl_time_dep_h` reproducible?; - You can probably ignore the compiler warning. I assume it is related to the pragma statement. Some OpenCL implementations refuse to work without it, others give you a warning that it is unnecessary. Maybe we can omit the statement based on the platform version and hide some warning, but that would require more testing (on different platforms). At the moment there is a lot of debug information to ease testing.; - The AttributeError you get is something I have not encountered yet. If you do consider merging this branch, it is a good idea to get more people involved in testing. The code has not been reviewed and probably contains some bugs. The questions you raised concerning the maintainability are all valid. On top of that setting up OpenCL is somewhat troublesome, which makes `mcsolve_cl` a kind of experimental feature. Ultimately it is up to the maintainers of qutip to decide whether such a feature should be included. The advantage `mcsolve_cl` has over `mcsolve_f90` is that it supports some time-dependence and introduces no build dependencies. If, for some reason `mcsolve_cl` does not work, the user can always fall back to `mcsolve`. By the way, is it wise to rebase this branch all the time or only when necessary?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-260134503:476,test,testing,476,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-260134503,3,['test'],['testing']
Testability,"Fixed some causes of travis tests not succeeding. In particular e303b0e fixes use of `round` in the function `_td_wrap_array_str` in rhs_generate.py. This function uses `round` to get an integer number that is then passed as an array index. Since `round` returns a float, this causes the deprecation warning ""DeprecationWarning: using a non-integer number instead of an integer will result in an error in the future"". I therefore wrapped the call to `round` with a call to `int`. The travis tests now pass succesfully for this pull request.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/404#issuecomment-162598230:28,test,tests,28,https://qutip.org,https://github.com/qutip/qutip/pull/404#issuecomment-162598230,2,['test'],['tests']
Testability,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:127,test,test,127,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360,2,['test'],"['test', 'tested']"
Testability,"For large matrices (`dim > ~500`), the dense matrix dot product is still a pretty large cost, but you're still saving a fair amount. That said, at that kind of dimension, the analytical formula may do you well enough. If you want derivatives wrt alpha, you should be able to get analytic ones from my method - there's no ""black box"" numerical work that goes on in `__call__`, everything is just matrix multiplication. Given that it appears non-linearly in a possibly large multiplication, though, and I would imagine the derivatives are pretty smooth, you may well just be faster just numerically approximating it with finite differences (I don't know anything about autodifferentiation). If you're so inclined, you can sacrifice some speed for higher accuracy in the eigenvector calculations, as we can find the eigenvalues semi-analytically. There are a few places in numpy and scipy that can find the roots of the Hermite polynomials for you (i.e. get the eigenvalues), which will be found exactly wrt double precision (I believe). You can then call out to the LAPACK routine `dstein` to get the eigenvectors from the eigenvalues. `dstein` is slower than `dstemr`/`dsteqr` (which is what scipy uses, I think), but it allows us to supply the eigenvalues, removing some numerical error. I didn't test that very thoroughly though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293#issuecomment-646100632:1297,test,test,1297,https://qutip.org,https://github.com/qutip/qutip/issues/1293#issuecomment-646100632,1,['test'],['test']
Testability,"For point 2: adding marks right now will cause conflicts, but if #1181 gets merged then it'll be much simpler. The main issue is that a lot of the testing structure has changed for tests up to `test_mcsolve.py` alphabetically, and so in general the tests are just not the same. The principle is pretty straightforwards - just like #1181 introduces a `requires_cython` mark, we would add `uses_cython`, `uses_mkl` and `uses_openmp` marks. These would be even simpler to add than `requires_cython` because unlike it, they don't require any test-generation logic at all. The change would simply be to add them to `pytest.ini`, mark the requisite functions and then change the pytest invocation of the specialised test to `pytest -m ""uses_cython""` or whatever. As far as I'm aware, the only parts of their codebase which modify their behaviour based on whether `Cython` is available is `QobjEvo`. The other parts (like `brmesolve`) just don't work if Cython isn't there. The MKL tests would become very short; by my reckoning, MKL is only used by `steadystate` and `countstat`. OpenMP is much more pervasive, as `sesolve`, `mesolve` and `brmesolve` all use it, and parts which depend on those are generally the slowest tests. The short tests could just become `pytest -m ""not slow""`? That's not super speedy, but it takes about half the time, maybe. If you want more, then a good starting point is `pytest --durations=0` which will tell us which tests are the slowest (perhaps that was what you already did when marking the slow ones?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604011776:147,test,testing,147,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604011776,10,"['log', 'test']","['logic', 'test', 'test-generation', 'testing', 'tests']"
Testability,"For the record, the combination of conda and Python 3.7 (instead of 3.8) works:; ~~~; = 629 passed, 11 skipped, 61 deselected, 2 xfailed, 906 warnings in 590.30s (0:09:50) =; ~~~; If mcsolve uses multiprocessing internally, it's possible the hanging test is related to the changes in Python 3.8 to use ""spawn"" instead of ""fork"" for multiprocessing on macOS (see also https://github.com/qutip/qutip-notebooks/issues/100). For the pip installation, the segfault occurs with both Python 3.7 and Python 3.8",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596676557:250,test,test,250,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596676557,1,['test'],['test']
Testability,For the tests I added I followed the naming convention already used in `tests/test_mesolve.py`. I guess we should try to change the naming convention in all the test modules then. Probably better to do this in another pull request though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/405#issuecomment-165445058:8,test,tests,8,https://qutip.org,https://github.com/qutip/qutip/pull/405#issuecomment-165445058,3,['test'],"['test', 'tests']"
Testability,For want of another idea I restarted the tests,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/428#issuecomment-184068338:41,test,tests,41,https://qutip.org,https://github.com/qutip/qutip/pull/428#issuecomment-184068338,1,['test'],['tests']
Testability,Fortran module is not tested in Travis so i'm merging this before travis tests finish.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/197#issuecomment-49156618:22,test,tested,22,https://qutip.org,https://github.com/qutip/qutip/pull/197#issuecomment-49156618,2,['test'],"['tested', 'tests']"
Testability,"From my perspective this is now ready to merge. ; fhenneke has fixed a bug in the gradient and a typo in a class name.; It seems like the last commit overwrote the previous one, and so some of the comments here have disappeared, however the queries to the code have been addressed.; I will look to add some unit tests (including the grad_check) over the Easter holiday, i.e. over the next few weeks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/325#issuecomment-82987952:312,test,tests,312,https://qutip.org,https://github.com/qutip/qutip/pull/325#issuecomment-82987952,1,['test'],['tests']
Testability,"From what I understand, on intel, brmesolve seems to work correctly, but not on M1.; This look like an issue with the eigensolver. Could you run the test suite to see if it fails the eigen and bloch redfield related tests: `pytest path_to_qutip/qutip/tests`. (Tests can take >30min). Also could you look at the tensor directly:; ```; R, H_eigenvector = bloch_redfield_tensor(sigmax(), a_ops=[[sigmax(), psd]]); ```; If the tensor is wrong on M1, this would explain the error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586:149,test,test,149,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1203272586,4,"['Test', 'test']","['Tests', 'test', 'tests']"
Testability,"Functions run, tests ok on my machine (darwin). Can you add a test for `molmer_sorensen` if appropriate?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1028#issuecomment-505092850:15,test,tests,15,https://qutip.org,https://github.com/qutip/qutip/pull/1028#issuecomment-505092850,2,['test'],"['test', 'tests']"
Testability,"Glad to be of service! I've been using a MATLAB-based library for most of my open-systems work, and I'm really excited to be able to move more things over to Python, thanks to QuTiP. Anyway, I can confirm that the test cases above now work as expected, and that `E_psi` correctly is identified as an `operator-bra`. As for code review, I'd be happy to help. It's a little late here, but I'll get to it soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/96#issuecomment-39052803:214,test,test,214,https://qutip.org,https://github.com/qutip/qutip/issues/96#issuecomment-39052803,1,['test'],['test']
Testability,Good addition @abhisekupadhyaya. The failing test is recurring in MacOS #963 and we can ignore it now and go ahead and merge this PR @nathanshammah,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/979#issuecomment-491755332:45,test,test,45,https://qutip.org,https://github.com/qutip/qutip/pull/979#issuecomment-491755332,1,['test'],['test']
Testability,"Good points. I suggest to simply remove the comment in `test_qobj`, and change to pytest in the `setup.py`. Something like what's [here](https://doc.pytest.org/en/3.0.4/goodpractices.html#integrating-with-setuptools-python-setup-py-test-pytest-runner) should work (basically changing `nose` with `pytest`). It seems however that testing it's a thorny [issue](https://github.com/pypa/setuptools/issues/1684), but these changes for the time being make the whole package at least consistent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1161#issuecomment-576003587:232,test,test-pytest-runner,232,https://qutip.org,https://github.com/qutip/qutip/pull/1161#issuecomment-576003587,2,['test'],"['test-pytest-runner', 'testing']"
Testability,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:83,benchmark,benchmarks,83,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"Great for the PR. . Somehow `nose` was not picking this error. ; It would be nice to investigate and fix. ; The problem seems to be at test 03 there,; ```; AttributeError: 'TestPulseOptim' object has no attribute 'tmp_dirs'; ```; Indeed, TestPulseOptim seems to have this attribute where `tmp_dirs`; are defined, ; ```; def setUp(self):; # list of file paths to be removed after test; self.tmp_files = []; # list of folder paths to be removed after test; self.tmp_dirs = []; ```; Investigating this locally (running the pytest only for this module) would be great.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-560236003:135,test,test,135,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-560236003,5,"['Test', 'test']","['TestPulseOptim', 'test']"
Testability,"Great, thanks for fixing this. Will merge when the test finish.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/300#issuecomment-68425743:51,test,test,51,https://qutip.org,https://github.com/qutip/qutip/pull/300#issuecomment-68425743,1,['test'],['test']
Testability,"Guess you can merge it now, unless you want me to add more test cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/145#issuecomment-45207270:59,test,test,59,https://qutip.org,https://github.com/qutip/qutip/pull/145#issuecomment-45207270,1,['test'],['test']
Testability,"HI @Titanosaurus , have submitted a PR, you will have your fix when it gets merged. :). Usage would be as follows:; ```b = Bloch(); b.save(""test"", dpsi=500); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1103#issuecomment-541321578:140,test,test,140,https://qutip.org,https://github.com/qutip/qutip/issues/1103#issuecomment-541321578,1,['test'],['test']
Testability,"HI Jake than you for the response.; I'll open a separate PR with just the update for the failing test and the changes in `__init__.py` if you are ok with it.; With respect to the check in OpenBLAS with SciPy 1.4, yes I can try it on a linux and a macOS env just in case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-819063126:97,test,test,97,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-819063126,1,['test'],['test']
Testability,"Haha, it's no problem - I didn't spot it was a problem in that PR either. I'm marginally worried that the test suite was even able to generate 68,000 warnings - it seems like the code was hit an excessive number of times. I'm fairly sure that `correlation.py` hasn't been meaningfully touched in years (there are 8-year-old deprecation warnings in it...), but it might be time for one of us to review it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1505#issuecomment-824433411:106,test,test,106,https://qutip.org,https://github.com/qutip/qutip/pull/1505#issuecomment-824433411,1,['test'],['test']
Testability,"Happy to create a notebook with some examples. Should it live at https://github.com/qutip/qutip-notebooks/tree/master/docs/guide ? If so, I'll make a PR there. For documentation, do I add them at https://github.com/qutip/qutip-doc/blob/master/apidoc/functions.rst?. Re measurement and teleportation -- that sounds like ordinary quantum teleportation, and probably would be a fun test to write once we get there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-547162310:379,test,test,379,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-547162310,1,['test'],['test']
Testability,"Hardcoded matrix will cause problem in later modification of the code. (Or if numpy update it's random number generator, etc.); Keeping the present tests, I would add something like this:; ```; O1 = rand_herm(..., seed=seed); O2 = rand_herm(..., seed=None); O3 = rand_herm(..., seed=seed); assert(O1!=O2); assert(O1==O3); ```; You check that random Qobj are reproducible using a seed and work as expected when not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-427319374:148,test,tests,148,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-427319374,3,"['assert', 'test']","['assert', 'tests']"
Testability,"Hardware info is only used to get the number of cpus... It may hve been used for benchmark in the past, it also fetch the cpu frequency and memsize... I would be for simply removing it in the next version.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1395#issuecomment-736660709:81,benchmark,benchmark,81,https://qutip.org,https://github.com/qutip/qutip/issues/1395#issuecomment-736660709,1,['benchmark'],['benchmark']
Testability,"Have you tried running the qutip tests? Do those fail? Again, I cannot reproduce the issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/508#issuecomment-237683040:33,test,tests,33,https://qutip.org,https://github.com/qutip/qutip/issues/508#issuecomment-237683040,1,['test'],['tests']
Testability,"Having any callable as a time-dependent components is good but the way here breaks the tests.; Moving the callable check after the check for `Cublic_Spline`, should fix the problem. `Cublic_Spline` is callable but not treated as a function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1107#issuecomment-543197728:87,test,tests,87,https://qutip.org,https://github.com/qutip/qutip/pull/1107#issuecomment-543197728,1,['test'],['tests']
Testability,"Hello @BoxiLi , @jakelishman . I implemented the issue forms for Bug Reports, Feature Requests and Other Issues.; Please check them out!. You can test them if you want over here: [test issue forms](https://github.com/Chasmiccoder/Algos-for-Amigos/issues/new/choose)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1728#issuecomment-981885178:146,test,test,146,https://qutip.org,https://github.com/qutip/qutip/pull/1728#issuecomment-981885178,2,['test'],['test']
Testability,"Hello @Ericgig, thanks a lot for your comments, it has been very instructive for me. I've solved most of the things, and I'm working with the tests your proposed and any other that comes to mind. . I have a question. When trying a test with <code>sesolve</code> and <code>e_ops=[lambda t, psi: qutip.expect(qutip.num(dim), psi)]</code> I get an <code>AttributeError</code> (krylovsolve seems to be working fine, however). It works if its not a list. This error comes from sesolve check of <code>op.isherm</code>:. ```python; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; AttributeError: 'function' object has no attribute 'isherm'; ```. Im using qutip 4.6.3. Should I not compare to qutip solvers for this functionality?. Here is a running example:. ```python; from qutip import rand_herm, rand_ket, sesolve, expect, num, jmat, krylovsolve; import numpy as np. dim = 100; psi0 = rand_ket(dim); H = rand_herm(dim); tlist = np.linspace(0, 1, 100). e_op = lambda t, psi: expect(num(dim), psi). try:; out = sesolve(H, psi0, tlist, e_ops=e_op); except AttributeError:; print(""first one didn't work""); try:; out2 = sesolve(H, psi0, tlist, e_ops=[e_op]); except AttributeError:; print(""second one didn't work""); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945:142,test,tests,142,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945,2,['test'],"['test', 'tests']"
Testability,Hello @Ericgig. I'm participating in the unitary hack. This looks like a good issue to start in qutip. Is necessary to add tests for `correalation.py ` once the function ` correlation_me_2t` has been changed? . Thanks!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1808#issuecomment-1146815109:123,test,tests,123,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1146815109,1,['test'],['tests']
Testability,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:226,test,tests,226,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,3,['test'],"['testing', 'tests']"
Testability,"Hello Eric,; I could have a look at it and add a test with the `scipy.special.sph_harm` .; Could you explain in more detail what errors you got?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1839#issuecomment-1079270356:49,test,test,49,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1079270356,1,['test'],['test']
Testability,"Hello Harsh,. Thank for your interest in qutip. The most efficient way for us to interact with code is through Github.; Please attempt a draft PR for this. There are many test functions in our; project that you can use as a template. Assuming that you are interested in GSoC, when assessing candidates, an; ability to work independently is a key criteria. All the best with it, we look forward to reviewing your PR. Alex. On Tue, 21 Mar 2023, 18:06 Harsh Khilawala, ***@***.***>; wrote:. > @Ericgig <https://github.com/Ericgig> Thanks for getting back to me. I; > will refer to pytest tutorials on web but I found some code lines like; > following:; >; > @pytest.mark.parametrize; > @check_pngs_equal; > @pytest.fixture; > @pytest.mark.repeat(10)...; >; > Can you please let me know when and why were these used? Is there a; > resource also for this one?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2127#issuecomment-1478364599>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ACGFP3MUPPBWDTOQGGBNOTLW5HU2ZANCNFSM6AAAAAAV7J6OKU>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804:171,test,test,171,https://qutip.org,https://github.com/qutip/qutip/pull/2127#issuecomment-1478682804,1,['test'],['test']
Testability,"Hello! Thank you for reporting the bug. This looks like it is the same bug posted to the mailing list, so let's combine discussion here. Running the same conda install and Python commands works for me, so we will need to dig a bit more. If you're using MKL and numpy 1.21.X it's possible that you're encountering this numpy bug https://github.com/numpy/numpy/issues/20356. It only occurs on certain Intel CPUs (those with AVX512 CPU extensions). I believe it is fixed in numpy 1.22, but I haven't had a chance to confirm that yet. If so, a quick solution is to try ""conda install nomkl qutip"" and confirm that that installs a no-MKL Blas and that the tests pass afterwards. If not, could you post the output of `qutip.abut()` in a comment here and I can try make some more suggestions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691:651,test,tests,651,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691,1,['test'],['tests']
Testability,"Here is another:; ```; ======================================================================; FAIL: Superoperator: Convert superoperator to Choi matrix and back.; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python3.5/site-packages/qutip-4.0.3-py3.5-linux-x86_64.egg/qutip/tests/test_superop_reps.py"", line 111, in test_ChoiKrausChoi; assert_((test_choi - choi_matrix).norm() < tol); File ""/home/travis/miniconda/envs/test-environment/lib/python3.5/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/621#issuecomment-270850810:306,test,test-environment,306,https://qutip.org,https://github.com/qutip/qutip/issues/621#issuecomment-270850810,8,"['Assert', 'test']","['AssertionError', 'test', 'test-environment', 'testing', 'tests']"
Testability,"Here is the method for getting OPENMP on OSX using homebrew:. brew install gcc --without-multilib (takes a couple of hours to build). after which you can install QuTiP using:. CC=gcc-6 python setup.py install. The tests run without any ABI incompatibilities so, with this method, all platforms should be able to use OPENMP and parallel tools.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/438#issuecomment-277468035:214,test,tests,214,https://qutip.org,https://github.com/qutip/qutip/issues/438#issuecomment-277468035,1,['test'],['tests']
Testability,"Hey @AGaliciaMartinez !. Thanks a lot for the reply. I tried it again on windows, but it didn't work.; In the end I just redid the whole thing with WSL and the tests ran like the wind (12 minutes).; All tests have passed, so that's great. Also, thanks for the tip (running tests on the changed files). That will help a lot. [ Will close this issue now ]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1711#issuecomment-975751156:160,test,tests,160,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-975751156,3,['test'],['tests']
Testability,"Hey @Ericgig, if I understand correctly, you want to remove TestPyPi in this PR. Is that correct?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2477#issuecomment-2199701824:60,Test,TestPyPi,60,https://qutip.org,https://github.com/qutip/qutip/pull/2477#issuecomment-2199701824,1,['Test'],['TestPyPi']
Testability,"Hey Simon and Eric,. - I've gone through and fixed (I hope!) the formatting and code issues due to the bad merge I did last week; - I've added in flimesolve_test.py as a test script for flimesolve; - I've tried to format everything according to PEP8, although there are likely some issues here. I've not had any formal training on PEP8 formatting (and python in general, to be honest), such that even with the help of the PEP8 style guide and Spyder's auto-formatting tool for PEP8, I'm sure there are some small fixes that need to be made; - I'm not entirely sure what Eric meant about separating out the physics from the data container, etc. I moved anything having to do with the precalculation of the Floquet states into its own function, but to kill this precalculation off entirely would severely hinder the speed of flimesolve, as an large advantage of Floquet theory comes from being able to accurately create the basis states at any time once you have the initial basis states. If this is still an issue (or if I've misinterpreted Eric's comment entirely and need to change something else in this regard), please let me know. Maybe we could have a live discussion over the issue, if that would work better. Thanks for your help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1624220778:170,test,test,170,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1624220778,1,['test'],['test']
Testability,"Hey Simon,. I've been working on a few issues this last week that Eric pointed out. I actually did end up going back and just copying the master branch to my; local and copying in my changes, so hopefully that won't be an issue going; forward. I'll likely do it a second time before submitting another request; just to be sure there wasn't anything I changed that I've forgotten about. I've also been working on adding in a few tests. I'm mostly working on; mirroring the floquet_test test file as best I can, although it looks like; there are some slight changes I need to make that I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33 PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:428,test,tests,428,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036,2,['test'],"['test', 'tests']"
Testability,"Hey guys, thanks for the feedback (this is the first time I have logged in to github in about a year!).. Just some replies to Paul's comments. The method is basically general, under certain assumptions about the bath spectrum density and bath temperature, so the 'system' can, in principle, be anything. I will also do so minor tweaking so it can deal with multiple baths and correlated baths. We will add some notebooks showing different examples and explaining when its valid later. . > Why is it not possible to directly calculate expectation values other than the coupling term?. Yeah there was a list of expectation values at some point, but it disappeared while we were making edits. Thanks for the reminder. Thanks for the other points, we will fix the various issues.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-103750029:65,log,logged,65,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-103750029,1,['log'],['logged']
Testability,"Hey, I tired solving this issue. I changed the add_vectors method such that it takes in an optional argument called 'color'. I created a dictionary called vector_color_specified which stores the vector-index and color as key-value pair. Then when plot_vectors is called, the color is taken from the dictionary if mentioned, otherwise the default value is used based on the cyclic color list which is already present. I tested my code and it works as you have mentioned above. So, is my approach right? Any advice would be helpful. This is the first open-source issue that I have taken up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1292#issuecomment-654410345:419,test,tested,419,https://qutip.org,https://github.com/qutip/qutip/issues/1292#issuecomment-654410345,1,['test'],['tested']
Testability,"Hey,; Thanks! Since test did not continue after this point, I am not sure whether to continue to use the qutip. Is there any way to bypass these kind of errors and continue the test?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1084#issuecomment-531466956:20,test,test,20,https://qutip.org,https://github.com/qutip/qutip/issues/1084#issuecomment-531466956,2,['test'],['test']
Testability,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:302,test,test,302,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650,2,['test'],['test']
Testability,"Hi @Ericgig , ; Could you please take a look at this? Me and @nathanshammah were wondering if this should be merged as-is, but a new issue should be opened to reflect that the Python no Cython tests fail? Or maybe we could fix them, and could you help with what's going wrong?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-561931270:193,test,tests,193,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-561931270,1,['test'],['tests']
Testability,"Hi @Ericgig ,; I just re-installed things with pip, and now the tests are passing (and my original examples work as expected)!. For what it's worth, I found that using pip to install scipy and qutip worked and resolved the issues.; The original problem seems to be related to conda installing a version of openblas which is buggy (in particular 0.3.20), see the scipy issue linked above for more info on that. Version 0.3.18 seems to work fine. Thanks for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071:64,test,tests,64,https://qutip.org,https://github.com/qutip/qutip/issues/1965#issuecomment-1205764071,1,['test'],['tests']
Testability,"Hi @Ericgig . I've ran the tests from the FreeBSD port's directory, and the errors above are what was printed. Yuri",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2190#issuecomment-1622099822:27,test,tests,27,https://qutip.org,https://github.com/qutip/qutip/issues/2190#issuecomment-1622099822,1,['test'],['tests']
Testability,"Hi @MartinSandeCosta, I have merged the PR of @mlaguna10. You can see now there is a few conflicts. Could you make a fresh PR including your changes based on the current master branch? . It could include:; - The controlled version of the gates; - Changes in QubitCircuit.propagator(); - Tests; and another enhancement you have related to #1208 . We shouldn't include the change of the attribution name `N` and `U_list` in this PR, as @jakelishman and @ajgpitch explained.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-607489616:287,Test,Tests,287,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-607489616,1,['Test'],['Tests']
Testability,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:1410,test,testing,1410,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355,1,['test'],['testing']
Testability,"Hi @dweigand, this looks interesting. It would you be nice to push this forward, adding some tests for this and integrating @Ericgig suggested changes. I am wondering whether there is a more intuitive (explicit) option than `qfunc_amat `. Something like a Boolean `precompute`?. Writing some documentation for this, in https://github.com/qutip/qutip-doc, would allow users to discover this option more easily at http://qutip.org/docs/latest/guide/guide-visualization.html#husimi-q-function, it's very nice you have some performance checks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-536368295:93,test,tests,93,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-536368295,1,['test'],['tests']
Testability,"Hi @egdeist, thanks for finding it, again. Somehow my change was reverted by #990. And no one realised it since QuTiP isn't automatically tested on windows. . Do you still have after changing it to `np.random.randint(0, np.iinfo(np.uint32).max, ntraj, dtype=np.uint32)`?; https://github.com/qutip/qutip/blob/8dbbe77f1c22ded7dc9c445d0dd82a3120fea94f/qutip/stochastic.py#L380-L390; https://github.com/qutip/qutip/blob/8dbbe77f1c22ded7dc9c445d0dd82a3120fea94f/qutip/stochastic.py#L410-L420",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/968#issuecomment-608290242:138,test,tested,138,https://qutip.org,https://github.com/qutip/qutip/issues/968#issuecomment-608290242,1,['test'],['tested']
Testability,"Hi @hodgestar , sounds good! I submitted the first PR for the tests.; For the `process_fidelity` and `average_gate_fidelity` PRs, I can definitely send them on the weekend, I can't promise before that unfortunately.; I'm happy to target either version with the other PRs, please let me know what makes more sense!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1703#issuecomment-958255641:62,test,tests,62,https://qutip.org,https://github.com/qutip/qutip/issues/1703#issuecomment-958255641,1,['test'],['tests']
Testability,"Hi @hodgestar thank you for yout input I will add the tests.; On further inspection it would be interesting if someone that wrote or uses this piece of code could comment if the new default settings for dnorm are correct. This specially affects the calls to Qobj.dnorm() since it does not have extra arguments, we could add a **kwargs there but I do not know if the hiding of the extra arguments was an intended feature in the original,",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1463#issuecomment-801903723:54,test,tests,54,https://qutip.org,https://github.com/qutip/qutip/pull/1463#issuecomment-801903723,1,['test'],['tests']
Testability,"Hi @jakelishman , Thanks for the great work and effort! I'm reading your code and also try to learn some pytest. . If I may, I have a minor suggestion. Could you maybe leave some more descriptive comments in the tests? I find it a bit hard to follow the logic when tests are automatically generated or parametrized, e.g. in test_control_pulseoptim. A lot of things are defined for the fixtures in the beging. It took me some time to understand what is happening. I guess it is because I'm not yet very familiar with the tools in pytest. Maybe some description like ; > We first define 4 test cases: ... or. > Test function1 against case1, case2 ... This might make it easier for whoever wants to add more tests later to understand what has been tested without too much digging. And another personal idea, maybe it is good to make a separate PR every 10 or 15 tests? A new branch can still base on this one. Just after the old PR is merged, fewer changes will be shown the new PR. It might make the later review a bit easier. Just personal ideas. Thanks again!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-591399487:212,test,tests,212,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-591399487,8,"['Test', 'log', 'test']","['Test', 'logic', 'test', 'tested', 'tests']"
Testability,"Hi @jakelishman you were right about the contraction, I changed the indexes as in http://qutip.org/docs/latest/guide/guide-tensor.html so that it represents a trace-like channel. On the other hand I find that mixed dimensions operator `[[m,n], [m,n ]]` appear in some of the tests that were already in place, I will try to write my thoughts on their meaning later. I am still going to refactor this a little bit more, and tell you when it is ready for review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-831049708:275,test,tests,275,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-831049708,1,['test'],['tests']
Testability,"Hi @loganbvh. Thanks for the interest!. The package you developed looks very nice. It does have some overlap with `qutip.qip`, but more following the perspective of experimentalists as you said. The start point of `qutip.qip` is a framework of simulating quantum circuit with more realistic noise. We are considering building an ecosystem around `qutip`, as described in a [roadmap discussion](https://github.com/qutip/qutip-doc/pull/125/files). If you are interested, we could propagate it as a ""QuTiP affilliated packages"" (packages that developed upon qutip but not maintained by the QuTiP team). We are also very interested in building APIs for importation and exportation pulses defined in other libraries. A possible GSoC project is listed [here](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2021#4-pulse-level-description-of-quantum-circuits). Best; Boxi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1439#issuecomment-778615974:4,log,loganbvh,4,https://qutip.org,https://github.com/qutip/qutip/issues/1439#issuecomment-778615974,1,['log'],['loganbvh']
Testability,"Hi @nathanshammah,. Could this issue perhaps be broken into sub-tasks in some way, perhaps, in order to enable work starting on it a bit more feasible?. Also, I can see it's been labelled as a ""good first issue"" but it seems to me the definition of done (i.e., what would a PR - or a set of PRs - that would successfully address the problem entail?), with respect to the entire issue, could be clarified a bit further, and the breakdown into sub-tasks (which itself might result organically from some further discussion) might help a bit in that direction. Regarding possible approaches for handling randomness - I have to admit I've started looking into QuTiP only very recently, and I'm yet to start familiarising myself with its more intricate details and get to run the full set of tests, and investigate what kind of test failures occur. In the meantime, I'll generally share some (what I _think_ is) relevant experience in the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:786,test,tests,786,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,['test'],"['test', 'tests']"
Testability,"Hi @nonhermitian,. I don't see any 4.2 release nor v4.2 tag, which commit should I test?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/723#issuecomment-317467358:83,test,test,83,https://qutip.org,https://github.com/qutip/qutip/issues/723#issuecomment-317467358,1,['test'],['test']
Testability,"Hi @nwlambert,. Sure! This is the code I used to test the changes:. ```; import numpy as np; from qutip import *. Gamma_r = 0.5; Gamma_l = 0.1. n_ket = (1)/(Gamma_l + Gamma_r)*Qobj([[Gamma_r],[Gamma_l]], ); n_bra = Qobj([[1, 1]]). Id = Qobj([[1, 0], [0, 1]]). L = Qobj([[-Gamma_l, Gamma_r], [Gamma_l, -Gamma_r]],). I_ops = Qobj([[0, Gamma_r], [0, 0]]). L_s = sprepost(L, Id). I_s = sprepost(I_ops, Id). current, noise, skw = third_cumulant(L_s, rhoss=n_ket*n_bra, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""). print(current, noise, skw); ```; It is based in a simple analytical example I found in a paper, which contains the expressions to check the results. This is the paper (page 7, the section ""Toy model""): [here is the paper](https://orbit.dtu.dk/en/publications/current-and-current-fluctuations-in-quantum-shuttles). As you can see it is really simple, although I had to make some changes to be able to applied in QuTip (I hope this doesn't lead to major fails). The effect of the frequency for the case when it is not defined in the function can be observed using the same example, just don't modify that part and you will see it, then you can try the solution I propose ( I don't know if I explained myself correctly).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531:49,test,test,49,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2126527531,1,['test'],['test']
Testability,"Hi @pschindler,. Indeed, the behavior you show is a bug in qutip 4.7.0. Thanks for reporting this! However, it is actually a bug in the `sparse=True` case. The scipy case gives a different result compared to qutip sparse because of the method used. `eigh` assumes the input is hermitian but `op` is not. You can see the correct eigenvalues using:; ```; In [7]: scipy.linalg.eigvals(op.full()); Out[7]:; array([-1. -2.22044605e-16j, -0.5+8.66025404e-01j, -0.5-8.66025404e-01j,; 0.5+8.66025404e-01j, 0.5-8.66025404e-01j, 1. +0.00000000e+00j]); ```. I am genuinely surprised that the `sparse=False` is bugged in the latest version of qutip. Fortunately, I tested this in the master branch of qutip (this contains the qutip 5.0.0 alpha version) and the bug seems to be solved there. This operator is indeed subjected to the same bug Eric shows (it is non-hermitian). However, due to the real part of the eigenvalues, it actually shows the correct answer (similar to the example I showed in my previous comment). I will try to find the source of the error but it seems very likely that we incorrectly label the operator as hermitian and hence uses the wrong method to find eigenvalues.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1419816348:653,test,tested,653,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1419816348,1,['test'],['tested']
Testability,"Hi @sahmed95, thanks a lot for your many suggestions on improving this module! I'll respond to each of your individual suggestions, but here is a summary of the ones worth discussing. > Changing QObj to :class: qutip.Qobj; line spacings; ""[[t1]_wg1]"" changes. I will make these changes. See the `temporal_basis_vector` comment for discussion on changing nested list to dictionary. > Things not covered by tests. I'll add tests for these or remove the functionalities (for example, `count_filled()` is never used and is just a debugging function I made while developing this module). > Lots of minor suggestions to comply with PEP8. I will make most of these changes. Some of the errors, such as the 80>79 errors and spaces around kwarg equals, were not shown as problematic using PyCharm's PEP8 linter with default inspection profile - can you provide steps to reproduce? However, I think that some bits that PEP8 classifies as problematic shouldn't be changed for notational consistency, such as H = hamiltonian, and my usage of T and W in the code and the notebook to denote number of time bins and waveguides. > Moving `__all__` to after import statements. I declared `__all__` in its current location because almost universally, all (heh) top-level qutip modules declare it before imports. (I actually checked about a dozen of these and can't find any instance of it being after imports.) I think this might be worth changing to comply with PEP8, but I think it should be done after the module is added in a separate commit where all occurrences of this are changed across QuTiP. > Shortening argument / function names. I'll respond to each proposed change individually, but in general I disagree with most of these proposed changes since I think they reduce conceptual clarity. (For example, `temporal_basis_vector` returns a specific vector in the temporal basis; I would expect a function named `temporal_basis` to return an enumeration of all basis vectors.) However, I will try to think of sh",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:405,test,tests,405,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,2,['test'],['tests']
Testability,"Hi @sarsid, there are still some tests failing. When you think the PR is really, just make it a ready-for-review PR and request a review. Besides, it would be great to address some of the style issues in code climate like ""Continuation line under-indented for visual indent"". Not all of them must be fixed though, it's more like a guide. The `pycodestyle` package can help you detect them locally if you would like to use it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-646002967:33,test,tests,33,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-646002967,1,['test'],['tests']
Testability,"Hi @victor-onofre @Ericgig . As far as I understand it, the only change needed is a single line in correlation_me_2t, as shown above. A test to show what the function should do, and how it currently does not work correctly, is shown in the code above. I've not attempted to 'solve' this issue further myself for the following 2 reasons:. 1) I'm not a theorist. I've discussed this with colleagues (as also mentioned above) but I'd like to have someone check this proposed change makes sense, preferably someone who knows why the code currently is what it is, maybe there is a reason for it?. 2) I'm unfamiliar with how github works, I've only used it for version control on private projects, so I actually don't know what to do to 'merge' the proposed changes into the code. On the other hand, I have been using qutip with the change suggested above, and as far as I can tell, for my use case, it works well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1808#issuecomment-1147586148:136,test,test,136,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1147586148,1,['test'],['test']
Testability,"Hi @victor-onofre, I don't think that this issue has a bounty for the unitary hack, but we would be grateful if you want to tackle it.; Yes, if you can add a test that would have failed but is now passing, it would be great. Also, I believe the same bug can be found in `_correlation_me_2t`, which should also be fixed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1808#issuecomment-1147521055:158,test,test,158,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1147521055,1,['test'],['test']
Testability,"Hi Alex. Nice to see your PR!. It is looking very good indeed, but deeper integration with qutip's frameworks for representing of operators and its evolution solvers would be nice. I'll test it for a few days and code review with inline comments in the code. You can make changes and push commits to your repository, and they will be automatically added to PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/246#issuecomment-61043885:186,test,test,186,https://qutip.org,https://github.com/qutip/qutip/pull/246#issuecomment-61043885,1,['test'],['test']
Testability,"Hi Anto, ; Could you please leave the issue for a GSoC candidate. There are no error raised but looking are the equations, something looks wrong. For example:; For positive `m`: `SPlm[1]`, but the equivalent term for negative values: `SPlm[abs(m)]`. So when adding the tests, I expect that some fixes will be needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1839#issuecomment-1079304653:269,test,tests,269,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1079304653,1,['test'],['tests']
Testability,"Hi Arne. Thanks for the bug report. Yes, you're right, it is the change in default value of the average_states (used to be called mc_avg) that is the course of the failing tests. And it could break backwards compatibility so perhaps it should be reverted. However, if average_states defaults to True it breaks backwards compatibility with the stochastic master equation solvers (which did not use this flag before, and had a different default behavior). However, since the stochastic ME and SE solvers has not yet been an official part of the qutip API in a release, perhaps priority should be to keep the mcsolve backward compatible (although I think it makes more sense not to take an average over the trajectories by default).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/37#issuecomment-22224680:172,test,tests,172,https://qutip.org,https://github.com/qutip/qutip/issues/37#issuecomment-22224680,1,['test'],['tests']
Testability,"Hi Ben. Thanks a lot for your contribution. It's looking great!. A couple of small things:; - We try to make qutip python3 compatible, so please use python3 compatible print(...) function calls instead of print ... statements.; - Functions super_to_choi and choi_to_super seems to do the same thing, while the function names suggest complementary conversion. Is this intentional?; - I think it would be better if you move the test code from within the if **name** == '**main**' to a separate file in the examples directory, or even better as unit tests in qutip/tests/; - Avoid global import of qutip ""from qutip import *"" by only selectively importing the functions that you need (we try to do this internally in qutip to avoid circular module dependencies).; - Make relative import of qutip functions (for example from qutip.super_to_choi import super_to_choi). This is also required for python3 compatibility.; - Add an import of the main functions (for example subsystem_apply) to qutip/**init**.py ; - I would probably prefer the super_to_choi.py module be called something more general, like choi_decomposition,py (or something like that), which would reflect that it does not only contain the super_to_choi function but other related functions as well.; - Avoid printouts in choi_to_kraus function. If you want to enable debugging or diagnostic info, consider adding an optional function argument debug=False or verbose=False and print the vals and vecs variables only if the user explicitly asks for it. Otherwise, one could get an excessive amount of printouts if your code is used in a loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/22#issuecomment-18592742:426,test,test,426,https://qutip.org,https://github.com/qutip/qutip/pull/22#issuecomment-18592742,3,['test'],"['test', 'tests']"
Testability,"Hi Ben. Thanks for getting back to his and finding the problem! However I think this PR has become a bit messy. I'm a bit concerned with f4e6dccb726d7d35415fd2208c4a4b84faab685d which seems to have introduced some merge conflicts and many changes. I think it is better to you create a new branch, apply the changes you want and create a new PR. I think this would create a much cleaner merge and perhaps fix the problems with the failing travis tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/83#issuecomment-36420130:445,test,tests,445,https://qutip.org,https://github.com/qutip/qutip/pull/83#issuecomment-36420130,1,['test'],['tests']
Testability,"Hi Bilal,. The conda-forge qutip package should install without VS-15. Most of qutip; functions should still work. This was certainly the intention when we; worked on it. I can't remember now though how well we tested without VS-15,; as the main focus was getting it to work with VS-15. The string type time-dependence needs a C++ compiler, so those functions; won't work. This means a lot of tests will fail. So, give it a go and let us know how you get on. Alex. On 26 February 2018 at 04:07, Bilal Riaz <notifications@github.com> wrote:. > Thanks for suggesting Linux subsystem, but it is not good enough to run; > simulations, it is slower for even day to day file manipulations, so from; > your comment and documentation you shared I come to conclusion that there; > is no alternative of VS to run Qutip in windows 10.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/826#issuecomment-368384720>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AIxX7ZQXPfD6q0cVTq1mY17St18hseO5ks5tYi4agaJpZM4SSlE1>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/826#issuecomment-368824556:211,test,tested,211,https://qutip.org,https://github.com/qutip/qutip/issues/826#issuecomment-368824556,2,['test'],"['tested', 'tests']"
Testability,"Hi Denis. Nice work, thanks! It would be great if you could create test notebooks that compares 'euler-maruyama' and 'euler-maruyama_fast', and 'milstein' and 'milstein_fast', and submit a pull request to our new repository for development notebooks at https://github.com/qutip/qutip-notebooks. I'll merge this PR now and do more tests later on. I might also make some small changes in your modifications, especially with the API for A_ops is still quite experimental (for example, not all operators that are precomputed and added to A_ops are used, so some could be dropped).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/51#issuecomment-25335125:67,test,test,67,https://qutip.org,https://github.com/qutip/qutip/pull/51#issuecomment-25335125,2,['test'],"['test', 'tests']"
Testability,"Hi Emi,; There are a few options:; `krylovsolver` could exist independently of Qutip and be used as:; ```; import qutip; from krylovsolver import krylovsolve; ...; result = krylovsolve(H, psi, tlist, ...); ```. If you want it to be part of qutip itself, since it solve the same problem as `sesolve`, it could be inserted as an options to `sesolve` or be it's own function. It would be better to not have too many function doing the same thing, but since we don't have many alternative method in `sesolve` it could be overlooked. Seeing the state of `krylovsolve`, both would be quite easy to do. Do you have benchmarks to compare it to `sesolve`? From what I understand, `krylovsolve` is a faster `sesolve` limited to constant Hamiltonian. So it would be interesting to see how fast it is. If we add `krylovsolve` to qutip, would you be able to maintain it? A new major version of qutip is in development and it will need to be updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1668#issuecomment-925327795:608,benchmark,benchmarks,608,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-925327795,1,['benchmark'],['benchmarks']
Testability,"Hi Ericgig, i tested it with a Rabi Hamiltonian. It returns the steadystate immediately! [This is the plot](https://ibb.co/PthSzRd) of the master equation time evolution with the direct steadystate expectation value.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1659#issuecomment-917369967:14,test,tested,14,https://qutip.org,https://github.com/qutip/qutip/issues/1659#issuecomment-917369967,1,['test'],['tested']
Testability,"Hi Ericgig,. Thanks for your response!. I installed the qutip manually with master branch. And yes, I used the qutip.testing.run() to test if the installation and functions are ready. I re-run the testing and the error happened on the ""**Monte-carlo: Collapse terms constant (func format)**"". Attached file is the error output with context. [issue1039.txt](https://github.com/qutip/qutip/files/3373987/issue1039.txt). Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1039#issuecomment-509716876:117,test,testing,117,https://qutip.org,https://github.com/qutip/qutip/issues/1039#issuecomment-509716876,3,['test'],"['test', 'testing']"
Testability,"Hi Jake okey will re align and pull then and focus the other modules. Let's see if I am getting this right, is it correct style to add parameter to fixtures when they are used all along the test module, but in very specific special cases just leave the variable assignment before the test definition, like here https://github.com/jakelishman/qutip/blob/862d0de844d9d5b39f0301d0ea4c47c37d995499/qutip/tests/test_metrics.py#L126 ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815030359:190,test,test,190,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815030359,3,['test'],"['test', 'tests']"
Testability,"Hi Jake,. Thanks for this, yeah I started looking into it but realised it would take too long for me to track it down. And definitely I have found some speed-ups in `dev.major` for some matrix operations compared to v4.5. Actually, I have been working a bit with Eric and Nathan to make a PR soon on something related to this, where I have been doing fairly rigorous speed testing. If you like, I can loop you in on this thread (I read your blog a bit and have been using the new `Dense` data layer -- this opens up some new possibilities).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1382#issuecomment-728332245:373,test,testing,373,https://qutip.org,https://github.com/qutip/qutip/issues/1382#issuecomment-728332245,1,['test'],['testing']
Testability,"Hi Kevin. I think that would be very interesting! Since we don't have any support for time-dependent systems in the Bloch-Redfield master equation at the moment, I think it would be a nice addition. With time-dependent systems one would have to diagonalize the Hamiltonian at each time-step, so I can't think of a better way of doing this than to consider a piecewise-constant approximation. How did you implement it? Did you for example put additional logic in brmesolve? I think that the ""array-based"" time-dependent format (see mesolve) could be suitable for defining piecewise constant problems for brmesolve.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/258#issuecomment-63427565:453,log,logic,453,https://qutip.org,https://github.com/qutip/qutip/pull/258#issuecomment-63427565,1,['log'],['logic']
Testability,Hi Markus. I think it is a good idea to pep8ify the code. I have had that in mind for some time so it's great that you took the initiative to do get started on this. I'm travelling now so it might take a while but I'll look through your PR and run the unit tests on it just to make sure nothing breaks (even though shouldn't of course..).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/6#issuecomment-10948380:257,test,tests,257,https://qutip.org,https://github.com/qutip/qutip/pull/6#issuecomment-10948380,1,['test'],['tests']
Testability,"Hi Nithin,; I think I found the bug: `_j_z`.; Could you correct it and add make the complex to real conversion explicit to remove the warning. I would suggest to merge in the present qutip/master since we changed the tests script. The test you have now don't work with the recent version of scipy and cython. If all but mac test passed we can merge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/912#issuecomment-468425102:217,test,tests,217,https://qutip.org,https://github.com/qutip/qutip/pull/912#issuecomment-468425102,3,['test'],"['test', 'tests']"
Testability,"Hi Vutshi. Thanks a lot for this contribution! It's looking very interesting indeed. I'll be looking into the details of your code, notebook and your paper in the coming days, but from a first look it's looking great! I've been working a lot on the stochastic solvers the last few months, but it is still very much under development. The milstein method has been on my todo list for a long time, but I've not gotten around to work on it yet, so your contribution is very timely and most welcome!. I have tried to design the API in the most general way I could think of while still keeping the complexity from growing too much. Defining an SME with its RHS function, D1 and D2 functions has worked for most problems I considered so far, but I'd be happy to discuss further if this could be changed to something more flexible, like a function for calculating rho_{n+1} like you suggest. We hope to have the stochastic solver API ready and mature enough to include in the next qutip release sometime this fall, so it would be good to have these things tested and thoroughly discussed before then. But until the stochastic module is officially in the QuTiP API we still have a lot of freedom to shake things up if necessary. Also, to keep complexity and code duplication down I wanted to follow the pattern. smesolve (choose solver by argument) -> smesolve_generic -> specific method and SDE by rhs, d1, d2 selection. So it would be good if smesolve_mil and smesolve_impl in your code could be combined with smesolve, and if smesolve_implicit and smesolve_milstein could be combined with smesolve_generic, etc. That would reduce a lot of code duplication I think. Of course, if smesolve_generic needs to be changed to accommodate this that would be totally fine with me. It would be great if you could do a pull request of this to the qutip master, then we could discuss details in the PR. You'd need to rebase your branch to the current master tip though, because things already changed a bit since the v",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22011953:1049,test,tested,1049,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22011953,1,['test'],['tested']
Testability,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:90,test,test,90,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056,6,['test'],"['test', 'testing', 'tests']"
Testability,"Hi albertomercurio, it's not needed to open an issue first but always nice to know it's coming.; The feature seems interesting, thank you for contributing. I took a quick look at your `steadystate-floquet` branch, the function look good. ; Have you added new tests for it?; Please open the PR when you have time, it does not have to be final.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1659#issuecomment-917295134:259,test,tests,259,https://qutip.org,https://github.com/qutip/qutip/issues/1659#issuecomment-917295134,1,['test'],['tests']
Testability,"Hi all, updated everything, added more tests and updated the notebooks too in the [notebook repository](https://github.com/qutip/qutip-notebooks/pull/52/commits/9fe1a6cafd5a4c8c2ac8b357db98c9483af818bd)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-370400958:39,test,tests,39,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-370400958,1,['test'],['tests']
Testability,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:432,test,test,432,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['test'],['test']
Testability,"Hi both, `dev.major` is currently quite a few commits behind `master`, particularly with regard to dev ops tooling - as you guys are spotting here - though I did bring some of the testing and setup tools up-to-speed last week. The reason we haven't added `-Werror` to the pytest runs on `dev.major` yet is because we haven't fixed all the warnings that are emitted in various parts of the code. We had hoped to do this before starting new projects on it, but I guess that didn't work out in the end. We still want to get it done in the next couple of weeks; the plan is to get #1481 merged, then merge `master` into `dev.major`. We don't want your projects to be blocked, so we can merge this PR in, though we intend to remove this entire file (and all the logistics that go with it) before the 5.0 release. Our original plan for managing the 4.x and development 5.x branches simultaneously started to fray at the edges once we started getting a much larger uptick in contributions; when it was mostly just me and Eric working on the code, it was easy to manage, but now there's lots of us, it's a bit harder (though a good problem to have!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864939384:180,test,testing,180,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864939384,2,"['log', 'test']","['logistics', 'testing']"
Testability,"Hi everyone and thank you all for the helpful advices.; I started testing OpenMP on v4. Some news from my side:; - I installed Qutip with OpenMP on Marconi100 and Galileo100 ; - I chose the spin-chain.ipynb example in https://github.com/qutip/qutip-notebooks/ for testing; - I passed options to `mesolve` in this way (varying n1, n2 and also the number of spins N): ; ```; opts=Options(num_cpus=n1 openmp_threads=n2, use_openmp=True); result = mesolve(H, psi0, tlist, c_op_list, sz_list, options=opts); ```; Unfortunately I didn't get any improvement. Do you have any ideas about it? Am I using OpenMP wrong or is the example chosen not adequate? Can you point me a snippet of code that you are sure works with OpenMP? ; Thank you so much!!!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-946521985:66,test,testing,66,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-946521985,2,['test'],['testing']
Testability,"Hi guys, thanks for looking at this! I actually made a fork to implement this: https://github.com/lfry512/qutip. In my fork I added some extra type checks and some extra functions in _LiouvillianFromFunc that support a c_ops callback. The way this was done just requires the user to use qt.lindblad_dissipator where appropriate. The use case that isn't implemented is H in list format and c_ops as a callback. @Ericgig thanks for the neat suggestion! This is very pertinent as I then moved on to try the same functionality with mcsolve, which doesn't support a callback for H and c_ops in the master branch. Yesterday I got callback functionality working for H in mcsolve but haven't committed it yet. However it's about 20 times slower than using the equivalent list format in my tests. @jakelishman it sounds like you worked on mcsolve. If you are interested I would love to discuss with you how to make the H callback method for mcsolve more efficient. I'm also trying to figure out if it is possible to make a cython callback builder class that can be used for building the Lindblad operators from instantaneous eigenstates of the Hamiltonian more efficiently. I am not sure how my changes fit in to the overhaul of the solver system, but in mcsolve I did somewhat make use of the SolverSystem instance that is built in place.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-629164724:781,test,tests,781,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-629164724,1,['test'],['tests']
Testability,"Hi guys,; yeah, the conflicts are because of the now merged #1224, which we knew about when we merged that one. It's a simple fix, but I'm hesitant to do it directly on this PR, depending on how we want to merge it. The simplest way is that I make the required changes, fix the merge conflict, and we keep going until this whole behemoth merges in one go. This ends up in the commit history being a bit of a mess, and it'll take ages. Instead, I think it might be better if I instead split this PR into a few different ones:; 1. add `pytest` markers and other test niceties; 2. the test files that Eric is checking; 3. the QIP-related ones so that Boxi can check those; 4. `brmesolve` tests; 5. trivially changed files; 6. whatever's left. This has the advantage that I can rebase them all individually to neaten them up with any changes suggested, and we can get parts merged in faster. PRs 2 to 6 will depend on PR 1, so this would require getting that first one merged ASAP, then the others will all be modular and can be merged in any order at any speed. If you're happy with that plan, I'll cherry-pick/rebase out the necessary bits of the history and form the new PRs. The end result will be 6 PRs, which, when merged, will have no conflicts, and will leave the repository in the exact same state it would be if this PR was merged in one lump (with the relevant conflict fixed). For each PR, then we just have a simple process:; 1. you review files; 2. I make suggested changes; 3. repeat until happy; 4. I rebase the PR to squash it into a logical form; 5. you merge",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-619434033:560,test,test,560,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-619434033,4,"['log', 'test']","['logical', 'test', 'tests']"
Testability,"Hi hodgestar,; Thank you for the PR.; The broken tests (smesolve) is not caused by your addition, you do not have to worry about it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-537232313:49,test,tests,49,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-537232313,1,['test'],['tests']
Testability,"Hi jakelishman,; Thank you for your work.; Why do you change the `from qutip import ...` to `import qutip`? Seems to be a lot of work with no real improvement. Also, do you know if pytest has a way to order tests? The tests are running in alphabetical order of the file name. It would be nice to test more basic function first, then does which build on them: `Qobj` -> `sesolve`, `mesolve` -> `floquet`, `correlation`. Say sesolve is broken, then a lot of other tests will also fail because of it, so catching it earlier in the test suite would be great.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-601734555:207,test,tests,207,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-601734555,5,['test'],"['test', 'tests']"
Testability,"Hi taw181, thank you for the PR. ; There are already test for `clebsch` in `test_utilities`. Could you move your new test there?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1177#issuecomment-583539450:53,test,test,53,https://qutip.org,https://github.com/qutip/qutip/pull/1177#issuecomment-583539450,2,['test'],['test']
Testability,"Hi the `steadystate` has some problem with optional keyword and scipy/mkl solver.; To have the notebook work, if you have mkl installed, you can change the cell calling `steadystate` to:; ```; solvers = ['direct','eigen','power','iterative-gmres','iterative-bicgstab']; mech_dms = []. for ss in solvers:; if ss in ['iterative-gmres','iterative-bicgstab']:; rho_ss, info = steadystate(H, c_ops, method=ss, use_precond=True, ; use_rcm=True, tol=1e-15, return_info=True); else:; rho_ss, info = steadystate(H, c_ops, method=ss,; use_rcm=False, return_info=True); print(ss,'solution time =',info['solution_time']); rho_mech = ptrace(rho_ss, 1); mech_dms.append(rho_mech); mech_dms = np.asarray(mech_dms); ```; Without mkl installed, skip the 'direct' method. Help Wanted: Some rework of the keywords_args treatment, testing solver/method mixes ('direct' + 'scipy' should work but don't) updating notebooks and docstring, etc. would be appreciated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1017#issuecomment-501454602:811,test,testing,811,https://qutip.org,https://github.com/qutip/qutip/issues/1017#issuecomment-501454602,1,['test'],['testing']
Testability,Hi! I tried running `conda install nomkl qutip` and then ran the test. I can confirm it solved the issue. I doubt it is a good permanent solution though. Would you recommend reverting back to MKL and upgrading numpy to 1.22?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1750#issuecomment-1005729943:65,test,test,65,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005729943,1,['test'],['test']
Testability,"Hi!. #### Imports; Honestly it wasn't really a particularly conscious decision, and there's no problem with `from qutip import (x, y, z)` lines though I don't think `from qutip import *` is a very good idea, especially with quite how many names `qutip` exports. The `from qutip.very.deep.nested.module import name` is certainly good, and I think I've generally left those. I think I started converting in a few places because there were things like `from qutip import Cubic_Spline` and `from scipy.interpolate import CubicSpline`, and then the test was unreadable as to which was which. Having `qutip.Cubic_Spline` and `scipy.interpolate.CubicSpline` is unambiguous. The smaller cases like `from qutip import Qobj` are highly unlikely to have any conflicts, but in general I just went for consistency. That all said, there's certainly arguments both ways, e.g. explicit `qutip.member` is good because it's clearly explicit at point of use which makes reading the code much easier, but bad because it adds unnecessary chaff which makes scanning lines take longer. I hadn't put much thought into it before, and I think I was just generally writing in my default style. #### Test ordering; I hadn't much considered this, but there are certainly ways of doing it. Essentially `pytest` goes through a few stages when you run `pytest` on the command line: discovery, generation, running, reporting, and it has lots of hook functions we can define to modify the state inbetween and during each of them. Default discovery is as you say: files in alphabetic order (I _think_ it's strictly shell globbing order, but generally that's alphabetical), then the contents of each file in order defined by the shared fixtures used. We tend not to need large amounts of state to be held in fixtures, so our files largely just run top-to-bottom. We can add in some logic into the collection-time hooks to re-order the tests. There's a `pytest` plugin called [`pytest-ordering`](https://github.com/ftobia/pytest-ordering)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-601793386:544,test,test,544,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-601793386,1,['test'],['test']
Testability,"Hi!. About the comments: yes, absolutely I'll leave more. It's a bit silly that I haven't yet, since one thing that was frustrating me previously was not understanding what was trying to be done! I think as time goes by I'm getting a bit better about being clearer in the code - some of the earlier parametrizations I did were too aggressive because I wasn't used to the tools yet. The `test_control_pulseoptim` parts are very complex, in part because the underlying calling convention of that code is complex too. I'll try and add more comments to it to ease that along, especially in the part where I just defined a load of systems to test. That certainly should have been commented. There are general comments about what I was using the `pytest` tooling for in the commit messages, but I didn't necessarily want to leave ""intro to pytest"" comments throughout, because it would mostly crowd out the actual tests, and the `pytest` documentation online is probably going to be a better explanation than what I can do. I'm also learning `pytest` by doing this (I'd not used it before I opened the first PR)!. About the PRs: I'm happy with whatever workflow works best for you guys - I don't have any control over when the PR gets merged. It might be a little difficult for me to maintain two branches at once (i.e. if the first PR with ~10 tests is awaiting merging), because there's likely to be conflicts in `conftest.py` (in particular). Even if I branched the new PR off the previous one on the expectation that it would be merged, I'd have to keep adding merge commits into (or force-rebasing) the other branch to keep it up-to-date, which wouldn't be completely ideal in that it would make a bit of a mess in the git log. If you want to merge this one (after I've gone through and put some more comments in), I'm happy to start a new one. I can also start a new one on a new branch, I think it might just make a bit more of a mess than it solves. I think this one only got big because I had a goo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-591413241:637,test,test,637,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-591413241,2,['test'],"['test', 'tests']"
Testability,"Hi, @nwlambert 1 test is failing , can you please suggest me how can i fix it ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2371#issuecomment-2049086230:17,test,test,17,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2049086230,1,['test'],['test']
Testability,"Hi, I am getting this error on the current master. I guess this will be solved once this PR is merged ?. ```; air:tests shahnawaz$ nosetests test_sparse.py; E; ======================================================================; ERROR: Failure: ImportError (No module named 'qutip.cy.spconvert'); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/609#issuecomment-270078397:114,test,tests,114,https://qutip.org,https://github.com/qutip/qutip/pull/609#issuecomment-270078397,1,['test'],['tests']
Testability,"Hi, I fixed the bug and improved the handling of the default cases. If the user wants to compute a very large Q func (e.g. 512*512 points, State size >256), a ResourceWarning will be given and the function falls back to the old method as that would use >1GB memory. I did only a manual test of this behavior, as a test function would be very slow. There is an automated test to ensure that precompute() raises a MemoryError for very large Q, if it is not manually set to use >1GB Memory. At least on my end, all the tests are now running fine. I might add some documentation in the future, but I am currently in the middle of writing my PhD Thesis, so no guarantees.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-561244172:286,test,test,286,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-561244172,4,['test'],"['test', 'tests']"
Testability,"Hi, I get many errors while running the test code, and at the end, I came up with a nitification that says (Failed(errors=12)). here are the errors:. td_brmesolve: passes all brmesolve tests ... ERROR; td_brmesolve: time-dependent a_ops ... ERROR; td_brmesolve: time-dependent a_ops tuple of strings ... ERROR; td_brmesolve: time-dependent a_ops tuple interp ... ERROR; td_brmesolve: time-dependent a_ops & c_ops interp ... ERROR; td_brmesolve: non-Hermitian e_ops check ... ERROR; td_brmesolve: states check ... ERROR; td_brmesolve: split ops #1 ... ERROR; td_brmesolve: split ops #2 ... ERROR; td_brmesolve: split ops, Cubic_Spline td-terms ... ERROR; td_brmesolve: split ops, multiple ... ERROR; td_brmesolve: Hamiltonian args ... ERROR. Please let me know how to fix it. thanks in advance",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1039#issuecomment-524421315:40,test,test,40,https://qutip.org,https://github.com/qutip/qutip/issues/1039#issuecomment-524421315,2,['test'],"['test', 'tests']"
Testability,"Hi, I have an implementation of the ICM model now and as a bonus, I got an introduction to topological quantum computing as well as a nice topological quantum computing circuit viewer. I have it all in this repo - https://github.com/sahmed95/icm. It needs major refactoring, testing and there is a lot of brute code in there so please ignore it for now. I had to finish this in the span of a few days to start work on something related to the same and hence the code isn't pretty. I will work on this after finishing up my winter internship and push the commits here. An example can be found in https://github.com/sahmed95/icm/blob/master/tqc_icm/icm_example.ipynb. If this code has to go into qip, I guess I need someone with experience in this for review. How about https://github.com/alexandrupaler. The ICM paper is by him and he has implemented it in C++ in https://github.com/alexandrupaler/tqec.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-273579746:275,test,testing,275,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-273579746,1,['test'],['testing']
Testability,"Hi, I have updated the interface to make it much much easier to use. And, I added the unit test and now the test will succeed. The test is the following: generate random Hamiltonians and run perturbation and see whether the energy levels match with the exact solutions. I have done all I want to do up to now. So, please review these codes again and consider merging them.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/282#issuecomment-109847098:91,test,test,91,https://qutip.org,https://github.com/qutip/qutip/pull/282#issuecomment-109847098,3,['test'],['test']
Testability,"Hi, I just added the support for QCircuit 2.6 in my fork and tested it with [quantum-gates.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/examples/quantum-gates.ipynb). Do you have any other notebook suggestion, which I could use for testing? . I didn't look into Quantikz yet.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1096#issuecomment-592936636:61,test,tested,61,https://qutip.org,https://github.com/qutip/qutip/issues/1096#issuecomment-592936636,2,['test'],"['tested', 'testing']"
Testability,"Hi, This is not ready for review so I added a new tag `WIP`. The tests etc are not proper and I just wanted to get a basic version out. The latest commits are @nwlambert's code to construct the Liouvillian for the Heom. I will start refactoring things now and update the tag to `review in progress` when this is ready.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962#issuecomment-472547191:65,test,tests,65,https://qutip.org,https://github.com/qutip/qutip/pull/962#issuecomment-472547191,1,['test'],['tests']
Testability,"Hi, are you sure you are not in the QuTiP folder when you start your Python; interpreter? Please provide some information as to how you installed QuTiP.; Which Python version are you using?. You can just type the command. >> which python. To find out the Python you are using. I would suggest the best way to run; QuTiP is using the conda installation. On Sun, 29 Nov 2020 at 20:42, ZahraQI <notifications@github.com> wrote:. > After installing qutip, in order to test qutip installation, I type; > ""python"" in terminal and then type ""import qutip.testing as qt"", getteing; > to the following error.; >; > import qutip.testing as qt; > Traceback (most recent call last):; > File """", line 1, in; > ModuleNotFoundError: No module named 'qutip'; >; > qt.run(); > Traceback (most recent call last):; > File """", line 1, in; > NameError: name 'qt' is not defined; >; > If anyone can help to solve the problem?; > Thanks; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1391>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ABVFIBB6E4CM7HU3CY2NT6LSSKP3PANCNFSM4UGXA6UA>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1391#issuecomment-735447201:464,test,test,464,https://qutip.org,https://github.com/qutip/qutip/issues/1391#issuecomment-735447201,3,['test'],"['test', 'testing']"
Testability,"Hi, something unrelated fails. Do we need to restart the build and test? All other cases pass except for NOMKL=1. FAIL: Random: Stochastic - left; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/qutip-4.3.0.dev0+b9fee234-py3.6-linux-x86_64.egg/qutip/tests/test_rand.py"", line 111, in testRandStochasticLeft; assert_(np.abs(np.sum(A.getcol(j).todense().real)-1.0) < 1e-15); File ""/home/travis/miniconda/envs/test-environment/lib/python3.6/site-packages/numpy/testing/nose_tools/utils.py"", line 93, in assert_; raise AssertionError(smsg); AssertionError",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-370777345:67,test,test,67,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-370777345,10,"['Assert', 'test']","['AssertionError', 'test', 'test-environment', 'testRandStochasticLeft', 'testing', 'tests']"
Testability,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1330,test,tests,1330,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325,7,['test'],"['test', 'tests']"
Testability,"Hi, thanks for the PR. Let me see if there is a test written to check this. You may add your own test to ensure this works fine. ; @ajgpitch",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/693#issuecomment-299716714:48,test,test,48,https://qutip.org,https://github.com/qutip/qutip/pull/693#issuecomment-299716714,2,['test'],['test']
Testability,"Hi, the failure is gone, though the error is still there. # . ## ERROR: Qobj addition. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_Qobj.py"", line 139, in test_QobjAddition; assert_equal(q4.type, ischeck(q4)); NameError: global name 'ischeck' is not defined. ---. Ran 221 tests in 269.779s. FAILED (SKIP=1, errors=1). I removed my installation with apt-get remove python-qutip before installing the development version.; Cheers; Clemens",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42922665:204,test,test,204,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42922665,3,['test'],"['test', 'tests']"
Testability,"Hi, the first part for this is ready for review. A typical use case would be to generate the matrix M.; @nathanshammah I made some small changes in the names of functions.; @ajgpitch Please suggest any changes if necessary for pep8, function naming, testing or the API in general. We have the examples and ipynb notebooks that @nathanshammah wrote. Where do they go ? . Once, this is merged, there are additional helper functions to calculate operator expectations, thermal states etc which can be added. However, this forms the core of the module.; ```; from qutip.pim.dicke import *; import numpy as np; from scipy.integrate import odeint. # system parameters. N = 10; gS, gL, gD, gP, gCP = .1, .1, .1, .1, .1. # define the model; model = Pim(N, emission=gS, loss=gL, dephasing=gD, pumping=gP, collective_pumping=gCP). M = model.generate_M(). # Evolve the system according to dp/dt = M.p. rho0 = initial_dicke_state(N, (5, 5)); t = np.linspace(0, 10, 100). def generate_rhs(rho, M):; return M.dot(rho). p = odeint(generate_rhs, rho0, t, args=(M,)); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-332110217:250,test,testing,250,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-332110217,1,['test'],['testing']
Testability,"Hi, there were some import statement errors which are fixed now and the tests pass, hopefully. The code is the same as in Nathan's repository where we have the notebooks as examples.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-361302051:72,test,tests,72,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-361302051,1,['test'],['tests']
Testability,"Hi, this is great. @agpitch, do you have any idea about the test? Looks like something related to optimal control and you could provide some insight. We can investigate the issue separately and fix this. Good job on the PR. Moving to PyTest will be great for us in the long run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/972#issuecomment-482522758:60,test,test,60,https://qutip.org,https://github.com/qutip/qutip/pull/972#issuecomment-482522758,1,['test'],['test']
Testability,"Hi, this is ready for review. It probably needs a lot of refactoring but I have documented all functions and provided unit tests. I made a simple script for my lab where you can specify a circuit in a text file and the outputs will be generated. You can check it out here: https://github.com/sahmed95/icm. I have an example describing the use of this module. Where do the examples go ? @ajgpitch @nonhermitian . As I mentioned, @alexandrupaler should be the right person for review. Dr. Devitt also mentioned Damian from ProjectQ (?) who could help perhaps.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-275668058:123,test,tests,123,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-275668058,1,['test'],['tests']
Testability,"Hi, you are absolutely correct that this is not a good place ""intro to pytest"". Comments on what is tested would be most helpful. I see your point. If some files need to be updated all the time then you are probably right. I'm also no maintainer of QuTiP so merging is beyond my ability :) But I'm sure there is no hurry in this. I'm also using my spare time browsing around here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-591687380:100,test,tested,100,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-591687380,1,['test'],['tested']
Testability,"Hi,. I think your new implementation of API should be flexible enough to incorporate any explicit scheme. The reason I think it is useful to calculate \rho_{n+1} is to apply a semi implicit method. This is what is done by Lsparse. I tried two ways of doing it. First, one can calculate (1 - (L+d1)_dt)^(-1) and apply it to to the stochastic part of the equation. Another way is to calculate the deterministic evolution expm[(L+d1)_dt] and also apply it to the stochastic part. Both of these methods work for linear deterministic part like in the homodyne detection. I've got good results with these semi-implicit methods on a problem with a few qubits. Due to a big nonlinearity for some parameters regime it really helps to apply the true deterministic evolution (or its approximation). For another regime it is better to use explicit method. In principle it should be good to adjust degree of implicitness. Anyway I'm still looking into the problem and comparing different possibilities. I hope to produce a new notebook with tests soon. This Milstein realisation is compatible in principle with the heterodyne detection. I'm not sure it is possible to express everything in terms of d1 and d2 only. The point is that I need to use derivatives of d2. I don't really see a problem to have separate RHSs for homodyne, heterodyne and photocurrent detections. I'll think a bit more about unification of homodyne and heterodyne and then I'll submit a pull request. Regarding expm for large systems. We need to calculate it only once, it works for small systems so I think it is a good option to have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22116628:1028,test,tests,1028,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22116628,1,['test'],['tests']
Testability,"Hi,; Thanks very much for your input. It looks like you are using github correctly to me, although I am no expert.; Well spotted on the typo, and thanks for sorting that out.; It looks like the tau factor on the propagator gradient is required - revisiting the paper by S Machnes (cited in the code). ; I am looking into your alternative method for the PSU normalisation now.; I am testing your branch locally as well.; I will report back when I have completed these tasks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/325#issuecomment-78077523:382,test,testing,382,https://qutip.org,https://github.com/qutip/qutip/pull/325#issuecomment-78077523,1,['test'],['testing']
Testability,"Hi,; There are many methods for the steadystate solver, some are faster, some are less stable. I would suggest trying other method until your find a good one for your problem.; Available method are: ; `'direct', 'eigen', 'iterative-gmres', 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power', 'power-gmres', 'power-lgmres', 'power-bicgstab'`. `'direct'` and `'power'` can use mkl as a solver, all can use scipy. You can also try to change some options such as the tolerance and max iteration number. ; The options for each solver are different depending on the solver and not all are documented. ; I list them here if you want to go deeper:. For scipy:; ```; 'sparse': True, ; 'use_rcm': False,; 'use_wbm': False, ; 'weight': None, ; 'use_precond': False,; 'all_states': False, ; 'M': None, ; 'x0': None, ; 'drop_tol': 1e-4,; 'fill_factor': 100, ; 'diag_pivot_thresh': None, ; 'maxiter': 1000,; 'tol': 1e-12, ; 'matol': 1e-15, ; 'mtol': None,; 'permc_spec': 'COLAMD', ; 'ILU_MILU': 'smilu_2',; 'restart': 20, ; 'return_info': False,; 'info': _empty_info_dict(),; 'verbose': False, ; 'solver': 'scipy'; ```. For mkl:; ```; 'max_iter_refine': 10, ; 'scaling_vectors': True, ; 'weighted_matching': True, ; 'return_info': False, ; 'info': _empty_info_dict(), ; 'verbose': False, ; 'solver': 'mkl', ; 'use_rcm': False, ; 'use_wbm': False, ; 'weight': None, ; 'tol': 1e-12, ; 'matol': 1e-15, ; 'mtol': None, ; 'maxiter': 1000; ```. Lastly, most steadystate's method have a logger if you activate debug in setting:; ```; import qutip.settings as settings; settings.debug = True; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1077#issuecomment-527620834:1472,log,logger,1472,https://qutip.org,https://github.com/qutip/qutip/issues/1077#issuecomment-527620834,1,['log'],['logger']
Testability,"Hi,; This a manual installation of the master branch?; Are you using the qutip tests in qutip.testing.run(), if so could you tell us which test is failing? (And which similar only are not.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1039#issuecomment-509709052:79,test,tests,79,https://qutip.org,https://github.com/qutip/qutip/issues/1039#issuecomment-509709052,3,['test'],"['test', 'testing', 'tests']"
Testability,"Hi. I've been looking in to this and plan to add it at some point, but we would need to rework some of our unit tests before adding travisci (because some of our tests take too long to run).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/77#issuecomment-35958903:112,test,tests,112,https://qutip.org,https://github.com/qutip/qutip/issues/77#issuecomment-35958903,2,['test'],['tests']
Testability,Hi. Thanks for reporting this problem. I'm not sure what the reason for this behavior might be. Do you see the same thing when you install with and without the f90 solver? Are you running the tests in the python interpreter or from IPython?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/46#issuecomment-23545094:192,test,tests,192,https://qutip.org,https://github.com/qutip/qutip/issues/46#issuecomment-23545094,1,['test'],['tests']
Testability,"Hi. Thanks for the information, that is good to know. In qutip we actually don't use the expm function from scipy yet, but we have plans to add an option to use scipys expm instead of qutips own. I hoped that scipys might be faster and have done some benchmarks, but I hardly saw any difference so I have not been sufficiently motivated make the add this option yet, but perhaps I need to revisit those benchmark tests now. Thanks again for the info!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/182#issuecomment-48682172:251,benchmark,benchmarks,251,https://qutip.org,https://github.com/qutip/qutip/pull/182#issuecomment-48682172,3,"['benchmark', 'test']","['benchmark', 'benchmarks', 'tests']"
Testability,Hm I'll have a look at those failing tests next week. But probably just too few times in `tlist`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2437#issuecomment-2139114804:37,test,tests,37,https://qutip.org,https://github.com/qutip/qutip/pull/2437#issuecomment-2139114804,1,['test'],['tests']
Testability,"Hmm, it still seems to use the old travis ci configuration, where I tried to install numpy/scipy with pip without wheels. But took too long to install the dependencies that way, and the tests will probably timeout and get cancelled. In the current travis ci configuration uses pip with wheels to install numpy/scipy much faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36083480:186,test,tests,186,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36083480,1,['test'],['tests']
Testability,"Hmmm. Now the documentation build works, and the macos test run works as well (except for unrelated test failures). The python 3.9 test runs fails to build mpi4py. Here, the problem solution would be [this](https://stackoverflow.com/a/73399242) (I've had the same problem before installing mpi4py on the RIKEN HPC). Should I add that?. All other test runs fail, seemingly because the first call to `mpi_pmap` hangs indefinitely. That's... hard to debug. Why would it work only on macos?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136:55,test,test,55,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1905456136,4,['test'],['test']
Testability,"Hmmm. You're right that there will be some nasty merge conflicts with #1181, but I don't see anyway around those, to be honest without that PR being merged before this one (which doesn't look very likely). Barring #1181 getting merged in the next day or two, I'd just go ahead with these commits as written. If the new-style tests were merged, `test_gates.py` would have a much tinier diff. The single-qubit gates would just go between lines 222 and 223 in https://github.com/qutip/qutip/blob/77c21f8a97ddfff2353490d3587cc1effdfe9abc/qutip/tests/test_gates.py#L222-L239 as; ```python; pytest.param(gates.x_gate, 0, ""X""),; pytest.param(gates.y_gate, 0, ""Y""),; ...; ```; (and we'd probably change the function name to `test_one_qubit`). The controlled qubits would similarly go into the next test's parametrisation list: https://github.com/qutip/qutip/blob/77c21f8a97ddfff2353490d3587cc1effdfe9abc/qutip/tests/test_gates.py#L241-L259. Overall, it's clear that you can't write sensible new-style tests without #1181 having been merged, so I wouldn't worry about it too much. I did drop in a couple of comments in-line (minor nitpicking), but given that this file may well get pretty much overwritten - keeping the actual tests, of course! - in short order, I wouldn't consider them changes that need to be made, unless Boxi asks. Also, as you noted, `test_gates.py` doesn't really do much testing of the actual form of the gates yet. I haven't actually been adding new tests as I go, because I wanted to keep #1181 roughly focussed on just converting what we've got so far.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607833088:325,test,tests,325,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607833088,8,['test'],"['test', 'testing', 'tests']"
Testability,"Hmmm... 4000/150\~25 second. That's not very short actually. The total time for a whole round of qutip CI test costs 15min\~20min on Travis. . Just ideas. Tests here seem to be two-folded:. - Test classical controlled gates in a circuit; - Test the measurement functions. So maybe we can split it. The teleportation circuit test can be done without measurement. Just check the final state tracing out the ancillary qubits. The test for measurement can probably be done for single or two `Qobj` along without circuit. But `run_circuit_statistics`... Probably we then only need to check if the number of elements in the result is correct after some 50 runs?. On a different matter, I'm wondering if running the statistics takes so long, for such a small teleportation circuit, is it still advantageous in any case? Since we are doing simulation and have the full quantum state, one can actually calculate all 4 possible final states, classically mix them into a density matrix with the corresponding measurement probability and calculate the exact statistics distribution. I doubt that will be slower than 25s, although coding will be harder I suppose.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640102122:106,test,test,106,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640102122,6,"['Test', 'test']","['Test', 'Tests', 'test']"
Testability,"How about instead of checking if it is Hermitian, we could put a seed parameter and check if the output is exactly equal (or [close](https://docs.scipy.org/doc/numpy/reference/generated/numpy.isclose.html)) to given hardcoded matrix?. https://github.com/qutip/qutip/blob/d91a4c93f35d97b8bfc633420ffa6ddebadc06a1/qutip/tests/test_rand.py#L57",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-427237727:318,test,tests,318,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-427237727,1,['test'],['tests']
Testability,"I actually did end up going back and just copying the master branch to my; local and copying in my changes, so hopefully that won't be an issue going; forward. I'll likely do it a second time before submitting another request; just to be sure there wasn't anything I changed that I've forgotten about. I've also been working on adding in a few tests. I'm mostly working on; mirroring the floquet_test test file as best I can, although it looks like; there are some slight changes I need to make that I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33 PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you ca",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:1138,test,testing,1138,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036,1,['test'],['testing']
Testability,"I added a section to the test suite that will skip the tests if pyopencl is not installed in the last commit. To get them working, installing pyopencl via pip will not be sufficient. There are nice guides for setting up OpenCL in [Gentoo](https://wiki.gentoo.org/wiki/OpenCL) and [Arch](https://wiki.archlinux.org/index.php/GPGPU#OpenCL). But most OpenCL implementations are proprietary. I found an example of installing AMDAPP in a travis vm [here](https://github.com/JuliaGPU/OpenCL.jl/blob/master/.travis.yml). This is the OpenCL implementation I would recommend in absence of a GPU. But this script circumvents the license agreement and I am not sure whether this is legal. If you still intent to set this up, you can push changes to this branch as well. As for documentation I feel there is not much to document. There are already notebooks showing how to use `mcsolve` [here](http://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/example-photon_birth_death.ipynb) and [here](http://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-6-Quantum-Monte-Carlo-Trajectories.ipynb). If everything is set up just exchanging `mcsolve` with `mcsolve_cl` should do the trick. The nuances are documented in the docstring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-258609202:25,test,test,25,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-258609202,2,['test'],"['test', 'tests']"
Testability,"I added a test that compares `correlation_2op_1t` to its analytical solution. I was trying to match the `c_ops` of this new test to the ones appearing in `test_correlation_solver_equivalence`, which are:; ` c_ops = [np.sqrt(G1 * (n_th+1)) * a,; np.sqrt(G1 * n_th) * a.dag()]; `; However, the analytical solution I obtained for this case did not work unless I used a very small value for `n_th = 0.1`. I was wondering whether the analytical solution I got was wrong or whether this actually makes sense. I was thinking that the difference probably comes from the cut we use for the number of states (`N = 20`). The new test for `correlation_2op_1t` should be very robust as it tests for a lot of different scenarios, including the one presented in #1460. I was wondering whether these were too many cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1478#issuecomment-813359081:10,test,test,10,https://qutip.org,https://github.com/qutip/qutip/pull/1478#issuecomment-813359081,4,['test'],"['test', 'tests']"
Testability,"I added all the suggested changes. However, now the tets for trace norm with csr matrices started failing (in particular `TestTraceNorm.test_mathematically_correct[CSR[square,sparse]->Number]`). Decreasing the tolerance to `1e-8` solves the problem but given that this was not a problem before (at least I do not remember this happening), I wonder if it is actually signaling that there is something wrong.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1635#issuecomment-929280362:122,Test,TestTraceNorm,122,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929280362,1,['Test'],['TestTraceNorm']
Testability,I added ipython to the testing workflow. Let me know if it should have been included somewhere else.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1918#issuecomment-1146047389:23,test,testing,23,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146047389,1,['test'],['testing']
Testability,I added the feature explanation in the docstring. I don't think we have special documentation for `testing.run`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1151#issuecomment-577266894:99,test,testing,99,https://qutip.org,https://github.com/qutip/qutip/pull/1151#issuecomment-577266894,1,['test'],['testing']
Testability,I added the test in `qutip/tests/test_correlation.py` and pytest returns no errors. Why not put it inside the `qutip/tests/test_steadystate.py` file instead?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1660#issuecomment-917597103:12,test,test,12,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917597103,3,['test'],"['test', 'tests']"
Testability,"I adjusted the test to be sensitive to the original issues. new test is just a driven two-level system. not sure why the old test of a driven boson was insensitive to that test. i could make it sensitive by making the drive act on the frequency, like the example in #2386 but this is simpler. . also adjusted the test to compare a period of the dynamics from mesolve to the result from the steadystate solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426:15,test,test,15,https://qutip.org,https://github.com/qutip/qutip/pull/2393#issuecomment-2053629426,5,['test'],['test']
Testability,I agree with @Ericgig on the possibility of having no template and adding the suggestions for tests in the template. . I understand now that the changelog in qutip/qutip was a bad idea for the reasons you mention.; I still think it would be nice to somehow automate the way the changelog is compiled (right now by whoever is in charge of the release). Is there a simple and smart way to do this? Otherwise we could just look up the changelog section in each PR as per this template.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1198#issuecomment-602676649:94,test,tests,94,https://qutip.org,https://github.com/qutip/qutip/pull/1198#issuecomment-602676649,1,['test'],['tests']
Testability,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:81,test,tests,81,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874,11,['test'],"['test', 'testing', 'tests']"
Testability,"I agree with @nwlambert that we should go without shifted object and simply add the shift in the times.; This shift method predate me, but I believe at some time solve would not work properly if not started at `0`...; But this should have been fixed a while ago. @victor-onofre, would you also remove the shifted operator, this should be right.; Also the `tlist` type is not tested and it could be a list instead of an array.; Ideally the same fixes should be made to `_correlation_mc_2t`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1929#issuecomment-1153946989:375,test,tested,375,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153946989,1,['test'],['tested']
Testability,"I agree with having a test pre 1.5.; These changes should be released quickly, but probably just to 4.5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1301#issuecomment-649631995:22,test,test,22,https://qutip.org,https://github.com/qutip/qutip/pull/1301#issuecomment-649631995,1,['test'],['test']
Testability,"I agree, I have also not had any problems with mingw.; The only issue seems to be that it won't work with python 3.5. Perhaps they; will fix that and solve our problem that way. On 31 May 2016 at 21:10, Paul Nation notifications@github.com wrote:. > Well, we have been using mingw for qutip, while the Win Python has always; > been compiled with VS. while I agree with your statement, using VS seems; > not to be an option for us. I haven't had any problems in mu minimal; > testing.; > ; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > https://github.com/qutip/qutip/issues/447#issuecomment-222805219, or mute; > the thread; > https://github.com/notifications/unsubscribe/AIxX7eTvGa_WbL8VzcQgAqIkgCEEI8heks5qHJXGgaJpZM4HpJf1; > .",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/447#issuecomment-222963411:475,test,testing,475,https://qutip.org,https://github.com/qutip/qutip/issues/447#issuecomment-222963411,1,['test'],['testing']
Testability,"I agree, I have some plans to create some unit tests. The check_grad function that fhenneke has pointed out will be part of them. I have tested the Frechet gradient methods (which are used by Lindbladian and symplectic dynamics) using the check_grad function and they seem to be fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/325#issuecomment-78238553:47,test,tests,47,https://qutip.org,https://github.com/qutip/qutip/pull/325#issuecomment-78238553,2,['test'],"['tested', 'tests']"
Testability,"I agree, if Travis say that they are interested, then we should tell them. I would be happy for you to raise this with them, if you ok with that. It would seem to make sense if you have done the tests. I'll do it if you think that is more appropriate.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/360#issuecomment-130291761:195,test,tests,195,https://qutip.org,https://github.com/qutip/qutip/pull/360#issuecomment-130291761,1,['test'],['tests']
Testability,I also added a development notebook to test this,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/338#issuecomment-95648513:39,test,test,39,https://qutip.org,https://github.com/qutip/qutip/pull/338#issuecomment-95648513,1,['test'],['test']
Testability,"I also note that Coveralls isn't running on any of these commits, and hasn't been run on `master` since December last year. While so far I've just been converting tests, rather than writing new ones (for the most part), it seems wrong that it isn't being run.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-593334189:163,test,tests,163,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-593334189,1,['test'],['tests']
Testability,"I am getting a variety of errors when running the test scripts under OSX:; - For `test_mcsolve_cl_time_dep_h` I get ""atol could not be reached for 1 trajectories"". I am also seeing:. ""CompilerWarning: Non-empty compiler output encountered. Set the environment variable PYOPENCL_COMPILER_OUTPUT=1 to see more.; ""to see more."", CompilerWarning)"". ""AttributeError: 'NoneType' object has no attribute 'clobj__delete'; Exception ignored in: <object repr() failed>""",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-259602577:50,test,test,50,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-259602577,1,['test'],['test']
Testability,"I am going to give it a final test on Windows, then build into 4.0.2",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/609#issuecomment-270050370:30,test,test,30,https://qutip.org,https://github.com/qutip/qutip/pull/609#issuecomment-270050370,1,['test'],['test']
Testability,I am going to merge this now as I am sure it passes the tests,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/565#issuecomment-264018068:56,test,tests,56,https://qutip.org,https://github.com/qutip/qutip/pull/565#issuecomment-264018068,1,['test'],['tests']
Testability,I am guessing that the test has too low a tolerance. Also not sure about the two tests. Didnt see it a day or two ago.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/721#issuecomment-316063869:23,test,test,23,https://qutip.org,https://github.com/qutip/qutip/pull/721#issuecomment-316063869,2,['test'],"['test', 'tests']"
Testability,I am guessing that there is some issue removing td files in config. The test that you do should not be looking for a RHS file as the test is time-independent. Why this only happens on Win is an interesting question. I put up a fork that may work here:. https://github.com/nonhermitian/qutip/tree/config_reset_test. Let me know how it goes. It seemed to work on my Win7 VM. It basically removes the old td files from config every time it is not needed anymore. I am not sure why we did not do this before. It still needs to be checked that the rhs_reuse setting in the Options class still works.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/728#issuecomment-317316149:72,test,test,72,https://qutip.org,https://github.com/qutip/qutip/issues/728#issuecomment-317316149,2,['test'],['test']
Testability,"I am happy to merge into master, I only want to double check with @ajgpitch @quantshah about #964. ; All issues seem to be resolved and work fine. We (mainly @fminga) thoroughly tested the solver and now I am more than confident into merging it into master. If I understand correctly we can then move on to assess #990.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/991#issuecomment-498735002:178,test,tested,178,https://qutip.org,https://github.com/qutip/qutip/pull/991#issuecomment-498735002,1,['test'],['tested']
Testability,I am happy to merge it as it is but note that _the tests do not serve to catch the bug!_ I am not sure how to test it properly though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1805#issuecomment-1042865561:51,test,tests,51,https://qutip.org,https://github.com/qutip/qutip/pull/1805#issuecomment-1042865561,2,['test'],"['test', 'tests']"
Testability,I am happy to review this. ; Tests seem to be failing with:; ```; ERROR: Failure: ModuleNotFoundError (No module named 'piqs'); ```; Perhaps this could be fixed first,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-361266618:29,Test,Tests,29,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-361266618,1,['Test'],['Tests']
Testability,I am happy with what @jakelishman has done with the tests. I think this is sufficient for now. I agree with @nathanshammah suggestion that we can raise the failing cases with cvxopt maintainers and see what options they suggest (or a fix maybe). So I think this issue can be closed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/874#issuecomment-635956702:52,test,tests,52,https://qutip.org,https://github.com/qutip/qutip/issues/874#issuecomment-635956702,1,['test'],['tests']
Testability,"I am hoping to save more time with ""not slow"", about a 3~4x faster. Maybe I will remove 3.6 to save more time. Other test that need mark will wait for #1181 for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604026374:117,test,test,117,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604026374,1,['test'],['test']
Testability,I am not completely familiar with black yet and how much it adheres to pep8 so I will keep that for a big PR some other time. Right now we can slowly start blacking our code for the new modules. . This PR passes all the tests so I will be happy to merge.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1046#issuecomment-529505406:220,test,tests,220,https://qutip.org,https://github.com/qutip/qutip/pull/1046#issuecomment-529505406,1,['test'],['tests']
Testability,"I am not using mpiexec when running the tests. I have done some more experimenting on my local machine. 1. If I install `mpi4py` with pip, I get the same problem on my machine (the test hangs, I can't even CTRL+C). The steps I have taken in detail are:; ```bash; conda create -n qutip-test-tmp python numpy scipy pytest; conda activate qutip-test-tmp; sudo apt install mpich libmpich-dev; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; (The `apt install` call is taken from the `mpi4py/setup-mpi` and without it, the installation fails. I `apt remove`d the packages again afterwards.). 2. Then I tried installing with conda as follows.; ```bash; conda create -n qutip-test2-tmp python numpy scipy pytest mpi4py; conda activate qutip-test2-tmp; pip install 'qutip[full] @ git+https://github.com/qutip/qutip.git@refs/pull/2296/head'; cd ~/miniconda3/envs/qutip-test2-tmp/lib/python3.12/site-packages/qutip/tests/; pytest --verbose --pyargs qutip.tests.solver.test_parallel; ```; Now things get even weirder. Here, `test_map` and `test_map_accumulator` pass, but `test_map_pass_error` hangs (I can get out with CTRL+C). 3. In my regular development environment, all tests pass without problem. I have no idea what the difference is between my regular environment and the one created in number 2. I will continue trying things out when I have time. In the end, I imagine the solution might be not to include `mpi4py` in the `extras` section, and only add it with conda in one or two test runs?. I recently had a good experience asking for help on the mpi4py discussion board, might do that again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803:40,test,tests,40,https://qutip.org,https://github.com/qutip/qutip/pull/2296#issuecomment-1907636803,11,['test'],"['test', 'test-tmp', 'tests']"
Testability,I am rerunning the tests that failed. Should pass unless we get unlucky twice.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/419#issuecomment-178980710:19,test,tests,19,https://qutip.org,https://github.com/qutip/qutip/pull/419#issuecomment-178980710,1,['test'],['tests']
Testability,"I am reviewing the pull request with @nathanshammah: ; - test on the latest notebook on Schrodinger cats produced expected results in comparable times;; - test on other bosonic models (where numerical instability may be present, `H.shape= (500, 500)`) gave expected results (checked with `mcsolve` of Qutip 4.3.1) and in agreement with semi-analytical results;; - I notice that the structure of the `Result.expect` class changes according to the option `average_states`: if `True`, the result is a ndarray of dimension `len(e_ops)`. If `average_states` is `False`, the array has dimension ntraj x `len(e_ops)`. ; This is in contrast with the previous choice for `mcsolve`, where the result for `average_states`: `True` where array of dimension 1 x`len(e_ops)`. Clearly, the option implemented makes more logical sense, but a deprecation warning may be better for backward compatibility. WIP: test on spin systems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/991#issuecomment-497358567:57,test,test,57,https://qutip.org,https://github.com/qutip/qutip/pull/991#issuecomment-497358567,4,"['log', 'test']","['logical', 'test']"
Testability,"I am trying to add some `.qasm` files to the folder `qutip/qutip/tests/qasm_files/` to use during test time. I thought it would be enough to add them to the `PACKAGE_DATA` variable in `setup.py` but that does not seem to work. Any ideas on how to make sure this folder is available during testing time? Beside this part, the PR is ready for review. @nathanshammah @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-655893373:65,test,tests,65,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-655893373,3,['test'],"['test', 'testing', 'tests']"
Testability,I am using Debian and when I build QuTiP with GCC 5 it passes all modules in qutip.tests. But with GCC 6 it gives a lot of errors in the tests. I am not sure if this is related to your problem @bastikr but hope it gives you some insight.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/681#issuecomment-292649790:83,test,tests,83,https://qutip.org,https://github.com/qutip/qutip/issues/681#issuecomment-292649790,2,['test'],['tests']
Testability,"I am using `mesolve` in the test now. I am not sure if that is considered a good style, since the test also depends on this function. I could also just hardcode the expected output. What do you think is better, @AGaliciaMartinez ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210:28,test,test,28,https://qutip.org,https://github.com/qutip/qutip/pull/1843#issuecomment-1086200210,2,['test'],['test']
Testability,"I am with the same problem. Note that the QuTiP version and the python version is different. I have installed the python via macports, but I have also tested in anaconda system. The problem is the same in the anaconda. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+3421bc5c; Numpy Version: 1.17.4; Scipy Version: 1.3.2; Cython Version: 0.29.14; Matplotlib Version: 3.1.1; Python Version: 3.8.0; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /opt/local/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/qutip-4.5.0.dev0+3421bc5c-py3.8-macosx-10.15-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.loggin",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:151,test,tested,151,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,1,['test'],['tested']
Testability,"I apologize to all for the delay, but I just added checks for regression on this issue. They currently fail due to a problem with `to_chi` and multiple qubits. ``` python; ======================================================================; ERROR: Failure: TypeError (Incompatible Qobj shapes); ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Anaconda\lib\site-packages\nose\loader.py"", line 251, in generate; for test in g():; File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\tests\test_qobj.py"", line 671, in test_dag_preserves_superrep; yield case, to_chi(qobj); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 435, in to_chi; return to_chi(to_choi(q_oper)); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 432, in to_chi; return choi_to_chi(q_oper); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 258, in choi_to_chi; return Qobj(B.dag() * q_oper * B, superrep='chi'); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\qobj.py"", line 455, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes. ----------------------------------------------------------------------; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/375#issuecomment-152945134:486,test,test,486,https://qutip.org,https://github.com/qutip/qutip/pull/375#issuecomment-152945134,2,['test'],"['test', 'tests']"
Testability,I asked @nwlambert to have a look at the memorycascade and tell us whether he thinks it is useful to keep and to help us come up with a test if it is.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2152#issuecomment-1506604844:136,test,test,136,https://qutip.org,https://github.com/qutip/qutip/pull/2152#issuecomment-1506604844,1,['test'],['test']
Testability,"I attempted to make `qobj` return an scalar for this case, as QuTiP 5 does, but that seems to be a no-go. Tens of tests start failing because QuTiP 4 doing things like:; ```python; (bra*ket).tr(); ```; or ; ```python; (bra*ket).data[0,0]; ```; Even thought fixing this is quite straightforward, I decided not to change it and open a PR to allow scalar-like qobj `**`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1691#issuecomment-947512829:114,test,tests,114,https://qutip.org,https://github.com/qutip/qutip/issues/1691#issuecomment-947512829,1,['test'],['tests']
Testability,"I believe that all permutation are run with `parametrize`. So the input (`qobj`) is compared to each outputs `(expected`), not just the matching one. Also the rotation matrix (`U = rand_unitary(3)`) must be constant. Here, at least 4 different random operators are created. Instead of `parametrize` and `yield` simply calling the function `case` would work:; ```; yield case(""Test Qobj: trunc_neg works for positive opers.""), \; rand_dm(5), method; ```; to; ```; case(rand_dm(5), method, None); ```; To keep the message, `assert_almost_equal` has a `err_msg` keyword to raise if the test fails. I do not believe the `yield` is the cause of the no cython fails. ps. I will make a branch of this PR and will add `mark` to prepare a subset of tests for faster testing #1147.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-571198523:376,Test,Test,376,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-571198523,4,"['Test', 'test']","['Test', 'test', 'testing', 'tests']"
Testability,"I believe that this is actually intentional, as random sampling of CPTP channels is implemented by the `rand_super_bcsz` and `to_kraus` functions. `rand_kraus_map` is useful for writing unit tests, but is not yet a part of the public API.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/473#issuecomment-222041567:191,test,tests,191,https://qutip.org,https://github.com/qutip/qutip/issues/473#issuecomment-222041567,1,['test'],['tests']
Testability,I can confirm that the failure in the CI occurs only on the `coverage` test environment and it disappears if we update scipy to 1.6,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-817211736:71,test,test,71,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-817211736,1,['test'],['test']
Testability,"I can get the same error on linux with:; ```; from qutip.testing import run; import multiprocessing as mp; mp.set_start_method('spawn'); run(); ```; It hangs on qutip/tests/test_mcsolve.py::test_MCTDFunc.; So maybe, set_start_method('fork') could probably fix the problem on mac.; Also this hang, both at console and jupyter:; ```; import multiprocessing as mp; mp.set_start_method('spawn'). def f(i):; return i+1. p = mp.Pool(); p.map(f, [1,2,3,4]); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1202#issuecomment-603919447:57,test,testing,57,https://qutip.org,https://github.com/qutip/qutip/issues/1202#issuecomment-603919447,2,['test'],"['testing', 'tests']"
Testability,"I can not imagine that that error would have much to do with a compiler change. Sometimes the tests fail for odd reasons and are fine if they get rerun. I will look into it tomorrow. . Paul . > On Feb 21, 2015, at 09:52, Dominic Meiser notifications@github.com wrote:; > ; > Ok makes sense. I will make that change over the weekend. Btw for whatever reason one of the builds failed in the most recent build:; > ; > https://travis-ci.org/qutip/qutip/jobs/51588003; > ; > Any idea what the problem is? Is this something I should be worried about?; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318#issuecomment-75411847:94,test,tests,94,https://qutip.org,https://github.com/qutip/qutip/pull/318#issuecomment-75411847,1,['test'],['tests']
Testability,"I can probably do it with [`unittest.mock.assert_called_once_with`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called_once_with), although I'm not sure what the etiquette is on using multiple different unittesting frameworks is, as I see this repo is `pytest`ed mostly. I guess `unittest` is part of the standard library so it should be okay?. I will add a commit with the unittest updated when I get the chance, though feel free to merge this 1-line fix as it might as well be in master now that it's been noticed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1322#issuecomment-659111222:37,mock,mock,37,https://qutip.org,https://github.com/qutip/qutip/pull/1322#issuecomment-659111222,4,"['Mock', 'mock']","['Mock', 'mock']"
Testability,"I carefully followed the instruction and installed qutip on an ubuntu system in windows. It seems the the only package I did not explicitly install is Python Headers.; After installing qutip and running the test, I got the following:; 634 passed, 6 skipped, 61 deselected, 2 xfailed, 959 warnings in 236.31s (0:03:56); qutip/tests/test_metrics.py::test_unitarity_known XFAIL [ 35%]; qutip/tests/test_metrics.py::test_unitarity_bounded XFAIL [ 35%]; qutip/tests/test_metrics.py::test_dnorm_bounded SKIPPED [ 35%]; qutip/tests/test_metrics.py::test_dnorm_qubit_known_cases SKIPPED [ 35%]; qutip/tests/test_metrics.py::test_dnorm_qubit_scalar SKIPPED [ 36%]; qutip/tests/test_metrics.py::test_dnorm_qubit_triangle SKIPPED [ 36%]; qutip/tests/test_metrics.py::test_dnorm_force_solve SKIPPED [ 36%]; qutip/tests/test_metrics.py::test_dnorm_cptp SKIPPED [ 36%]. 1. I am wondering how to solve these problems. 2. Do I need to worry about deselected and warnings? What should the normal output be if qutip is installed successfully?; As a beginner, I feel it is really challenging to install the package and be free of errors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1222#issuecomment-605556711:207,test,test,207,https://qutip.org,https://github.com/qutip/qutip/issues/1222#issuecomment-605556711,9,['test'],"['test', 'tests']"
Testability,"I changed the build matrix to; - gcc, python 2.7; - gcc, python 3.4; - clang, python 3.4. The compiler versions are gcc 4.6 and clang 3.4 (default on travis build machines).; For the latest commit all tests pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318#issuecomment-75440408:201,test,tests,201,https://qutip.org,https://github.com/qutip/qutip/pull/318#issuecomment-75440408,1,['test'],['tests']
Testability,"I changed the merge target from `qutip-5.0.X` to `master`. The `qutip-...` branches are for released version.; Could you merge the current master branch, we added fixes for the new numpy, scipy version and it should help tests to passes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2140#issuecomment-1610223257:221,test,tests,221,https://qutip.org,https://github.com/qutip/qutip/pull/2140#issuecomment-1610223257,1,['test'],['tests']
Testability,"I checked locally by intentionally making the tests fail, and the case descriptions do show up in failure logs correctly, so at least the hack works?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/417#issuecomment-179027129:46,test,tests,46,https://qutip.org,https://github.com/qutip/qutip/pull/417#issuecomment-179027129,2,"['log', 'test']","['logs', 'tests']"
Testability,"I completely agree with you that random tests really aren't the right way to go in general, but right now our problem is that basically QuTiP's entire testing suite is based on randomised tests, and that's an awful lot of technical debt to overcome any time soon :(. . The `dnorm` tests have historically been a huge problem, even though basically nobody's worked on `dnorm` for a long long time now (for context, see in particular #880 and #874). We don't actually even know if the failures in `dnorm` are deterministic and reproducible, although it turns out that I had a brief look into this when I joined as a GSoC student about a year ago... I don't remember doing it at all!. I know this is super inelegant and not the perfect method, but it's kind of a nasty trade-off - I don't have time to really dig into `dnorm` (a topic I know almost nothing about) to work out an appropriate solution to temperamental errors, we do want `dnorm` to be tested since we're shipping it, and the slight flakiness keeps causing us test suite failures about 1 in 10 times. I'm somewhat opposed to fixing the random seed because having the variance over several test runs does actually help us cover more ground (eventually) - fixing it to a ""known good"" seed actually seems to me to be more of a mask of potential problems than this. Of note: the pytest plugin I'm using reports the number of reruns it performed in the analysis at the bottom - they show up in a yellow alongside the ""skips"" and ""xfails"" - so it's not completely hidden. I'd love to have a property-based testing suite like hypothesis up and running - that definitely seems like the proper solution to this in the end. In the meantime, I'm open to swapping to a fixed random seed if you think that's much better - testing is one place where I'm really aware of my lack of formal experience in software engineering, so I'm basically just learning as I go.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227:40,test,tests,40,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227,9,['test'],"['test', 'tested', 'testing', 'tests']"
Testability,"I couldn't reproduce this with an install into a fresh `conda` environment, _but_ I did once see that same error when I tried to make an OpenMP and a non-OpenMP `qutip` coexist in the same environment. When that previously happened, the package actually worked, it just reported that error. My guess is that this happens if `pyximport.install()` has already been activated when `qutip` is imported, and consequently the test in `__init__.py` as to whether `qutip.cy.openmp.parfuncs` is importable causes this error. It should not be able to even attempt to import it _unless_ `pyximport` has been turned on, and if it's been turned on by something other than QuTiP, then it should fail with a `numpy` header file error instead (this is something we should probably fix too, but I've not noticed it before). Is there any chance you're importing or reimporting `qutip` in a Python session in which some other version of `qutip` is already imported (like in an IPython profile file)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1334#issuecomment-670003770:420,test,test,420,https://qutip.org,https://github.com/qutip/qutip/issues/1334#issuecomment-670003770,1,['test'],['test']
Testability,"I did some tests and ; 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian matrices) (c's version Ok); 2 - It happen when installing the scipy stack with pip but not when installing it with conda.; 3 - It depend on the problem size, 64 seems particularly bad, usually it fails on the second call.; 4 - I only got it in zheevr which is only used in `brmesolve`. But Nathan got it in other tests which use scipy's `eigh`.; 4 - It happen in scipy in the fortan version of lapack:. ```; import numpy as np; from scipy.linalg import eigh; H = random_hermitian(64); eigh(H) # Work fine; eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; ```. Possible solutions (for zheevr):. - Installing scipy with conda, the easiest solution, but not in our control.; - Finding a way to link clapack from cython. Linking scipy's one would require good knowledge of scipy internals since only one cython interface is provided. Linking to another installation of lapack, but it would require the user to install lapack or install it with qutip. Both seems wrong to me.; - For mac user, call scipy's eigh from cython i zheevr, slower but better than risking segfault.; - Have the code directly in qutip. We can adapt it from OpenBlas: https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492:11,test,tests,11,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492,2,['test'],['tests']
Testability,"I discovered that we were missing a small bit of towncrier configuration, so I added this test that does a trial run of generating the changelog. In addition to checking that the changelog can be generated, it also outputs the draft so that reviewers can look at it if they like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480:90,test,test,90,https://qutip.org,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480,1,['test'],['test']
Testability,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:148,test,testing,148,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791,10,['test'],"['test', 'testing', 'tests']"
Testability,"I don't know if the test failure is related or not -- it *looks* unrelated but it is a data layer test, so we should probably check a bit carefully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-892573255:20,test,test,20,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892573255,2,['test'],['test']
Testability,"I don't know if this is helpful, but I can get a different error if I first `import numpy`:. ```; >>> import numpy; >>> import qutip.testing as qt; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-113235398:133,test,testing,133,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-113235398,1,['test'],['testing']
Testability,"I don't know, since jax is developed by google I expect it to work well with gpus it provide through collab... We don't use schur decomposition for mesolve directly. I think it's the integrator from diffrax that does, if not it could be the norm (it's using trace norm which call sqrtm instead of trace, fixed in #2408). Maybe trying other ODE solver or not normalizing would work. Neill seems to have run most of his test using dopri:. ```; from diffrax import Dopri5, PIDController. options = {; ""method"": ""diffrax"",; ""normalize_output"": False,; ""stepsize_controller"" : PIDController(rtol=1e-8, atol=1e-6), # This is now the default.; ""solver"": Dopri5(),; }; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078:418,test,test,418,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-2090722078,1,['test'],['test']
Testability,"I don't think that this is ready quite yet, but it's getting significantly closer. I want to add some more dnorm() tests for known cases, since the current known cases are all fairly trivial. I'd also like to add the difference of two unitaries trick for fast dnorm() calculations, since that will be an especially common case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/456#issuecomment-197591071:115,test,tests,115,https://qutip.org,https://github.com/qutip/qutip/pull/456#issuecomment-197591071,1,['test'],['tests']
Testability,"I don't think that type checking should be done in the mcsolver. Instead we should just unit test the operators themselves. The reason that this happened is because we bypassed the checks done by the Qobj class by operating on the underlying data itself. For most users, this will never be an issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/209#issuecomment-51128352:93,test,test,93,https://qutip.org,https://github.com/qutip/qutip/issues/209#issuecomment-51128352,1,['test'],['test']
Testability,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:271,test,test,271,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921,4,['test'],['test']
Testability,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:754,test,test,754,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515,1,['test'],['test']
Testability,"I don't think we need a fix for master, I haven't seen the test fail yet. ; In master, we create the file in the active directory and use pyx import. So the absolute path should never be used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1975#issuecomment-1218012520:59,test,test,59,https://qutip.org,https://github.com/qutip/qutip/pull/1975#issuecomment-1218012520,1,['test'],['test']
Testability,"I don't want to approve or block it.; I can't understand the template so I don't know if the generated changelog will be useful for release.; And the tests don't pass... Personally the issue number as the tag looks good to me. Yes we have many PRs without issues, but it may be a good idea to open them just to tell other what we are working on and it's easier for first time contributor who take a `good first issue`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927#issuecomment-1159098604:150,test,tests,150,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159098604,1,['test'],['tests']
Testability,"I finally got a chance to test the intel MKL on my workstation with 12 cores. For larger systems I ma getting about a 6x speed-up. On the previous system it was 4 cores, but showed only a ~2x speed up. So for many core systems, I do see noticeable improvement when the Hilbert space becomes large.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/438#issuecomment-186747186:26,test,test,26,https://qutip.org,https://github.com/qutip/qutip/issues/438#issuecomment-186747186,1,['test'],['test']
Testability,"I fixed steadystate tests:; - `_permute` use numpy array, @AGaliciaMartinez is looking to fix the data layer function.; - Lowered the precision required for `test_exact_solution_for_simple_methods`. The test looked for `1e-16 +/- 1e-16` and most calls returned `0`. Most methods cannot match this precision and can fail from numerical error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212:20,test,tests,20,https://qutip.org,https://github.com/qutip/qutip/pull/1850#issuecomment-1097177212,2,['test'],"['test', 'tests']"
Testability,"I fixed the BoFiN test, but I'm a little bit worried that it might be common for people to accidentally write `dims=[2, 2]` instead of `dims=[[2], [2]]`, for example, and that with the call to `np.hstack(dims[0])` this will now raise a TypeError, because `np.hstack` must be called with a list. I.e. we are also forcing `dims[0]` and `dims[1]` to be lists, which is not something we checked before.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1783#issuecomment-1028022762:18,test,test,18,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028022762,1,['test'],['test']
Testability,"I fixed this and added the feature for the 2op 2t function that uses the me solver. It should be fine, but I'm going to need to think for a bit to come up with a good test/check, but it appears to behave like I would expect (from 2D plots). I'll add the notebook at some point next week/update the docs?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/206#issuecomment-52936076:167,test,test,167,https://qutip.org,https://github.com/qutip/qutip/pull/206#issuecomment-52936076,1,['test'],['test']
Testability,"I get the not the docstring but the function name. `verbosity=2` also give the test file full path, but not the docstring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-574221111:79,test,test,79,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-574221111,1,['test'],['test']
Testability,"I get the same issue on a [Travis CI build](https://travis-ci.org/github/qutech/filter_functions/jobs/757061484) with; ```; Distributor ID:	Ubuntu; Description:	Ubuntu 16.04.6 LTS; Release:	16.04; Codename:	xenial; ```; running on `amd64` with `qutip-4.5.2` installed via `pip`. The same test config runs fine on Python 3.6 and 3.7, though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-777523352:288,test,test,288,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-777523352,1,['test'],['test']
Testability,I got a hard crash (segfault?) on macOS 10.14 but not on macOS 10.13: xcode10 vs xcode11.2; We should wait a bit more for tests python 3.8,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1125#issuecomment-552629094:122,test,tests,122,https://qutip.org,https://github.com/qutip/qutip/pull/1125#issuecomment-552629094,1,['test'],['tests']
Testability,I guess I need to edit the tests to match the new function behavior.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/528#issuecomment-243330602:27,test,tests,27,https://qutip.org,https://github.com/qutip/qutip/pull/528#issuecomment-243330602,1,['test'],['tests']
Testability,I guess this was the ZVODE error in the mcsolve_f90 tests?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/197#issuecomment-49157591:52,test,tests,52,https://qutip.org,https://github.com/qutip/qutip/pull/197#issuecomment-49157591,1,['test'],['tests']
Testability,"I guess you need to fix the merge conflict before the tests can run. I won't have time to look through this today, so there's plenty of time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1444#issuecomment-810110009:54,test,tests,54,https://qutip.org,https://github.com/qutip/qutip/pull/1444#issuecomment-810110009,1,['test'],['tests']
Testability,"I had a bit more success by switching as much as possible in the setup of the testing environment to pip:; ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y numpy scipy cython; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install -e .; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install nose ipython; ~~~; I also added a `unittest.skipIf` decorator to `qutip/tests/test_stochastic_se.py:test_smesolve_homodyne_methods`, which is the only test that consistently fails on `master`. With this, the test suite runs through about 50% of the time. The other 50% it crashes with the following:; ~~~; ...; PIQS: Test the warning for diagonal Hamiltonians to use internal solver. ... ok; Propagator: HO ('single mode') ... ok; Propagator: HO ('batch mode') ... ok; Propagator: HO parallel ... ok; Propagator: str td format ... ok; Propagator: func td format ... ok; Propagator: steady state ... python(52709,0x10fc1f5c0) malloc: Incorrect checksum for freed object 0x7fcbf338af10: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(52709,0x10fc1f5c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ~~~",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378:78,test,testing,78,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378,5,"['Test', 'test']","['Test', 'test', 'testing', 'tests']"
Testability,"I had a quick look at this since i was benchmarking expm() anyway. Essentially I think the issue is your A operator is diagonal, and in 4.7 there is a check that notices it is diagonal, and quickly returns the result. In v5, there is a similar check for sparse matrices, but the default behavior is to convert to dense, so the check is not done. if you use expm(dtype=""CSR"") the v5 example should be quick (with the caveat that the result is nan in both 5 and 4.7). I guess we need to add a check for diagonality for dense cases too. edit:; @hodgestar pointed out that A.to(""dense"") helps too, so I guess it is just; https://github.com/qutip/qutip/blob/fccec5d60e396c964627664bff85a22901adb85a/qutip/core/data/expm.py#L40; which needs a diagonality check?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2115#issuecomment-1463773076:39,benchmark,benchmarking,39,https://qutip.org,https://github.com/qutip/qutip/issues/2115#issuecomment-1463773076,1,['benchmark'],['benchmarking']
Testability,"I had actually tried that before, following the user guide for conda, but it didn't work. Seems that it was fixed in a conda update, though, as it works fine now. Thanks! Will use that to test installation instructions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-150990762:188,test,test,188,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-150990762,1,['test'],['test']
Testability,I had seen the tests folder and I have given some thought to what we can add to test the control modules. As you suggest I will add something based on the notebooks. I guess I should do this as a separate pull request.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/281#issuecomment-66294867:15,test,tests,15,https://qutip.org,https://github.com/qutip/qutip/pull/281#issuecomment-66294867,2,['test'],"['test', 'tests']"
Testability,"I had some issues with python3 on my OS X (it dislikes my python2 and vice versa), so I didn't test it for python3. Otherwise, it should be fine and merge-ready. Great thanks for your help! . (I have a few more ideas, but for other plots, so let they come as separate issues.). With respect to the IPython Notebook demonstrating visualizations - definitely I should prepare (or rather: polish) one of two.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/105#issuecomment-43785864:95,test,test,95,https://qutip.org,https://github.com/qutip/qutip/pull/105#issuecomment-43785864,1,['test'],['test']
Testability,"I had to move faster and complete the full implementation in a rather quick and unstructured manner for my lab. I will finish it and then systematically build this PR so that it becomes easy for review. I have a working implementation of the ICM model now and a partial implementation of [Pauli tracking](https://www.date-conference.com/files/proceedings/2014/pdffiles/05.6_7_ip2-19.pdf) which pushes all the corrections and measurement to the end of the circuit.; ### Circuit with a rotation gate (V gate). ![v](https://cloud.githubusercontent.com/assets/6968324/21744357/3fe6c324-d557-11e6-8829-7202ff6d3760.png). ### Pauli tracked ICM representation of circuit. ![v_p](https://cloud.githubusercontent.com/assets/6968324/21744360/48959432-d557-11e6-8a5e-02b47b33698f.png). Thus, we get a quantum circuit with qubit initializations in the begining, a mesh of CNOT gates in the middle and measurements in the end. This seems to be very useful as the starting point of topological quantum circuit optimization. Future work: . 1. Represent qubit initializations in some way. Right now I consider everything as a gate. (Perhaps make new objects for qubit intializations, measurement, correction etc.). 2. Better visualization such that all initializations, measurements and corrections can be stacked in one line. 3. Representing the information regarding P_dagger, T_dagger, V_dagger gate teleportation in some way. The difference is just based on the interpretation of the measurement. 4. Complete the Pauli tracking algorithm to get the gate sequence for correction based on measurement. Tests, tests and more tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-271102783:1588,Test,Tests,1588,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-271102783,3,"['Test', 'test']","['Tests', 'tests']"
Testability,I have a branch with int64 matrice that pass all tests except the mkl ones which are skipped. ; https://github.com/Ericgig/qutip/tree/long,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-420798144:49,test,tests,49,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-420798144,1,['test'],['tests']
Testability,"I have a couplle of questions to understande better the difference between using `assert_all_close`, `assert` and `assert_equal`. ; In this case you changed `assert_all_close` to `assert` because of the time difference right? ; Why are the other tests in the same file using `assert_equal` instead of `assert` ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-822708414:102,assert,assert,102,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-822708414,4,"['assert', 'test']","['assert', 'tests']"
Testability,I have added 4 IPython notebooks for testing too.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/246#issuecomment-63363264:37,test,testing,37,https://qutip.org,https://github.com/qutip/qutip/pull/246#issuecomment-63363264,1,['test'],['testing']
Testability,I have added a development notebook to test this pull-request.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/338#issuecomment-95258458:39,test,test,39,https://qutip.org,https://github.com/qutip/qutip/pull/338#issuecomment-95258458,1,['test'],['test']
Testability,"I have added the unit tests and moved the old ptrace to a new 'legacy' folder. . The permute method for Qobj's has a similar routine to those for selecting indices in ptrace. I have switched that code to the new ptrace functions as well, but there is some additional cleanup that needs to be done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/634#issuecomment-272784039:22,test,tests,22,https://qutip.org,https://github.com/qutip/qutip/pull/634#issuecomment-272784039,1,['test'],['tests']
Testability,I have been trying out pytest for the last couple of days and we can start by using it for the testing as it is now. We need to replace installation [lines](https://github.com/qutip/qutip/blob/master/.travis.yml#L23) like this in the .travis.yml file to install pytest:; ```; conda install mkl blas=*=mkl numpy scipy pytest cython coveralls pytest-cov; ```. and then change the runner script to use pytest instead of `nose` by changing:; ```; nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ```; to; ```; pytest --verbosity=1 --cov=qutip qutip; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/958#issuecomment-480825870:95,test,testing,95,https://qutip.org,https://github.com/qutip/qutip/issues/958#issuecomment-480825870,1,['test'],['testing']
Testability,I have built this branch and tested on my linux machine here. All tests pass.; I am assuming that you need to make another commit before it's ready for me to test on Windows?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/648#issuecomment-280327735:29,test,tested,29,https://qutip.org,https://github.com/qutip/qutip/pull/648#issuecomment-280327735,3,['test'],"['test', 'tested', 'tests']"
Testability,"I have corrected the code for compound systems and added tests for two and three qubits. I am not sure about which is the best place for this function, I made it to solve the Issue #2340. If you consider it fits better in a different place I will be happy to modify it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2545#issuecomment-2417329528:57,test,tests,57,https://qutip.org,https://github.com/qutip/qutip/pull/2545#issuecomment-2417329528,1,['test'],['tests']
Testability,"I have finally gotten around to look at this. Compared to usual ODE evolution, the expm_multiply (as of SciPy 0.18) is over an order of magnitude slower when testing against simple harmonic oscillator evolution. Profiling showed that the inf and one norms were the main issue as they cannot call BLAS functions for complex numbers. I wrote Cython versions that were ~5x faster. The next profile suggested replacing the dot calls with our own spmv. All together, I could get a factor of 3x improvement over the base SciPy code, but the spmv is still the dominate time consumer, so there is nothing further I could do to speed things up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/84#issuecomment-242475532:158,test,testing,158,https://qutip.org,https://github.com/qutip/qutip/issues/84#issuecomment-242475532,1,['test'],['testing']
Testability,"I have just finished testing with Vs 2015 as well (win10, Python 3.5). All passed.; I feel this is a momentous occasion. Great work!; I think this is worthy of a 4.1 release. Very keen to get working conda package for Windows out there",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/648#issuecomment-281725155:21,test,testing,21,https://qutip.org,https://github.com/qutip/qutip/pull/648#issuecomment-281725155,1,['test'],['testing']
Testability,"I have just installed qutip using the master branch. When running the tests script test_steadystate.py, I receive a similar violation as above. . ```python; packages\qutip\qutip\steadystate.py:275: in steadystate; return _steadystate_direct_sparse(A, ss_args); packages\qutip\qutip\steadystate.py:442: in _steadystate_direct_sparse; v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; packages\qutip\qutip\_mkl\spsolve.py:393: in mkl_spsolve; x = lu.solve(b, verbose=verbose); OSError: exception: access violation reading 0x00000000000000C4; packages\qutip\qutip\_mkl\spsolve.py:167: OSError; ```; Is this a known bug with windows, or is there a fix?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1077#issuecomment-653144199:70,test,tests,70,https://qutip.org,https://github.com/qutip/qutip/issues/1077#issuecomment-653144199,1,['test'],['tests']
Testability,I have just successfully installed qutip using pip into a fresh conda env (python=3.6) on Linux Mint. I believe this Mint is pretty much identical to Ubuntu.; All dependencies were installed automatically. qutip tests run fine.; So I don't think that there is anything wrong with our setup configuration.; Note we do not recommend installing qutip into a system python env - especially on Linux.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/739#issuecomment-323319515:212,test,tests,212,https://qutip.org,https://github.com/qutip/qutip/issues/739#issuecomment-323319515,1,['test'],['tests']
Testability,"I have managed to reproduce.; It would that conda is currently installing an openblas version of numpy even when `mkl` version is set. I guess this is a mistake by Anaconda that they will fix soon. Probably because they rushed the fix for #871 ; This means that the 'metrics' tests with ""known issues"" are not skipped.; What does not make sense is why the 'NOMKL' tests are failing. Some questions:; - why do we install a specific version cvxopt in our test build?; - These ""known issues"" must be quite old, so perhaps may have been fixed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/872#issuecomment-394194142:276,test,tests,276,https://qutip.org,https://github.com/qutip/qutip/issues/872#issuecomment-394194142,3,['test'],"['test', 'tests']"
Testability,"I have not put any tests in for this, because it seems like a lot of effort for something that is used as a kind of testing tool anyway. When I make my PR for the hsolve enhancements, including tests, this file will get pretty reasonable coverage.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454#issuecomment-193176693:19,test,tests,19,https://qutip.org,https://github.com/qutip/qutip/pull/454#issuecomment-193176693,3,['test'],"['testing', 'tests']"
Testability,I have raised the issue with anaconda; https://github.com/ContinuumIO/anaconda-issues/issues/9500. I think we should suspend the NOMKL tests until there is a fix (from them),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/871#issuecomment-393925753:135,test,tests,135,https://qutip.org,https://github.com/qutip/qutip/issues/871#issuecomment-393925753,1,['test'],['tests']
Testability,"I have rebased to pick up all the recent bug fixes. Hopefully this will mean this will pass all the tests now.; I have been using the new features quite a lot, so I will squash and merge if this passes the tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/478#issuecomment-223043013:100,test,tests,100,https://qutip.org,https://github.com/qutip/qutip/pull/478#issuecomment-223043013,2,['test'],['tests']
Testability,"I have replicated this. The hardcode num_waves seems a bit spurious. I think it is best to delete it altogether. It does mean that it breaks backward compatibility, but I can't why anyone would rely on this (or why I coded it that way in the first place). I am working on unit tests for this now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/412#issuecomment-170951539:277,test,tests,277,https://qutip.org,https://github.com/qutip/qutip/issues/412#issuecomment-170951539,1,['test'],['tests']
Testability,"I have seen this quite a bit in the tests. Calling the code outside of the test always works. So it could be the test suite, which is based on the out of date nose, needs to be updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458154837:36,test,tests,36,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458154837,3,['test'],"['test', 'tests']"
Testability,"I have some slight reservations about the copying around of the tidyup logic in the CSR methods, but it's not in too many places so far, so I'm happy with the duplication for now. If we get more copies, I would recommend we define an inline method that does the `if real < tol: ... if imag < tol: ...` dance for us.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1615#issuecomment-894223373:71,log,logic,71,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-894223373,1,['log'],['logic']
Testability,I have tested an OPENMP version of the zcsr_kron function and there is not much to gain overall when compared to the serial version.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/530#issuecomment-243980181:7,test,tested,7,https://qutip.org,https://github.com/qutip/qutip/pull/530#issuecomment-243980181,1,['test'],['tested']
Testability,"I have tried on Win7x64 using anaconda. ; under Python2.7:; I found qutip would install, and most things would work. However there were many warnings when running tests and occurrences of python.exe crashing; under Python 3.5; I found qutip would install. However nothing much would run, e.g. issues importing spmatfuncs when creating a Qobj",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-148701161:163,test,tests,163,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-148701161,1,['test'],['tests']
Testability,"I haven't personally tested this, but it looks fine to me. Thanks for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/783#issuecomment-351775139:21,test,tested,21,https://qutip.org,https://github.com/qutip/qutip/pull/783#issuecomment-351775139,1,['test'],['tested']
Testability,"I haven't run into that failure before, but I've only tried on Windows 8.1; and 10 so far. Do you have a console log for a python.exe crash?. On Fri, Oct 16, 2015 at 11:14 PM Alexander Pitchford <; notifications@github.com> wrote:. > I have tried on Win7x64 using anaconda.; > under Python2.7:; > I found qutip would install, and most things would work. However there; > were many warnings when running tests and occurrences of python.exe crashing; > under Python 3.5; > I found qutip would install. However nothing much would run, e.g. issues; > importing spmatfuncs when creating a Qobj; > ; > —; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/377#issuecomment-148701161.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-148703467:113,log,log,113,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-148703467,2,"['log', 'test']","['log', 'tests']"
Testability,I just added a dummy commit to trigger the tests,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/915#issuecomment-434057248:43,test,tests,43,https://qutip.org,https://github.com/qutip/qutip/pull/915#issuecomment-434057248,1,['test'],['tests']
Testability,"I just cleaned up a tool I used when making the jax data layer, but I don't want to add something that will ask for our time to maintain, thus no test or coverage. In this meaning, it doesn't seems belong here. I am closing this and making a new one with just the missing specializations + will check if they were also skipped in test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2132#issuecomment-1481288399:146,test,test,146,https://qutip.org,https://github.com/qutip/qutip/pull/2132#issuecomment-1481288399,2,['test'],['test']
Testability,"I just realize that test in qutip-qip won't work because this has to be merged and released first. The code looks fine to me. Will test it locally later. @hodgestar Just to get a second opinion, what do you think about this? As it could also be used by further family packages like control.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998:20,test,test,20,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1104475998,2,['test'],['test']
Testability,"I just tidied up the branch with a rebase.; Tests are all passing except in the NOMKL build - this is not related, see #871 . I think this should be merged. @nonhermitian @sahmed95 please could someone check and merge if you agree",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/870#issuecomment-393877287:44,Test,Tests,44,https://qutip.org,https://github.com/qutip/qutip/pull/870#issuecomment-393877287,1,['Test'],['Tests']
Testability,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:56,test,test,56,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663,3,['test'],['test']
Testability,"I know you've marked this as draft, but let me point out that you've not really aligned your `master` with ours after the merge (one of the reasons it's not a good idea to develop using `master`). You've merged in the changes from our branch, but really you needed to overwrite your local copy with ours; I squashed the previous PR down into just one commit to keep the commit log cleaner and easier to interpret. In this sort of triangular workflow where you're proposing PRs that might not be merged as-is, you need to treat our repository as the single source of truth - you should never change your `master` branch except by doing `git pull` to our repository, so you can't get out of sync. Since you've now developed on the top of an incorrect tip, it'll be a bit difficult for you to untangle if you're not very familiar with `git`. You _can_ do it with rebasing or cherry-picking techniques to keep what you've done, but in this particular case (and there's no way you could have known this), I was actually just about to publish PR #1490 that makes all these same changes in `test_metrics.py`, but also goes a lot further in rewriting the tests in a more pytest-y style. It might be better for you if you reset your repository to match ours exactly, and then start again using the proper branching structure for the superoperator and tensor tests you wanted to look at. Perhaps you could have a look at #1490 as well to see how I go about parametrising tests and organising everything to keep it tidy (not saying that my code is perfect by a long shot, and the concept of ""random"" tests is questionable overall, but it's what we've got at the moment). Remember as well that readibility is a big concern. Using an automated tool to enforce pep8 compliance often won't get you the best results - our real style requirement is that it's easy to read, so linebreaks should be in sensible places (that still abide by pep8).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-814998778:377,log,log,377,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-814998778,5,"['log', 'test']","['log', 'tests']"
Testability,"I looked at the failures and they seem to be in parts that are completely disconnected from logging. I have no idea why they aren't also in the main branch, but I'll investigate. Anyway, I agree with you, @jrjohansson, that the current implementation is not in keeping with the design of Python's logging package. At the time, it was a bit of a hack to try and make it fit as well as possible, but I think in retrospect that may have been misguided. Do you think the refactoring to more appropriately use Python logging would be a good 3.2.0 feature, or would you suggest that for ≥ 3.3? Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/379#issuecomment-147493646:92,log,logging,92,https://qutip.org,https://github.com/qutip/qutip/pull/379#issuecomment-147493646,3,['log'],['logging']
Testability,"I made some benchmarks timing different way to call matmul and contouring the dispatcher is worth it. ; For 10x10, CRS x Dense, it's 4x slowdown for matmul and 2x for expect.; For 1000 x 1000, it's 10% and 5%, reasonable but still felt. The easiest would be having `matmul(self, Dense in, Dense out)` method for Data layer. There is no need for all pairs of layer types to be supported by this, states in scipy's solver are always Dense. But it's a little late for that. Not having that, since 99% of users will use our data type and we only really need it for `matmul` and `expect`, we can so a manual disptach for just those. The way I did it was quite ugly, I wanted to limit the calls to `isinstance` which are not proper cython so did it once moving the type. I did not think of `type`...; `type(op) is CSR` is 15x faster than `isinstance(op, CSR)` and about as fast as comparing for enums, making have `layer_type` useless. Renamed it to `matmul_data_dense_dense` in matmul.pyx.; Still short of a c dispatcher for function pointers, but I am not attacking this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1407#issuecomment-747703407:12,benchmark,benchmarks,12,https://qutip.org,https://github.com/qutip/qutip/pull/1407#issuecomment-747703407,1,['benchmark'],['benchmarks']
Testability,I made some pep8 fixes since we are revisiting this code after a long time. Is it okay to merge this even when the MKL build fails? Or should this test be disabled on MKL and then we merge this PR?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/870#issuecomment-394056250:147,test,test,147,https://qutip.org,https://github.com/qutip/qutip/pull/870#issuecomment-394056250,1,['test'],['test']
Testability,"I made some tests with this PR and ran into one problem: the iscptp is very computationally demanding for large system, so it cannot be used in the `__str__` and `_latex_repr_`, because it prevents large systems from being displayed. Also, whether a super operator is CPTP is not always relevant so it does not need to be shown in every printed Qobj. Also, superrep should probably only be displayed if it is not 'super' (to avoid both type and superrep duplicating the same information),",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/90#issuecomment-37786513:12,test,tests,12,https://qutip.org,https://github.com/qutip/qutip/pull/90#issuecomment-37786513,1,['test'],['tests']
Testability,"I managed to get all the tests working on Win7 x64 using Anaconda and mingw in the manner that Chris suggested. However, one caveat is that the user name for the installation can not have any spaces in it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-150083795:25,test,tests,25,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-150083795,1,['test'],['tests']
Testability,I marked a few spot where the seed was applied more than once.; The failed test is a known issue.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-468400582:75,test,test,75,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-468400582,1,['test'],['test']
Testability,I need to fix (or hide) some warning given out by the integrator during the test. I will do that before I merge,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/455#issuecomment-194686130:76,test,test,76,https://qutip.org,https://github.com/qutip/qutip/pull/455#issuecomment-194686130,1,['test'],['test']
Testability,I never saw the test failure in `test_zheevr`. That's odd - I thought we'd merged a change that fixed that. I certainly haven't seen one for a very long time personally - it's all `test_diag_liou_mult`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1446#issuecomment-805888167:16,test,test,16,https://qutip.org,https://github.com/qutip/qutip/pull/1446#issuecomment-805888167,1,['test'],['test']
Testability,"I notice that all tests, including MacOS, past on this!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/957#issuecomment-469722557:18,test,tests,18,https://qutip.org,https://github.com/qutip/qutip/pull/957#issuecomment-469722557,1,['test'],['tests']
Testability,"I notice that our mkl tests are not running with the mkl version of numpy.; This has been reported by others; https://github.com/ContinuumIO/anaconda-issues/issues/9519. Solution copied here for convenience:; ""please install blas=*=mkl to remedy this. Sorry for the confusion. We're working on better ways to select package variants, and we're having some growing pains.""",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/875#issuecomment-394669389:22,test,tests,22,https://qutip.org,https://github.com/qutip/qutip/pull/875#issuecomment-394669389,1,['test'],['tests']
Testability,"I noticed this recently while addressing an issue for which the test of `average_gate_fidelity` was failing when the random supermatrix included an odd dimensional object. I had your same impression but was unsure of the proper function. I am pinging @BoxiLi and @quantshah to keep an eye on this, if they are knowledgeable, in the future months. Thank you @lucainnocenti, and if you think that your fix is fine, please open directly a pull request.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/869#issuecomment-497300028:64,test,test,64,https://qutip.org,https://github.com/qutip/qutip/issues/869#issuecomment-497300028,1,['test'],['test']
Testability,"I now noticed that the tests failed because of the added warnings. Unsure how to handle this, could add `@pytest.mark.filterwarnings('ignore::UserWarning')` to the tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2234#issuecomment-1740361085:23,test,tests,23,https://qutip.org,https://github.com/qutip/qutip/pull/2234#issuecomment-1740361085,2,['test'],['tests']
Testability,"I only have doubt about the 'other' form. Does that mean that issues cannot be open without using a template? Having the changelog in the PR is the best I believe. The file in qutip-doc can be undated at each release. A file in qutip could create a lot of conflict since each PR would have to add something at the end of 1 file and a lot of PR would be waiting on it. The same way we have good PR that are only waiting for a test to be added before merging. In the pull request template, I would mention the need for tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1198#issuecomment-602628987:425,test,test,425,https://qutip.org,https://github.com/qutip/qutip/pull/1198#issuecomment-602628987,2,['test'],"['test', 'tests']"
Testability,"I opened an issue https://github.com/scipy/scipy/issues/3424 for this, but it will probably not happen unless a PR mysteriously appears at the doorstep. Also consider that combinations of {linux, pc, mac} x {32 bit OS, 64 bit} x {small matrices (< 2^31 rows, cols, nnz), big matrices} will probably have to be tested somehow. Getting sparse matrix algorithms to work on all these combinations seems to have been a sticking point in the recent scipy release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36465061:310,test,tested,310,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36465061,1,['test'],['tested']
Testability,"I prefer smaller PRs, this is big enough.; Continue in another one please.; I will put the test to a to check list and review it when working on `brmesolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1351#issuecomment-680228966:91,test,test,91,https://qutip.org,https://github.com/qutip/qutip/pull/1351#issuecomment-680228966,1,['test'],['test']
Testability,"I ran the full tests on Windows 10. All passed except 1. Trace as follows:; ```; ======================================================================; FAIL: Monte-carlo: Collapse terms constant (str format); ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-dev-py36\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Anaconda2\envs\q4_2-dev-py36\lib\site-packages\qutip-4.3.0.dev0+6915aee-py3.6-win-amd64.egg\qutip\tests\test_mcsolve.py"", line 326, in test_MCSimpleConstStr; assert_equal(avg_diff < mc_error, True); File ""C:\Anaconda2\envs\q4_2-dev-py36\lib\site-packages\numpy\testing\utils.py"", line 416, in assert_equal; raise AssertionError(msg); AssertionError:; Items are not equal:; ACTUAL: False; DESIRED: True; -------------------- >> begin captured stdout << ---------------------; 10.0%. Run time: 8.27s. Est. time left: 00:00:01:14; 20.0%. Run time: 10.17s. Est. time left: 00:00:00:40; 30.0%. Run time: 12.19s. Est. time left: 00:00:00:28; 40.0%. Run time: 14.11s. Est. time left: 00:00:00:21; 50.0%. Run time: 16.05s. Est. time left: 00:00:00:16; 60.0%. Run time: 18.03s. Est. time left: 00:00:00:12; 70.0%. Run time: 19.99s. Est. time left: 00:00:00:08; 80.0%. Run time: 21.94s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.94s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.87s. Est. time left: 00:00:00:00; Total run time: 25.99s. --------------------- >> end captured stdout << ----------------------. ----------------------------------------------------------------------; Ran 488 tests in 2700.806s. FAILED (SKIP=9, failures=1); >>>; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/729#issuecomment-317797935:15,test,tests,15,https://qutip.org,https://github.com/qutip/qutip/pull/729#issuecomment-317797935,7,"['Assert', 'test']","['AssertionError', 'test', 'testing', 'tests']"
Testability,"I re-launched the Travis tests on all platforms. They pass for all besides Mac OS (similar error as for other PR). With `python setup.py install`, with `install` instead of `develop`, things seem to work. What it is unclear to me is why it reads that the QuTiP Version is `4.4.0.dev0+1a639d7a`, when I could not find this hash in here (or maybe I am confused). Now, after some tries with install and develop, I am on that version of qutip-dev. . To begin with, I am running the contents of the [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). Some comments below are relevant to the PR of the notebooks, https://github.com/qutip/qutip-notebooks/pull/71. * `development-qobjevo.ipynb`: Runs fine. ; * `development-qobjevo-adv.ipynb`: Runs fine. ; * `development-qobjevo-timing.ipynb`: Runs fine. * The notebook [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb) could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:25,test,tests,25,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,1,['test'],['tests']
