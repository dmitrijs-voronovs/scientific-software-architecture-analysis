quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,";  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGTextEditCommand; TGTextEdit * fEdit;  ; TGLongPosition fPos;  . Inheritance diagram for TDelCharCom:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDelCharCom(). TDelCharCom::TDelCharCom ; (; TGTextEdit * ; te). inline . Definition at line 117 of file TGTextEdit.cxx. Member Function Documentation. ◆ Notify(). Bool_t TDelCharCom::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 122 of file TGTextEdit.cxx. Member Data Documentation. ◆ fChar. char TDelCharCom::fChar. private . Definition at line 114 of file TGTextEdit.cxx. gui/gui/src/TGTextEdit.cxx. TDelCharCom. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDelCharCom.html:10454,load,load,10454,doc/master/classTDelCharCom.html,https://root.cern,https://root.cern/doc/master/classTDelCharCom.html,2,['load'],['load']
Performance,";  ; static int WinNTUnixConnect (int port);  Connect to a Unix domain socket. ;  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  . Private Member Functions; Bool_t CheckDescriptors ();  Check if there is activity on some file descriptors and call their Notify() member. ;  ; Bool_t CheckSignals (Bool_t sync);  Check if some signals were raised and call their Notify() member. ;  ; Bool_t CollectGroups ();  ; Bool_t CollectMembers (const char *lpszGroupName, int &groupIdx, int &memberIdx);  ; Bool_t CountMembers (const char *lpszGroupName);  ; Bool_t DispatchTimers (Bool_t mode);  Handle and dispatch timers. ;  ; void DoBeep (Int_t freq=-1, Int_t duration=-1) const override;  Beep. ;  ; void FillWithHomeDirectory (const char *userName, char *mydir) const;  Fill buffer with user's home directory. ;  ; const char * GetLinkedLibraries () override;  Get list of shared libraries loaded at the start of the executable. ;  ; Bool_t GetNbGroups ();  ; char * GetWorkingDirectory (char driveletter) const;  Return working directory for the selected drive (helper function). ;  ; Bool_t InitUsersGroups ();  Collect local users and groups accounts information. ;  ; Long_t LookupSID (const char *lpszAccountName, int what, int &groupIdx, int &memberIdx);  Take the name and look up a SID so that we can get full domain/user information. ;  ; void TimerThread ();  Special Thread to check asynchronous timers. ;  . Static Private Member Functions; static void ThreadStub (void *Parameter);  . Private Attributes; int fActUser {-1};  ; std::string fDirNameBuffer;  ; struct group * fGroups {nullptr};  ; Bool_t fGroupsInitDone {kFALSE};  ; void * fGUIThreadHandle {nullptr};  ; ULong_t fGUIThreadId {0};  ; HANDLE fhProcess;  ; int fNbGroups {0};  ; int fNbUsers {0};  ; struct passwd * fPasswords {nullptr};  . Additional Inherited Members;  Protected Types inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:32807,load,loaded,32807,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['load'],['loaded']
Performance,";  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooAbsReal & cloneModel () const;  ; RooAbsReal & clonePdf () const;  ; RooRealVar & cloneVar () const;  ; void initialize () const;  One-time initialization of object. ;  ; void printCompactTreeHook (std::ostream &os, const char *indent="""") override;  Hook function to intercept printCompactTree() calls so that it can print out the content of its private cache in the print sequence. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:51040,cache,cache,51040,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['cache'],['cache']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . #include <TEmulatedCollectionProxy.h>. Inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:12463,Optimiz,Optimization,12463,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . #include <TEmulatedMapProxy.h>. Inheritance d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:12601,Optimiz,Optimization,12601,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenBitsetProxy:. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:10617,Optimiz,Optimization,10617,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenListProxy:. This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenListProxy.html:10755,Optimiz,Optimization,10755,doc/master/classTGenListProxy.html,https://root.cern,https://root.cern/doc/master/classTGenListProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenMapProxy:. This b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenMapProxy.html:11189,Optimiz,Optimization,11189,doc/master/classTGenMapProxy.html,https://root.cern,https://root.cern/doc/master/classTGenMapProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenSetProxy:. This b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenSetProxy.html:10950,Optimiz,Optimization,10950,doc/master/classTGenSetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenSetProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenVectorBoolProxy:.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenVectorBoolProxy.html:10812,Optimiz,Optimization,10812,doc/master/classTGenVectorBoolProxy.html,https://root.cern,https://root.cern/doc/master/classTGenVectorBoolProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenVectorProxy:. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenVectorProxy.html:10732,Optimiz,Optimization,10732,doc/master/classTGenVectorProxy.html,https://root.cern,https://root.cern/doc/master/classTGenVectorProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions; TGenCollectionStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:11106,Optimiz,Optimization,11106,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['Optimiz'],['Optimization']
Performance,";  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions;  TGenCollectionProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:11168,Optimiz,Optimization,11168,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['Optimiz'],['Optimization']
Performance,";  ; unsigned int NPar () const override;  Return the number of Parameters. ;  ; MultiDimParamGradFunctionAdapter & operator= (const MultiDimParamGradFunctionAdapter &rhs);  Assignment operator. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const override;  ; const double * Parameters () const override;  Access the parameter values. ;  ; void SetParameters (const double *p) override;  Set the parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionMultiDimTempl< T >;  ~IParametricGradFunctionMultiDimTempl () override;  Virtual Destructor (no operations) ;  ; virtual bool HasParameterHessian () const;  ; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  ; T ParameterDerivative (const T *x, const double *p, unsigned int ipar=0) const;  Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ;  ; T ParameterDerivative (const T *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; virtual bool ParameterG2 (const T *, const double *, T *) const;  Evaluate all the second derivatives (diagonal ones) of the function with respect to the parameters at a point x. ;  ; virtual void ParameterGradient (const T *x, const double *p, T *grad) const;  Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (const T *x, T *grad) const;  Evaluate all derivatives using cached parameter values. ;  ; virtual bool ParameterHessian (const T *, const double *, T *) const;  Evaluate the all the Hessian (second derivatives matrix) of the function with respect to the parameters at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html:3691,cache,cached,3691,doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamGradFunctionAdapter.html,1,['cache'],['cached']
Performance,";  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TListOfDataMembers.h>. Inheritance diagram for TListOfDataMembers:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ DeclId_t. typedef TDictionary::DeclId_t TListOfDataMembers::DeclId_t. Definition at line 51 of file TListOfDataMembers.h. Constructor & Destructor Documentation. ◆ TListOfDataMembers() [1/3]. TListOfDataMembers::TListOfDataMembers ; (; const TListOfDataMembers & ; ). privatedelete . Whether the list should contain regular data members or only using decls or both. . ◆ TListOfDataMembers() [2/3]. TListOfDataMembers::TListOfDataMembers ; (; TClass * ; cl, . TDictionary::EMemberSelection ; selection . ). inline . C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:22839,cache,cache,22839,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['cache'],['cache']
Performance,";  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TListOfEnumsWithLock.h>. Inheritance diagram for TListOfEnumsWithLock:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ DeclId_t. typedef TDictionary::DeclId_t TListOfEnumsWithLock::DeclId_t. private . Definition at line 33 of file TListOfEnumsWithLock.h. Constructor & Destructor Documentation. ◆ TListOfEnumsWithLock() [1/2]. TListOfEnumsWithLock::TListOfEnumsWithLock ; (; const TListOfEnumsWithLock & ; ). privatedelete . ◆ TListOfEnumsWithLock() [2/2]. TListOfEnumsWithLock::TListOfEnumsWithLock ; (; TClass * ; cl = nullptr). Definition at line 32 of file TListOfEnumsWithLock.cxx. ◆ ~TListOfEnumsWithLock(). TListOfEnumsWithL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:21893,cache,cache,21893,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['cache'],['cache']
Performance,";  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TListOfFunctionTemplates.h>. Inheritance diagram for TListOfFunctionTemplates:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ DeclId_t. typedef TDictionary::DeclId_t TListOfFunctionTemplates::DeclId_t. private . Definition at line 39 of file TListOfFunctionTemplates.h. Constructor & Destructor Documentation. ◆ TListOfFunctionTemplates() [1/2]. TListOfFunctionTemplates::TListOfFunctionTemplates ; (; const TListOfFunctionTemplates & ; ). privatedelete . ◆ TListOfFunctionTemplates() [2/2]. TListOfFunctionTemplates::TListOfFunctionTemplates ; (; TClass * ; cl). Constructor. ; Definition at line 32 of file TListOfFunctionTempla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:22133,cache,cache,22133,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['cache'],['cache']
Performance,";  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TListOfFunctions.h>. Inheritance diagram for TListOfFunctions:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ DeclId_t. typedef TDictionary::DeclId_t TListOfFunctions::DeclId_t. Definition at line 53 of file TListOfFunctions.h. Constructor & Destructor Documentation. ◆ TListOfFunctions() [1/2]. TListOfFunctions::TListOfFunctions ; (; const TListOfFunctions & ; ). privatedelete . ◆ TListOfFunctions() [2/2]. TListOfFunctions::TListOfFunctions ; (; TClass * ; cl). Constructor. ; Definition at line 31 of file TListOfFunctions.cxx. ◆ ~TListOfFunctions(). TListOfFunctions::~TListOfFunctions ; (; ). Destructor. ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:22090,cache,cache,22090,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['cache'],['cache']
Performance,";  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TSelectorList.h>. Inheritance diagram for TSelectorList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSelectorList(). TSelectorList::TSelectorList ; (; ). inline . Definition at line 38 of file TSelectorList.h. Member Function Documentation. ◆ AddAfter() [1/2]. void TSelectorList::AddAfter ; (; const TObject * ; after, . TObject * ; obj . ). overridevirtual . Add to the list. ; Reimplemented from THashList.; Definition at line 127 of file TSelectorList.cxx. ◆ AddAfter() [2/2]. void TSelectorList::AddAfter ; (; TObjLink * ; after, . TObject * ; obj . ). overridevirtual . Add to the list. ; Reimplemented from TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorList.html:21095,cache,cache,21095,doc/master/classTSelectorList.html,https://root.cern,https://root.cern/doc/master/classTSelectorList.html,1,['cache'],['cache']
Performance,";  ; virtual void ProgressNotifier (TString, TString);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::IFitterTarget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; friend TestOptimizeConfigParameters;  . Private Member Functions; Double_t EstimatorFunction (std::vector< Double_t > &);  return the estimator (from current FOM) for the fitting interface ;  ; Double_t GetBkgEffAtSigEff (Double_t sigEff=0.5);  calculate the background efficiency for a given signal efficiency ;  ; Double_t GetBkgRejAtSigEff (Double_t sigEff=0.5);  calculate the background rejection for a given signal efficiency ;  ; Double_t GetFOM ();  Return the Figure of Merit (FOM) used in the parameter optimization process. ;  ; MethodBase * GetMethod ();  ; void GetMVADists ();  fill the private histograms with the mva distributions for sig/bkg ;  ; Double_t GetROCIntegral ();  calculate the area (integral) under the ROC curve as a overall quality measure of the classification ;  ; std::vector< int > GetScanIndices (int val, std::vector< int > base);  helper function to scan through the all the combinations in the parameter space ;  ; Double_t GetSeparation ();  return the separation between the signal and background MVA ouput distribution ;  ; Double_t GetSigEffAtBkgEff (Double_t bkgEff=0.1);  calculate the signal efficiency for a given background efficiency ;  ; MsgLogger & Log () const;  ; void optimizeFit ();  ; void optimizeScan ();  do the actual optimization using a simple scan method, i.e. ;  . Private Attributes; std::map< std::vector< Double_t >, Double_t > fAlreadyTrainedParCombination;  save parameters for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:2190,optimiz,optimization,2190,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimization']
Performance,";  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot () const;  ; Long64_t GetPrefetchedBlocks () const;  ; virtual TFilePrefetch * GetPrefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:16548,cache,cache,16548,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,";  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static Bool_t CanDelete ();  static function returning true if ReadBuffer can delete object ;  ; static Bool_t CanOptimize ();  static function returning true if optimization can be on ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualStreamerInfo * Factory ();  Static function returning a pointer to a new TVirtualStreamerInfo object. ;  ; static TStreamerBasicType * GetElementCounter (const char *countName, TClass *cl);  Get pointer to a TStreamerBasicType in TClass *cl static function. ;  ; static const char * GetElementCounterStart (const char *dmTitle);  Given a comment/title declaring an array counter, for example: ;  ; static Bool_t GetStreamMemberWise ();  Return whether the TStreamerInfos will save the collections in ""member-wise"" order whenever possible. ;  ; static void Optimize (Bool_t opt=kTRUE);  This is a static function. ;  ; static void SetCanDelete (Bool_t opt=kTRUE);  This is a static function. ;  ; static void SetFactory (TVirtualStreamerInfo *factory);  static function: Set the StreamerInfo factory ;  ; static Bool_t SetStreamMemberWise (Bool_t enable=k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:14554,optimiz,optimization,14554,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['optimiz'],['optimization']
Performance,";  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-swap N primitive-elements in the buffer. ;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion () const;  ; char * GetCurrent () const;  ; TObject * GetParent () const;  Return pointer to parent of this buffer. ;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; void SetBuffer (void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Sets a new buffer in an existing TBuffer object. ;  ; void SetBufferOffset (Int_t offset=0);  ; void SetParent (TObject *parent);  Set parent owning this buffer. ;  ; void SetReadMode ();  Set buffer in read mode. ;  ; void SetReAllocFunc (ReAllocCharFun_t reallocfunc=nullptr);  Set which memory reallocation method to use. ;  ; void SetWriteMode ();  Set buffer in write mode. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:24224,cache,cache,24224,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,6,['cache'],['cache']
Performance,";  ; void MakeZombie ();  . Static Protected Member Functions; static Bool_t Bidiagonalize (TMatrixD &v, TMatrixD &u, TVectorD &sDiag, TVectorD &oDiag);  Bidiagonalize the (m x n) - matrix a (stored in v) through a series of Householder transformations applied to the left (Q^T) and to the right (H) of a , so that A = Q . ;  ; static void Diag_1 (TMatrixD &v, TVectorD &sDiag, TVectorD &oDiag, Int_t k);  Step 1 in the matrix diagonalization. ;  ; static void Diag_2 (TVectorD &sDiag, TVectorD &oDiag, Int_t k, Int_t l);  Step 2 in the matrix diagonalization. ;  ; static void Diag_3 (TMatrixD &v, TMatrixD &u, TVectorD &sDiag, TVectorD &oDiag, Int_t k, Int_t l);  Step 3 in the matrix diagonalization. ;  ; static Bool_t Diagonalize (TMatrixD &v, TMatrixD &u, TVectorD &sDiag, TVectorD &oDiag);  Diagonalizes in an iterative fashion the bidiagonal matrix C as described through sDiag and oDiag, so that S' = U'^T . ;  ; static void SortSingular (TMatrixD &v, TMatrixD &u, TVectorD &sDiag);  Perform a permutation transformation on the diagonal matrix S', so that matrix S'' = U''^T . ;  ;  Static Protected Member Functions inherited from TDecompBase; static void DiagProd (const TVectorD &diag, Double_t tol, Double_t &d1, Double_t &d2);  . Protected Attributes; TVectorD fSig;  ; TMatrixD fU;  ; TMatrixD fV;  ;  Protected Attributes inherited from TDecompBase; Int_t fColLwb;  ; Double_t fCondition;  ; Double_t fDet1;  ; Double_t fDet2;  ; Int_t fRowLwb;  ; Double_t fTol;  . Additional Inherited Members;  Protected Types inherited from TDecompBase; enum  { kWorkMax = 100; };  ; enum  EMatrixDecompStat { ;   kInit = (1ULL << ( 14 )); , kPatternSet = (1ULL << ( 15 )); , kValuesSet = (1ULL << ( 16 )); , kMatrixSet = (1ULL << ( 17 )); , ;   kDecomposed = (1ULL << ( 18 )); , kDetermined = (1ULL << ( 19 )); , kCondition = (1ULL << ( 20 )); , kSingular = (1ULL << ( 21 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TDecompSVD.h>. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSVD.html:14987,Perform,Perform,14987,doc/master/classTDecompSVD.html,https://root.cern,https://root.cern/doc/master/classTDecompSVD.html,1,['Perform'],['Perform']
Performance,";  ;  PDEFoamVect (const PDEFoamVect &);  Copy constructor. ;  ;  PDEFoamVect (Int_t);  USER Constructor. ;  ; virtual ~PDEFoamVect ();  Destructor. ;  ; Double_t GetCoord (Int_t i) const;  ; Int_t GetDim () const;  ; virtual TClass * IsA () const;  ; PDEFoamVect & operator*= (const Double_t &);  unary multiplication operator *= ;  ; PDEFoamVect operator+ (const PDEFoamVect &);  addition operator +; sum of 2 vectors: c=a+b, a=a+b, NEVER USE IT, VERY SLOW!!! ;  ; PDEFoamVect & operator+= (const PDEFoamVect &);  unary addition operator +=; adding vector c*=x, ;  ; PDEFoamVect operator- (const PDEFoamVect &);  subtraction operator -; difference of 2 vectors; c=a-b, a=a-b, NEVER USE IT, VERY SLOW!!! ;  ; PDEFoamVect & operator-= (const PDEFoamVect &);  unary subtraction operator -= ;  ; PDEFoamVect & operator= (const PDEFoamVect &);  substitution operator ;  ; PDEFoamVect & operator= (Double_t);  Loading in double prec. number, sometimes can be useful. ;  ; PDEFoamVect & operator= (Double_t[]);  Loading in ordinary double prec. vector, sometimes can be useful. ;  ; Double_t & operator[] (Int_t);  [] is for access to elements as in ordinary matrix like a[j]=b[j] (Perhaps against some strict rules but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ;  ; void Print (Option_t *option) const;  Printout of all vector components. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamVect.html:1401,Load,Loading,1401,doc/master/classTMVA_1_1PDEFoamVect.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamVect.html,1,['Load'],['Loading']
Performance,";  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TEntryListBlock ();  Default c-tor. ;  ;  TEntryListBlock (const TEntryListBlock &eblock);  Copy c-tor. ;  ;  ~TEntryListBlock () override;  Destructor. ;  ; Int_t Contains (Int_t entry);  True if the block contains entry #entry. ;  ; bool Enter (Int_t entry);  If the block has already been optimized and the entries are stored as a list and not as bits, trying to enter a new entry will make the block switch to bits representation. ;  ; Int_t GetEntry (Int_t entry);  Return entry #entry. ;  ; Int_t GetNPassed ();  Returns the number of entries, passing the selection. ;  ; Int_t GetType ();  ; TClass * IsA () const override;  ; Int_t Merge (TEntryListBlock *block);  Merge with the other block Returns the resulting number of entries in the block. ;  ; Int_t Next ();  Return the next non-zero entry Faster than GetEntry() function. ;  ; TEntryListBlock & operator= (const TEntryListBlock &rhs);  ; void OptimizeStorage ();  If there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. ;  ; void Print (const Option_t *option="""") const override;  Print the entries in this block. ;  ; void PrintWithShift (Int_t shift) const;  Print the indices of this block + shift (used from TEntryList::Print()) to print the current values. ;  ; bool Remove (Int_t entry);  Remove entry #entry If the block has a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListBlock.html:2588,optimiz,optimized,2588,doc/master/classTEntryListBlock.html,https://root.cern,https://root.cern/doc/master/classTEntryListBlock.html,1,['optimiz'],['optimized']
Performance,";  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:12229,cache,cache,12229,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,2,"['cache', 'load']","['cache', 'loaded']"
Performance,";  CTVirtualHistPainterAbstract interface to a histogram painter ;  CTVirtualIndexAbstract interface for Tree Index ;  CTVirtualIsAProxy;  CTVirtualMagFieldAbstract class for magnetic field ;  CTVirtualMCAbstract Monte Carlo interface ;  CTVirtualMCApplicationInterface to a user Monte Carlo application ;  CTVirtualMCDecayerAbstract base class for particle decays ;  CTVirtualMCGeometryInterface to Monte Carlo geometry construction ;  CTVirtualMCSensitiveDetectorInterface to a user defined sensitive detector ;  CTVirtualMCStackInterface to a user defined particles stack ;  CTVirtualMonitoringReader;  CTVirtualMonitoringWriter;  CTVirtualMutexThis class implements a mutex interface ;  CTVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary ;  ►CTVirtualPacketizerThe packetizer is a load balancing object created for each query ;  CTVirtualSlaveStat;  CTVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes ;  CTVirtualPadEditorAbstract base class used by ROOT graphics editor ;  CTVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas ;  CTVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTVirtualProofPlayerAbstract interface for the PROOF player ;  CTVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG ;  CTVirtualQConnectionMediates the link between the signal and the slot ;  CTVirtualRefProxy;  CTVirtualStreamerInfoAbstract Interface class describing Streamer information for one class ;  CTVirtualTableInterface;  CTVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan, Process, MakeProxy, etc ;  CTVirtualVectorIterators;  CTVirtualViewer3DAbstract 3D shapes viewer ;  CTVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:219707,perform,performance,219707,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,2,['perform'],['performance']
Performance,";  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:53750,optimiz,optimizeDirtyHook,53750,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,149,['optimiz'],['optimizeDirtyHook']
Performance,";  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgusBG.html:27457,cache,cache,27457,doc/master/classRooArgusBG.html,https://root.cern,https://root.cern/doc/master/classRooArgusBG.html,59,['cache'],['cache']
Performance,;  Event.cxx;  ExpectedErrorPruneTool.cxx;  Factory.cxx;  FitterBase.cxx;  GeneticAlgorithm.cxx;  GeneticFitter.cxx;  GeneticGenes.cxx;  GeneticPopulation.cxx;  GeneticRange.cxx;  GiniIndex.cxx;  GiniIndexWithLaplace.cxx;  HyperParameterOptimisation.cxx;  IFitterTarget.cxx;  IMethod.cxx;  Interval.cxx;  KDEKernel.cxx;  LDA.cxx;  LogInterval.cxx;  LossFunction.cxx;  MCFitter.cxx;  MethodANNBase.cxx;  MethodBase.cxx;  MethodBayesClassifier.cxx;  MethodBDT.cxx;  MethodBoost.cxx;  MethodCategory.cxx;  MethodCFMlpANN.cxx;  MethodCFMlpANN_Utils.cxx;  MethodCompositeBase.cxx;  MethodCuts.cxx;  MethodDNN.cxx;  MethodDT.cxx;  MethodFDA.cxx;  MethodFisher.cxx;  MethodHMatrix.cxx;  MethodKNN.cxx;  MethodLD.cxx;  MethodLikelihood.cxx;  MethodMLP.cxx;  MethodPDEFoam.cxx;  MethodPDERS.cxx;  MethodPlugins.cxx;  MethodRuleFit.cxx;  MethodSVM.cxx;  MethodTMlpANN.cxx;  MinuitFitter.cxx;  MinuitWrapper.cxx;  MisClassificationError.cxx;  ModulekNN.cxx;  MsgLogger.cxx;  NeuralNet.cxx;  Node.cxx;  OptimizeConfigParameters.cxx;  Option.cxx;  OptionMap.cxx;  PDEFoam.cxx;  PDEFoamCell.cxx;  PDEFoamDecisionTree.cxx;  PDEFoamDecisionTreeDensity.cxx;  PDEFoamDensityBase.cxx;  PDEFoamDiscriminant.cxx;  PDEFoamDiscriminantDensity.cxx;  PDEFoamEvent.cxx;  PDEFoamEventDensity.cxx;  PDEFoamKernelBase.cxx;  PDEFoamKernelGauss.cxx;  PDEFoamKernelLinN.cxx;  PDEFoamKernelTrivial.cxx;  PDEFoamMultiTarget.cxx;  PDEFoamTarget.cxx;  PDEFoamTargetDensity.cxx;  PDEFoamVect.cxx;  PDF.cxx;  QuickMVAProbEstimator.cxx;  Ranking.cxx;  Reader.cxx;  RegressionVariance.cxx;  Results.cxx;  ResultsClassification.cxx;  ResultsMulticlass.cxx;  ResultsRegression.cxx;  ROCCalc.cxx;  ROCCurve.cxx;  RootFinder.cxx;  Rule.cxx;  RuleCut.cxx;  RuleEnsemble.cxx;  RuleFit.cxx;  RuleFitAPI.cxx;  RuleFitParams.cxx;  SdivSqrtSplusB.cxx;  SeparationBase.cxx;  SimulatedAnnealing.cxx;  SimulatedAnnealingFitter.cxx;  SVEvent.cxx;  SVKernelFunction.cxx;  SVKernelMatrix.cxx;  SVWorkingSet.cxx;  TActivation.cxx;  TActivationChooser.cxx;  T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:92529,Optimiz,OptimizeConfigParameters,92529,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['Optimiz'],['OptimizeConfigParameters']
Performance,";  Factory (TString theJobName, TFile *theTargetFile, TString theOption="""");  Standard constructor. ;  ;  Factory (TString theJobName, TString theOption="""");  Constructor. ;  ; virtual ~Factory ();  Destructor. ;  ; MethodBase * BookMethod (DataLoader *, TMVA::Types::EMVA, TString, TString, TMVA::Types::EMVA, TString);  ; MethodBase * BookMethod (DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""");  Book a classifier or regression method. ;  ; MethodBase * BookMethod (DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption="""");  Books MVA method. ;  ; void DeleteAllMethods (void);  Delete methods. ;  ; void EvaluateAllMethods (void);  Iterates over all MVAs that have been booked, and calls their evaluation methods. ;  ; void EvaluateAllVariables (DataLoader *loader, TString options="""");  Iterates over all MVA input variables and evaluates them. ;  ; TH1F * EvaluateImportance (DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""");  Evaluate Variable Importance. ;  ; IMethod * GetMethod (const TString &datasetname, const TString &title) const;  Returns pointer to MVA that corresponds to given method title. ;  ; TGraph * GetROCCurve (DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ;  ; TCanvas * GetROCCurve (DataLoader *loader, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Draws ROC curves for all methods booked with the factory for a given class onto a canvas. ;  ; TGraph * GetROCCurve (TString datasetname, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ;  ; TCanvas * GetROCCurve (TString datasetname, UInt_t iClass=0, Types::ETreeType type=Types",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:2221,load,loader,2221,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,";  Find location of file in a search path. ;  ; virtual void FreeDirectory (void *dirp);  Free a directory. ;  ; virtual EAclicMode GetAclicMode () const;  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual Int_t GetAclicProperties () const;  Return the ACLiC properties field. ;  ; void GetBeepDefaults (Int_t &freq, Int_t &duration) const;  ; virtual const char * GetBuildArch () const;  Return the build architecture. ;  ; virtual const char * GetBuildCompiler () const;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual int GetCpuInfo (CpuInfo_t *info, Int_t sampleTime=1000) const;  Returns cpu load average and load info into the CpuInfo_t structure. ;  ; virtual Int_t GetCryptoRandom (void *buf, Int_t len);  Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ;  ; virtual const char * GetDirEntry (void *dirp);  Get a directory entry. Returns 0 if no more entries. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void * GetDirPtr () const;  ; virtual const char * GetDynamicPath ();  Return the dynamic path (used to find shared libraries). ;  ; virtual Int_t GetEffectiveGid ();  Returns the effective group id. ;  ; virtual Int_t GetEffectiveUid ();  Returns the effective user id. ;  ; virtual const char * Getenv (const char *env);  Get environment variable. ;  ; virtual const char * GetError ();  Return system error string. ;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:6773,load,load,6773,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['load'],['load']
Performance,";  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TString fClassName;  ; void * fReceiver = nullptr;  ; TQSlot * fSlot = nullptr;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Additional Inherited Members;  Public Types inherited from TList; typedef TListIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQConnection.html:24722,cache,cache,24722,doc/master/classTQConnection.html,https://root.cern,https://root.cern/doc/master/classTQConnection.html,1,['cache'],['cache']
Performance,";  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void Openlog (const char *name, Int_t options, ELogFacility facility);  Open connection to system log daemon. ;  ; virtual FILE * OpenPipe (const char *command, const char *mode);  Open a pipe. ;  ; virtual const char * PrependPathName (const char *dir, TString &name);  Concatenate a directory and a file name. ;  ; virtual Bool_t ProcessEvents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGSystem.html:13046,Load,LoadAllLibraries,13046,doc/master/classTNetXNGSystem.html,https://root.cern,https://root.cern/doc/master/classTNetXNGSystem.html,4,['Load'],"['Load', 'LoadAllLibraries']"
Performance,";  LSResidualFunc (const Func &func, unsigned int i);  ;  LSResidualFunc (const LSResidualFunc< Func > &rhs);  ; IMultiGenFunction * Clone () const override;  Clone a function. ;  ; void FdF (const double *x, double &f, double *g) const override;  ; void Gradient (const double *x, double *g) const override;  ; unsigned int NDim () const override;  Retrieve the dimension of the function. ;  ; LSResidualFunc< Func > & operator= (const LSResidualFunc< Func > &rhs);  ;  Public Member Functions inherited from ROOT::Math::IGradientFunctionMultiDimTempl< T >; T Derivative (const T *x, unsigned int icoord, T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the derivative algorithm will use information from the previous step, these can be passed in with this overload. ;  ; T Derivative (const T *x, unsigned int icoord=0) const;  Return the partial derivative with respect to the passed coordinate. ;  ; virtual void FdF (const T *x, T &f, T *df) const;  Optimized method to evaluate at the same time the function value and derivative at a point x. ;  ; virtual void Gradient (const T *x, T *grad) const;  Evaluate all the vector of function derivatives (gradient) at a point x. ;  ; virtual void GradientWithPrevResult (const T *x, T *grad, T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the gradient algorithm will use information from the previous step, these can be passed in with this overload. ;  ; bool HasGradient () const;  ; virtual bool returnsInMinuit2ParameterSpace () const;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  . Private Member Functions; double DoDerivative (const double *, unsigned int) const override;  ; double DoEval (const double *x) const override;  . Private Attributes; const Func * fChi2;  ; unsigned int fIndex;  . Additional Inherited Memb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LSResidualFunc.html:2046,Optimiz,Optimized,2046,doc/master/classROOT_1_1Math_1_1LSResidualFunc.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LSResidualFunc.html,1,['Optimiz'],['Optimized']
Performance,";  Open a remote file. Requires fOption to be set correctly. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Return file stat information. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; virtual Int_t SysWrite (Int_t fd, const void *buf, Int_t len);  Interface to system write. All arguments like in POSIX write(). ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:32498,cache,cache,32498,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['cache'],['cache']
Performance,";  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooListProxy _list;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRecursiveFraction.html:55558,Cache,Cache,55558,doc/master/classRooRecursiveFraction.html,https://root.cern,https://root.cern/doc/master/classRooRecursiveFraction.html,1,['Cache'],['Cache']
Performance,";  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooNumRunningInt; std::string _binningName;  Name of binning to be used for cache histogram. ;  ; RooRealProxy func;  Proxy to functions whose running integral is calculated. ;  ; RooRealProxy x;  Integrated observable. ;  ;  Protected Attributes inherited from RooAbsCachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:61099,cache,cache,61099,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,2,['cache'],['cache']
Performance,";  Return a pointer to the list containing user objects associated to this tree. ;  ; virtual Double_t * GetV1 ();  ; virtual Double_t * GetV2 ();  ; virtual Double_t * GetV3 ();  ; virtual Double_t * GetV4 ();  ; virtual Double_t * GetVal (Int_t i);  ; TTreeFormula * GetVar (Int_t i);  ; TTreeFormula * GetVar1 ();  ; TTreeFormula * GetVar2 ();  ; TTreeFormula * GetVar3 ();  ; TTreeFormula * GetVar4 ();  ; virtual Double_t * GetW ();  ; virtual Double_t GetWeight () const;  ; virtual Long64_t GetZipBytes () const;  ; virtual void IncrementTotalBuffers (Int_t nbytes);  ; virtual bool InPlaceClone (TDirectory *newdirectory, const char *options="""");  Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ;  ; bool IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; virtual Int_t LoadBaskets (Long64_t maxmemory=2000000000);  Read in memory all baskets from all branches up to the limit of maxmemory bytes. ;  ; virtual Long64_t LoadTreeFriend (Long64_t entry, TTree *T);  Load entry on behalf of our master tree, we may use an index. ;  ; virtual Int_t MakeClass (const char *classname=nullptr, Option_t *option="""");  Generate a skeleton analysis class for this tree. ;  ; virtual Int_t MakeCode (const char *filename=nullptr);  Generate a skeleton function for this tree. ;  ; virtual Int_t MakeProxy (const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3);  Generate a skeleton analysis class for this Tree using TBranchProxy. ;  ; virtual Int_t MakeSelector (const char *selector=nullptr, Option_t *option="""");  Generate skeleton selector class for this tree. ;  ; bool MemoryFull (Int_t nbytes);  Check if adding nbytes to memory we are still below MaxVirtualsize. ;  ; virtual Long64_t Merge (TCollection *list, Option_t *option="""");  Merge ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:14270,Load,LoadBaskets,14270,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['Load'],['LoadBaskets']
Performance,";  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; Int_t fMaximum;  Maximum value if leaf range is specified. ;  ; Int_t fMinimum;  Minimum value if leaf range is specified. ;  ; Char_t ** fPointer;  ! Address of pointer to data buffer ;  ; Char_t * fValue;  ! Pointer to data buffer ;  ;  Protected Attributes inherited from TLeaf; TBranch * fBranch;  ! Pointer to supporting branch (we do not own the branch) ;  ; bool fIsRange;  (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement. ;  ; bool fIsUnsigned;  (=true if unsigned, false otherwise) ;  ; TLeaf * fLeafCount;  Pointer to Leaf count if variable length (we do not own the counter) ;  ; LeafCountValues * fLeafCountValues;  ! Cache of collection/array sizes ;  ; Int_t fLen;  Number of fixed length elements in the leaf's data. ;  ; Int_t fLenType;  Number of bytes for this data type. ;  ; Int_t fNdata;  ! Number of elements in fAddress data buffer. ;  ; Int_t fOffset;  Offset in ClonesArray object (if one) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TLeaf; enum class  DeserializeType { ;   kInvalid = 0; , kExternal; , kDestructive = kExternal; , kInPlace; , ;   kZeroCopy. };  ; enum  EStatusBits { kIndirectAddress = (1ULL << ( 11 )); , kNewValue = (1ULL << ( 12 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafC.html:14828,Cache,Cache,14828,doc/master/classTLeafC.html,https://root.cern,https://root.cern/doc/master/classTLeafC.html,1,['Cache'],['Cache']
Performance,";  RooProduct ();  Default constructor. ;  ;  RooProduct (const char *name, const char *title, const RooArgList &prodSet);  Construct function representing the product of functions in prodSet. ;  ;  RooProduct (const char *name, const char *title, RooAbsReal &real1, RooAbsReal &real2);  ;  RooProduct (const RooProduct &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooProduct () override;  Destructor. ;  ; void addTerm (RooAbsArg *term);  Add a term to this product. ;  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Calculate integral internally from appropriate partial integral cache. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; CacheMode canNodeBeCached () const override;  ; const RooArgList & categoricalComponents () const;  ; TObject * clone (const char *newname) const override;  ; RooArgList components ();  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force internal handling of integration of given observable if any of the product terms depend on it. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Declare that we handle all integrations internally. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the product operator construction. ;  ; const RooArgList & realComponents () c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:1344,Cache,CacheMode,1344,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['Cache'],['CacheMode']
Performance,;  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Attributes; RooListProxy _coefList;  List of coefficients. ;  ; bool _doFloor = false;  Introduce floor at zero in pdf. ;  ; bool _extended;  Allow use as extended p.d.f. ;  ; RooListProxy _funcList;  List of component FUNCs. ;  ; bool _haveWarned {false};  ! ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plot,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:62745,cache,cache,62745,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,2,['cache'],['cache']
Performance,";  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Observable to be cached for given choice of normalization. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Parameters of the cache. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Create and return a derived MorphCacheElem. ;  ; double evaluate () const override;  Dummy. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the cache with the interpolated shape. ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:65436,cache,cacheNameSuffix,65436,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,3,['cache'],"['cache', 'cacheNameSuffix']"
Performance,";  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:49664,cache,cache,49664,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,";  class dealing with the transformation between user specified parameters (external) and internal parameters used for minimization More...;  ; class  MnVectorTransform;  ; class  ModularFunctionMinimizer;  Base common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters. More...;  ; class  MPIProcess;  ; class  MPITerminate;  ; class  NegativeG2LineSearch;  In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive. More...;  ; class  Numerical2PGradientCalculator;  class performing the numerical gradient calculation More...;  ; class  NumericalDerivator;  ; class  ParametricFunction;  Function which has parameters. More...;  ; class  PrefixStack;  ; class  ScanBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  ScanMinimizer;  Class implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. More...;  ; class  SimplexBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  SimplexMinimizer;  Class implementing the required methods for a minimization using Simplex. More...;  ; class  SimplexParameters;  class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process. More...;  ; class  SimplexSeedGenerator;  generate Simplex starting point (state) More...;  ; class  SinParameterTransformation;  class for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one More...;  ; class  SqrtLowParameterTransformation;  Transformation from external to internal Parameter based o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:11194,Perform,Performs,11194,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['Perform'],['Performs']
Performance,"; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__SeparationBase.html:1558,optimiz,optimized,1558,root/html534/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html534/TMVA__SeparationBase.html,1,['optimiz'],['optimized']
Performance,"; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TNonSplitBrowsable(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNonSplitBrowsable.html:1168,cache,cached,1168,root/html528/TNonSplitBrowsable.html,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html,8,['cache'],['cached']
Performance,"; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TNonSplitBrowsa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNonSplitBrowsable.html:1168,cache,cached,1168,root/html602/TNonSplitBrowsable.html,https://root.cern,https://root.cern/root/html602/TNonSplitBrowsable.html,4,['cache'],['cached']
Performance,";; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:39796,cache,cache,39796,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,";; 1118}; 1119 ; 1120////////////////////////////////////////////////////////////////////////////////; 1121/// Replaces all occurrences of VORIG with VNEW in the geometry tree. The volume VORIG; 1122/// is not replaced from the list of volumes, but all node referencing it will reference; 1123/// VNEW instead. Returns number of occurrences changed.; 1124 ; 1125Int_t TGeoManager::ReplaceVolume(TGeoVolume *vorig, TGeoVolume *vnew); 1126{; 1127 Int_t nref = 0;; 1128 if (!vorig || !vnew); 1129 return nref;; 1130 TGeoMedium *morig = vorig->GetMedium();; 1131 Bool_t checkmed = kFALSE;; 1132 if (morig); 1133 checkmed = kTRUE;; 1134 TGeoMedium *mnew = vnew->GetMedium();; 1135 // Try to limit the damage produced by incorrect usage.; 1136 if (!mnew && !vnew->IsAssembly()) {; 1137 Error(""ReplaceVolume"", ""Replacement volume %s has no medium and it is not an assembly"", vnew->GetName());; 1138 return nref;; 1139 }; 1140 if (mnew && checkmed) {; 1141 if (mnew->GetId() != morig->GetId()); 1142 Warning(""ReplaceVolume"", ""Replacement volume %s has different medium than original volume %s"", vnew->GetName(),; 1143 vorig->GetName());; 1144 checkmed = kFALSE;; 1145 }; 1146 ; 1147 // Medium checking now performed only if replacement is an assembly and old volume a real one.; 1148 // Check result is dependent on positioning.; 1149 Int_t nvol = fVolumes->GetEntriesFast();; 1150 Int_t i, j, nd;; 1151 Int_t ierr = 0;; 1152 TGeoVolume *vol;; 1153 TGeoNode *node;; 1154 TGeoVoxelFinder *voxels;; 1155 for (i = 0; i < nvol; i++) {; 1156 vol = (TGeoVolume *)fVolumes->At(i);; 1157 if (!vol); 1158 continue;; 1159 if (vol == vorig || vol == vnew); 1160 continue;; 1161 nd = vol->GetNdaughters();; 1162 for (j = 0; j < nd; j++) {; 1163 node = vol->GetNode(j);; 1164 if (node->GetVolume() == vorig) {; 1165 if (checkmed) {; 1166 mnew = node->GetMotherVolume()->GetMedium();; 1167 if (mnew && mnew->GetId() != morig->GetId()); 1168 ierr++;; 1169 }; 1170 nref++;; 1171 if (node->IsOverlapping()) {; 1172 node->SetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:41477,perform,performed,41477,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['perform'],['performed']
Performance,";; 1346 ; 1347 std::string hjson;; 1348 ; 1349 SearchVisibles(fSearch, hjson, fSearchJson);; 1350 ; 1351 (void)hjson; // not used here; 1352}; 1353 ; 1354/////////////////////////////////////////////////////////////////////; 1355/// Collect all information required to draw geometry on the client; 1356/// This includes list of each visible nodes, meshes and matrixes; 1357 ; 1358void RGeomDescription::ProduceDrawData(); 1359{; 1360 auto json = ProduceJson();; 1361 ; 1362 TLockGuard lock(fMutex);; 1363 ; 1364 fDrawJson = ""GDRAW:""s + json;; 1365}; 1366 ; 1367/////////////////////////////////////////////////////////////////////; 1368/// Clear raw data. Will be rebuild when next connection will be established; 1369 ; 1370void RGeomDescription::ClearDrawData(); 1371{; 1372 TLockGuard lock(fMutex);; 1373 ; 1374 fDrawJson.clear();; 1375 fSearchJson.clear();; 1376}; 1377 ; 1378/////////////////////////////////////////////////////////////////////; 1379/// Clear cached data, need to be clear when connection broken; 1380 ; 1381void RGeomDescription::ClearCache(); 1382{; 1383 ClearDrawData();; 1384 ; 1385 TLockGuard lock(fMutex);; 1386 fShapes.clear();; 1387 fSearch.clear();; 1388}; 1389 ; 1390/////////////////////////////////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:41763,cache,cached,41763,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['cache'],['cached']
Performance,";; 139 - SetScanFileName : define a name for the file where TTree::Scan command; 140 is redirected when the `<Scan>` button is checked;; 141 - SetTreeName : open a new tree with this name in the viewer;; 142 ; 143 A specific context menu is activated if expressions/leaves are right-clicked.; 144 ; 145 Commands are :; 146 - Draw : draw a histogram for this item;; 147 - EditExpression : pops-up the expression editor;; 148 - Empty : empty the name and alias of this item;; 149 - RemoveItem : removes clicked item from the list;; 150 - Scan : scan this expression;; 151 - SetExpression : edit name and alias for this item by hand;; 152 ; 153Starting the viewer; 154 ; 155 1. From the TBrowser: Select a tree in the TBrowser, then call the; 156 StartViewer() method from its context menu (right-click on the tree).; 157 2. From the command line: Start a ROOT session in the directory where you have; 158 your tree. You will need first to load the library for TTreeViewer and; 159 optionally other libraries for user defined classes (you can do this later in; 160 the session) :; 161~~~ {.cpp}; 162 root [0] gSystem->Load(\""TTreeViewer\"");; 163~~~; 164Supposing you have the tree MyTree in the file MyFile, you can do :; 165~~~ {.cpp}; 166 root [1] TFile file(""Myfile"");; 167 root [2] new TTreeViewer(""Mytree"");; 168~~~; 169or :; 170~~~ {.cpp}; 171 root [2] TTreeViewer *tv = new TTreeViewer();; 172 root [3] tv->SetTreeName(""Mytree"");; 173~~~; 174\image html ttree_treeview.png; 175*/; 176 ; 177#include ""RConfigure.h""; 178 ; 179#include <iostream>; 180#include <fstream>; 181#include ""TTreeViewer.h""; 182#include ""HelpText.h""; 183#include ""HelpTextTV.h""; 184#include ""TTVLVContainer.h""; 185#include ""TTVSession.h""; 186 ; 187#include ""TROOT.h""; 188#include ""TError.h""; 189#include ""TGMsgBox.h""; 190#include ""TTreePlayer.h""; 191#include ""TContextMenu.h""; 192#include ""TInterpreter.h""; 193#include ""TLeaf.h""; 194#include ""TBranch.h""; 195#include ""TRootHelpDialog.h""; 196#include ""TSystem.h""; 197#include",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:8184,load,load,8184,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['load'],['load']
Performance,";; 145 void SetLoaded(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fLoaded; }; 146 void SetLoaded(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fLoaded; }; 147 void SetLoadedMiss(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fLoadedMiss; }; 148 void SetLoadedMiss(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fLoadedMiss; }; 149 void SetMissed(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fMissed; }; 150 void SetMissed(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fMissed; }; 151 void SetUsed(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fUsed; }; 152 void SetUsed(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fUsed; }; 153 void UpdateBranchIndices(TObjArray *branchNames) override;; 154 ; 155 BasketList_t GetDuplicateBasketCache() const;; 156 ; 157 ClassDefOverride(TTreePerfStats, 8) // TTree I/O performance measurement; 158};; 159 ; 160#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:8241,perform,performance,8241,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['perform'],['performance']
Performance,";; 1499 for (size_t l = 0; l < nlayers; ++l) {; 1500 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0); 1501 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),; 1502 TString::Format(""initial weights layer %d"", l).Data());; 1503 ; 1504 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetOutput(),; 1505 TString::Format(""output tensor layer %d"", l).Data());; 1506 }; 1507#endif; 1508 ; 1509 //Architecture_t::PrintTensor(deepNet.GetLayerAt(nlayers-1)->GetOutput(),""output tensor last layer"" );; 1510 ; 1511 deepNet.Backward(my_batch.GetInput(), my_batch.GetOutput(), my_batch.GetWeights());; 1512 ; 1513 if (debugFirstEpoch); 1514 std::cout << ""- doing optimizer update \n"";; 1515 ; 1516 // increment optimizer step that is used in some algorithms (e.g. ADAM); 1517 optimizer->IncrementGlobalStep();; 1518 optimizer->Step();; 1519 ; 1520#ifdef DEBUG; 1521 std::cout << ""minmimizer step - momentum "" << settings.momentum << "" learning rate "" << optimizer->GetLearningRate() << std::endl;; 1522 for (size_t l = 0; l < nlayers; ++l) {; 1523 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0) {; 1524 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),TString::Format(""weights after step layer %d"",l).Data());; 1525 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightGradientsAt(0),""weight gradients"");; 1526 }; 1527 }; 1528#endif; 1529 ; 1530 }; 1531 ; 1532 if (debugFirstEpoch) std::cout << ""\n End batch loop - compute validation loss \n"";; 1533 //}; 1534 debugFirstEpoch = false;; 1535 if ((nTrainEpochs % settings.testInterval) == 0) {; 1536 ; 1537 std::chrono::time_point<std::chrono::system_clock> t1,t2;; 1538 ; 1539 t1 = std::chrono::system_clock::now();; 1540 ; 1541 // Compute validation error.; 1542 ; 1543 ; 1544 Double_t valError = 0.0;; 1545 bool inTraining = false;; 1546 for (auto batch : validationData) {; 1547 auto inputTensor = batch.GetInput();; 1548 auto outputMatrix = batch.GetOutput();; 1549 auto weights = batch.GetWeights();; 1550 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:60410,optimiz,optimizer,60410,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizer']
Performance,";; 1517 return 0;; 1518 }; 1519 ; 1520 UInt_t nvars=0, ntgts=0, nspcts=0;; 1521 if (transformBase); 1522 transformBase->CountVariableTypes( nvars, ntgts, nspcts );; 1523 else {; 1524 nvars =events.at(0)->GetNVariables ();; 1525 ntgts =events.at(0)->GetNTargets ();; 1526 nspcts=events.at(0)->GetNSpectators();; 1527 }; 1528 ; 1529 ; 1530 // init matrices; 1531 Int_t matNum = maxCls;; 1532 if (maxCls > 1 ) matNum++; // if more than one classes, then produce one matrix for all events as well (beside the matrices for each class); 1533 ; 1534 std::vector<TVectorD*>* vec = new std::vector<TVectorD*>(matNum);; 1535 std::vector<TMatrixD*>* mat2 = new std::vector<TMatrixD*>(matNum);; 1536 std::vector<Double_t> count(matNum);; 1537 count.assign(matNum,0);; 1538 ; 1539 Int_t cls = 0;; 1540 TVectorD* v;; 1541 TMatrixD* m;; 1542 UInt_t ivar=0, jvar=0;; 1543 for (cls = 0; cls < matNum ; cls++) {; 1544 vec->at(cls) = new TVectorD(nvars);; 1545 mat2->at(cls) = new TMatrixD(nvars,nvars);; 1546 v = vec->at(cls);; 1547 m = mat2->at(cls);; 1548 ; 1549 for (ivar=0; ivar<nvars; ivar++) {; 1550 (*v)(ivar) = 0;; 1551 for (jvar=0; jvar<nvars; jvar++) {; 1552 (*m)(ivar, jvar) = 0;; 1553 }; 1554 }; 1555 }; 1556 ; 1557 // perform event loop; 1558 for (UInt_t i=0; i<events.size(); i++) {; 1559 ; 1560 // fill the event; 1561 const Event * ev = events[i];; 1562 cls = ev->GetClass();; 1563 Double_t weight = ev->GetWeight();; 1564 ; 1565 std::vector<Float_t> input;; 1566 std::vector<Char_t> mask; // entries with kTRUE must not be transformed; 1567 // Bool_t hasMaskedEntries = kFALSE;; 1568 if (transformBase) {; 1569 /* hasMaskedEntries = */ transformBase->GetInput (ev, input, mask);; 1570 } else {; 1571 for (ivar=0; ivar<nvars; ++ivar) {; 1572 input.push_back (ev->GetValue(ivar));; 1573 }; 1574 }; 1575 ; 1576 if (maxCls > 1) {; 1577 v = vec->at(matNum-1);; 1578 m = mat2->at(matNum-1);; 1579 ; 1580 count.at(matNum-1)+=weight; // count used events; 1581 for (ivar=0; ivar<nvars; ivar++) {; 1582 ; 1583 D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:55828,perform,perform,55828,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['perform'],['perform']
Performance,";; 1587 if (fTree) {; 1588 nentries = fTree->GetEntries();; 1589 }; 1590 ; 1591 if (fTreeOffset[fTreeNumber+1] != (fTreeOffset[fTreeNumber] + nentries)) {; 1592 fTreeOffset[fTreeNumber+1] = fTreeOffset[fTreeNumber] + nentries;; 1593 fEntries = fTreeOffset[fNtrees];; 1594 element->SetNumberEntries(nentries);; 1595 // Below we must test >= in case the tree has no entries.; 1596 if (entry >= fTreeOffset[fTreeNumber+1]) {; 1597 if ((fTreeNumber < (fNtrees - 1)) && (entry < fTreeOffset[fTreeNumber+2])) {; 1598 // The request entry is not in the tree 'fTreeNumber' we will need; 1599 // to look further.; 1600 ; 1601 // Before moving on, let's record the result.; 1602 element->SetLoadResult(returnCode);; 1603 ; 1604 // Before trying to read the file file/tree, notify the user; 1605 // that we have switched trees if requested; the user might need; 1606 // to properly account for the number of files/trees even if they; 1607 // have no entries.; 1608 if (fNotify) {; 1609 if(!fNotify->Notify()) return -6;; 1610 }; 1611 ; 1612 // Load the next TTree.; 1613 return LoadTree(entry);; 1614 } else {; 1615 treeReadEntry = fReadEntry = -2;; 1616 }; 1617 }; 1618 }; 1619 ; 1620 ; 1621 if (!fTree) {; 1622 // The Error message already issued. However if we reach here; 1623 // we need to make sure that we do not use fTree.; 1624 //; 1625 // Force a reload of the tree next time.; 1626 fTreeNumber = -1;; 1627 ; 1628 element->SetLoadResult(returnCode);; 1629 return returnCode;; 1630 }; 1631 // ----- End of modifications by MvL; 1632 ; 1633 // Copy the chain's clone list into the new tree's; 1634 // clone list so that branch addresses stay synchronized.; 1635 if (fClones) {; 1636 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 1637 TTree* clone = (TTree*) lnk->GetObject();; 1638 ((TChain*) fTree)->TTree::AddClone(clone);; 1639 }; 1640 }; 1641 ; 1642 // Since some of the friends of this chain might simple trees; 1643 // (i.e., not really chains at all), we need to execute t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:58205,Load,Load,58205,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['Load']
Performance,";; 15901 return 1;; 15902 }; 15903 return 0;; 15904}; 15905 ; 15906 ; 15907#if defined(OPENSSL_API_1_1); 15908#else; 15909static void; 15910ssl_locking_callback(int mode, int mutex_num, const char *file, int line); 15911{; 15912 (void)line;; 15913 (void)file;; 15914 ; 15915 if (mode & 1) {; 15916 /* 1 is CRYPTO_LOCK */; 15917 (void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);; 15918 } else {; 15919 (void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);; 15920 }; 15921}; 15922#endif /* OPENSSL_API_1_1 */; 15923 ; 15924 ; 15925#if !defined(NO_SSL_DL); 15926/* Load a DLL/Shared Object with a TLS/SSL implementation. */; 15927static void *; 15928load_tls_dll(char *ebuf,; 15929 size_t ebuf_len,; 15930 const char *dll_name,; 15931 struct ssl_func *sw,; 15932 int *feature_missing); 15933{; 15934 union {; 15935 void *p;; 15936 void (*fp)(void);; 15937 } u;; 15938 void *dll_handle;; 15939 struct ssl_func *fp;; 15940 int ok;; 15941 int truncated = 0;; 15942 ; 15943 if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {; 15944 mg_snprintf(NULL,; 15945 NULL, /* No truncation check for ebuf */; 15946 ebuf,; 15947 ebuf_len,; 15948 ""%s: cannot load %s"",; 15949 __func__,; 15950 dll_name);; 15951 return NULL;; 15952 }; 15953 ; 15954 ok = 1;; 15955 for (fp = sw; fp->name != NULL; fp++) {; 15956#if defined(_WIN32); 15957 /* GetProcAddress() returns pointer to function */; 15958 u.fp = (void (*)(void))dlsym(dll_handle, fp->name);; 15959#else; 15960 /* dlsym() on UNIX returns void *. ISO C forbids casts of data; 15961 * pointers to function pointers. We need to use a union to make a; 15962 * cast. */; 15963 u.p = dlsym(dll_handle, fp->name);; 15964#endif /* _WIN32 */; 15965 ; 15966 /* Set pointer (might be NULL) */; 15967 fp->ptr = u.fp;; 15968 ; 15969 if (u.fp == NULL) {; 15970 DEBUG_TRACE(""Missing function: %s\n"", fp->name);; 15971 if (feature_missing) {; 15972 feature_missing[fp->required]++;; 15973 }; 15974 if (fp->required == TLS_Mandatory) {; 15975 /* Mandatory function is missing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:471255,load,load,471255,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['load']
Performance,";; 15902 return 1;; 15903 }; 15904 return 0;; 15905}; 15906 ; 15907 ; 15908#if defined(OPENSSL_API_1_1); 15909#else; 15910static void; 15911ssl_locking_callback(int mode, int mutex_num, const char *file, int line); 15912{; 15913 (void)line;; 15914 (void)file;; 15915 ; 15916 if (mode & 1) {; 15917 /* 1 is CRYPTO_LOCK */; 15918 (void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);; 15919 } else {; 15920 (void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);; 15921 }; 15922}; 15923#endif /* OPENSSL_API_1_1 */; 15924 ; 15925 ; 15926#if !defined(NO_SSL_DL); 15927/* Load a DLL/Shared Object with a TLS/SSL implementation. */; 15928static void *; 15929load_tls_dll(char *ebuf,; 15930 size_t ebuf_len,; 15931 const char *dll_name,; 15932 struct ssl_func *sw,; 15933 int *feature_missing); 15934{; 15935 union {; 15936 void *p;; 15937 void (*fp)(void);; 15938 } u;; 15939 void *dll_handle;; 15940 struct ssl_func *fp;; 15941 int ok;; 15942 int truncated = 0;; 15943 ; 15944 if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {; 15945 mg_snprintf(NULL,; 15946 NULL, /* No truncation check for ebuf */; 15947 ebuf,; 15948 ebuf_len,; 15949 ""%s: cannot load %s"",; 15950 __func__,; 15951 dll_name);; 15952 return NULL;; 15953 }; 15954 ; 15955 ok = 1;; 15956 for (fp = sw; fp->name != NULL; fp++) {; 15957#if defined(_WIN32); 15958 /* GetProcAddress() returns pointer to function */; 15959 u.fp = (void (*)(void))dlsym(dll_handle, fp->name);; 15960#else; 15961 /* dlsym() on UNIX returns void *. ISO C forbids casts of data; 15962 * pointers to function pointers. We need to use a union to make a; 15963 * cast. */; 15964 u.p = dlsym(dll_handle, fp->name);; 15965#endif /* _WIN32 */; 15966 ; 15967 /* Set pointer (might be NULL) */; 15968 fp->ptr = u.fp;; 15969 ; 15970 if (u.fp == NULL) {; 15971 DEBUG_TRACE(""Missing function: %s\n"", fp->name);; 15972 if (feature_missing) {; 15973 feature_missing[fp->required]++;; 15974 }; 15975 if (fp->required == TLS_Mandatory) {; 15976 /* Mandatory function is missing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:471288,load,load,471288,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['load']
Performance,";; 1651 ; 1652 auto action = std::make_unique<Action_t>(Helper_t(std::move(f)), validColumnNames, fProxiedPtr, fColRegister);; 1653 ; 1654 fLoopManager->Run();; 1655 }; 1656 ; 1657 // clang-format off; 1658 ////////////////////////////////////////////////////////////////////////////; 1659 /// \brief Execute a user-defined reduce operation on the values of a column.; 1660 /// \tparam F The type of the reduce callable. Automatically deduced.; 1661 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1662 /// \param[in] f A callable with signature `T(T,T)`; 1663 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1664 /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; 1665 ///; 1666 /// A reduction takes two values of a column and merges them into one (e.g.; 1667 /// by summing them, taking the maximum, etc). This action performs the; 1668 /// specified reduction operation on all processed column values, returning; 1669 /// a single value of the same type. The callable f must satisfy the general; 1670 /// requirements of a *processing function* besides having signature `T(T,T)`; 1671 /// where `T` is the type of column columnName.; 1672 ///; 1673 /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; 1674 /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; 1675 /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; 1676 /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; 1677 /// overload.; 1678 ///; 1679 /// ### Example usage:; 1680 /// ~~~{.cpp}; 1681 /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; 1682 /// ~~~; 1683 ///; 1684 /// This action is *lazy*: upon invocation of this method the calculation is;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:93367,perform,performs,93367,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['perform'],['performs']
Performance,";; 1702 return -1; // indflg[0] = 1;; 1703 }; 1704 } else { // Chi2 method; 1705 sig = fEXDA[k2]; // sigma of experimental point; 1706 y = y - fEXDA[k1-1]; // f(x_i) - F_i; 1707 fS = fS + (y*y/(sig*sig))*.5; // simple chi2/2; 1708 }; 1709 Int_t n = 0;; 1710 for (i=0;i<fNpar;i++) {; 1711 if (fPL0[i]>0){; 1712 df[n] = df[i]/sig; // left only non-fixed param derivatives div by Sig; 1713 fGr[i] += df[n]*(y/sig);; 1714 n++;; 1715 }; 1716 }; 1717 l = 0;; 1718 for (i=0;i<n;i++); 1719 for (j=0;j<=i;j++); 1720 fZ[l++] += df[i]*df[j];; 1721 k2 += fNED2;; 1722 }; 1723 ; 1724 delete[] df;; 1725 delete[] x;; 1726 return 1;; 1727}; 1728 ; 1729 ; 1730////////////////////////////////////////////////////////////////////////////////; 1731/// Minimization function for H1s using a Chisquare method.; 1732/// Default method (function evaluated at center of bin); 1733/// for each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 177",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:49595,cache,cache,49595,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['cache'],['cache']
Performance,";; 1942 gLibraryVersion = TStorage::ReAllocInt(gLibraryVersion, gLibraryVersionMax, gLibraryVersionIdx);; 1943 }; 1944 ret = gInterpreter->Load(path, system);; 1945 if (ret < 0) ret = -1;; 1946 if (gDebug > 0); 1947 Info(""Load"", ""loaded library %s, status %d"", path, ret);; 1948 if (ret == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVersionCode2Int(gLibraryVersion[gLibraryVersionIdx]);; 1950 Error(""Load"", ""version mismatch, %s = %d, ROOT = %d"",; 1951 path, v, gROOT->GetVersionInt());; 1952 ret = -2;; 1953 gLibraryVersion[gLibraryVersionIdx] = 0;; 1954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:63681,load,loaded,63681,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,";; 1980 }; 1981 if ((fDimension==2) && (parm1>=kOptions1D) &&(parm1<kOptions2D)) {; 1982 Warning(""ProcessMessage"", ""1D drawing options not apply to 2D histograms."");; 1983 break;; 1984 }; 1985 // make composed option; 1986 MapOptions(parm1);; 1987 break;; 1988 }; 1989 switch (parm1) {; 1990 case kFileCanvas:; 1991 gROOT->MakeDefCanvas();; 1992 break;; 1993 case kFileBrowse:; 1994 if (true) {; 1995 static TString dir(""."");; 1996 TGFileInfo info;; 1997 info.fFileTypes = gOpenTypes;; 1998 info.SetIniDir(dir);; 1999 new TGFileDialog(fClient->GetRoot(), this, kFDOpen, &info);; 2000 if (!info.fFilename) return true;; 2001 dir = info.fIniDir;; 2002 TString command = TString::Format(""tv__tree_file = new TFile(\""%s\"");"",; 2003 gSystem->UnixPathName(info.fFilename));; 2004 ExecuteCommand(command.Data());; 2005 ExecuteCommand(""tv__tree_file->ls();"");; 2006 std::cout << ""Use SetTreeName() from context menu and supply a tree name"" << std::endl;; 2007 std::cout << ""The context menu is activated by right-clicking the panel from right"" << std::endl;; 2008 }; 2009 break;; 2010 case kFileLoadLibrary:; 2011 fBarCommand->SetText(""gSystem->Load(\""\"");"");; 2012 if (true) {; 2013 Event_t event;; 2014 event.fType = kButtonPress;; 2015 event.fCode = kButton1;; 2016 event.fX = event.fY = 1;; 2017 fBarCommand->HandleButton(&event);; 2018 }; 2019 fBarCommand->SetCursorPosition(15);; 2020 break;; 2021 case kFileOpenSession:; 2022 if (true) {; 2023 static TString dir(""."");; 2024 TGFileInfo info;; 2025 info.fFileTypes = gMacroTypes;; 2026 info.SetIniDir(dir);; 2027 new TGFileDialog(fClient->GetRoot(), this, kFDOpen, &info);; 2028 if (!info.fFilename) return true;; 2029 dir = info.fIniDir;; 2030 gInterpreter->Reset();; 2031 if (!gInterpreter->IsLoaded(info.fFilename)) gInterpreter->LoadMacro(info.fFilename);; 2032 char command[1024];; 2033 command[0] = 0;; 2034 snprintf(command,1024,""open_session((void*)0x%zx);"", (size_t)this);; 2035 ExecuteCommand(command);; 2036 }; 2037 break;; 2038 case kFileSa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:72685,Load,Load,72685,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['Load'],['Load']
Performance,";; 210 RNTupleWriteOptions fWriteOptions;; 211 ; 212 /// Whether or not dot characters in branch names should be converted to underscores. If this option is not set and a; 213 /// branch with a '.' is encountered, the importer will throw an exception.; 214 bool fConvertDotsInBranchNames = false;; 215 ; 216 /// The maximum number of entries to import. When this value is -1 (default), import all entries.; 217 std::int64_t fMaxEntries = -1;; 218 ; 219 /// No standard output, conversely if set to false, schema information and progress is printed.; 220 bool fIsQuiet = false;; 221 std::unique_ptr<RProgressCallback> fProgressCallback;; 222 FieldModifier_t fFieldModifier;; 223 ; 224 std::unique_ptr<RNTupleModel> fModel;; 225 std::unique_ptr<REntry> fEntry;; 226 std::vector<RImportBranch> fImportBranches;; 227 std::vector<RImportField> fImportFields;; 228 /// Maps the count leaf to the information about the corresponding untyped collection; 229 std::map<std::string, RImportLeafCountCollection> fLeafCountCollections;; 230 /// The list of transformations to be performed for every entry; 231 std::vector<std::unique_ptr<RImportTransformation>> fImportTransformations;; 232 ; 233 ROOT::Experimental::RResult<void> InitDestination(std::string_view destFileName);; 234 ; 235 void ResetSchema();; 236 /// Sets up the connection from TTree branches to RNTuple fields, including initialization of the memory; 237 /// buffers used for reading and writing.; 238 RResult<void> PrepareSchema();; 239 void ReportSchema();; 240 ; 241public:; 242 RNTupleImporter(const RNTupleImporter &other) = delete;; 243 RNTupleImporter &operator=(const RNTupleImporter &other) = delete;; 244 RNTupleImporter(RNTupleImporter &&other) = delete;; 245 RNTupleImporter &operator=(RNTupleImporter &&other) = delete;; 246 ~RNTupleImporter() = default;; 247 ; 248 /// Opens the input file for reading and the output file for writing (update).; 249 static std::unique_ptr<RNTupleImporter>; 250 Create(std::string_view sourceFileNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8hxx_source.html:10757,perform,performed,10757,doc/master/RNTupleImporter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx_source.html,1,['perform'],['performed']
Performance,";; 2249 Printf(""******************************************************************************"");; 2250 TFile *file = TFile::Open(element->GetTitle());; 2251 if (file && !file->IsZombie()) {; 2252 TTree *tree = (TTree*)file->Get(element->GetName());; 2253 if (tree) tree->Print(option);; 2254 }; 2255 delete file;; 2256 }; 2257}; 2258 ; 2259////////////////////////////////////////////////////////////////////////////////; 2260/// Process all entries in this chain, calling functions in filename.; 2261/// The return value is -1 in case of error and TSelector::GetStatus() in; 2262/// in case of success.; 2263/// See TTree::Process.; 2264 ; 2265Long64_t TChain::Process(const char *filename, Option_t *option, Long64_t nentries, Long64_t firstentry); 2266{; 2267 if (fProofChain) {; 2268 // Make sure the element list is up to date; 2269 if (!TestBit(kProofUptodate)); 2270 SetProof(true, true);; 2271 fProofChain->SetEventList(fEventList);; 2272 fProofChain->SetEntryList(fEntryList);; 2273 return fProofChain->Process(filename, option, nentries, firstentry);; 2274 }; 2275 ; 2276 if (LoadTree(firstentry) < 0) {; 2277 return 0;; 2278 }; 2279 return TTree::Process(filename, option, nentries, firstentry);; 2280}; 2281 ; 2282////////////////////////////////////////////////////////////////////////////////; 2283/// Process this chain executing the code in selector.; 2284/// The return value is -1 in case of error and TSelector::GetStatus() in; 2285/// in case of success.; 2286 ; 2287Long64_t TChain::Process(TSelector* selector, Option_t* option, Long64_t nentries, Long64_t firstentry); 2288{; 2289 if (fProofChain) {; 2290 // Make sure the element list is up to date; 2291 if (!TestBit(kProofUptodate)); 2292 SetProof(true, true);; 2293 fProofChain->SetEventList(fEventList);; 2294 fProofChain->SetEntryList(fEntryList);; 2295 return fProofChain->Process(selector, option, nentries, firstentry);; 2296 }; 2297 ; 2298 return TTree::Process(selector, option, nentries, firstentry);; 2299}; 2300 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:82372,Load,LoadTree,82372,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,";; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_tail; /* Tail of the socket queue */; 2357 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2358 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2359 volatile int sq_blocked; /* Status information: sq is full */; 2360 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:72857,queue,queue,72857,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,4,['queue'],['queue']
Performance,";; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_tail; /* Tail of the socket queue */; 2358 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2359 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2360 volatile int sq_blocked; /* Status information: sq is full */; 2361 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:72889,queue,queue,72889,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,4,['queue'],['queue']
Performance,";; 2367 ; 2368 if (nbits > 60) {; 2369 Log() << kERROR << ""Number of combinations is too large , is 2^"" << nbits << Endl;; 2370 return nullptr;; 2371 }; 2372 long int range = sum(nbits);; 2373 // std::cout<<range<<std::endl;; 2374 // vector to save importances; 2375 std::vector<Double_t> importances(nbits);; 2376 for (int i = 0; i < nbits; i++); 2377 importances[i] = 0;; 2378 ; 2379 Double_t SROC, SSROC; // computed ROC value; 2380 ; 2381 x = range;; 2382 ; 2383 std::bitset<VIBITS> xbitset(x);; 2384 if (x == 0); 2385 Log() << kFATAL << ""Error: need at least one variable.""; // data loader need at least one variable; 2386 ; 2387 // creating loader for seed; 2388 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2389 ; 2390 // adding variables from seed; 2391 for (int index = 0; index < nbits; index++) {; 2392 if (xbitset[index]); 2393 seedloader->AddVariable(varNames[index], 'F');; 2394 }; 2395 ; 2396 // Loading Dataset; 2397 DataLoaderCopy(seedloader, loader);; 2398 ; 2399 // Booking Seed; 2400 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2401 ; 2402 // Train/Test/Evaluation; 2403 TrainAllMethods();; 2404 TestAllMethods();; 2405 EvaluateAllMethods();; 2406 ; 2407 // getting ROC; 2408 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2409 ; 2410 // cleaning information to process sub-seeds; 2411 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2412 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2413 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2414 delete sresults;; 2415 delete seedloader;; 2416 this->DeleteAllMethods();; 2417 fMethodsMap.clear();; 2418 ; 2419 // removing global result because it is requiring a lot of RAM for all seeds; 2420 ; 2421 for (uint32_t i = 0; i < VIBITS; ++i) {; 2422 if (x & (1 << i)) {; 2423 y = x & ~(uint64_t(1) << i);; 2424 std::bitset<VIBITS> ybitset(y);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:99972,Load,Loading,99972,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,"['Load', 'load']","['Loading', 'loader']"
Performance,";; 3023 ; 3024 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 3025 else fWriteMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3026 ; 3027 if (fWriteText) fWriteText->fActions.clear();; 3028 else fWriteText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3029 ; 3030 if (!ndata) {; 3031 // This may be the case for empty classes (e.g., TAtt3D).; 3032 // We still need to properly set the size of emulated classes (i.e. add the virtual table); 3033 if (fClass->GetState() == TClass::kEmulated && fNVirtualInfoLoc!=0) {; 3034 fSize = sizeof(TStreamerInfo*);; 3035 }; 3036 fComp = new TCompInfo[1];; 3037 fCompFull = new TCompInfo*[1];; 3038 fCompOpt = new TCompInfo*[1];; 3039 fCompOpt[0] = fCompFull[0] = &(fComp[0]);; 3040 SetIsCompiled();; 3041 return;; 3042 }; 3043 ; 3044 // At most half of the elements can be used to hold optimized versions.; 3045 // We use the bottom to hold the optimized-into elements and the non-optimized elements; 3046 // and the top to hold the original copy of the optimized out elements.; 3047 fNslots = ndata + ndata/2 + 1;; 3048 Int_t optiOut = 0;; 3049 ; 3050 fComp = new TCompInfo[fNslots];; 3051 fCompFull = new TCompInfo*[ndata];; 3052 fCompOpt = new TCompInfo*[ndata];; 3053 ; 3054 TStreamerElement* element;; 3055 TStreamerElement* previous = 0;; 3056 Int_t keep = -1;; 3057 Int_t i;; 3058 ; 3059 if (!CanOptimize()) {; 3060 SetBit(kCannotOptimize);; 3061 }; 3062 ; 3063 Bool_t isOptimized = kFALSE;; 3064 Bool_t previousOptimized = kFALSE;; 3065 ; 3066 for (i = 0; i < ndata; ++i) {; 3067 element = (TStreamerElement*) fElements->At(i);; 3068 if (!element) {; 3069 break;; 3070 }; 3071 ; 3072 Int_t asize = element->GetSize();; 3073 if (element->GetArrayLength()) {; 3074 asize /= element->GetArrayLength();; 3075 }; 3076 fComp[fNdata].fType = element->GetType();; 3077 fComp[fNdata].fNewType = element->GetNewType();; 3078 fComp[fNdata].fOffset = element->GetOffset();; 3079 fComp[fNdata].fL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:133445,optimiz,optimized-into,133445,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,3,['optimiz'],"['optimized', 'optimized-into']"
Performance,";; 303 ; 304 // Re-compute bounding box of mother(s) if needed; 305 for (i = fLevel - 1; i > 0; i--) {; 306 Bool_t dassm = vd->IsAssembly(); // is daughter assembly ?; 307 vd = GetVolume(i);; 308 if (!vd); 309 break;; 310 Bool_t cassm = vd->IsAssembly(); // is current assembly ?; 311 if (cassm); 312 ((TGeoShapeAssembly *)vd->GetShape())->NeedsBBoxRecompute();; 313 if ((cassm || dassm) && vd->GetVoxels()); 314 vd->GetVoxels()->SetNeedRebuild();; 315 if (!cassm); 316 break;; 317 }; 318 ; 319 // Now we have to re-voxelize the mother volume; 320 TGeoVoxelFinder *voxels = vm->GetVoxels();; 321 if (voxels); 322 voxels->SetNeedRebuild();; 323 // Eventually check for overlaps; 324 if (check) {; 325 if (voxels) {; 326 voxels->Voxelize();; 327 vm->FindOverlaps();; 328 }; 329 // Set aligned node to be checked; 330 i = fLevel;; 331 node = GetNode(i);; 332 if (!node); 333 return kTRUE;; 334 if (node->IsOverlapping()) {; 335 Info(""Align"",; 336 ""The check for overlaps for node: \n%s\n cannot be performed since the node is declared possibly ""; 337 ""overlapping"",; 338 GetName());; 339 } else {; 340 gGeoManager->SetCheckedNode(node);; 341 // Check overlaps for the first non-assembly parent node; 342 while ((node = GetNode(--i))) {; 343 if (!node->GetVolume()->IsAssembly()); 344 break;; 345 }; 346 if (node && node->IsOverlapping()) {; 347 Info(""Align"",; 348 ""The check for overlaps for assembly node: \n%s\n cannot be performed since the parent %s is declared ""; 349 ""possibly overlapping"",; 350 GetName(), node->GetName());; 351 node = nullptr;; 352 }; 353 if (node); 354 node->CheckOverlaps(ovlp);; 355 gGeoManager->SetCheckedNode(nullptr);; 356 }; 357 }; 358 // Clean current matrices from cache; 359 gGeoManager->CdTop();; 360 SetAligned(kTRUE);; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365 ; 366void TGeoPhysicalNode::cd() const; 367{; 368 if (GetNode(0) != gGeoManager->GetTopNode()); 369 return;; 370 gGeoManager->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:11719,perform,performed,11719,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['perform'],['performed']
Performance,";; 339 settings.learningRate = fetchValueTmp(block, ""LearningRate"", 1e-5);; 340 settings.momentum = fetchValueTmp(block, ""Momentum"", 0.3);; 341 settings.dropoutProbabilities = fetchValueTmp(block, ""DropConfig"", std::vector<Double_t>());; 342 ; 343 TString regularization = fetchValueTmp(block, ""Regularization"", TString(""NONE""));; 344 if (regularization == ""L1"") {; 345 settings.regularization = DNN::ERegularization::kL1;; 346 } else if (regularization == ""L2"") {; 347 settings.regularization = DNN::ERegularization::kL2;; 348 } else {; 349 settings.regularization = DNN::ERegularization::kNone;; 350 }; 351 ; 352 TString optimizer = fetchValueTmp(block, ""Optimizer"", TString(""ADAM""));; 353 settings.optimizerName = optimizer;; 354 if (optimizer == ""SGD"") {; 355 settings.optimizer = DNN::EOptimizer::kSGD;; 356 } else if (optimizer == ""ADAM"") {; 357 settings.optimizer = DNN::EOptimizer::kAdam;; 358 } else if (optimizer == ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optimizer = DNN::EOptimizer::kRMSProp;; 362 } else if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:13971,optimiz,optimizer,13971,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],['optimizer']
Performance,";; 3486 if (R__v > 2) {; 3487 R__b.ReadClassBuffer(TH3::Class(), this, R__v, R__s, R__c);; 3488 return;; 3489 }; 3490 //====process old versions before automatic schema evolution; 3491 TH1::Streamer(R__b);; 3492 TAtt3D::Streamer(R__b);; 3493 R__b.CheckByteCount(R__s, R__c, TH3::IsA());; 3494 //====end of old versions; 3495 ; 3496 } else {; 3497 R__b.WriteClassBuffer(TH3::Class(),this);; 3498 }; 3499}; 3500 ; 3501////////////////////////////////////////////////////////////////////////////////; 3502/// static methdod performing the projection to 1D histogram; 3503 ; 3504TH1D *TH3::DoProject1D(const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors,; 3505 bool originalRange, bool useUF, bool useOF); 3506{; 3507 return h.DoProject1D(name, title, projX, nullptr, nullptr, computeErrors, originalRange, useUF, useOF);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// static methdod performing the projection to 2D histogram; 3512 ; 3513TH2D *TH3::DoProject2D(const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY,; 3514 bool computeErrors, bool originalRange, bool useUF, bool useOF); 3515{; 3516 return h.DoProject2D(name, title, projX, projY, computeErrors, originalRange, useUF, useOF);; 3517}; 3518 ; 3519//______________________________________________________________________________; 3520// TH3C methods; 3521// TH3C a 3-D histogram with one byte per cell (char); 3522//______________________________________________________________________________; 3523 ; 3524ClassImp(TH3C);; 3525 ; 3526 ; 3527////////////////////////////////////////////////////////////////////////////////; 3528/// Constructor.; 3529 ; 3530TH3C::TH3C(); 3531{; 3532 SetBinsLength(27);; 3533 if (fgDefaultSumw2) Sumw2();; 3534}; 3535 ; 3536 ; 3537////////////////////////////////////////////////////////////////////////////////; 3538/// Destructor.; 3539 ; 3540TH3C::~TH3C(); 3541{; 3542}; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:137423,perform,performing,137423,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['perform'],['performing']
Performance,";; 3837 }; 3838 ; 3839 } else; 3840 ; 3841 // use generic write action when special handling is not provided; 3842 if (generic); 3843 writeSequence->AddAction(GenericWriteAction, new TGenericConfiguration(this, i, compinfo));; 3844 ; 3845#if defined(CDJ_NO_COMPILE); 3846 if (element->TestBit(TStreamerElement::kCache)) {; 3847 TConfiguredAction action(writeSequence->fActions.back()); // Action is moved, we must pop it next.; 3848 writeSequence->fActions.pop_back();; 3849 writeSequence->AddAction(UseCache,; 3850 new TConfigurationUseCache(this, action, element->TestBit(TStreamerElement::kRepeat)));; 3851 }; 3852#endif; 3853}; 3854 ; 3855////////////////////////////////////////////////////////////////////////////////; 3856/// This is for streaming via a TClonesArray (or a vector of pointers of this type).; 3857 ; 3858void TStreamerInfo::AddWriteMemberWiseVecPtrAction(TStreamerInfoActions::TActionSequence *writeSequence, Int_t i, TStreamerInfo::TCompInfo *compinfo); 3859{; 3860 TStreamerElement *element = compinfo->fElem;; 3861 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 3862 // Skip element cached for reading purposes.; 3863 return;; 3864 }; 3865 if (element->GetType() >= kArtificial && !element->TestBit(TStreamerElement::kWrite)) {; 3866 // Skip artificial element used for reading purposes.; 3867 return;; 3868 }; 3869 ; 3870#if defined(CDJ_NO_COMPILE); 3871 if (element->TestBit(TStreamerElement::kCache)) {; 3872 TConfiguredAction action( GetCollectionWriteAction<VectorLooper>(this,element,compinfo->fType,i,compinfo,compinfo->fOffset) );; 3873 writeSequence->AddAction( UseCacheVectorPtrLoop, new TConfigurationUseCache(this,action,element->TestBit(TStreamerElement::kRepeat)) );; 3874 } else {; 3875 writeSequence->Addaction( GetCollectionWriteAction<VectorPtrLooper>(this,element,compinfo->fType,i,compinfo,compinfo->fOffset) );; 3876 }; 3877#else; 3878 writeSequence->AddAction( VectorPtrLooper::GenericWrite, new TGener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:179513,cache,cached,179513,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,";; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPathName(lib, kReadPermission)) {; 563 if (linkedDylibs.Length()); 564 linkedDylibs += "" "";; 565 linkedDylibs += lib;; 566 }; 567 }; 568}; 569#endif; 570 ; 571ClassImp(TUnixSystem);; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574 ; 575TUnixSystem::TUnixSystem() : TSystem(""Unix"", ""Unix System""); 576{ }; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:16165,load,loaded,16165,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['loaded']
Performance,";; 529 _norm = new RooRealVar(nname.c_str(),ntitle.c_str(),1) ;; 530 } else {; 531 const char* nr = (_normRangeOverride.Length()>0 ? _normRangeOverride.Data() : (_normRange.Length()>0 ? _normRange.Data() : nullptr)) ;; 532 ; 533// cout << ""RooAbsPdf::syncNormalization("" << GetName() << "") rangeName for normalization is "" << (nr?nr:""<null>"") << endl ;; 534 RooAbsReal* normInt;; 535 {; 536 // Normalization is always over all pdf components. Overriding the global; 537 // component selection temporarily makes all RooRealIntegrals created during; 538 // that time always include all components.; 539 GlobalSelectComponentRAII selCompRAII(true);; 540 normInt = std::unique_ptr<RooAbsReal>{createIntegral(depList,*getIntegratorConfig(),nr)}.release();; 541 }; 542 static_cast<RooRealIntegral*>(normInt)->setAllowComponentSelection(false);; 543 normInt->getVal() ;; 544// cout << ""resulting normInt = "" << normInt->GetName() << endl ;; 545 ; 546 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 547 if (cacheParamsStr && strlen(cacheParamsStr)) {; 548 ; 549 std::unique_ptr<RooArgSet> intParams{normInt->getVariables()} ;; 550 ; 551 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 552 ; 553 if (!cacheParams.empty()) {; 554 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 555 << ""-dim value cache for integral over "" << depList << "" as a function of "" << cacheParams << "" in range "" << (nr?nr:""<default>"") << endl ;; 556 string name = Form(""%s_CACHE_[%s]"",normInt->GetName(),cacheParams.contentsString().c_str()) ;; 557 RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,cacheParams) ;; 558 cachedIntegral->setInterpolationOrder(2) ;; 559 cachedIntegral->addOwnedComponents(*normInt) ;; 560 cachedIntegral->setCacheSource(true) ;; 561 if (normInt->operMode()==ADirty) {; 562 cachedIntegral->setOperMode(ADirty) ;; 563 }; 564 normInt= cachedIntegral ;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:21053,cache,cacheParamsStr,21053,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,7,"['CACHE', 'cache']","['CACHEPARAMINT', 'cacheParams', 'cacheParamsStr']"
Performance,";; 558 methodList += regMethod;; 559 }; 560 return TMVAClassification(methodList);; 561}; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Double_tdouble Double_tDefinition RtypesCore.h:59; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; TSystem.h; TTree.h; Tools.h; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kTMlpANN@ kTMlpANNDefinition Types.h:85; TMVA::Types::kFDA@ kFDADefinition Types.h:92; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kPDERS@ kPDERSDefinition Types.h:80; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kPDEFoam@ kPDEFoamDefinition Types.h:94; TMVA::Types::kLikelihood@ kLikelihoodDefinition Types.h:79; TMVA::Types::kCuts@ kCutsDefinition Types.h:78; TMVA::Types::kLD@ kLDDefinition Types.h:95; TMVA::Types::kHMatrix@ kHMatrixDefinition Types.h:81; TMVA::Types::k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:28796,cache,cacheDir,28796,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,2,['cache'],"['cache', 'cacheDir']"
Performance,";; 689 return kTRUE;; 690 }; 691 ; 692 // add call arg to the list; 693 std::unique_lock<std::mutex> lk(fMutex);; 694 fArgs.push(arg);; 695 return kFALSE;; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Process requests, submitted for execution; 700///; 701/// Returns number of processed requests; 702///; 703/// Normally invoked by THttpTimer, when somewhere in the code; 704/// gSystem->ProcessEvents() is called.; 705/// User can call serv->ProcessRequests() directly, but only from main thread.; 706/// If special server thread is created, called from that thread; 707 ; 708Int_t THttpServer::ProcessRequests(); 709{; 710 auto id = TThread::SelfId();; 711 ; 712 if (fMainThrdId != id) {; 713 if (gDebug > 0 && fMainThrdId); 714 Warning(""ProcessRequests"", ""Changing main thread to %ld"", (long)id);; 715 fMainThrdId = id;; 716 }; 717 ; 718 Bool_t recursion = kFALSE;; 719 ; 720 if (fProcessingThrdId) {; 721 if (fProcessingThrdId == id) {; 722 recursion = kTRUE;; 723 } else {; 724 Error(""ProcessRequests"", ""Processing already running from %ld thread"", (long) fProcessingThrdId);; 725 return 0;; 726 }; 727 }; 728 ; 729 if (!recursion); 730 fProcessingThrdId = id;; 731 ; 732 Int_t cnt = 0;; 733 ; 734 std::unique_lock<std::mutex> lk(fMutex, std::defer_lock);; 735 ; 736 // first process requests in the queue; 737 while (true) {; 738 std::shared_ptr<THttpCallArg> arg;; 739 ; 740 lk.lock();; 741 if (!fArgs.empty()) {; 742 arg = fArgs.front();; 743 fArgs.pop();; 744 }; 745 lk.unlock();; 746 ; 747 if (!arg); 748 break;; 749 ; 750 if (arg->fFileName == ""root_batch_holder.js"") {; 751 ProcessBatchHolder(arg);; 752 continue;; 753 }; 754 ; 755 auto prev = fSniffer->SetCurrentCallArg(arg.get());; 756 ; 757 try {; 758 cnt++;; 759 ProcessRequest(arg);; 760 fSniffer->SetCurrentCallArg(prev);; 761 } catch (...) {; 762 fSniffer->SetCurrentCallArg(prev);; 763 }; 764 ; 765 arg->NotifyCondition();; 766 }; 767 ; 768 // regularly call Process() m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:23430,queue,queue,23430,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['queue'],['queue']
Performance,";; 8949 TBranch *b;; 8950 while ( ( b = (TBranch*)next() ) ) {; 8951 b->SetEntryOffsetLen( newdefault, true );; 8952 }; 8953 if (fBranchRef) {; 8954 fBranchRef->SetEntryOffsetLen( newdefault, true );; 8955 }; 8956 }; 8957}; 8958 ; 8959////////////////////////////////////////////////////////////////////////////////; 8960/// Change the tree's directory.; 8961///; 8962/// Remove reference to this tree from current directory and; 8963/// add reference to new directory dir. The dir parameter can; 8964/// be 0 in which case the tree does not belong to any directory.; 8965///; 8966 ; 8967void TTree::SetDirectory(TDirectory* dir); 8968{; 8969 if (fDirectory == dir) {; 8970 return;; 8971 }; 8972 if (fDirectory) {; 8973 fDirectory->Remove(this);; 8974 ; 8975 // Delete or move the file cache if it points to this Tree; 8976 TFile *file = fDirectory->GetFile();; 8977 MoveReadCache(file,dir);; 8978 }; 8979 fDirectory = dir;; 8980 if (fDirectory) {; 8981 fDirectory->Append(this);; 8982 }; 8983 TFile* file = nullptr;; 8984 if (fDirectory) {; 8985 file = fDirectory->GetFile();; 8986 }; 8987 if (fBranchRef) {; 8988 fBranchRef->SetFile(file);; 8989 }; 8990 TBranch* b = nullptr;; 8991 TIter next(GetListOfBranches());; 8992 while((b = (TBranch*) next())) {; 8993 b->SetFile(file);; 8994 }; 8995}; 8996 ; 8997////////////////////////////////////////////////////////////////////////////////; 8998/// Change number of entries in the tree.; 8999///; 9000/// If n >= 0, set number of entries in the tree = n.; 9001///; 9002/// If n < 0, set number of entries in the tree to match the; 9003/// number of entries in each branch. (default for n is -1); 9004///; 9005/// This function should be called only when one fills each branch; 9006/// independently via TBranch::Fill without calling TTree::Fill.; 9007/// Calling TTree::SetEntries() make sense only if the number of entries; 9008/// in each branch is identical, a warning is issued otherwise.; 9009/// The function returns the number of entries.; 9010/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:347903,cache,cache,347903,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,";; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindCPAsymVar.html:32692,cache,cache,32692,root/html526/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html526/RooUnblindCPAsymVar.html,2,['cache'],['cache']
Performance,";; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; We can see there is a tree “T”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches.; root[] T->Print();; From the output of print we can see that the tree has one branch for each data member of Event, Track, and EventHeader. Now we can use TTree::MakeClass on our tree “T”. MakeClass takes one parameter, a string containing the name of the class to be made. In the command below, the name of our class will be “MyClass”.; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; Cling informs us that it has created two files. MyClass.h contains the class definition and MyClass.C contains the MyClass::Loop() method. MyClass has more methods than just Loop(). The other methods are a constructor, a destructor, GetEntry(), LoadTree(), Notify(), Cut() and Show(). The implementations of these methods are in the .h file. This division of methods was done intentionally. The .C file is kept as short as possible, and contains only code that is intended for you to customize. The .h file contains all the other methods. It is clear that you want to be as independent as possible of the header file (i.e. MyClass.h) generated by MakeClass. The solution is to implement a derived class, for example MyRealClass deriving from MyClass such that a change in your Treeor regeneration of MyClass.h does not force you to change MyRealClass.h. You can imagine deriving several classes from MyClass.h, each with a specific algorithm. To understand both files, let’s start with MyClass.h and the class declaration:; 12.21.2 MyClass.h; class MyClass {; public :; // Pointer to the analyzed TTree or TChain; TTree *fChain;; // Current Tree number in a TChain; Int_t fCurrent;; // Declaration of leaves types; UInt_t fUniqueID;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:636890,Load,LoadTree,636890,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['LoadTree']
Performance,";; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in the use of borders because of the potential for clutter. Do not place them around single entry fields, single combo boxes, list boxes and groups of command buttons. The design of these widgets provides them with a border. The picture above provides kind of borders to avoid.; 25.6 Layout Management; The layout process is an integral part of any GUI. When you create a simple message window, laying out its few buttons and text widgets is quite simple. However, this process becomes increasingly difficult if you have to implement large GUI’s with many widgets that should behave properly when the GUI is resized or uses a different font type or size. Layout management is the process of determining the size and position of every widget in a container.; A layout manager is an object that performs layout management for the widgets within a container. You already know that when adding a component (child widget) to a container (parent widget) you can provide alignment hints (or rely on the default ones). These hints are used by the layout manager to correctly position the widgets in the container. The TGLayoutManager is an abstract class providing the basic layout functionality. The layout classes hierarchy. The base “container” class is TGCmpositeFrame. You can easily change the layout manager using the SetLayoutManager(TGLayoutManager *l) method. Setting the proper layout manager for each container is the first step you have to do. The container uses that layout manager to position and size the components before they are painted. ROOT currently provides the layout managers shown on the picture above.; The next important step is to provide hints about every widget in the container, i.e. to provide positions and right amount of space between the components. The TGLayoutHints objects s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1157956,perform,performs,1157956,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performs']
Performance,";; dnnMethodName = ""DNN_GPU"";; } else {; dnnOptions += "":Architecture=CPU"";; }; ; factory.BookMethod(loader, TMVA::Types::kDL, dnnMethodName, dnnOptions);; }; ; // Keras deep learning; if (useKeras) {; ; Info(""TMVA_Higgs_Classification"", ""Building deep neural network with keras "");; // create python script which can be executed; // create 2 conv2d layer + maxpool + dense; TMacro m;; m.AddLine(""import tensorflow"");; m.AddLine(""from tensorflow.keras.models import Sequential"");; m.AddLine(""from tensorflow.keras.optimizers import Adam"");; m.AddLine(""from tensorflow.keras.layers import Input, Dense"");; m.AddLine("""");; m.AddLine(""model = Sequential() "");; m.AddLine(""model.add(Dense(64, activation='relu',input_dim=7))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(2, activation='sigmoid'))"");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('Higgs_model.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_higgs_model.py"");; ; if (gSystem->AccessPathName(""Higgs_model.h5"")) {; Warning(""TMVA_Higgs_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_Higgs_Classification"", ""Booking tf.Keras Dense model"");; factory.BookMethod(; loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=Higgs_model.h5:tf.keras:""; ""FilenameTrainedModel=Higgs_trained_model.h5:NumEpochs=20:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; /**; ## Train Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:68111,optimiz,optimizer,68111,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['optimiz'],['optimizer']
Performance,";; float ComputeInvariantMass(RVecF pt, RVecF eta, RVecF phi, RVecF e) {; ROOT::Math::PtEtaPhiEVector p1(pt[0], eta[0], phi[0], e[0]);; ROOT::Math::PtEtaPhiEVector p2(pt[1], eta[1], phi[1], e[1]);; return (p1 + p2).mass() / 1000.0;; }; """"""); ; # Define a new column with the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] for s in [""ggH"", ""VBF"", ""data""]]); ; ggh = hists[""ggH""].GetValue(); vbf = hists[""VBF""].GetValue(); data = hists[""data""].GetValue(); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pads for main plot and data/MC ratio; c = ROOT.TCanvas(""c"", """", 700, 750); ; upper_pad = ROOT.TPad(""upper_pad"", """", 0, 0.35, 1, 1); lower_pad = ROOT.TPad(""lower_pad"", """", 0, 0, 1, 0.35); for p in [upper_pad, lower_pad]:; p.SetLeftMargin(0.14); p.SetRightMargin(0.05); p.SetTickx(False); p.SetTicky(False); upper_pad.SetBottomMargin(0); lower_pad.SetTopMargin(0); lower_pad.SetBottomMargin(0.3); ; upper_pad.Draw(); lower_pad.Draw(); ; # Fit signal + backg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:3702,concurren,concurrently,3702,doc/master/df104__HiggsToTwoPhotons_8py.html,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html,1,['concurren'],['concurrently']
Performance,";; root[] TEntryList *list2 = new TEntryList(""list2"", ""list2"");; root[] list2->SetTree(""tree2"", ""file2"");; root[] list2->Enter(0);; root[] list2->Enter(3);; root[] list1->Add(list2);; root[] list1->Print(""all""); tree1 file1; 0; 2; tree2 file2; 0; 3; The result is a TEntryList for a TChain of tree1 and tree2. If the second list was for the same TTree in the same file as the first list, the result would be as follows:; root[] TEntryList *list2_2 = new TEntryList(""list2_2"", ""list2_2"");; root[] list2_2->SetTree(""tree2"", ""file2"");; root[] list2_2->Enter(1);; root[] list2_2->Enter(2);; root[] list2->Add(list2_2);; root[] list2->Print(""all""); tree2 file2; 0; 1; 2; 3; 12.20.10.4 TEntryListFromFile; This is a special kind of TEntryList, used only when processing TChain objects (see the method TChain::SetEntryListFile()). It is used in the case, when the entry lists, corresponding to the trees of this chain, are stored in separate files. It allows to load the entry lists in memory one by one, keeping only the list for the currently processed tree loaded.; For more details on entry lists, see TEntryList, TEntryListBlock and TEntryListFromFile class descriptions, functions TChain::SetEntryList(), TChain::SetEntryListFile(), and the macro $ROOTSYS/test/stressEntryList.C.; 12.20.11 Filling a Histogram; The TTree::Draw method can also be used to fill a specific histogram. The syntax is:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; As we can see, this created a TH1, called myHisto. If you want to append more entries to the histogram, you can use this syntax:; root[] T->Draw(""fNtrack >>+ myHisto""); If you do not create a histogram ahead of time, ROOT will create one at the time of the Draw command (as is the case above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ah",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:627760,load,load,627760,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],"['load', 'loaded']"
Performance,";; }; ; //write a Tree; TFile *hfile = new TFile(""clonesA_Event.root"",""RECREATE"",""Test TClonesArray"");; TTree *tree = new TTree(""clonesA_Event"",""An example of a ROOT tree"");; TUsrSevtData1 *event1 = new TUsrSevtData1();; TUsrSevtData2 *event2 = new TUsrSevtData2();; tree->Branch(""top1"",""TUsrSevtData1"",&event1,8000,99);; tree->Branch(""top2"",""TUsrSevtData2"",&event2,8000,99);; for (Int_t ev = 0; ev < 10; ev++) {; cout << ""event "" << ev << endl;; event1->SetEvent(ev);; event2->SetEvent(ev);; tree->Fill();; if (ev <3) tree->Show(ev);; }; tree->Write();; tree->Print();; delete hfile;; }; ; void clonesA_Event_r(); {; //read the Tree; TFile * hfile = new TFile(""clonesA_Event.root"");; TTree *tree = (TTree*)hfile->Get(""clonesA_Event"");; ; TUsrSevtData1 * event1 = 0;; TUsrSevtData2 * event2 = 0;; tree->SetBranchAddress(""top1"",&event1);; tree->SetBranchAddress(""top2"",&event2);; for (Int_t ev = 0; ev < 8; ev++) {; tree->Show(ev);; cout << ""Pileup event1: "" << event1->GetPileup() << endl;; cout << ""Pileup event2: "" << event2->GetPileup() << endl;; event1->Clear();; event2->Clear();; // gObjectTable->Print(); // detect possible memory leaks; }; delete hfile;; }; ; void clonesA_Event(bool /*secondrun*/) {; // Embedding this load inside the first run of the script is not yet; // supported in v6; // gROOT->ProcessLine("".L clonesA_Event.cxx+""); // compile shared lib; clonesA_Event_w(); // write the tree; clonesA_Event_r(); // read back the tree; }; ; #endif; s1#define s1(x)Definition RSha256.hxx:91; Int_tint Int_tDefinition RtypesCore.h:45; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TMrbSubevent_Caen::Clearvoid Clear(Option_t *="""")Definition clonesA_Ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/clonesA__Event_8C.html:2414,load,load,2414,doc/master/clonesA__Event_8C.html,https://root.cern,https://root.cern/doc/master/clonesA__Event_8C.html,1,['load'],['load']
Performance,"< Index, Value >::MakeBoundariesExact. Build boundaries for each node. ; Unlike MakeBoundaries() function the boundaries built here always pass through a point of the original dataset So, for example, for a terminal node with just one point minimum and maximum for each dimension are the same. Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would return an array of boundaries for the specified node, or GetBoundaries() function that would return the complete array. ; Definition at line 1114 of file TKDTree.cxx. ◆ operator=(). template<typename Index , typename Value > . TKDTree< Index, Value > & TKDTree< Index, Value >::operator= ; (; const TKDTree< Index, Value > & ; ). private . ◆ SetData() [1/2]. template<typename Index , typename Value > . Int_t TKDTree< Index, Value >::SetData ; (; Index ; idim, . Value * ; data . ). Set the coordinate #ndim of all points (the column #ndim of the data matrix) After setting all the data columns, proceed by calling Build() function Note, that calling this function after Build() is not possible Note also, that no checks on the array sizes is performed anywhere. ; Definition at line 943 of file TKDTree.cxx. ◆ SetData() [2/2]. template<typename Index , typename Value > . void TKDTree< Index, Value >::SetData ; (; Index ; npoints, . Index ; ndim, . UInt_t ; bsize, . Value ** ; data . ). Set the data array. See the constructor function comments for details. ; Definition at line 918 of file TKDTree.cxx. ◆ SetOwner(). template<typename Index , typename Value > . void TKDTree< Index, Value >::SetOwner ; (; Int_t ; owner). inline . Definition at line 65 of file TKDTree.h. ◆ Spread(). template<typename Index , typename Value > . void TKDTree< Index, Value >::Spread ; (; Index ; ntotal, . Value * ; a, . Index * ; index, . Value & ; min, . Value & ; max . ); const. Calculate spread of the array a. ; Definition at line 963 of file TKDTree.cxx. ◆ Streamer(). template<typename Index , typename Value > . void TKDTree< ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:42137,perform,performed,42137,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['perform'],['performed']
Performance,"< Matrix_t > > & GetPastSquaredBiasUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredBiasUpdatesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredWeightUpdatesAt (size_t i);  ; Scalar_t GetRho () const;  Getters. ;  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The accumulation of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasUpdates;  The accumulation of the square of the past bias updates associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The accumulation of the square of the past weight gradients associated with the deep net. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:2436,Perform,Performs,2436,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,2,"['Perform', 'optimiz']","['Performs', 'optimization']"
Performance,"< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options)Create a writer, potentially wrapping the sink in a RPageSinkBuf.Definition RNTupleWriter.cxx:58; ROOT::Experimental::RNTupleWriter::CommitClusterGroupvoid CommitClusterGroup()Definition RNTupleWriter.cxx:102; ROOT::Experimental::RNTupleWriter::fMetricsDetail::RNTupleMetrics fMetricsDefinition RNTupleWriter.hxx:70; ROOT::Experimental::RNTupleWriter::~RNTupleWriter~RNTupleWriter()Definition RNTupleWriter.cxx:47; ROOT::Experimental::RNTupleWriter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:71; ROOT::Experimental::RNTupleWriter::fFillContextRNTupleFillContext fFillContextDefinition RNTupleWriter.hxx:69; ROOT::Experimental::RNTupleWriter::Appendstatic std::unique_ptr< RNTupleWriter > Append(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, TFile &file, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:95; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; ROOT::Experimental::Internal::CreateRNTupleWriterstd::unique_ptr< RNTupleWriter > CreateRNTupleWriter(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink)Definition RNTupleWriter.cxx:111; ROOT::Experimental::NTupleLogRLogChannel & NTupleLog()Log channel for RNTuple diagnostics.Definition RNTupleUtil.cxx:24; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570. treentuplev7srcRNTupleWriter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html:9642,multi-thread,multi-threading,9642,doc/master/RNTupleWriter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"< RooAbsReal > RooRealIntegral::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. overridevirtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented from RooAbsReal.; Definition at line 746 of file RooRealIntegral.cxx. ◆ DeclFileName(). static const char * RooRealIntegral::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 150 of file RooRealIntegral.h. ◆ evaluate(). double RooRealIntegral::evaluate ; (; ); const. overrideprotectedvirtual . Perform the integration and return the result. ; Implements RooAbsReal.; Definition at line 802 of file RooRealIntegral.cxx. ◆ funcNormSet(). RooArgSet const * RooRealIntegral::funcNormSet ; (; ); const. inline . Definition at line 83 of file RooRealIntegral.h. ◆ getAllowComponentSelection(). bool RooRealIntegral::getAllowComponentSelection ; (; ); const. Check if component selection is allowed. ; Definition at line 1024 of file RooRealIntegral.cxx. ◆ getCacheAllNumeric(). Int_t RooRealIntegral::getCacheAllNumeric ; (; ). static . Return minimum dimensions of num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:68220,perform,performed,68220,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['perform'],['performed']
Performance,"< RooArgSet > RooAbsCachedPdf::actualObservables ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooIntegralMorph, RooCachedPdf, and RooFFTConvPdf. ◆ actualParameters(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedPdf::actualParameters ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooIntegralMorph, RooCachedPdf, and RooFFTConvPdf. ◆ analyticalIntegralWN(). double RooAbsCachedPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 376 of file RooAbsCachedPdf.cxx. ◆ binningName(). virtual const char * RooAbsCachedPdf::binningName ; (; ); const. inlineprotectedvirtual . Definition at line 97 of file RooAbsCachedPdf.h. ◆ cacheNameSuffix(). std::string RooAbsCachedPdf::cacheNameSuffix ; (; const RooArgSet & ; nset); const. protected . Construct string with unique suffix for cache objects based on observable names that define cache configuration. ; Definition at line 241 of file RooAbsCachedPdf.cxx. ◆ Class(). static TClass * RooAbsCachedPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCachedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 137 of file RooAbsCachedPdf.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooAbsCachedPdf::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsArg.; Definition at line 410 of file RooAbsCachedPdf.cxx. ◆ createCache(). virtual PdfCacheElem * RooAbsC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:78573,cache,cacheNameSuffix,78573,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cacheNameSuffix']
Performance,"< RooDataHist > _ownedDataHist;  ! Owned pointer to underlying histogram ;  ; double _totVolume = 0.0;  ! Total volume of space (product of ranges of observables) ;  ; bool _unitNorm = false;  ! Assume contents is unit normalized (for use as pdf cache) ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:57998,Cache,Cache,57998,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['Cache'],['Cache']
Performance,"< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Long64_t fgMaxFullCacheSize = 500000000;  ; static TUrl fgProxy;  size of the cached content ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Private Member Functions;  TWebFile ();  . Friends; class TWebSocket;  ; class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:39969,CACHE,CACHEREAD,39969,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['CACHE'],['CACHEREAD']
Performance,"< TString > varNames)TMVA::Factoryprivate; GetMethod(const TString &datasetname, const TString &title) constTMVA::Factory; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetOptions() constTMVA::Configurableinline; GetReferenceFile() constTMVA::Configurableinlineprotected; GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factoryprivate; GetROC(TString datasetname, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factoryprivate; GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurve(TString datasetname, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurve(DataLoader *loader, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurve(TString datasetname, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurveAsMultiGraph(TString datasetname, UInt_t iClass, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCIntegral(TString datasetname, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; Greetings()TMVA::Factoryprivate; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; HasMethod(const TString &datasetname, const TString &title) constTMVA::Factory; Info(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory-members.html:6220,load,loader,6220,doc/master/classTMVA_1_1Factory-members.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory-members.html,2,['load'],['loader']
Performance,"< ULong64_t, ULong64_t > &&newRange);  ; void SetTree (std::shared_ptr< TTree > tree);  ; void StopProcessing () final;  ; void ToJitExec (const std::string &) const;  ;  Public Member Functions inherited from ROOT::Detail::RDF::RNodeBase;  RNodeBase (const std::vector< std::string > &variations={}, RLoopManager *lm=nullptr);  ; virtual ~RNodeBase ();  ; const std::vector< std::string > & GetVariations () const;  ; virtual std::shared_ptr< RNodeBase > GetVariedFilter (const std::string &);  Return a clone of this node that acts as a Filter working with values in the variationName ""universe"". ;  ; virtual void ResetChildrenCount ();  . Private Types; using ColumnNames_t = std::vector< std::string >;  ; enum class  ELoopType { ;   kROOTFiles; , kROOTFilesMT; , kNoFiles; , kNoFilesMT; , ;   kDataSource; , kDataSourceMT. };  . Private Member Functions; void CleanUpNodes ();  Perform clean-up operations. To be called at the end of each event loop. ;  ; void CleanUpTask (TTreeReader *r, unsigned int slot);  Perform clean-up operations. To be called at the end of each task execution. ;  ; void EvalChildrenCounts ();  Trigger counting of number of children nodes for each node of the functional graph. ;  ; void InitNodes ();  Initialize all nodes of the functional graph before running the event loop. ;  ; void InitNodeSlots (TTreeReader *r, unsigned int slot);  Build TTreeReaderValues for all nodes This method loops over all filters, actions and other booked objects and calls their InitSlot method, to get them ready for running a task. ;  ; void RunAndCheckFilters (unsigned int slot, Long64_t entry);  Execute actions and make sure named filters are called for each event. ;  ; void RunDataSource ();  Run event loop over data accessed through a DataSource, in sequence. ;  ; void RunDataSourceMT ();  Run event loop over data accessed through a DataSource, in parallel. ;  ; void RunEmptySource ();  Run event loop with no source files, in sequence. ;  ; void RunEmptySourceMT ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:5928,Perform,Perform,5928,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['Perform'],['Perform']
Performance,"< kINFO << ""Optimize method: "" << mva->GetMethodName() << "" for ""; 727 << (fAnalysisType == Types::kRegression; 728 ? ""Regression""; 729 : (fAnalysisType == Types::kMulticlass ? ""Multiclass classification"" : ""Classification"")); 730 << Endl;; 731 ; 732 TunedParameters = mva->OptimizeTuningParameters(fomType, fitType);; 733 Log() << kINFO << ""Optimization of tuning parameters finished for Method:"" << mva->GetName() << Endl;; 734 }; 735 }; 736 ; 737 return TunedParameters;; 738}; 739 ; 740////////////////////////////////////////////////////////////////////////////////; 741/// Private method to generate a ROCCurve instance for a given method.; 742/// Handles the conversion from TMVA ResultSet to a format the ROCCurve class; 743/// understands.; 744///; 745/// \note You own the retured pointer.; 746///; 747 ; 748TMVA::ROCCurve *; 749TMVA::Factory::GetROC(TMVA::DataLoader *loader, TString theMethodName, UInt_t iClass, Types::ETreeType type); 750{; 751 return GetROC((TString)loader->GetName(), theMethodName, iClass, type);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Private method to generate a ROCCurve instance for a given method.; 756/// Handles the conversion from TMVA ResultSet to a format the ROCCurve class; 757/// understands.; 758///; 759/// \note You own the retured pointer.; 760///; 761 ; 762TMVA::ROCCurve *TMVA::Factory::GetROC(TString datasetname, TString theMethodName, UInt_t iClass, Types::ETreeType type); 763{; 764 if (fMethodsMap.find(datasetname) == fMethodsMap.end()) {; 765 Log() << kERROR << Form(""DataSet = %s not found in methods map."", datasetname.Data()) << Endl;; 766 return nullptr;; 767 }; 768 ; 769 if (!this->HasMethod(datasetname, theMethodName)) {; 770 Log() << kERROR << Form(""Method = %s not found with Dataset = %s "", theMethodName.Data(), datasetname.Data()); 771 << Endl;; 772 return nullptr;; 773 }; 774 ; 775 std::set<Types::EAnalysisType> allowedAnalysisTypes = {Types::kClassification,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:30219,load,loader,30219,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance,"< std::endl;; 2678 out << ""{"" << std::endl;; 2679 out << ""//=== Macro generated by ROOT version "" << gROOT->GetVersion() << "" : "" << t.AsString() << std::endl;; 2680 out << ""//=== Attributes for "" << GetTitle() << "" geometry"" << std::endl;; 2681 out << ""//===== <run this macro AFTER loading the geometry in memory>"" << std::endl;; 2682 // save current top volume; 2683 out << "" TGeoVolume *top = gGeoManager->GetVolume(\"""" << fTopVolume->GetName() << ""\"");"" << std::endl;; 2684 out << "" TGeoVolume *vol = 0;"" << std::endl;; 2685 out << "" TGeoNode *node = 0;"" << std::endl;; 2686 out << "" // clear all volume attributes and get painter"" << std::endl;; 2687 out << "" gGeoManager->ClearAttributes();"" << std::endl;; 2688 out << "" gGeoManager->GetGeomPainter();"" << std::endl;; 2689 out << "" // set visualization modes and bomb factors"" << std::endl;; 2690 out << "" gGeoManager->SetVisOption("" << GetVisOption() << "");"" << std::endl;; 2691 out << "" gGeoManager->SetVisLevel("" << GetVisLevel() << "");"" << std::endl;; 2692 out << "" gGeoManager->SetExplodedView("" << GetBombMode() << "");"" << std::endl;; 2693 Double_t bombx, bomby, bombz, bombr;; 2694 GetBombFactors(bombx, bomby, bombz, bombr);; 2695 out << "" gGeoManager->SetBombFactors("" << bombx << "","" << bomby << "","" << bombz << "","" << bombr << "");""; 2696 << std::endl;; 2697 out << "" // iterate volumes container and set new attributes"" << std::endl;; 2698 // out << "" TIter next(gGeoManager->GetListOfVolumes());""<<std::endl;; 2699 TGeoVolume *vol = nullptr;; 2700 fTopNode->SaveAttributes(out);; 2701 ; 2702 TIter next(fVolumes);; 2703 while ((vol = (TGeoVolume *)next())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:94660,load,loading,94660,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['load'],['loading']
Performance,"</a>; 57\endhtmlonly; 58 ; 59## For the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Performance tips and parallel execution](\ref parallel-execution); 71- [More features](\ref more-features); 72 - [Systematic variations](\ref systematics); 73 - [RDataFrame objects as function arguments and return values](\ref rnode); 74 - [Storing RDataFrame objects in collections](\ref RDFCollections); 75 - [Executing callbacks every N events](\ref callbacks); 76 - [Default column lists](\ref default-branches); 77 - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); 78 - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); 79 - [User-defined custom actions](\ref generic-actions); 80 - [Dataset joins with friend trees](\ref friends); 81 - [Reading data formats other than ROOT trees](\ref other-file-formats); 82 - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); 83 - [Visualizing the computation graph](\ref representgraph); 84 - [Activating RDataFrame execution logs](\ref rdf-logging); 85 - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); 86 - [Adding a progress bar](\ref progressbar); 87- [Efficient analysis in Python](\ref python); 88- <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>; 89 ; 90\anchor cheatsheet; 91## Cheat sheet; 92These are the operations which can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:3144,Perform,Performance,3144,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['Perform'],['Performance']
Performance,"<< ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; mainint main()Definition Prototype.cxx:12; RDataFrame.hxx; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; See the Book() method for more information and this tutorial for a more complete example.; Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and executes the callable on the values of those columns for each event that passes all upstream selections. It can be used to perform actions that are not already available in the interface. For example, the following snippet evaluates the root mean square of column ""x"": // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:67754,perform,perform,67754,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['perform']
Performance,"<< ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooNumRunningInt; std::string _binningName;  Name of binning to be used for cache histogram. ;  ; RooRealProxy func;  Proxy to functions whose running integral is calculated. ;  ; RooRealProxy x;  Integrated observable. ;  ;  Protected Attributes inherited from RooAbsCachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:60083,Cache,CacheElem,60083,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['Cache'],['CacheElem']
Performance,"<< ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:62125,Cache,CacheElem,62125,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['Cache'],['CacheElem']
Performance,"<< ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from RooAbsCachedReal; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumRunningInt.h>. Inheritance diagram for RooNumRunningInt:. This browser is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:61999,Cache,CacheElem,61999,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['Cache'],['CacheElem']
Performance,"<< ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  Factory (TString theJobName, TFile *theTargetFile, TString theOption="""");  Standard constructor. ;  ;  Factory (TString theJobName, TString theOption="""");  Constructor. ;  ; virtual ~Factory ();  Destructor. ;  ; MethodBase * BookMethod (DataLoader *, TMVA::Types::EMVA, TString, TString, TMVA::Types::EMVA, TString);  ; MethodBase * BookMethod (DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""");  Book a classifier or regression method. ;  ; MethodBase * BookMethod (DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption="""");  Books MVA method. ;  ; void DeleteAllMethods (void);  Delete methods. ;  ; void EvaluateAllMethods (void);  Iterates over all MVAs that have been booked, and calls their evaluation methods. ;  ; void EvaluateAllVariables (DataLoader *loader, TString options="""");  Iterates over all MVA input variables and evaluates them. ;  ; TH1F * EvaluateImportance (DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""");  Evaluate Variable Importance. ;  ; IMethod * GetMethod (const TString &datasetname, const TString &title) const;  Returns pointer to MVA that corresponds to given method title. ;  ; TGraph * GetROCCurve (DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ;  ; TCanvas * GetROCCurve (DataLoader *loader, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Draws ROC curves for all methods booked with the factory for a given class onto a canvas. ;  ; TGraph * GetROCCurve (TString datasetname, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting);  Argument iClass specifies the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:2089,load,loader,2089,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"<< std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utili",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25861,cache,cacheParams,25861,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['cache'],['cacheParams']
Performance,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:8707,perform,performance,8707,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['perform'],['performance']
Performance,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:8935,perform,performance,8935,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['perform'],['performance']
Performance,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:9012,perform,performance,9012,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['perform'],['performance']
Performance,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:8959,perform,performance,8959,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['perform'],['performance']
Performance,"<Data> & data) {; 521 fData = std::static_pointer_cast<Data>(data);; 522 }; 523 ; 524 /// Set the input data for the fit (Copying the given data object); 525 template <class Data>; 526 void SetData(const Data & data) {; 527 auto dataClone = std::make_shared<Data>(data);; 528 SetData(dataClone);; 529 }; 530 ; 531 /// look at the user provided FCN and get data and model function is; 532 /// they derive from ROOT::Fit FCN classes; 533 void ExamineFCN();; 534 ; 535 ; 536 /// internal functions to get data set and model function from FCN; 537 /// useful for fits done with customized FCN classes; 538 template <class ObjFuncType>; 539 bool GetDataFromFCN();; 540 ; 541 /// Return pointer to the used objective function for fitting.; 542 /// If using an external function (e.g. given in SetFCN), return the cached pointer,; 543 /// otherwise use the one stored as shared ptr and managed by the Fitter class; 544 const ROOT::Math::IBaseFunctionMultiDimTempl<double> * ObjFunction() const {; 545 // need to specify here full return type since when using the typedef (IMultiGenFunction); 546 // there is an error when using the class in Python (see issue #12391); 547 return (fExtObjFunction) ? fExtObjFunction : fObjFunction.get();; 548 }; 549 ; 550private:; 551 ; 552 bool fUseGradient = false; ///< flag to indicate if using gradient or not; 553 ; 554 bool fBinFit = false; ///< flag to indicate if fit is binned; 555 ///< in case of false the fit is unbinned or undefined); 556 ///< flag it is used to compute chi2 for binned likelihood fit; 557 ; 558 int fFitType = 0; ///< type of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood); 559 ; 560 int fDataSize = 0; ///< size of data sets (need for Fumili or LM fitters); 561 ; 562 FitConfig fConfig; ///< fitter configuration (options and parameter settings); 563 ; 564 std::shared_ptr<IModelFunction_v> fFunc_v; ///<! copy of the fitted function containing on output the fit result; 565 ; 566 std::shared_ptr<IModelFunction> fFunc;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:22348,cache,cached,22348,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['cache'],['cached']
Performance,"<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCatDefault (unmapped) output type; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooCategoryProxy_inputCatInput category; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; map<std::string,RooMappedCategory::Entry>_mapArrayList of mapping rules; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debug",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMappedCategory.html:20553,cache,cache,20553,root/html534/RooMappedCategory.html,https://root.cern,https://root.cern/root/html534/RooMappedCategory.html,4,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"<T>(std::move(field), range);; 322 }; 323 ; 324 /// Raises an exception if:; 325 /// * there is no field with the given name or,; 326 /// * the field is not a collection; 327 RNTupleCollectionView GetCollectionView(std::string_view fieldName); 328 {; 329 auto fieldId = fSource->GetSharedDescriptorGuard()->FindFieldId(fieldName);; 330 if (fieldId == kInvalidDescriptorId) {; 331 throw RException(R__FAIL(""no field named '"" + std::string(fieldName) + ""' in RNTuple '"" +; 332 fSource->GetSharedDescriptorGuard()->GetName() + ""'""));; 333 }; 334 return GetCollectionView(fieldId);; 335 }; 336 ; 337 RNTupleCollectionView GetCollectionView(DescriptorId_t fieldId); 338 {; 339 return RNTupleCollectionView::Create(fieldId, fSource.get());; 340 }; 341 ; 342 RIterator begin() { return RIterator(0); }; 343 RIterator end() { return RIterator(GetNEntries()); }; 344 ; 345 /// Enable performance measurements (decompression time, bytes read from storage, etc.); 346 ///; 347 /// **Example: inspect the reader metrics after loading every entry**; 348 /// ~~~ {.cpp}; 349 /// #include <ROOT/RNTupleReader.hxx>; 350 /// using ROOT::Experimental::ENTupleInfo;; 351 /// using ROOT::Experimental::RNTupleReader;; 352 ///; 353 /// #include <iostream>; 354 ///; 355 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 356 /// // metrics must be turned on beforehand; 357 /// ntuple->EnableMetrics();; 358 ///; 359 /// for (auto i : ntuple->GetEntryRange()) {; 360 /// ntuple->LoadEntry(i);; 361 /// }; 362 /// ntuple->PrintInfo(ENTupleInfo::kMetrics);; 363 /// ~~~; 364 void EnableMetrics() { fMetrics.Enable(); }; 365 const Detail::RNTupleMetrics &GetMetrics() const { return fMetrics; }; 366}; // class RNTupleReader; 367 ; 368} // namespace Experimental; 369} // namespace ROOT; 370 ; 371#endif // ROOT7_RNTupleReader; RConfig.hxx; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; RError.hxx; R__FAIL#define R__FAIL(msg)Short-hand to return an RResult<T> in an error state; the RErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:14556,load,loading,14556,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['load'],['loading']
Performance,"<U>&) used to merge the results of the accumulations of each thread ; [in]columnNameThe column to be aggregated. If omitted, the first default column is used instead. ; [in]aggIdentityThe aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted) . Returnsthe result of the aggregation wrapped in a RResultPtr.; An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is initialized to aggIdentity or default-constructed if aggIdentity is omitted. This action calls the aggregator callable for each processed entry, passing in the aggregator variable and the value of the column columnName. If the signature is U(U,T) the aggregator variable is then copy-assigned the result of the execution of the callable. Otherwise the signature of aggregator must be void(U&,T).; The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions. If its signature is U(U,U) the aggregator variables of each thread are merged two by two. If its signature is void(std::vector<U>& a) it is assumed that it merges all aggregators in a[0].; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; Example usage: auto aggregator = [](double acc, double x) { return acc * x; };; ROOT::EnableImplicitMT();; // If multithread is enabled, the aggregator function will be called by more threads; // and will produce a vector of partial accumulators.; // The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:32758,multi-thread,multi-thread,32758,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['multi-thread'],['multi-thread']
Performance,"<memory>; #include <vector>. Include dependency graph for RNTupleImporter.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::RNTupleImporter::RCStringTransformation;  Transform a NULL terminated C string branch into an std::string field. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportBranch;  ; struct  ROOT::Experimental::RNTupleImporter::RImportField;  ; struct  ROOT::Experimental::RNTupleImporter::RImportGuard;  When the schema is set up and the import started, it needs to be reset before the next Import() call can start. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportLeafCountCollection;  Leaf count arrays require special treatment. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportTransformation;  Base class to perform data transformations from TTree branches to RNTuple fields if necessary. More...;  ; class  ROOT::Experimental::RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  ROOT::Experimental::RNTupleImporter::RProgressCallback;  Used to report every ~100 MB (compressed), and at the end about the status of the import. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2022-11-22 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RNTupleImporter.hxx. treentupleutilv7incROOTRNTupleImporter.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8hxx.html:1584,perform,perform,1584,doc/master/RNTupleImporter_8hxx.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx.html,1,['perform'],['perform']
Performance,"<typename G > ; bool Invert (G *m) const;  place the inverse into m ;  ; template<class M > ; bool Invert (M &m) const;  place the inverse into m ;  ; bool ok () const;  returns true if decomposition was successful ;  ;  operator bool () const;  returns true if decomposition was successful ;  ; template<class V > ; bool Solve (V &rhs) const;  solves a linear system for the given right hand side ;  . Private Attributes; F * fL;  lower triangular matrix L ;  ; unsigned fN;  dimensionality dimensionality of the problem ;  ; bool fOk;  flag indicating a successful decomposition ;  . #include <Math/CholeskyDecomp.h>; Constructor & Destructor Documentation. ◆ CholeskyDecompGenDim() [1/2]. template<class F > . template<class M > . ROOT::Math::CholeskyDecompGenDim< F >::CholeskyDecompGenDim ; (; unsigned ; N, . const M & ; m . ). inline . perform a Cholesky decomposition ; perform a Cholesky decomposition of a symmetric positive definite matrix m; this is the constructor to uses with an SMatrix (and objects that behave like an SMatrix in terms of using operator()(int i, int j) for access to elements) ; Definition at line 331 of file CholeskyDecomp.h. ◆ CholeskyDecompGenDim() [2/2]. template<class F > . template<typename G > . ROOT::Math::CholeskyDecompGenDim< F >::CholeskyDecompGenDim ; (; unsigned ; N, . G * ; m . ). inline . perform a Cholesky decomposition ; perform a Cholesky decomposition of a symmetric positive definite matrix m; this is the constructor to use in special applications where plain arrays are used; NOTE: the matrix is given in packed representation, matrix element m(i,j) (j <= i) is supposed to be in array element (i * (i + 1)) / 2 + j ; Definition at line 349 of file CholeskyDecomp.h. ◆ ~CholeskyDecompGenDim(). template<class F > . ROOT::Math::CholeskyDecompGenDim< F >::~CholeskyDecompGenDim ; (; ). inline . destructor ; Definition at line 359 of file CholeskyDecomp.h. Member Function Documentation. ◆ getL() [1/2]. template<class F > . template<typename",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1CholeskyDecompGenDim.html:3158,perform,perform,3158,doc/master/classROOT_1_1Math_1_1CholeskyDecompGenDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1CholeskyDecompGenDim.html,2,['perform'],['perform']
Performance,"<typename T > ; static TClass * GetClass (Bool_t load=kTRUE, Bool_t silent=kFALSE);  ; static TClass * GetClass (ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE);  Static method returning pointer to TClass of the specified ClassInfo. ;  ; static TClass * GetClass (const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);  ; static TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE);  Static method returning pointer to TClass of the specified class name. ;  ; static TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Return pointer to class with name. ;  ; static Bool_t GetClass (DeclId_t id, std::vector< TClass * > &classes);  ; static DictFuncPtr_t GetDict (const char *cname);  Return a pointer to the dictionary loading function generated by rootcint. ;  ; static DictFuncPtr_t GetDict (const std::type_info &info);  Return a pointer to the dictionary loading function generated by rootcint. ;  ; static Bool_t HasDictionarySelection (const char *clname);  Check whether a class has a dictionary or ROOT can load one. ;  ; static ENewType IsCallingNew ();  Static method returning the defConstructor flag passed to TClass::New(). ;  ; static TClass * Load (TBuffer &b);  Load class description from I/O buffer and return class object. ;  ; static TClass * LoadClass (const char *requestedname, Bool_t silent);  Helper function used by TClass::GetClass(). ;  ; static Int_t ReadRules ();  Read the class.rules files from the default location:. ;  ; static Int_t ReadRules (const char *filename);  Read a class.rules file which contains one rule per line with comment starting with a #. ;  ; static void RemoveClass (TClass *cl);  static: Remove a class from the list and map of classes ;  ; static void RemoveClassDeclId (TDictionary::DeclId_t id);  ;  Static Public Member Functions inherited from TDictionary; static TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:34446,load,loading,34446,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['load'],['loading']
Performance,"= """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidselectDefaultAlgorithm(); voidselectFastAlgorithm(); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVoigtian.html:29368,cache,cache,29368,root/html534/RooVoigtian.html,https://root.cern,https://root.cern/root/html534/RooVoigtian.html,3,['cache'],['cache']
Performance,"= """"); Set location string. void SetSessionID(Int_t id); Set session ID to 'id'. If id < 0, disable also the asynchronous handler. void DisconnectSession(Int_t id, Option_t* opt = """"); Disconnect a session. Use opt= ""S"" or ""s"" to; shutdown remote session.; Default is opt = """". void Close(Option_t* opt = """"); Close connection. Available options are (case insensitive); 'P' force closing of the underlying physical connection; 'S' shutdown remote session, is any; A session ID can be given using #...# signature, e.g. ""#1#"".; Default is opt = """". UnsolRespProcResult ProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); We are here if an unsolicited response comes from a logical conn; The response comes in the form of an XrdClientMessage *, that must NOT be; destroyed after processing. It is destroyed by the first sender.; Remember that we are in a separate thread, since unsolicited; responses are asynchronous by nature. void PostMsg(Int_t type, const char* msg = 0); Post a message of type 'type' into the read messages queue.; If 'msg' is defined it is also added as TString.; This is used, for example, with kPROOF_FATAL to force the main thread; to mark this socket as bad, avoiding race condition when a worker; dies while in processing state. Bool_t IsServProofd(); Return kTRUE if the remote server is a 'proofd'. Int_t GetInterrupt(Bool_t& forward); Get latest interrupt level and reset it; if the interrupt has to be; propagated to lower stages forward will be kTRUE after the call. Int_t Flush(); Flush the asynchronous queue.; Typically called when a kHardInterrupt is received.; Returns number of bytes in flushed buffers. Bool_t Create(Bool_t attach = kFALSE); This method sends a request for creation of (or attachment to) a remote; server application. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); Send a raw buffer of specified length.; Use opt = kDontBlock to ask xproofd to push the message into the proofsrv.; (by default i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:15412,queue,queue,15412,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['queue'],['queue']
Performance,"= """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(const char* name, Double_t min, Double_t max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:26488,cache,cache,26488,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,1,['cache'],['cache']
Performance,"= """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); voidsetCallWarning(Int_t threshold = 2000); voidsetConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:25148,cache,cache,25148,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['cache'],['cache']
Performance,"= """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the caceh information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:28229,cache,caches,28229,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,3,['cache'],['caches']
Performance,"= """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:32226,cache,caches,32226,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['caches']
Performance,"= ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optimizer = DNN::EOptimizer::kRMSProp;; 362 } else if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamName) > 0) {; 383 double defValue = defaultValues[optimParamName];; 384 double val = fetchValueTmp(block, optimParamName, defValue);; 385 // create entry in settings for this optimizer parameter; 386 settings.optimizerParams[optimParamName] = val;; 387 }; 388 }; 389 ; 390 fTrainingSettings.push_back(settings);; 391 }; 392 ; 393 // this set fInputShape[0] = batchSize; 394 this->SetBatchSize(fTrainingSettings.front().batchSize);; 395 ; 396 // case inputlayout and batch layout was not given. Use default then; 397 // (1, batchsize, nvariables); 398 // fInputShape[0] -> BatchSize; 399 // fInputShape[1] -> InputDepth; 400 // fInputShape[2] -> InputHeight; 401 // fInputShape[3] -> InputWidth; 402 if (fInputShape[3] == 0 && fInputShape[2] == 0 && fInputShape[1] == 0) {; 403 fInputShape[1] = 1;; 404 fInputShape[2] = 1;; 405 fInputShape[3] = GetNVariables();; 406 }; 407 // case when batch layout is not provided (all zero)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:14883,optimiz,optimizerName,14883,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizer', 'optimizerName']"
Performance,"= (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3928{; 3929 TList* lb = GetListOfBases();; 3930 if (!lb) return;; 3931 TIter nextBase(lb);; 3932 TBaseClass*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:148118,load,load,148118,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"= (TBaseClass *) nextBase())) {; 3949 TClass *base = baseClass->GetClassPointer();; 3950 if (base) base->GetMenuItems(list);; 3951 }; 3952 ; 3953 // remove methods redefined in this class with no menu; 3954 TMethod *method, *m;; 3955 TIter next(GetListOfMethods(), kIterBackward);; 3956 while ((method = (TMethod*)next())) {; 3957 m = (TMethod*)list->FindObject(method->GetName());; 3958 if (method->IsMenuItem() != kMenuNoMenu) {; 3959 if (!m); 3960 list->AddFirst(method);; 3961 } else {; 3962 if (m && m->GetNargs() == method->GetNargs()); 3963 list->Remove(m);; 3964 }; 3965 }; 3966}; 3967 ; 3968////////////////////////////////////////////////////////////////////////////////; 3969/// Check whether a class has a dictionary or not.; 3970/// This is equivalent to ask if a class is coming from a bootstrapping; 3971/// procedure initiated during the loading of a library.; 3972 ; 3973Bool_t TClass::HasDictionary() const; 3974{; 3975 return IsLoaded();; 3976}; 3977 ; 3978////////////////////////////////////////////////////////////////////////////////; 3979/// Check whether a class has a dictionary or ROOT can load one.; 3980/// This is equivalent to ask HasDictionary() or whether a library is known; 3981/// where it can be loaded from, or whether a Dictionary function is; 3982/// available because the class's dictionary library was already loaded.; 3983 ; 3984Bool_t TClass::HasDictionarySelection(const char* clname); 3985{; 3986 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3987 return cl->IsLoaded();; 3988 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3989}; 3990 ; 3991////////////////////////////////////////////////////////////////////////////////; 3992/// Verify the base classes always.; 3993 ; 3994void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3995{; 3996 TList* lb = GetListOfBases();; 3997 if (!lb) return;; 3998 TIter nextBase(lb);; 3999 TBaseClass*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:150869,load,load,150869,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"= (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2871 } else {; 2872 local = (ULongptr_t) new TClassLocalStorage();; 2873 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2874 }; 2875 return (TClassLocalStorage*)local;; 2876 }; 2877 return nullptr;; 2878 }; 2879 };; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// Return the 'type' of the STL the TClass is representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2900 // removed in optimized code.; 2901 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2902 if (gThreadTsd && fCollectionProxy) {; 2903 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2904 if (local == nullptr) return fCollectionProxy;; 2905 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2906 return local->fCollectionProxy;; 2907 }; 2908 return fCollectionProxy;; 2909}; 2910 ; 2911////////////////////////////////////////////////////////////////////////////////; 2912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:108290,optimiz,optimized,108290,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"= (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2938 } else {; 2939 local = (ULongptr_t) new TClassLocalStorage();; 2940 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2941 }; 2942 return (TClassLocalStorage*)local;; 2943 }; 2944 return nullptr;; 2945 }; 2946 };; 2947}; 2948 ; 2949////////////////////////////////////////////////////////////////////////////////; 2950/// Return the 'type' of the STL the TClass is representing.; 2951/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2952 ; 2953ROOT::ESTLType TClass::GetCollectionType() const; 2954{; 2955 auto proxy = GetCollectionProxy();; 2956 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2957 return ROOT::kNotSTL;; 2958}; 2959 ; 2960 ; 2961////////////////////////////////////////////////////////////////////////////////; 2962/// Return the proxy describing the collection (if any).; 2963 ; 2964TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2965{; 2966 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2967 // removed in optimized code.; 2968 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2969 if (gThreadTsd && fCollectionProxy) {; 2970 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2971 if (local == nullptr) return fCollectionProxy;; 2972 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2973 return local->fCollectionProxy;; 2974 }; 2975 return fCollectionProxy;; 2976}; 2977 ; 2978////////////////////////////////////////////////////////////////////////////////; 2979/// Return the Streamer Class allowing streaming (if any).; 2980 ; 2981TClassStreamer *TClass::GetStreamer() const; 2982{; 2983 if (gThreadTsd && fStreamer) {; 2984 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2985 if (local==nullptr) return fStreamer;; 2986 if (local-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:111041,optimiz,optimized,111041,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"= 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:3401,Cache,CacheModeRooAbsArg,3401,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"= 0, Bool_t doFactorize = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:24559,cache,cache,24559,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,2,['cache'],['cache']
Performance,"= 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static Bool_tMethodProxy_Check(PyObject* pyobject); static Bool_tMethodProxy_CheckExact(PyObject* pyobject); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname, Bool_t python_owns = kFALSE); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPython.html:3432,Load,LoadMacro,3432,root/html534/TPython.html,https://root.cern,https://root.cern/root/html534/TPython.html,1,['Load'],['LoadMacro']
Performance,"= 0x10000; , kRefreshLs = 0x20000; , kList = 0x40000; , kAllFiles = 0x80000; , ;   kStagedFiles = 0x100000; , kNoStagedCheck = 0x200000. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TDataSetManager (const char *group=0, const char *user=0, const char *options=0);  Main constructor. ;  ;  ~TDataSetManager () override;  Destructor. ;  ; virtual Int_t ClearCache (const char *uri);  Clear cached information matching uri. ;  ; virtual Bool_t ExistsDataSet (const char *uri);  Checks if the indicated dataset exits. ;  ; virtual Long64_t GetAvgFileSize () const;  ; virtual TFileCollection * GetDataSet (const char *uri, const char *server=0);  Utility function used in various methods for user dataset upload. ;  ; virtual TMap * GetDataSets (const char *uri, UInt_t=TDataSetManager::kExport);  Returns all datasets for the <group> and <user> specified by <uri>. ;  ; virtual Long64_t GetGroupQuota (const char *group);  returns the quota a group is allowed to have ;  ; virtual TMap * GetGroupQuotaMap ();  ; virtual Long64_t GetGroupUsed (const char *group);  Returns the used space of that group. ;  ; virtual TMap * GetSubDataSets (const char *uri, const char *excludeservers);  Partition dataset 'ds' accordingly to the servers. ;  ; TClass * IsA () const override;  ; virtual void MonitorUsedSpace (TVirtualMonitoringWriter *monitoring);  Log info to the monitoring serve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:2187,cache,cached,2187,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['cache'],['cached']
Performance,"= 1, . Bool_t ; reverse = kFALSE . ). overridevirtual . Bevel is used to create 3D effect while drawing buttons, or any other image that needs to be framed. ; Bevel is drawn using 2 primary colors: one for top and left sides - hi color, and another for bottom and right sides - low color. Bevel can be drawn over existing image or as newly created, as it is shown in code below: TImage *img = TImage::Create();; img->Bevel(0, 0, 400, 300, ""#dddddd"", ""#000000"", 3);; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Createstatic TImage * Create()Create an image.Definition TImage.cxx:35; TImage::Bevelvirtual void Bevel(Int_t=0, Int_t=0, UInt_t=0, UInt_t=0, const char *=""#ffdddddd"", const char *=""#ff555555"", UShort_t=1, Bool_t=kFALSE)Definition TImage.h:178. Reimplemented from TImage.; Definition at line 3251 of file TASImage.cxx. ◆ Blur(). void TASImage::Blur ; (; Double_t ; hr = 3, . Double_t ; vr = 3 . ). overridevirtual . Perform Gaussian blur of the image (useful for drop shadows). . hr - horizontal radius of the blur; vr - vertical radius of the blur . Reimplemented from TImage.; Definition at line 2757 of file TASImage.cxx. ◆ Browse(). void TASImage::Browse ; (; TBrowser * ; ). overridevirtual . Browse image. ; Reimplemented from TObject.; Definition at line 6267 of file TASImage.cxx. ◆ Class(). static TClass * TASImage::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TASImage::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TASImage::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 211 of file TASImage.h. ◆ Clone(). TObject * TASImage::Clone ; (; const char * ; newname); const. overridevirtual . Clone image. ; Reimplemented from TObject.; Definition at line 2786 of file TASImage.cxx. ◆ CopyArea(). void TASImage::CopyArea ; (; TImage * ; dst, . Int_t ; xsrc, . Int_t ; ysrc, . UInt_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:37892,Perform,Perform,37892,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['Perform'],['Perform']
Performance,"= 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:30310,cache,cache,30310,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['cache'],['cache']
Performance,"= 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetFloor(Bool_t flag); static voidsetFloorGlobal(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:29521,cache,cache,29521,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,1,['cache'],['cache']
Performance,"= 13.2436; TH1.Print Name = TrainingHistory_PyKeras_'val_loss', Entries= 0, Total sum= 12.1109; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.012 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00146 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0456 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : ----------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:49941,perform,performance,49941,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performance']
Performance,"= 2); RooCacheManager<RooAbsCacheElement>(const RooCacheManager<RooAbsCacheElement>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3532,cache,cache,3532,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['cache'],['cache']
Performance,"= GetReadCache(src);; 6991 if (dst) {; 6992 src->SetCacheRead(nullptr,this);; 6993 dst->SetCacheRead(pf, this);; 6994 } else {; 6995 if (pf) {; 6996 pf->WaitFinishPrefetch();; 6997 }; 6998 src->SetCacheRead(nullptr,this);; 6999 delete pf;; 7000 }; 7001}; 7002 ; 7003////////////////////////////////////////////////////////////////////////////////; 7004/// Copy the content to a new new file, update this TTree with the new; 7005/// location information and attach this TTree to the new directory.; 7006///; 7007/// options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for; 7008/// details; 7009///; 7010/// If new and old directory are in the same file, the data is untouched,; 7011/// this ""just"" does a call to SetDirectory.; 7012/// Equivalent to an ""in place"" cloning of the TTree.; 7013bool TTree::InPlaceClone(TDirectory *newdirectory, const char *options); 7014{; 7015 if (!newdirectory) {; 7016 LoadBaskets(2*fTotBytes);; 7017 SetDirectory(nullptr);; 7018 return true;; 7019 }; 7020 if (newdirectory->GetFile() == GetCurrentFile()) {; 7021 SetDirectory(newdirectory);; 7022 return true;; 7023 }; 7024 TTreeCloner cloner(this, newdirectory, options);; 7025 if (cloner.IsValid()); 7026 return cloner.Exec();; 7027 else; 7028 return false;; 7029}; 7030 ; 7031////////////////////////////////////////////////////////////////////////////////; 7032/// Function called when loading a new class library.; 7033 ; 7034bool TTree::Notify(); 7035{; 7036 TIter next(GetListOfLeaves());; 7037 TLeaf* leaf = nullptr;; 7038 while ((leaf = (TLeaf*) next())) {; 7039 leaf->Notify();; 7040 leaf->GetBranch()->Notify();; 7041 }; 7042 return true;; 7043}; 7044 ; 7045////////////////////////////////////////////////////////////////////////////////; 7046/// This function may be called after having filled some entries in a Tree.; 7047/// Using the information in the existing branch buffers, it will reassign; 7048/// new branch buffer sizes to optimize time and memory.; 7049///; 7050/// The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:274604,Load,LoadBaskets,274604,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadBaskets']
Performance,"= RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooArgSet* addColumns(const RooArgList& varList); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE). void setArgStatus(const RooArgSet& set, Bool_t active). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). RooAbsDataStore* clone(const char* newname = 0) const; Empty ctor. { return new RooCompositeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooCompositeDataStore(*this,vars,newname) ; }. RooCategory* index(); { return _indexCat ; }. const RooAbsArg* cacheOwner(); { return 0 ; }. » Last changed: Tue Jun 2 15:30:04 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCompositeDataStore.html:13229,cache,cacheArgs,13229,root/html604/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html604/RooCompositeDataStore.html,5,['cache'],"['cache', 'cacheArgs', 'cacheOwner', 'cachedVars']"
Performance,"= []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; returns true on success.; 1695 ; 1696void TCling::LoadPCMImpl(TFile &pcmFile); 1697{; 1698 auto listOfKeys = pcmFile.GetListOfKeys();; 1699 ; 1700 // This is an empty pcm; 1701 if (listOfKeys && ((listOfKeys->GetSize() == 0) || // Nothing here, or; 1702 ((listOfKeys->GetSize() == 1) && // only one, and; 1703 !strcmp(((TKey *)listOfKeys->At(0))->GetName(), ""EMPTY"") // name is EMPTY; 1704 ))) {; 1705 return;; 1706 }; 1707 ; 1708 TObjArray *protoClasses;; 1709 if (gDebug > 1); 1710 ::Info(""TCling::LoadPCMImpl"", ""reading protoclasses for %s \n"", pcmFile.GetName());; 1711 ; 1712 TObjArray *enums;; 1713 pcmFile.GetObject(""__Enums"", enums);; 1714 if (enums) {; 1715 // Cache the pointers; 1716 auto listOfGlobals = gROOT->GetListOfGlobals();; 1717 auto listOfEnums = dynamic_cast<THashList *>(gROOT->GetListOfEnums());; 1718 // Loop on enums and then on enum constants; 1719 for (auto selEnum : *enums) {; 1720 c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:63514,load,load,63514,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"= \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:173111,cache,cachefile,173111,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cachefile']
Performance,"= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 4752 }; 4753 Printf("" j=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:191116,optimiz,optimized,191116,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"= false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented in RooAddModel, RooAddPdf, and RooSimultaneous.; Definition at line 3360 of file RooAbsReal.cxx. ◆ selectNormalizationRange(). void RooAbsReal::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given normalization range to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented in RooBernstein, RooChebychev, RooAddModel, RooAddPdf, RooProdPdf, and RooSimultaneous.; Definition at line 3373 of file RooAbsReal.cxx. ◆ setCachedValue(). void RooAbsReal::setCachedValue ; (; double ; value, . bool ; notifyClients = true . ). inlinefinalvirtual . Overwrite the value stored in this object's cache. ; This can be used to fake a computation that resulted in value. Parameters. [in]valueValue to write. ; [in]notifyClientsIf true, notify users of this object that its value changed. This is the default. . Reimplemented from RooAbsArg.; Definition at line 558 of file RooAbsReal.h. ◆ setData(). virtual bool RooAbsReal::setData ; (; RooAbsData & ; , . bool ; = true . ). inlinevirtual . Reimplemented in ProgressMonitor, RooAddition, RooConstraintSum, and RooAbsTestStatistic.; Definition at line 367 of file RooAbsReal.h. ◆ setEvalErrorLoggingMode(). void RooAbsReal::setEvalErrorLoggingMode ; (; RooAbsReal::ErrorLoggingMode ; m). static . Set evaluation error logging mode. ; Options are; PrintErrors - Print each error through RooMsgService() as it occurs CollectErrors - Accumulate errors, but do not print them. A subsequent call to printEvalErrors() will print a summary CountErrors - Accumulate error count, but do not print them. ; Definition at line 4316 of file Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:144901,cache,cache,144901,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['cache']
Performance,"= false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented in RooAddModel, RooAddPdf, and RooSimultaneous.; Definition at line 3442 of file RooAbsReal.cxx. ◆ selectNormalizationRange(). void RooAbsReal::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given normalization range to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented in RooBernstein, RooChebychev, RooAddModel, RooAddPdf, RooProdPdf, and RooSimultaneous.; Definition at line 3455 of file RooAbsReal.cxx. ◆ setCachedValue(). void RooAbsReal::setCachedValue ; (; double ; value, . bool ; notifyClients = true . ). inlinefinalvirtual . Overwrite the value stored in this object's cache. ; This can be used to fake a computation that resulted in value. Parameters. [in]valueValue to write. ; [in]notifyClientsIf true, notify users of this object that its value changed. This is the default. . Reimplemented from RooAbsArg.; Definition at line 568 of file RooAbsReal.h. ◆ setData(). virtual bool RooAbsReal::setData ; (; RooAbsData & ; , . bool ; = true . ). inlinevirtual . Reimplemented in ProgressMonitor, RooAbsTestStatistic, RooAddition, and RooConstraintSum.; Definition at line 374 of file RooAbsReal.h. ◆ setEvalErrorLoggingMode(). void RooAbsReal::setEvalErrorLoggingMode ; (; RooAbsReal::ErrorLoggingMode ; m). static . Set evaluation error logging mode. ; Options are; PrintErrors - Print each error through RooMsgService() as it occurs CollectErrors - Accumulate errors, but do not print them. A subsequent call to printEvalErrors() will print a summary CountErrors - Accumulate error count, but do not print them. ; Definition at line 4392 of file Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:146738,cache,cache,146738,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['cache']
Performance,"= fopen(TString::Format(""/proc/%d/statm"", gSystem->GetPid()), ""r"");; 5302 if (f) {; 5303 s.Gets(f);; 5304 fclose(f);; 5305 Long_t total, rss;; 5306 sscanf(s.Data(), ""%ld %ld"", &total, &rss);; 5307 procinfo->fMemVirtual = total * (getpagesize() / 1024);; 5308 procinfo->fMemResident = rss * (getpagesize() / 1024);; 5309 }; 5310}; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173235,load,load,173235,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['load'],['load']
Performance,"= kFALSE) const; Create a generator context for this p.d.f. If both the p.d.f and the resolution model; support internal generation of the convolution observable on an infinite domain,; deploy a specialized convolution generator context, which generates the physics distribution; and the smearing separately, adding them a posteriori. If this is not possible return; a (slower) generic generation context that uses accept/reject sampling. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Return true if it is safe to generate the convolution observable; from the internal generator (this is the case if the chosen resolution; model is the truth model). const RooRealVar* convVar() const; Return a pointer to the convolution variable instance used in the resolution model. Double_t evaluate() const; Calculate the current unnormalized value of the PDF. PDF = sum_k coef_k * [ basis_k (x) ResModel ]. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise capability to perform (analytical) integrals; internally. For a given integration request over allVars while; normalized over normSet2 and in range 'rangeName', returns; largest subset that can be performed internally in analVars; Return code is unique integer code identifying integration scenario; to be passed to analyticalIntegralWN() to calculate requeste integral. Class RooAbsAnaConv defers analytical integration request to; resolution model and/or coefficient implementations and; aggregates results into composite configuration with a unique; code assigned by RooAICRegistry. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given code, which is returned; by getAnalyticalIntegralWN(). For unnormalized integrals the returned value is; _ _; PDF = sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:44058,perform,perform,44058,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,7,['perform'],['perform']
Performance,"= kFALSE) const; Double_tgetCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:37720,optimiz,optimizeDirtyHook,37720,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"= kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetPlayer(TVirtualProofPlayer* player); static void*SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t attach = kFALSE); static voidSystemCmd(const char* cmd, Int_t fdout); voidUpdateDialog(); virtual voidValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:19135,cache,cachedir,19135,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,2,['cache'],['cachedir']
Performance,"= kFALSE, . Bool_t ; uniqueWorkers = kTRUE, . TList * ; wrks = 0 . ). virtual . Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ; The macro file is uploaded if new or updated. Additional files to be uploaded (or updated, if needed) can be specified after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"". If existing in the same directory, a header basename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. ◆ LoadPackage(). Int_t TProof::LoadPackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; loadopts = 0, . TList * ; workers = 0 . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP macro will be executed like this: SETUP.C(loadopts). Returns 0 in case of success and -1 in case of error. ; Definition at line 8069 of file TProof.cxx. ◆ LogMessage(). void TProof::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Log a message into the appropriate window by emitting a signal. ; Definition at line 6414 of file TProof.cxx. ◆ LogViewer(). void TProof::LogViewer ; (; const char * ; url = 0, . Int_t ; sessionidx = 0 . ). static . Start the log viewer window usign the plugin manager. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:114871,Load,LoadPackage,114871,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['Load'],['LoadPackage']
Performance,"= kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddPdf::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:34189,Cache,CacheElem,34189,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['Cache'],['CacheElem']
Performance,"= kTRUE); TStringcurrentLabel() const; const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiCategory.html:17911,optimiz,optimizeDirtyHook,17911,root/html532/RooMultiCategory.html,https://root.cern,https://root.cern/root/html532/RooMultiCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"= kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMoment.html:24275,cache,cache,24275,root/html526/RooMoment.html,https://root.cern,https://root.cern/root/html526/RooMoment.html,1,['cache'],['cache']
Performance,"= new TF1(""f1"",""f1"",""sin(x)"",0,10);; TFormula * formula = (TFormula *) f1;; it is not valid anymore. The equivalent correct code is now; TF1 * f1 = new TF1(""f1"",""f1"",""sin(x)"",0,10);; TFormula * formula = f1->GetFormula();. Allow possibility to automatically normalize itself. If the function TF1::SetNormalized(true) is called, when evaluated, the function will return its value divided by its integral computed in the function range. TF1NormSum. New helper class computing the normalized sum of TF1 objects. It is a functor class which can be used as input to a global TF1 for fitting a sum of normalized components. This is useful for example in signal plus background fit, where one can fit directly the number of signal and background events, without the need to use something like TF1::IntegralError. See the tutorial tutorials/fit/fitNormSum.C as an example on how to use the TF1NormSum and perform such a fit. TF1Convolution. Another helper functor class for performing numerical convolution of functions, expressed as TF1 objects, using Fast Fourier Transform. The class requires the FFTW package installed in ROOT. The tutorial tutorials/fit/fitConvolution.C provides an example on how to create a TF1 based on the convolution of two others TF1 objects and used it to fit some data. TGraph2DPainter. In some case and extra point was drawn in the center od the plot when a TGRaph2dwas drawn with P, P0, or PCOL options. THistPainter. It was possible to interactively zoom outside the histograms’ limits. Protections have been added.; When an histogram was drawn with the option E0 and log scale along the Y axis, some additional markers were drawn at the bottom line of the plot. This was reported <a href=“http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18778”>here.; Implement the option 0 combined with the option COL as requested <a href=“https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=19046”>here. When the minimum of the histogram is set to a greater value than the real minimum, the bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:16495,perform,performing,16495,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['perform'],['performing']
Performance,"= std::cout); print information about measurement object in tree-like structure to given stream. void PrintXML(string Directory = """", string NewOutputPrefix = """"); create XML files for this measurement in the given directory; XML files can be configured with a different output prefix. void writeToFile(TFile* file); A measurement, once fully configured, can be saved into a ROOT; file. This will persitify the Measurement object, along with any; channels and samples that have been added to it. It can then be; loaded, potentially modified, and used to create new models. std::string GetDirPath(TDirectory* dir); Return the directory's path,; stripped of unnecessary prefixes. void CollectHistograms(); The most common way to add histograms to channels is to have them; stored in ROOT files and to give HistFactory the location of these; files. This means providing the path to the ROOT file and the path; and name of the histogram within that file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. Measurement(const char* Name, const char* Title = """"). void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html:11576,load,load,11576,root/html602/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html,2,['load'],['load']
Performance,"= std::cout); print information about measurement object in tree-like structure to given stream. void PrintXML(string Directory = """", string NewOutputPrefix = """"); create XML files for this measurement in the given directory; XML files can be configured with a different output prefix. void writeToFile(TFile* file); A measurement, once fully configured, can be saved into a ROOT; file. This will persitify the Measurement object, along with any; channels and samples that have been added to it. It can then be; loaded, potentially modified, and used to create new models. std::string GetDirPath(TDirectory* dir); Return the directory's path,; stripped of unnecessary prefixes. void CollectHistograms(); The most common way to add histograms to channels is to have them; stored in ROOT files and to give HistFactory the location of these; files. This means providing the path to the ROOT file and the path; and name of the histogram within that file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html:11014,load,load,11014,root/html534/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html,1,['load'],['load']
Performance,"= std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement.; 76 bool fIsUnsigned; ///< (=true if unsigned, false otherwise); 77 TLeaf *fLeafCount; ///< Pointer to Leaf count if variable length (we do not own the counter); 78 TBranch *fBranch; ///<! Pointer to supporting branch (we do not own the branch); 79 LeafCountValues *fLeafCountValues; ///<! Cache of collection/array sizes; 80 ; 81 TLeaf(const TLeaf&);; 82 TLeaf& operator=(const TLeaf&);; 83 ; 84 template <typename T> struct GetValueHelper {; 85 static T Exec(const TLeaf *leaf, Int_t i = 0) { return leaf->GetValue(i); }; 86 };; 87 ; 88 Int_t *GenerateOffsetArrayBase(Int_t base, Int_t events) const; // For leaves containing fixed-size objects (no; 89 // polymorphism!), this will generate an appropriate; 90 // offset array.; 91 ; 92 ; 93public:; 94 enum EStatusBits {; 95 kIndirectAddress = BIT(11), ///< Data member is a pointer to an array of basic types.; 96 kNewValue = BIT(12) ///< Set if we own the value buffer and so must delete it ourselves.; 97 };; 98 ; 99 enum class DeserializeType {; 100 kInvalid = 0, // Invalid deserialization information.; 101 kExternal, // Deserialization of this Leaf requires a separate output buffer, i.e. the on-disk and in-memory representation are likely to be different sizes.; 102 kDestructive = kExternal, // For backward compatibility; 103 kInPlace, // Deserialization can be done directly in the input buffer.; 104",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8h_source.html:3185,Cache,Cache,3185,doc/master/TLeaf_8h_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html,1,['Cache'],['Cache']
Performance,"= style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user reques",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:338658,cache,cache,338658,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],['cache']
Performance,"= trfs.end(); ++trfIt) {; 683 // setting a Root dir causes the variables distributions to be saved to the root file; 684 (*trfIt)->SetRootDir(RootBaseDir()->GetDirectory(fDataSetInfo.GetName())); // every dataloader have its own dir; 685 (*trfIt)->CalcTransformations(inputEvents);; 686 }; 687 if (identityTrHandler); 688 identityTrHandler->PrintVariableRanking();; 689 ; 690 // clean up; 691 for (trfIt = trfs.begin(); trfIt != trfs.end(); ++trfIt); 692 delete *trfIt;; 693}; 694 ; 695////////////////////////////////////////////////////////////////////////////////; 696/// Iterates through all booked methods and sees if they use parameter tuning and if so; 697/// does just that, i.e.\ calls ""Method::Train()"" for different parameter settings and; 698/// keeps in mind the ""optimal one""...\ and that's the one that will later on be used; 699/// in the main training loop.; 700 ; 701std::map<TString, Double_t> TMVA::Factory::OptimizeAllMethods(TString fomType, TString fitType); 702{; 703 ; 704 std::map<TString, MVector *>::iterator itrMap;; 705 std::map<TString, Double_t> TunedParameters;; 706 for (itrMap = fMethodsMap.begin(); itrMap != fMethodsMap.end(); ++itrMap) {; 707 MVector *methods = itrMap->second;; 708 ; 709 MVector::iterator itrMethod;; 710 ; 711 // iterate over methods and optimize; 712 for (itrMethod = methods->begin(); itrMethod != methods->end(); ++itrMethod) {; 713 Event::SetIsTraining(kTRUE);; 714 MethodBase *mva = dynamic_cast<MethodBase *>(*itrMethod);; 715 if (!mva) {; 716 Log() << kFATAL << ""Dynamic cast to MethodBase failed"" << Endl;; 717 return TunedParameters;; 718 }; 719 ; 720 if (mva->Data()->GetNTrainingEvents() < MinNoTrainingEvents) {; 721 Log() << kWARNING << ""Method "" << mva->GetMethodName() << "" not trained (training tree has less entries [""; 722 << mva->Data()->GetNTrainingEvents() << ""] than required ["" << MinNoTrainingEvents << ""]"" << Endl;; 723 continue;; 724 }; 725 ; 726 Log() << kINFO << ""Optimize method: "" << mva->GetMethodName() << "" for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:28331,Optimiz,OptimizeAllMethods,28331,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,"['Optimiz', 'Tune']","['OptimizeAllMethods', 'TunedParameters']"
Performance,"="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::MinValuevirtual double MinValue() const =0return minimum function value; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; Factory.h; NumericalMinimizationDefinition NumericalMinimization.py:1; AuthorLorenzo Moneta ; Definition in file NumericalMinimization.C. tutorialsfitNumericalMinimization.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NumericalMinimization_8C.html:4352,perform,perform,4352,doc/master/NumericalMinimization_8C.html,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html,1,['perform'],['perform']
Performance,"=(0)+(1)*x0+(2)*x1:ParRanges=(-100,100);(-100,100);(-100,100):FitMethod=GA:Converger=MINUIT:ErrorLevel=1:PrintLevel=-1:FitStrategy=0:!UseImprove:!UseMinos:SetBatch:Cycles=1:PopSize=5:Steps=5:Trim"" );; 268 ; 269 // Neural network (MLP); 270 if (Use[""MLP""]); 271 factory->BookMethod( dataloader, TMVA::Types::kMLP, ""MLP"", ""!H:!V:VarTransform=Norm:NeuronType=tanh:NCycles=20000:HiddenLayers=N+20:TestRate=6:TrainingMethod=BFGS:Sampling=0.3:SamplingEpoch=0.8:ConvergenceImprove=1e-6:ConvergenceTests=15:!UseRegulator"" );; 272 ; 273 if (Use[""DNN_CPU""] || Use[""DNN_GPU""]) {; 274 ; 275 TString archOption = Use[""DNN_GPU""] ? ""GPU"" : ""CPU"";; 276 ; 277 TString layoutString(""Layout=TANH|50,TANH|50,TANH|50,LINEAR"");; 278 ; 279 ; 280 TString trainingStrategyString(""TrainingStrategy="");; 281 ; 282 trainingStrategyString +=""LearningRate=1e-3,Momentum=0.3,ConvergenceSteps=20,BatchSize=50,TestRepetitions=1,WeightDecay=0.0,Regularization=None,Optimizer=Adam"";; 283 ; 284 TString nnOptions(""!H:V:ErrorStrategy=SUMOFSQUARES:VarTransform=G:WeightInitialization=XAVIERUNIFORM:Architecture="");; 285 nnOptions.Append(archOption);; 286 nnOptions.Append("":"");; 287 nnOptions.Append(layoutString);; 288 nnOptions.Append("":"");; 289 nnOptions.Append(trainingStrategyString);; 290 ; 291 TString methodName = TString(""DNN_"") + archOption;; 292 ; 293 factory->BookMethod(dataloader, TMVA::Types::kDL, methodName, nnOptions); // NN; 294 }; 295 ; 296 ; 297 ; 298 // Support Vector Machine; 299 if (Use[""SVM""]); 300 factory->BookMethod( dataloader, TMVA::Types::kSVM, ""SVM"", ""Gamma=0.25:Tol=0.001:VarTransform=Norm"" );; 301 ; 302 // Boosted Decision Trees; 303 if (Use[""BDT""]); 304 factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDT"",; 305 ""!H:!V:NTrees=100:MinNodeSize=1.0%:BoostType=AdaBoostR2:SeparationType=RegressionVariance:nCuts=20:PruneMethod=CostComplexity:PruneStrength=30"" );; 306 ; 307 if (Use[""BDTG""]); 308 factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; 309 ""!H:!V:NTrees=2000::BoostType=Grad:Shri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:12318,Optimiz,Optimizer,12318,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['Optimiz'],['Optimizer']
Performance,"=-999);  Calculates the kernel bandwidth for x & y and the probability look up table _p[i][j]. ;  ; TObject * clone (const char *newname) const override;  ; double evaluate () const override;  Evaluates the kernel estimation for x,y, interpolating between the points if necessary. ;  ; Int_t getBandWidthType () const;  ; double getMean (const char *axis) const;  ; void getOptions (void) const;  ; double getSigma (const char *axis) const;  ; TClass * IsA () const override;  ; Int_t loadDataSet (RooDataSet &data, TString options);  Loads a new data set into the class instance. ;  ; void PrintInfo (std::ostream &) const;  Prints out _p[_nPoints][_nPoints] indicating the domain limits. ;  ; void setOptions (TString options);  ; void setWidthScaleFactor (double widthScaleFactor);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeHistToFile (char *outputFile, const char *histName) const;  Plots the PDF as a histogram and saves it to a file, so that it can be loaded in as a Roo2DHist PDF in the future to save on calculation time. ;  ; void writeNTupleToFile (char *outputFile, const char *name) const;  Saves the data and calculated bandwidths to a file, as a record of what produced the PDF and to give a reduced data set in order to facilitate re-calculation in the future. ;  ; void writeToFile (char *outputFile, const char *name) const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:1945,load,loaded,1945,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['load'],['loaded']
Performance,"=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::SetBackgroundWeightExpressionvoid SetBackgroundWeightExpression(const TString &variable)Definition DataLoader.cxx:556; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Envelope::BookMethodvirtual void BookMethod(TString methodname, TString methodtitle, TString options="""")Method to book the machine learning method to perform the algorithm.Definition Envelope.cxx:163; TMVA::Experimental::ClassificationDefinition Classification.h:162; TMVA::Experimental::Classification::GetResultsstd::vector< ClassificationResult > & GetResults()Return the vector of TMVA::Experimental::ClassificationResult objects.Definition Classification.cxx:945; TMVA::Experimental::Classification::Evaluatevirtual void Evaluate()Method to perform Train/Test over all ml method booked.Definition Classification.cxx:248; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kSVM@ kSVMDefinition Types.h:89; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; classificationvoid classification(UInt_t jobs=4)Definition classification.C:14; unsigned int; ; #include <TMVA/Classification.h>; The documentation for this class was generated from the following file:; tmva/tmva/inc/TMVA/Classification.h. Classification. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:5660,perform,perform,5660,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,1,['perform'],['perform']
Performance,"=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:8625,Optimiz,Optimizer,8625,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['Optimiz'],['Optimizer']
Performance,"=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""G"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|7"" [The Layout of the input]; : BatchLayout: ""1|128|7"" [The Layout of the batch]; : Layout: ""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=20,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""G"" with eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:12322,perform,perform,12322,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['perform'],['perform']
Performance,"=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""G"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|7"" [The Layout of the input]; : BatchLayout: ""1|128|7"" [The Layout of the batch]; : Layout: ""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=30,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""G"" with eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:12309,perform,perform,12309,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['perform']
Performance,"=0TBufferpure virtual; WriteFastArray(const ULong64_t *l, Long64_t n)=0TBufferpure virtual; WriteFastArray(const Float_t *f, Long64_t n)=0TBufferpure virtual; WriteFastArray(const Double_t *d, Long64_t n)=0TBufferpure virtual; WriteFastArray(void *start, const TClass *cl, Long64_t n=1, TMemberStreamer *s=nullptr)=0TBufferpure virtual; WriteFastArray(void **startp, const TClass *cl, Long64_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=nullptr)=0TBufferpure virtual; WriteFastArrayDouble32(const Double_t *d, Long64_t n, TStreamerElement *ele=nullptr)=0TBufferpure virtual; WriteFastArrayFloat16(const Float_t *f, Long64_t n, TStreamerElement *ele=nullptr)=0TBufferpure virtual; WriteFastArrayString(const Char_t *c, Long64_t n)=0TBufferpure virtual; WriteFloat(Float_t f)=0TBufferpure virtual; WriteFloat16(Float_t *f, TStreamerElement *ele=nullptr)=0TBufferpure virtual; WriteInt(Int_t i)=0TBufferpure virtual; WriteLong(Long_t l)=0TBufferpure virtual; WriteLong64(Long64_t l)=0TBufferpure virtual; WriteObject(const TObject *obj, Bool_t cacheReuse)=0TBufferpure virtual; WriteObject(const T *objptr, Bool_t cacheReuse=kTRUE)TBufferinline; WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0TBufferpure virtual; WriteProcessID(TProcessID *pid)=0TBufferpure virtual; WriteShort(Short_t s)=0TBufferpure virtual; WriteStdString(const std::string *s)=0TBufferpure virtual; WriteStdString(std::string &s)TBufferinlinevirtual; WriteString(const char *s)=0TBufferpure virtual; WriteTString(const TString &s)=0TBufferpure virtual; WriteUChar(UChar_t c)=0TBufferpure virtual; WriteUInt(UInt_t i)=0TBufferpure virtual; WriteULong(ULong_t l)=0TBufferpure virtual; WriteULong64(ULong64_t l)=0TBufferpure virtual; WriteUShort(UShort_t s)=0TBufferpure virtual; WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0TBufferpure virtual; WriteVersionMemberWise(const TClass *cl, Bool_t useBcnt=kFALSE)=0TBufferpure virtual; ~TBuffer()TBuffervirtual; ~TObject()TObjectvirtual.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer-members.html:18449,cache,cacheReuse,18449,doc/master/classTBuffer-members.html,https://root.cern,https://root.cern/doc/master/classTBuffer-members.html,3,['cache'],['cacheReuse']
Performance,"=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=20,Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIERUNIFORM:ValidationSize=0.2:RandomSeed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=20,Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:6491,perform,performed,6491,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['performed']
Performance,"=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; }; // Use a kernel density estimator to approximate the PDFs; if (useLikelihoodKDE) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""LikelihoodKDE"",; ""!H:!V:!TransformOutput:PDFInterpol=KDE:KDEtype=Gauss:KDEiter=Adaptive:KDEFineFactor=0.3:KDEborder=None:NAvEvtPerBin=50"" );; ; }; ; // Fisher discriminant (same as LD); if (useFischer) {; factory.BookMethod(loader, TMVA::Types::kFisher, ""Fisher"", ""H:!V:Fisher:VarTransform=None:CreateMVAPdfs:PDFInterpolMVAPdf=Spline2:NbinsMVAPdf=50:NsmoothMVAPdf=10"" );; }; ; //Boosted Decision Trees; if (useBDT) {; factory.BookMethod(loader,TMVA::Types::kBDT, ""BDT"",; ""!V:NTrees=200:MinNodeSize=2.5%:MaxDepth=2:BoostType=AdaBoost:AdaBoostBeta=0.5:UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20"" );; }; ; //Multi-Layer Perceptron (Neural Network); if (useMLP) {; factory.BookMethod(loader, TMVA::Types::kMLP, ""MLP"",; ""!H:!V:NeuronType=tanh:VarTransform=N:NCycles=100:HiddenLayers=N+5:TestRate=5:!UseRegulator"" );; }; ; ; /// Here we book the new DNN of TMVA if we have support in ROOT. We will use GPU version if ROOT is enabled with GPU; ; ; /***; ; ## Booking Deep Neural Network; ; Here we define the option string for building the Deep Neural network model.; ; #### 1. Define DNN layout; ; The DNN configuration is defined using a string. Note that whitespaces between characters are not allowed.; ; We define first the DNN layout:; ; - **input layout** : this defines the input data format for the DNN as ``input depth | height | width``.; In case of a dense layer as first layer the input layout should be ``1 | 1 | number of input variables`` (features); - **batch layout** : this defines how are the input batch. It is related to input layout but not the same.; If the first layer is dense it should be ``1 | batch size ! number of variables`` (features); ; *(note the use of the character `|` as separator of input parameters for DNN layout)*; ; note that in case of on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:62846,load,loader,62846,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['load'],['loader']
Performance,"=2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGraph; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEllipse.html:31643,perform,perform,31643,doc/master/classRooEllipse.html,https://root.cern,https://root.cern/doc/master/classRooEllipse.html,1,['perform'],['perform']
Performance,"==; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Fa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:22660,perform,performance,22660,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['perform'],['performance']
Performance,"========. void SetRGB(Int_t cindex, Float_t r, Float_t g, Float_t b). void SetRGB(Int_t cindex, Float_t r, Float_t g, Float_t b, Float_t a); Set the color with the alpha component (supported wuth Qt 4 only). void SetAlpha(Int_t cindex, Float_t a); Add the alpha component (supported with Qt 4 only). void GetRGBA(Int_t cindex, Float_t& r, Float_t& g, Float_t& b, Float_t& a); Return RGBA components for the color cindex. Float_t GetAlpha(Int_t cindex); Return Alpha component for the color cindex. void SetTextAlign(Short_t talign = 11); Set text alignment*-*-*-*-*-*-*-; *-* ==================; *-* txalh : horizontal text alignment; *-* txalv : vertical text alignment; *. void SetTextColor(Color_t cindex); Set color index for text*-*-*-*-; *-* ========================; *-* cindex : color index defined my IXSETCOL; *. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=kCheck = 0 : search if the font exist (kCheck); mode= kLoad = 1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); -*Set current text font number; *-* ===========================; *-* List of the currently supported fonts (screen and PostScript); *-* =============================================================; *-* Font ID X11 Win32 TTF lfItalic lfWeight x 10; *-* 1 : times-medium-i-normal ""Times New Roman"" 1 5; *-* 2 : times-bold-r-normal ""Times New Roman"" 0 8; *-* 3 : times-bold-i-normal ""Times New Roman"" 1 8; *-* 4 : helvetica-medium-r-normal ""Arial"" 0 5; *-* 5 : helvetica-medium-o-normal ""Arial"" 1 5; *-* 6 : helvetica-bold-r-normal ""Arial"" 0 8; *-* 7 : helvetica-bold-o-normal ""Arial"" 1 8; *-* 8 : courier-medium-r-normal ""Courier New"" 0 5; *-* 9 : courier-medium-o-normal ""Courier New"" 1 5; *-* 10 : courier-bold-r-normal ""Courier New"" 0 8; *-* 11 : courier-bold-o-normal ""Courier Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:32273,load,loading,32273,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,6,['load'],"['load', 'loading']"
Performance,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:54331,Perform,Performs,54331,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,5,['Perform'],['Performs']
Performance,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMinuit.html:54967,Perform,Performs,54967,root/html604/TMinuit.html,https://root.cern,https://root.cern/root/html604/TMinuit.html,1,['Perform'],['Performs']
Performance,"============. TBranch* GetMother() const; Get our top-level parent branch in the tree. TBranch* GetSubBranch(const TBranch* br) const; Find the parent branch of child.; Return 0 if child is not in this branch hierarchy. Long64_t GetTotalSize(Option_t* option = """") const; Return total number of bytes in the branch (including current buffer). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranch.html:20661,Load,LoadBaskets,20661,root/html526/TBranch.html,https://root.cern,https://root.cern/root/html526/TBranch.html,1,['Load'],['LoadBaskets']
Performance,"========================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<std::string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:19200,load,load,19200,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,4,['load'],['load']
Performance,"========================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:24773,load,load,24773,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['load'],['load']
Performance,"=========================; : ========================================; : ; <HEADER> Factory : Booking method: BDTG_fold1; : ; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; : Regression Loss Function: Huber; : Training 500 Decision Trees ... patience please; : Elapsed time for training with 4999 events: 1.31 sec ; : Dataset[datasetcvreg] : Create results for training; : Dataset[datasetcvreg] : Evaluation of BDTG_fold1 on training sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 4999 events: 0.21 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: datasetcvreg/weights/TMVACrossValidationRegression_BDTG_fold1.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG_fold1 for Regression performance; : ; : Dataset[datasetcvreg] : Create results for testing; : Dataset[datasetcvreg] : Evaluation of BDTG_fold1 on testing sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 5000 events: 0.214 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; <HEADER> Factory : Evaluate all methods; : Evaluate regression method: BDTG_fold1; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 5000 events: 0.213 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 4999 events: 0.21 sec ; : ; : Evaluation results ranked by smallest RMS on test sample:; : (""Bias"" quotes the mean deviation of the regression from true target.; : ""MutInf"" is the ""Mutual Information"" between regression and target.; : Indicated by ""_T"" are the corresponding ""truncated"" quantities ob-; : tained when removing events deviating more than 2sigma from average.); : --------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:4274,perform,performance,4274,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['perform'],['performance']
Performance,"=========================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; Factory : Booking method: ␛[1mPyKeras␛[0m; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Loading Keras Model ; : Loaded model from file: model_cnn.h5; Factory : Booking method: ␛[1mPyTorch␛[0m; : ; : Using PyTorch - setting special configuration options ; : Using PyTorch version 2; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; running Torch code defining the model....; The PyTorch CNN model is created and saved as PyTorchModelCNN.pt; : Loaded pytorch train function: ; : Loaded pytorch optimizer: ; : Loaded pytorch loss function: ; : Loaded pytorch predict function: ; : Loaded model from file: PyTorchModelCNN.pt; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: BDT for Classification; : ; BDT : #events: (reweighted) sig: 800 bkg: 800; : #events: (unweighted) sig: 800 bkg: 800; : Training 200 Decision Trees ... patience please; : Elapsed time for training with 1600 events: 0.877 sec ; BDT : [dataset] : Evaluation of BDT on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0172 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_BDT.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_BDT.class.C␛[0m; : TMVA_CNN_ClassificationOutput.root:/dataset/Method_BDT/BDT; Factory : Training finished; : ; Factory : Train method: TMVA_DNN_CPU for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 8 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:9148,Load,Loaded,9148,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,6,"['Load', 'optimiz']","['Loaded', 'optimizer']"
Performance,"=====================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ KNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The k-nearest neighbor (k-NN) algorithm is a multi-dimensional classification; : and regression algorithm. Similarly to other TMVA algorithms, k-NN uses a set of; : training events for which a classification category/regression target is known. ; : The k-NN method compares a test event to all training events using a distance ; : function, which is an Euclidean distance in a space defined by the input variables. ; : The k-NN method, as implemented in TMVA, uses a kd-tree algorithm to perform a; : quick search for the k events with shortest distance to the test event. The method; : returns a fraction of signal events among the k neighbors. It is recommended; : that a histogram which stores the k-NN decision variable is binned with k+1 bins; : between 0 and 1.; : ; : ␛[1m--- Performance tuning via configuration options: ␛[0m; : ; : The k-NN method estimates a density of signal and background events in a ; : neighborhood around the test event. The method assumes that the density of the ; : signal and background events is uniform and constant within the neighborhood. ; : k is an adjustable parameter and it determines an average size of the ; : neighborhood. Small k values (less than 10) are sensitive to statistical ; : fluctuations and large (greater than 100) values might not sufficiently capture ; : local differences between events in the training set. The speed of the k-NN; : method also increases with larger values of k. ; : ; : The k-NN method assigns equal weight to all input variables. Different scales ; : among the input variables is compensated using ScaleFrac parameter: the input ; : variables are scaled so that the widths for central ScaleFrac*100% events are ; : equal among all the input variables.; : ; : ␛[1m--- Additional configuration options: ␛[0m; : ; : The method inclues an option to use a Gaussian kernel to smooth ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:33089,Perform,Performance,33089,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['Perform'],['Performance']
Performance,"=============>..............] - ETA: 0s - loss: 0.5682 - accuracy: 0.6946␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 94/112 [========================>.....] - ETA: 0s - loss: 0.5718 - accuracy: 0.6922; Epoch 20: val_loss improved from 0.59141 to 0.58978, saving model to trained_model_higgs.h5; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 112/112 [==============================] - 0s 2ms/step - loss: 0.5754 - accuracy: 0.6892 - val_loss: 0.5898 - val_accuracy: 0.6757; : Getting training history for item:0 name = 'loss'; : Getting training history for item:1 name = 'accuracy'; : Getting training history for item:2 name = 'val_loss'; : Getting training history for item:3 name = 'val_accuracy'; : Elapsed time for training with 14000 events: 6.33 sec ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_higgs.h5; PyKeras : [dataset] : Evaluation of PyKeras on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.26 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.class.C␛[0m; Factory : Training finished; : ; : Ranking input variables (method specific)...; Likelihood : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Delta Separation; : -------------------------------------; : 1 : m_bb : 3.688e-02; : 2 : m_wbb : 3.307e-02; : 3 : m_wwbb : 2.885e-02; : 4 : m_jjj : -1.155e-03; : 5 : m_jj : -1.436e-03; : 6 : m_lv : -5.963e-03; : 7 : m_jlv : -9.884e-03; : -------------------------------------; Fisher : Ranking result (top variable is best ranked); : ---------------------------------; : Rank : Variable : Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:46347,Load,Loading,46347,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,2,['Load'],"['Loaded', 'Loading']"
Performance,=========>..............] - ETA: 0s - loss: 0.5691 - accuracy: 0.7035␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 90/112 [=======================>......] - ETA: 0s - loss: 0.5717 - accuracy: 0.6967; Epoch 20: val_loss did not improve from 0.58687; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 112/112 [==============================] - 0s 2ms/step - loss: 0.5716 - accuracy: 0.6941 - val_loss: 0.5930 - val_accuracy: 0.6779; : Getting training history for item:0 name = 'loss'; : Getting training history for item:1 name = 'accuracy'; : Getting training history for item:2 name = 'val_loss'; : Getting training history for item:3 name = 'val_accuracy'; : Elapsed time for training with 14000 events: 6.58 sec ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: Higgs_trained_model.h5; PyKeras : [dataset] : Evaluation of PyKeras on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.275 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.class.C␛[0m; Factory : Training finished; : ; : Ranking input variables (method specific)...; Likelihood : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Delta Separation; : -------------------------------------; : 1 : m_bb : 3.688e-02; : 2 : m_wbb : 3.307e-02; : 3 : m_wwbb : 2.885e-02; : 4 : m_jjj : -1.155e-03; : 5 : m_jj : -1.436e-03; : 6 : m_lv : -5.963e-03; : 7 : m_jlv : -9.884e-03; : -------------------------------------; Fisher : Ranking result (top variable is best ranked); : ---------------------------------; : Rank : Variabl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:46797,Load,Loading,46797,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['Load'],"['Loaded', 'Loading']"
Performance,"=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create / open a file. ;  ; static TFile * Open (TFileOpenHandle *handle);  Waits for the completion of an asynchronous open request. ;  ; static Bool_t SetCacheFileDir (std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE);  Sets the directory where to locally stage/cache remote files. ;  ; static void SetFileBytesRead (Long64_t bytes=0);  ; static void SetFileBytesWritten (Long64_t bytes=0);  ; static void SetFileReadCalls (Int_t readcalls=0);  ; static Bool_t SetOnlyStaged (Bool_t onlystaged);  Sets only staged flag. ;  ; static UInt_t SetOpenTimeout (UInt_t timeout);  Sets open timeout time (in ms). Returns previous timeout value. ;  ; static void SetReadaheadSize (Int_t bufsize=256000);  ; static void SetReadStreamerInfo (Bool_t readinfo=kTRUE);  Specify if the streamerinfos must be read at file opening. ;  ; static Bool_t ShrinkCacheFileDir (Long64_t shrinkSize, Long_t cleanupInteval=0);  Try to shrink the cache to the desired size. ;  ;  Static Public Member Functions inherited from TDirectoryFile; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:30452,cache,cache,30452,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['cache'],['cache']
Performance,"=false);  Decode all pad options, which includes ranges plus objects options. ;  ; TObject * FindPrimitive (const std::string &id, int idcnt=1, TPad *pad=nullptr, TObjLink **objlnk=nullptr, TPad **objpad=nullptr);  Search of object with given id in list of primitives One could specify pad where search could be start Also if object is in list of primitives, one could ask for entry link for such object, This can allow to change draw option. ;  ; Bool_t IsFirstConn (unsigned connid) const;  ; Bool_t IsFirstDrawn () const;  ; virtual Bool_t IsJSSupportedClass (TObject *obj, Bool_t many_primitives=kFALSE);  Returns kTRUE when object is fully supported on JSROOT side In ROOT7 Paint function will just return appropriate flag that object can be displayed on JSROOT side. ;  ; Bool_t IsLocked () override;  ; Bool_t IsWeb () const override;  ; void Lock () override;  ; Bool_t PerformUpdate (Bool_t async) override;  if canvas or any subpad was modified, scan all primitives in the TCanvas and subpads and convert them into the structure which will be delivered to JSROOT client ;  ; virtual Bool_t ProcessData (unsigned connid, const std::string &arg);  Handle data from web browser Returns kFALSE if message was not processed. ;  ; void ProcessExecs (TPad *pad, TExec *extra=nullptr);  Process TExec objects in the pad. ;  ; void ProcessLinesForObject (TObject *obj, const std::string &lines);  Execute one or several methods for selected object String can be separated by "";;"" to let execute several methods at once. ;  ; TPad * ProcessObjectOptions (TWebObjectOptions &item, TPad *pad, int idcnt=1);  Process data for single primitive Returns object pad if object was modified. ;  ; void SetWindowGeometry (const std::vector< int > &arr);  Set window geometry as array with coordinates and dimensions. ;  ; void ShowCmd (const std::string &arg, Bool_t show);  Function used to send command to browser to toggle menu, toolbar, editors, ... ;  ; void Unlock () override;  ; Bool_t WaitWhenCanvasPai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:11838,Perform,PerformUpdate,11838,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['Perform'],['PerformUpdate']
Performance,"=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; Optimisation interface; These functions allow RooFit to optimise a computation graph, to keep track of cached values, and to invalidate caches. . virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:20955,optimiz,optimizeCacheMode,20955,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,3,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:26309,load,load,26309,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"=kFALSE)TClass; CalculateStreamerOffset() constTClass; CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constTClass; CanIgnoreTObjectStreamer()TClassinline; CanSplit() constTClass; CanSplitBaseAllow()TClassprivate; CheckedHash()TObjectinline; Class()TClassstatic; Class_Name()TClassstatic; Class_Version()TClassinlinestatic; ClassName() constTObjectvirtual; ClassProperty() constTClass; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTClassvirtual; Compare(const TObject *obj) const overrideTNamedvirtual; ConvSIMap_t typedefTClassprivate; ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)TClassprivatestatic; Copy(TObject &named) const overrideTNamedvirtual; CopyCollectionProxy(const TVirtualCollectionProxy &)TClass; CreateAttributeMap()TDictionary; CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)TClassprivate; DeclFileName()TClassinlinestatic; DeclId_t typedefTDictionary; Delete(Option_t *option="""")TObjectvirtual; DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)TClass; DeleteArray(ObjectPtr ary, Bool_t dtorOnly=kFALSE)TClass; Destructor(void *obj, Bool_t dtorOnly=kFALSE)TClass; Destructor(ObjectPtr obj, Bool_t dtorOnly=kFALSE)TClass; DetermineCurrentStreamerInfo()TClassprivate; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""") overrideTClassvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() const overrideTClassinlinevirtual; Dump(const void *obj, Bool_t noAddr=kFALSE) constTClass; DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)TClass; DynamicCast(const TClass *base, const void *obj, Bool_t up=kTRUE)TClass; ECheckSum enum nameTClass; EDeprecatedStatusBits enum nameTObject; EMemberSelectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:2114,load,load,2114,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"=nullptr, bool force=false)RooAbsRealprotectedvirtual; selectNormalizationRange(const char *rangeName=nullptr, bool force=false)RooAbsRealprotectedvirtual; selfNormalized() constRooAbsPdfinlinevirtual; serverNameChangeHook(const RooAbsArg *, const RooAbsArg *)RooAbsArginlinevirtual; servers() constRooAbsArginline; setActiveNormSet(RooArgSet const *normSet) constRooAbsPdfinlineprivate; setAttribute(const Text_t *name, bool value=true)RooAbsArg; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; setCacheAndTrackHints(RooArgSet &)RooAbsArginlinevirtual; setCachedValue(double value, bool notifyClients=true) finalRooAbsRealinlinevirtual; setData(RooAbsData &, bool=true)RooAbsRealinlinevirtual; setDataToken(std::size_t index)RooAbsArg; setDirtyInhibit(bool flag)RooAbsArgstatic; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; setEvalErrorLoggingMode(ErrorLoggingMode m)RooAbsRealstatic; setExpensiveObjectCache(RooExpensiveObjectCache &cache)RooAbsArginlinevirtual; setGeneratorConfig()RooAbsPdf; setGeneratorConfig(const RooNumGenConfig &config)RooAbsPdf; setHideOffset(bool flag)RooAbsRealstatic; setIntegratorConfig()RooAbsReal; setIntegratorConfig(const RooNumIntConfig &config)RooAbsReal; setLocalNoDirtyInhibit(bool flag) constRooAbsArginline; SetName(const char *name) overrideRooAbsArgvirtual; SetNameTitle(const char *name, const char *title) overrideRooAbsArgvirtual; setNormRange(const char *rangeName)RooAbsPdf; setNormRangeOverride(const char *rangeName)RooAbsPdf; SetObjectStat(Bool_t stat)TObjectstatic; setOperMode(OperMode mode, bool recurseADirty=true)RooAbsArg; setParameterizeIntegral(const RooArgSet &paramVars)RooAbsReal; setPlotLabel(const char *label)RooAbsReal; setProhibitServerRedirect(bool flag)RooAbsArginline; setProxyNormSet(const RooArgSet *nset)RooAbsArgprotected; setShapeDirty()RooAbsArginline; setShapeDirty(const RooAbsArg *source)RooAbsArgprotected; setStringAttribute(const Text_t *key, const Text_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:36068,cache,cache,36068,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['cache'],['cache']
Performance,"=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722/////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:172492,cache,cachefile,172492,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cachefile']
Performance,"={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:16847,cache,cache,16847,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,12,['cache'],['cache']
Performance,"={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:16988,cache,cache,16988,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['cache'],['cache']
Performance,"> &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual bool isValid () const;  WVE (08/21/01) Probably obsolete now. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; virtual void setTreeBranchStatus (TTree &t, bool active)=0;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; virtual void syncCache (const RooArgSet *nset=nullptr)=0;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:35951,cache,cached,35951,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"> &autoloads); 659{; 660 std::string keyname;; 661 std::string libs;; 662 std::string line;; 663 ; 664 // For ""class "", ""namespace "" and ""typedef "" respectively; 665 const std::unordered_map<char, unsigned int> keyLenMap = {{'c', 6}, {'n', 10}, {'t', 8}};; 666 ; 667 while (getline(file, line, '\n')) {; 668 if (line == ""{ decls }"") {; 669 while (getline(file, line, '\n')) {; 670 if (line[0] == '[') break;; 671 }; 672 }; 673 const char firstChar = line[0];; 674 if (firstChar == '[') {; 675 // new section; 676 libs = line.substr(1, line.find(']') - 1);; 677 while (libs[0] == ' ') libs.replace(0, 1, """");; 678 } else if (0 != keyLenMap.count(firstChar)) {; 679 unsigned int keyLen = keyLenMap.at(firstChar);; 680 keyname = line.substr(keyLen, line.length() - keyLen);; 681 CheckClassNameForRootMap(keyname, autoloads);; 682 autoloads[keyname] = libs;; 683 }; 684 }; 685 ; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Fill the map of libraries to be loaded in presence of a class; 690/// Transparently support the old and new rootmap file format; 691 ; 692void LoadLibraryMap(const std::string &fileListName, map<string, string> &autoloads); 693{; 694 std::ifstream filelist(fileListName.c_str());; 695 ; 696 std::string filename;; 697 std::string line;; 698 ; 699 while (filelist >> filename) {; 700 ; 701 if (llvm::sys::fs::is_directory(filename)) continue;; 702 ; 703 ifstream file(filename.c_str());; 704 ; 705 // Check which format is this; 706 file >> line;; 707 bool new_format = (line[0] == '[' || line[0] == '{') ;; 708 file.clear();; 709 file.seekg(0, std::ios::beg);; 710 ; 711 // Now act; 712 if (new_format) {; 713 ParseRootMapFileNewFormat(file, autoloads);; 714 } else {; 715 ParseRootMapFile(file, autoloads);; 716 }; 717 ; 718 file.close();; 719 ; 720 } // end loop on files; 721 filelist.close();; 722}; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Check if the specif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:23747,load,loaded,23747,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,2,"['Load', 'load']","['LoadLibraryMap', 'loaded']"
Performance,"> *fldHrweek; >> *fldCost >> *fldDivision >> *fldNation;; ntuple->Fill();; }; ; // The ntuple unique pointer goes out of scope here. On destruction, the ntuple flushes unwritten data to disk; // and closes the attached ROOT file.; }; ; void Analyze() {; // Get a unique pointer to an empty RNTuple model; auto model = RNTupleModel::Create();; ; // We only define the fields that are needed for reading; std::shared_ptr<int> fldAge = model->MakeField<int>(""Age"");; ; // Create an ntuple and attach the read model to it; auto ntuple = RNTupleReader::Open(std::move(model), ""Staff"", kNTupleFileName);; ; // Quick overview of the ntuple and list of fields.; ntuple->PrintInfo();; ; std::cout << ""The first entry in JSON format:"" << std::endl;; ntuple->Show(0);; // In a future version of RNTuple, there will be support for ntuple->Scan(); ; auto c = new TCanvas(""c"", """", 200, 10, 700, 500);; TH1I h(""h"", ""Age Distribution CERN, 1988"", 100, 0, 100);; h.SetFillColor(48);; ; for (auto entryId : *ntuple) {; // Populate fldAge; ntuple->LoadEntry(entryId);; h.Fill(*fldAge);; }; ; h.DrawCopy();; }; ; void ntpl001_staff() {; Ingest();; Analyze();; }; RNTupleModel.hxx; RNTupleReader.hxx; RNTupleWriter.hxx; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; TCanvas.h; TH1I.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; ROOT::Experimental::RNTupleModelThe RNTupleModel encapulates the schema of an ntuple.Definition RNTupleModel.hxx:136; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; DateApril 2019 ; AuthorThe ROOT Team ; Definition in file ntpl001_staff.C. tutorialsv7ntuplentpl001_staff.C. ROOT master - Refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C.html:3890,Load,LoadEntry,3890,doc/master/ntpl001__staff_8C.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html,1,['Load'],['LoadEntry']
Performance,"> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayPNE() const;; 154 Bool_t InsertPNEId(Int_t uid, Int_t ientry);; 155 void SetLoopVolumes(Bool_t flag = kTRUE) { fLoopVolumes = flag; }; 156 void UpdateElements();; 157 void Voxelize(Option_t *option = nullptr);; 158 ; 159public:; 160 // constructors; 161 TGeoManager();; 162 TGeoManager(const char *name, const char *title);; 163 // destructor; 164 ~TGeoManager() override;; 165 //--- adding geometrical objects; 166 Int_t AddMaterial(const TGeoMaterial *material);; 167 Int_t AddOverlap(const TNamed *ovlp);; 168 Int_t AddRegion(TGeoRegion *region);; 169 Int_t AddTransfor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:7013,multi-thread,multi-threading,7013,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['multi-thread'],['multi-threading']
Performance,">& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKernel ker) const; { return UInt_t(ker); }. EKernel UIntToKernel(UInt_t iker). UInt_t TargetSelectionToUInt(TMVA::ETargetSelection ts) const; { return UInt_t(ts);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDEFoam.html:24502,load,load,24502,root/html530/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDEFoam.html,3,['load'],['load']
Performance,">& GetRegressionValues(); Return regression values for both multi- and mono-target regression. TMVA::PDEFoamKernelBase* CreatePDEFoamKernel(); create a pdefoam kernel estimator, depending on the current; value of fKernel. void DeleteFoams(); Deletes all trained foams. void Reset(); reset MethodPDEFoam:; - delete all PDEFoams; - delete the kernel estimator. void PrintCoefficients( void ); {}. void AddWeightsXMLTo(void* parent) const; create XML output of PDEFoam method variables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0). EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDEFoam.html:26271,load,load,26271,root/html602/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDEFoam.html,2,['load'],['load']
Performance,">);  set the function implementing Hessian computation (re-implemented by Minimizer using it) ;  ; virtual bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower);  set a new lower limit variable (override if minimizer supports them ) ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; virtual bool SetUpperLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double upper);  set a new upper limit variable (override if minimizer supports them ) ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; virtual bool SetVariableLimits (unsigned int ivar, double lower, double upper);  set the limits of an already existing variable ;  ; virtual bool SetVariableLowerLimit (unsigned int ivar, double lower);  set the lower-limit of an already existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; virtual bool SetVariableStepSize (unsigned int ivar, double value);  set the step size of an already existing variable ;  ; virtual bool SetVariableUpperLimit (unsigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html:8588,perform,perform,8588,doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,2,['perform'],['perform']
Performance,">2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:2914,Perform,Perform,2914,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,1,['Perform'],['Perform']
Performance,">: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Schedule the destruction of TROOT.; 2099 atexit(at_exit_of_TROOT);; 2100 ; 2101 gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, ""DestroyInterpreter"");; 2102 if (!gDestroyInterpreter) {; 2103 TString err = dlerror();; 2104 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2105 exit(1);; 2106 }; 2107 ; 2108 const char *interpArgs[] = {; 2109#ifdef NDEBUG; 2110 ""-DNDEBUG"",; 2111#else; 2112 ""-UNDEBUG"",; 2113#endif; 2114#ifdef DEBUG; 2115 ""-DDEBUG"",; 2116#else; 2117 ""-UDEBUG"",; 2118#endif; 2119#ifdef _DEBUG; 2120 ""-D_DEBUG"",; 2121#else; 2122 ""-U_DEBUG"",; 2123#endif; 2124 nullptr};; 2125 ; 2126 fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);; 2127 ; 2128 fCleanups->Add(fInterpreter);; 2129 fInterpreter->SetBit(kMustCleanup);; 2130 ; 2131 fgRootInit = kTRUE;; 2132 ; 2133 // initialize gClassTable is not already done; 2134 if (!gClassTable); 2135 new TClassTable;; 2136 ; 2137 // Initialize all registered dictionaries.; 2138 for (std::vector<ModuleHeaderInfo_t>::const_iterator; 2139 li = GetModuleHeaderInfoBuffer().begin(),; 2140 le = GetModuleHeaderInfoBuffer().end(); li != le; ++li) {; 2141 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:80930,load,load,80930,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,">>. private . Execute a function without arguments several times in parallel. ; Implementation of the Map method.; Parameters. funcFunction to be executed. ; nTimesNumber of times function should be called. . ReturnsA vector with the results of the function calls. Functions that take arguments can be executed (with fixed arguments) by wrapping them in a lambda or with std::bind. ; Definition at line 119 of file TProcessExecutor.hxx. ◆ MapReduce() [1/3]. template<class F , class T , class R , class Cond > . auto ROOT::TProcessExecutor::MapReduce ; (; F ; func, . const std::vector< T > & ; args, . R ; redfunc . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of an immutable vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsImmutable vector, whose elements are passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func into partial results, and these into a final result. Must return the same type as func and should be callable with const std::vector<T> where T is the output of func. ; nChunksNumber of chunks to split the input data for processing. . ReturnsA value result of ""reducing"" the vector returned by the Map operation into a single object. ; Definition at line 344 of file TProcessExecutor.hxx. ◆ MapReduce() [2/3]. template<class F , class T , class R , class Cond > . auto ROOT::TProcessExecutor::MapReduce ; (; F ; func, . std::vector< T > & ; args, . R ; redfunc . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of a vector (Map) and accumulate the results into ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:17093,perform,performs,17093,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['perform'],['performs']
Performance,">Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101463,multi-thread,multi-threaded,1101463,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['multi-thread'],['multi-threaded']
Performance,">Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");. Example of Loop on TEntryList with a TChain. void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *ch = new TChain(""ntuple"");; ch->Add(""hsimple.root"");; ch->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = ch->GetEntries();; Int_t treenum = 0;; ch->SetEntryList(myelist);; for (entry=start;entry < end;entry++) {; entryNumber = treechain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = fTree->LoadTree(entryNumber);; if (localEntry < 0) break;; // then either call branch->GetEntry(localEntry);; // or entryNumber->GetEntry(entryNumber);; // In the later case the LoadTree is then somewhat redudant.; }; }. When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:. Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);. to obtain the entry number within the chain you need to add to it the value; of; treeEntry+ch->GetTreeOffset()[treenum]; such that the loop in the previous example can also be written as:; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum]; ; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }. TSelectors; To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to ; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ; Using a TEntryList as input (TTree::SetEntryList() and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryList.html:7374,Load,LoadTree,7374,root/html534/TEntryList.html,https://root.cern,https://root.cern/root/html534/TEntryList.html,1,['Load'],['LoadTree']
Performance,">Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");. Example of Loop on TEntryList with a TChain. void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *ch = new TChain(""ntuple"");; ch->Add(""hsimple.root"");; ch->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = ch->GetEntries();; Int_t treenum = 0;; ch->SetEntryList(myelist);; for (entry=start;entry < end;entry++) {; entryNumber = treechain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = fTree->LoadTree(entryNumber);; if (localEntry < 0) break;; // then either call branch->GetEntry(localEntry);; // or entryNumber->GetEntry(entryNumber);; // In the later case the LoadTree is then somewhat redudant.; }; }. When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:. Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);. to obtain the entry number within the chain you need to add to it the value; of; treeEntry+ch->GetTreeOffset()[treenum]; such that the loop in the previous example can also be written as:; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }. TSelectors; To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed.; Using a TEntryList as input (TTree::SetEntryList() and TCh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryList.html:7336,Load,LoadTree,7336,root/html602/TEntryList.html,https://root.cern,https://root.cern/root/html602/TEntryList.html,2,['Load'],['LoadTree']
Performance,">Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flatened/linearilized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly support in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:75438,load,load,75438,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['load'],['load']
Performance,">GetDirEntry(dirp))) {; 5792 TString f = f1;; 5793 if (f.EndsWith("".rootmap"")) {; 5794 TString p;; 5795 p = d + ""/"" + f;; 5796 if (!gSystem->AccessPathName(p, kReadPermission)) {; 5797 if (!fRootmapFiles->FindObject(f) && f != "".rootmap"") {; 5798 if (gDebug > 4) {; 5799 Info(""LoadLibraryMap"", "" rootmap file: %s"", p.Data());; 5800 }; 5801 Int_t ret = ReadRootmapFile(p, &uniqueString);; 5802 ; 5803 if (ret == 0); 5804 fRootmapFiles->Add(new TNamed(gSystem->BaseName(f), p.Data()));; 5805 if (ret == -3) {; 5806 // old format; 5807 fMapfile->ReadFile(p, kEnvGlobal);; 5808 fRootmapFiles->Add(new TNamed(f, p));; 5809 }; 5810 }; 5811 // else {; 5812 // fprintf(stderr,""Reject %s because %s is already there\n"",p.Data(),f.Data());; 5813 // fRootmapFiles->FindObject(f)->ls();; 5814 // }; 5815 }; 5816 }; 5817 if (f.BeginsWith(""rootmap"")) {; 5818 TString p;; 5819 p = d + ""/"" + f;; 5820 FileStat_t stat;; 5821 if (gSystem->GetPathInfo(p, stat) == 0 && R_ISREG(stat.fMode)) {; 5822 Warning(""LoadLibraryMap"", ""please rename %s to end with \"".rootmap\"""", p.Data());; 5823 }; 5824 }; 5825 }; 5826 }; 5827 gSystem->FreeDirectory(dirp);; 5828 }; 5829 }; 5830 delete paths;; 5831 if (fMapfile->GetTable() && !fMapfile->GetTable()->GetEntries()) {; 5832 return -1;; 5833 }; 5834 }; 5835 if (rootmapfile && *rootmapfile) {; 5836 Int_t res = ReadRootmapFile(rootmapfile, &uniqueString);; 5837 if (res == 0) {; 5838 //TString p = gSystem->ConcatFileName(gSystem->pwd(), rootmapfile);; 5839 //fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), p.Data()));; 5840 fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));; 5841 }; 5842 else if (res == -3) {; 5843 // old format; 5844 Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);; 5845 fMapfile->ReadFile(rootmapfile, kEnvGlobal);; 5846 fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));; 5847 fMapfile->IgnoreDuplicates(ignore);; 5848 }; 5849 }; 5850 TEnvRec* rec;; 5851 TIter next(fMapfile->GetTable());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:226466,Load,LoadLibraryMap,226466,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,">Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions; 2053//______________________________________________________________________________; 2054 ; 2055////////////////////////////////////////////////////////////////////////////////; 2056/// Minimization function for H1s using a Chisquare method.; 2057 ; 2058void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2059{; 2060 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2061 hFitter->FitChisquare(npar, gin, f, u, flag);; 2062}; 2063 ; 2064////////////////////////////////////////////////////////////////////////////////; 2065/// Minimization function for H1s using a Likelihood method.; 2066/// Basically, it forms the likelihood by determining the Poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:59378,cache,cache,59378,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['cache'],['cache']
Performance,">PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 330 return *this;; 331 }; 332 ; 333 // clang-format off; 334 /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:15237,concurren,concurrently,15237,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['concurren'],['concurrently']
Performance,">Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:580429,load,load,580429,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,">Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(proton, i, new TGeoTranslation(x, y, z));; i++;; }; }; i = 0;; while ( i < nNeutrons) {; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(neutron, i + nProtons, new TGeoTranslation(x, y, z));; i++;; }; }; geom->CloseGeometry();; geom->SetVisLevel(4);; top->Draw(""ogl"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::SetNsegmentsvoid Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/nucleus_8C.html:2677,perform,performedDefinition,2677,doc/master/nucleus_8C.html,https://root.cern,https://root.cern/doc/master/nucleus_8C.html,1,['perform'],['performedDefinition']
Performance,">RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:35908,cache,cache,35908,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,">SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#define I(x, y, z); And also support for MakeSharedLibs() and MakeExe().; (the ... have to be replaced by the actual values and are here only to shorten this comment).; Note that the default behavior is to remove libraries when closing ROOT, ie TSystem::CleanCompiledMacros() is called in the TROOT destructor. The default behavior of .L script.C+ is the opposite one, leaving things after closing, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:45422,Load,Load,45422,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['Load'],['Load']
Performance,">SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }. for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }. // Create Histogram; TH2D *HistStreamFn = new TH2D(""HstreamFn"",; ""#splitline{Histogram with negative and positive contents. Six contours are defined.}{It is plotted with options CONT LIST to retrieve the contours points in TGraphs}"",; nZsamples, z[0], z[nZsamples-1], nPhiSamples, phi[0], phi[nPhiSamples-1]);. // Load Histogram Data; for (Int_t i = 0; i < nZsamples; i++) {; for(Int_t j = 0; j < nPhiSamples; j++){; HistStreamFn->SetBinContent(i,j, HofZ[i]*FofPhi[j]);; }; }. gStyle->SetPalette(1);; gStyle->SetOptStat(0);; gStyle->SetTitleW(0.99);; gStyle->SetTitleH(0.08);. Double_t contours[6];; contours[0] = -0.7;; contours[1] = -0.5;; contours[2] = -0.1;; contours[3] = 0.1;; contours[4] = 0.4;; contours[5] = 0.8;. HistStreamFn->SetContour(6, contours);. // Draw contours as filled regions, and Save points; HistStreamFn->Draw(""CONT Z LIST"");; c->Update(); // Needed to force the plotting and retrieve the contours in TGraphs. // Get Contours; TObjArray *conts = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; TList* contLevel = NULL;; TGraph* curv = NULL;; TGraph* gc = NULL;. Int_t nGraphs = 0;; Int_t TotalConts = 0;. if (conts == NULL){; printf(""*** No Contours Were Extracted!\n"");; TotalConts = 0;; return 0;; } else {; TotalConts = conts->GetSize();; }. printf(""TotalConts = %d\n"", TotalConts);. for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:42075,Load,Load,42075,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,2,['Load'],['Load']
Performance,">Write();; 6949 delete newtree;; 6950 }; 6951 // Make sure things are really written out to disk before attempting any reading.; 6952 info->fOutputDirectory->GetFile()->Flush();; 6953 info->fOutputDirectory->ReadTObject(this,this->GetName());; 6954 }; 6955 }; 6956 if (!li) return 0;; 6957 Long64_t storeAutoSave = fAutoSave;; 6958 // Disable the autosave as the TFileMerge keeps a list of key and deleting the underlying; 6959 // key would invalidate its iteration (or require costly measure to not use the deleted keys).; 6960 // Also since this is part of a merging operation, the output file is not as precious as in; 6961 // the general case since the input file should still be around.; 6962 fAutoSave = 0;; 6963 TIter next(li);; 6964 TTree *tree;; 6965 while ((tree = (TTree*)next())) {; 6966 if (tree==this) continue;; 6967 if (!tree->InheritsFrom(TTree::Class())) {; 6968 Error(""Add"",""Attempt to add object of class: %s to a %s"", tree->ClassName(), ClassName());; 6969 fAutoSave = storeAutoSave;; 6970 return -1;; 6971 }; 6972 ; 6973 CopyEntries(tree, -1, options, true);; 6974 }; 6975 fAutoSave = storeAutoSave;; 6976 return GetEntries();; 6977}; 6978 ; 6979////////////////////////////////////////////////////////////////////////////////; 6980/// Move a cache from a file to the current file in dir.; 6981/// if src is null no operation is done, if dir is null or there is no; 6982/// current file the cache is deleted.; 6983 ; 6984void TTree::MoveReadCache(TFile *src, TDirectory *dir); 6985{; 6986 if (!src) return;; 6987 TFile *dst = (dir && dir != gROOT) ? dir->GetFile() : nullptr;; 6988 if (src == dst) return;; 6989 ; 6990 TTreeCache *pf = GetReadCache(src);; 6991 if (dst) {; 6992 src->SetCacheRead(nullptr,this);; 6993 dst->SetCacheRead(pf, this);; 6994 } else {; 6995 if (pf) {; 6996 pf->WaitFinishPrefetch();; 6997 }; 6998 src->SetCacheRead(nullptr,this);; 6999 delete pf;; 7000 }; 7001}; 7002 ; 7003///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:273290,cache,cache,273290,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,">end(); ++itrMethod) {; 333 Log() << kDEBUG << ""Delete method: "" << (*itrMethod)->GetName() << Endl;; 334 delete (*itrMethod);; 335 }; 336 methods->clear();; 337 delete methods;; 338 }; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342 ; 343void TMVA::Factory::SetVerbose(Bool_t v); 344{; 345 fVerbose = v;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Book a classifier or regression method.; 350 ; 351TMVA::MethodBase *; 352TMVA::Factory::BookMethod(TMVA::DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption); 353{; 354 if (fModelPersistence); 355 gSystem->MakeDirectory(loader->GetName()); // creating directory for DataLoader output; 356 ; 357 TString datasetname = loader->GetName();; 358 ; 359 if (fAnalysisType == Types::kNoAnalysisType) {; 360 if (loader->GetDataSetInfo().GetNClasses() == 2 && loader->GetDataSetInfo().GetClassInfo(""Signal"") != NULL &&; 361 loader->GetDataSetInfo().GetClassInfo(""Background"") != NULL) {; 362 fAnalysisType = Types::kClassification; // default is classification; 363 } else if (loader->GetDataSetInfo().GetNClasses() >= 2) {; 364 fAnalysisType = Types::kMulticlass; // if two classes, but not named ""Signal"" and ""Background""; 365 } else; 366 Log() << kFATAL << ""No analysis type for "" << loader->GetDataSetInfo().GetNClasses() << "" classes and ""; 367 << loader->GetDataSetInfo().GetNTargets() << "" regression targets."" << Endl;; 368 }; 369 ; 370 // booking via name; the names are translated into enums and the; 371 // corresponding overloaded BookMethod is called; 372 ; 373 if (fMethodsMap.find(datasetname) != fMethodsMap.end()) {; 374 if (GetMethod(datasetname, methodTitle) != 0) {; 375 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 376 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 377 }; 378 }; 379 ; 380 Log() << kHEADER << ""Booking m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:14195,load,loader,14195,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,">fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; static doublefgEpsepsilon used in derivative calculation h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. {}. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(const double* x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoParameterDerivative(const double* x, const double* p, unsigned int ipar) const; eva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__WrappedMultiTF1.html:2786,cache,cached,2786,root/html526/ROOT__Math__WrappedMultiTF1.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__WrappedMultiTF1.html,1,['cache'],['cached']
Performance,">getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:46105,Load,Load,46105,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['Load', 'loaded']"
Performance,">handled_requests);; 18700 mg_atomic_dec(&(conn->phys_ctx->active_connections));; 18701#endif; 18702}; 18703 ; 18704 ; 18705#if defined(ALTERNATIVE_QUEUE); 18706 ; 18707static void; 18708produce_socket(struct mg_context *ctx, const struct socket *sp); 18709{; 18710 unsigned int i;; 18711 ; 18712 while (!ctx->stop_flag) {; 18713 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 18714 /* find a free worker slot and signal it */; 18715 if (ctx->client_socks[i].in_use == 2) {; 18716 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18717 if ((ctx->client_socks[i].in_use == 2) && !ctx->stop_flag) {; 18718 ctx->client_socks[i] = *sp;; 18719 ctx->client_socks[i].in_use = 1;; 18720 /* socket has been moved to the consumer */; 18721 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18722 (void)event_signal(ctx->client_wait_events[i]);; 18723 return;; 18724 }; 18725 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18726 }; 18727 }; 18728 /* queue is full */; 18729 mg_sleep(1);; 18730 }; 18731 /* must consume */; 18732 set_blocking_mode(sp->sock);; 18733 closesocket(sp->sock);; 18734}; 18735 ; 18736 ; 18737static int; 18738consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18739{; 18740 DEBUG_TRACE(""%s"", ""going idle"");; 18741 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18742 ctx->client_socks[thread_index].in_use = 2;; 18743 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18744 ; 18745 event_wait(ctx->client_wait_events[thread_index]);; 18746 ; 18747 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18748 *sp = ctx->client_socks[thread_index];; 18749 if (ctx->stop_flag) {; 18750 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18751 if (sp->in_use == 1) {; 18752 /* must consume */; 18753 set_blocking_mode(sp->sock);; 18754 closesocket(sp->sock);; 18755 }; 18756 return 0;; 18757 }; 18758 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18759 if (sp->in_use == 1) {; 18760 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18761 return 1;; 18762 }; 1876",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:556340,queue,queue,556340,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,">handled_requests);; 18701 mg_atomic_dec(&(conn->phys_ctx->active_connections));; 18702#endif; 18703}; 18704 ; 18705 ; 18706#if defined(ALTERNATIVE_QUEUE); 18707 ; 18708static void; 18709produce_socket(struct mg_context *ctx, const struct socket *sp); 18710{; 18711 unsigned int i;; 18712 ; 18713 while (!ctx->stop_flag) {; 18714 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 18715 /* find a free worker slot and signal it */; 18716 if (ctx->client_socks[i].in_use == 2) {; 18717 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18718 if ((ctx->client_socks[i].in_use == 2) && !ctx->stop_flag) {; 18719 ctx->client_socks[i] = *sp;; 18720 ctx->client_socks[i].in_use = 1;; 18721 /* socket has been moved to the consumer */; 18722 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18723 (void)event_signal(ctx->client_wait_events[i]);; 18724 return;; 18725 }; 18726 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18727 }; 18728 }; 18729 /* queue is full */; 18730 mg_sleep(1);; 18731 }; 18732 /* must consume */; 18733 set_blocking_mode(sp->sock);; 18734 closesocket(sp->sock);; 18735}; 18736 ; 18737 ; 18738static int; 18739consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18740{; 18741 DEBUG_TRACE(""%s"", ""going idle"");; 18742 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18743 ctx->client_socks[thread_index].in_use = 2;; 18744 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18745 ; 18746 event_wait(ctx->client_wait_events[thread_index]);; 18747 ; 18748 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18749 *sp = ctx->client_socks[thread_index];; 18750 if (ctx->stop_flag) {; 18751 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18752 if (sp->in_use == 1) {; 18753 /* must consume */; 18754 set_blocking_mode(sp->sock);; 18755 closesocket(sp->sock);; 18756 }; 18757 return 0;; 18758 }; 18759 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18760 if (sp->in_use == 1) {; 18761 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18762 return 1;; 18763 }; 1876",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:556373,queue,queue,556373,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,">request_method, ""HEAD""))) {; 14526 mg_send_http_error(conn,; 14527 405,; 14528 ""%s method not allowed"",; 14529 conn->request_info.request_method);; 14530 return;; 14531 }; 14532 ; 14533 /* 14. directories */; 14534 if (file.stat.is_directory) {; 14535 /* Substitute files have already been handled above. */; 14536 /* Here we can either generate and send a directory listing,; 14537 * or send an ""access denied"" error. */; 14538 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14539 ""yes"")) {; 14540 handle_directory_request(conn, path);; 14541 } else {; 14542 mg_send_http_error(conn,; 14543 403,; 14544 ""%s"",; 14545 ""Error: Directory listing denied"");; 14546 }; 14547 return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const char *path,; 14577 struct mg_file *file); 14578{; 14579#if !defined(NO_CGI); 14580 unsigned char cgi_config_idx, inc, max;; 14581#endif; 14582 ; 14583 if (!conn || !conn->dom_ctx) {; 14584 return;; 14585 }; 14586 ; 14587#if defined(USE_LUA); 14588 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14589 path); 14590 > 0) {; 14591 if (is_in_script_path(conn, path)) {; 14592 /* Lua server page: an SS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:428888,cache,cached,428888,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['cache'],['cached']
Performance,">request_method, ""HEAD""))) {; 14527 mg_send_http_error(conn,; 14528 405,; 14529 ""%s method not allowed"",; 14530 conn->request_info.request_method);; 14531 return;; 14532 }; 14533 ; 14534 /* 14. directories */; 14535 if (file.stat.is_directory) {; 14536 /* Substitute files have already been handled above. */; 14537 /* Here we can either generate and send a directory listing,; 14538 * or send an ""access denied"" error. */; 14539 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14540 ""yes"")) {; 14541 handle_directory_request(conn, path);; 14542 } else {; 14543 mg_send_http_error(conn,; 14544 403,; 14545 ""%s"",; 14546 ""Error: Directory listing denied"");; 14547 }; 14548 return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const char *path,; 14578 struct mg_file *file); 14579{; 14580#if !defined(NO_CGI); 14581 unsigned char cgi_config_idx, inc, max;; 14582#endif; 14583 ; 14584 if (!conn || !conn->dom_ctx) {; 14585 return;; 14586 }; 14587 ; 14588#if defined(USE_LUA); 14589 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14590 path); 14591 > 0) {; 14592 if (is_in_script_path(conn, path)) {; 14593 /* Lua server page: an SS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:428921,cache,cached,428921,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['cache'],['cached']
Performance,"@ kfmodDefinition TFormula.h:144; ROOT::v5::TFormula::kabs@ kabsDefinition TFormula.h:156; ROOT::v5::TFormula::kxgaus@ kxgausDefinition TFormula.h:178; ROOT::v5::TFormula::fLinearPartsTObjArray fLinearPartsDefinition TFormula.h:86; ROOT::v5::TFormula::fNvalInt_t fNvalDefinition TFormula.h:76; ROOT::v5::TFormula::ClearFormulavoid ClearFormula(Option_t *option="""")Resets the objects.Definition TFormula_v5.cxx:2222; ROOT::v5::TFormula::GetParNamevirtual const char * GetParName(Int_t ipar) constReturn name of one parameter.Definition TFormula_v5.cxx:3245; ROOT::v5::TFormula::SetNumbervirtual void SetNumber(Int_t number)Definition TFormula.h:251; ROOT::v5::TFormula::fOperOffsetTOperOffset * fOperOffset[fNOperOptimized] List of operators. (See documentation for changes made at version 7)Definition TFormula.h:94; ROOT::v5::TFormula::DefinedStringvirtual char * DefinedString(Int_t code)Return address of string corresponding to special code.Definition TFormula_v5.cxx:2555; ROOT::v5::TFormula::Optimizevoid Optimize()MI include.Definition TFormula_v5.cxx:3818; ROOT::v5::TFormula::EvalParFastDouble_t EvalParFast(const Double_t *x, const Double_t *params)Evaluate this formula.Definition TFormula_v5.cxx:4189; ROOT::v5::TFormula::SetParametersvirtual void SetParameters(const Double_t *params)Initialize array of all parameters.Definition TFormula_v5.cxx:3397; ROOT::v5::TFormula::fOperInt_t * fOperDefinition TFormula.h:80; ROOT::v5::TFormula::GetNdimvirtual Int_t GetNdim() constDefinition TFormula.h:237; ROOT::v5::TFormula::GetActionShort_t GetAction(Int_t code) constDefinition TFormula.h:104; ROOT::v5::TFormula::SetMaximastatic void SetMaxima(Int_t maxop=1000, Int_t maxpar=1000, Int_t maxconst=1000)static function to set the maximum value of 3 parametersDefinition TFormula_v5.cxx:4527; ROOT::v5::TFormula::GetLinearPartvirtual const TObject * GetLinearPart(Int_t i)Return linear part.Definition TFormula_v5.cxx:3212; ROOT::v5::TFormula::fNOperOptimizedInt_t fNOperOptimizedcache for inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/v5_2TFormula_8h_source.html:22834,Optimiz,Optimizevoid,22834,doc/master/v5_2TFormula_8h_source.html,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html,2,['Optimiz'],"['Optimize', 'Optimizevoid']"
Performance,"A LOADER ; Factory : Booking method: ␛[1mTMVA_LSTM␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIERUNIFORM:ValidationSize=0.2:RandomSeed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=20,Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIERUNIFORM:ValidationSize=0.2:RandomSeed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=20,Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:6232,Optimiz,Optimizer,6232,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,"A methods. We book a Boosted Decision Tree method (BDT); ; **/; ; // Boosted Decision Trees; if (useTMVABDT) {; factory.BookMethod(&loader, TMVA::Types::kBDT, ""BDT"",; ""!V:NTrees=200:MinNodeSize=2.5%:MaxDepth=2:BoostType=AdaBoost:AdaBoostBeta=0.5:""; ""UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20"");; }; /**; ; #### Booking Deep Neural Network; ; Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; options; ; **/; ; if (useTMVADNN) {; ; TString layoutString(; ""Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"");; ; // Training strategies; // one can catenate several training strings with different parameters (e.g. learning rates or regularizations; // parameters) The training string must be concatenates with the `|` delimiter; TString trainingString1(""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""MaxEpochs=10,WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."");; ; TString trainingStrategyString(""TrainingStrategy="");; trainingStrategyString += trainingString1; // + ""|"" + trainingString2 + ....; ; // Build now the full DNN Option string; ; TString dnnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:""; ""WeightInitialization=XAVIER"");; dnnOptions.Append("":"");; dnnOptions.Append(layoutString);; dnnOptions.Append("":"");; dnnOptions.Append(trainingStrategyString);; ; TString dnnMethodName = ""TMVA_DNN_CPU"";; // use GPU if available; #ifdef R__HAS_TMVAGPU; dnnOptions += "":Architecture=GPU"";; dnnMethodName = ""TMVA_DNN_GPU"";; #elif defined(R__HAS_TMVACPU); dnnOptions += "":Architecture=CPU"";; #endif; ; factory.BookMethod(&loader, TMVA::Types::kDL, dnnMethodName, dnnOptions);; }; ; /***; ### Book Convolutional Neural Network in TMVA; ; For building a CNN one needs to define; ; - Input Layout : number of channels (in this case = 1) | image height | image ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:54688,Optimiz,Optimizer,54688,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,"A trapezoid with both x and y dimensions varying along z ;  ►CTTreeA TTree object has a header with a name and a title ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  ►CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CIOPos;  ►CMissCache;  CEntry;  ►CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  CUnzipState;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:213612,perform,performance,213612,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['perform'],['performance']
Performance,"A(). TClass * TPackMgr::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 106 of file TPackMgr.h. ◆ IsEnabled(). Bool_t TPackMgr::IsEnabled ; (; const char * ; pack, . TPackMgr * ; packmgr = nullptr . ). static . Check if the package is enabled; priority is given to packmgr, if defined. ; Returns kTRUE if enabled ; Definition at line 961 of file TPackMgr.cxx. ◆ IsInDir(). Bool_t TPackMgr::IsInDir ; (; const char * ; path). Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ; Definition at line 478 of file TPackMgr.cxx. ◆ IsPackageEnabled(). Bool_t TPackMgr::IsPackageEnabled ; (; const char * ; pack). inline . Definition at line 82 of file TPackMgr.h. ◆ Load() [1/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . const char * ; opts . ). Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ; Definition at line 206 of file TPackMgr.cxx. ◆ Load() [2/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . TList * ; optls = 0 . ). Method to load a package taking an option list Return -1 on error, 0 otherwise. ; Definition at line 220 of file TPackMgr.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). static . Parse one or more paths as possible sources of packages Returns number of paths added; or -1 in case of problems. ; Definition at line 872 of file TPackMgr.cxx. ◆ Remove(). Int_t TPackMgr::Remove ; (; const char * ; p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:21401,Load,Load,21401,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['Load'],['Load']
Performance,"A.html; ; #include ""TMVA/DataLoader.h""; #include ""TMVA/Factory.h""; ; #include ""TFile.h""; #include ""TString.h""; #include ""TTree.h""; ; //; // Helper function to generate 2-D gaussian data points and fill to a ROOT; // TTree.; //; // Arguments:; // nPoints Number of points to generate.; // offset Mean of the generated numbers; // scale Standard deviation of the generated numbers.; // seed Seed for random number generator. Use `seed=0` for random; // seed.; // Returns a TTree ready to be used as input to TMVA.; //; TTree *genTree(Int_t nPoints, Double_t offset, Double_t scale, UInt_t seed = 100); {; TRandom rng(seed);; Double_t x = 0;; Double_t y = 0;; ; TTree *data = new TTree();; data->Branch(""x"", &x, ""x/D"");; data->Branch(""y"", &y, ""y/D"");; ; for (Int_t n = 0; n < nPoints; ++n) {; x = rng.Rndm() * scale;; y = offset + rng.Rndm() * scale;; data->Fill();; }; ; // Important: Disconnects the tree from the memory locations of x and y.; data->ResetBranchAddresses();; return data;; }; ; //; // Minimal setup for performing binary classification in TMVA.; //; // Modify the setup to your liking and run with; // `root -l -b -q TMVAMinimalClassification.C`.; // This will generate an output file ""out.root"" that can be viewed with; // `root -l -e 'TMVA::TMVAGui(""out.root"")'`.; //; void TMVAMinimalClassification(); {; TString outputFilename = ""out.root"";; TFile *outFile = new TFile(outputFilename, ""RECREATE"");; ; // Data generation; TTree *signalTree = genTree(1000, 0.0, 2.0, 100);; TTree *backgroundTree = genTree(1000, 1.0, 2.0, 101);; ; TString factoryOptions = ""AnalysisType=Classification"";; TMVA::Factory factory{"""", outFile, factoryOptions};; ; TMVA::DataLoader dataloader{""dataset""};; ; // Data specification; dataloader.AddVariable(""x"", 'D');; dataloader.AddVariable(""y"", 'D');; ; dataloader.AddSignalTree(signalTree, 1.0);; dataloader.AddBackgroundTree(backgroundTree, 1.0);; ; TCut signalCut = """";; TCut backgroundCut = """";; TString datasetOptions = ""SplitMode=Random"";; dataloader",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMinimalClassification_8C.html:7731,perform,performing,7731,doc/master/TMVAMinimalClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMinimalClassification_8C.html,1,['perform'],['performing']
Performance,A::MethodANNBase; ←. TMVA::MethodMLP. TMVA::MethodBDT. TMVA::MethodBayesClassifier. TMVA::MethodCFMlpANN. TMVA::MethodCommittee. TMVA::MethodCompositeBase; ←. TMVA::MethodBoost. TMVA::MethodCategory. TMVA::MethodCuts. TMVA::MethodDT. TMVA::MethodFDA. TMVA::MethodFisher. TMVA::MethodHMatrix. TMVA::MethodKNN. TMVA::MethodLD. TMVA::MethodLikelihood. TMVA::MethodPDEFoam. TMVA::MethodPDERS. TMVA::MethodRuleFit. TMVA::MethodSVM. TMVA::MethodTMlpANN. TMVA::MethodBayesClassifier. TMVA::MethodBoost. TMVA::MethodCFMlpANN. TMVA::MethodCategory. TMVA::MethodCommittee. TMVA::MethodCompositeBase←. TMVA::MethodBoost. TMVA::MethodCategory. TMVA::MethodCuts. TMVA::MethodDT. TMVA::MethodFDA. TMVA::MethodFisher. TMVA::MethodHMatrix. TMVA::MethodKNN. TMVA::MethodLD. TMVA::MethodLikelihood. TMVA::MethodMLP. TMVA::MethodPDEFoam. TMVA::MethodPDERS. TMVA::MethodRuleFit. TMVA::MethodSVM. TMVA::MethodTMlpANN. TMVA::MinuitFitter. TMVA::MinuitWrapper. TMVA::MisClassificationError. TMVA::MsgLogger. TMVA::OptimizeConfigParameters. TMVA::PDEFoam. TMVA::PDEFoamCell. TMVA::PDEFoamDistr. TMVA::PDEFoamVect. TMVA::PDF. TMVA::Reader. TMVA::RootFinder. TMVA::SdivSqrtSplusB. TMVA::SimulatedAnnealingFitter. TMVA::TActivationIdentity. TMVA::TActivationRadial. TMVA::TActivationSigmoid. TMVA::TActivationTanh. TMVA::TNeuron. TMVA::TNeuronInputAbs. TMVA::TNeuronInputSqSum. TMVA::TNeuronInputSum. TMVA::TSpline1. TMVA::TSpline2. TMVA::TSynapse. TMVA::Timer. TMVA::VariableDecorrTransform. TMVA::VariableGaussTransform. TMVA::VariableIdentityTransform. TMVA::VariableNormalizeTransform. TMVA::VariablePCATransform. TMVA::VariableTransformBase←. TMVA::VariableDecorrTransform. TMVA::VariableGaussTransform. TMVA::VariableIdentityTransform. TMVA::VariableNormalizeTransform. TMVA::VariablePCATransform. TMacro←. TEveMacro. TMap. TMapFile. TMapIter. TMarker. TMarker3DBox. TMaterial←. TMixture. TMatrixT<double>. TMatrixT<float>. TMatrixTBase<double>←. TMatrixT<double>. TMatrixTSparse<double>. TMatrixTSym<double>. TMatrixTBas,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassHierarchy.html:71374,Optimiz,OptimizeConfigParameters,71374,root/html528/ClassHierarchy.html,https://root.cern,https://root.cern/root/html528/ClassHierarchy.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,A::MethodANNBase; ←. TMVA::MethodMLP. TMVA::MethodBDT. TMVA::MethodBayesClassifier. TMVA::MethodCFMlpANN. TMVA::MethodCommittee. TMVA::MethodCompositeBase; ←. TMVA::MethodBoost. TMVA::MethodCategory. TMVA::MethodCuts. TMVA::MethodDT. TMVA::MethodFDA. TMVA::MethodFisher. TMVA::MethodHMatrix. TMVA::MethodKNN. TMVA::MethodLD. TMVA::MethodLikelihood. TMVA::MethodPDEFoam. TMVA::MethodPDERS. TMVA::MethodRuleFit. TMVA::MethodSVM. TMVA::MethodTMlpANN. TMVA::MethodBayesClassifier. TMVA::MethodBoost. TMVA::MethodCFMlpANN. TMVA::MethodCategory. TMVA::MethodCommittee. TMVA::MethodCompositeBase←. TMVA::MethodBoost. TMVA::MethodCategory. TMVA::MethodCuts. TMVA::MethodDT. TMVA::MethodFDA. TMVA::MethodFisher. TMVA::MethodHMatrix. TMVA::MethodKNN. TMVA::MethodLD. TMVA::MethodLikelihood. TMVA::MethodMLP. TMVA::MethodPDEFoam. TMVA::MethodPDERS. TMVA::MethodRuleFit. TMVA::MethodSVM. TMVA::MethodTMlpANN. TMVA::MinuitFitter. TMVA::MinuitWrapper. TMVA::MisClassificationError. TMVA::MsgLogger. TMVA::OptimizeConfigParameters. TMVA::PDEFoam←. TMVA::PDEFoamDiscriminant; ←. TMVA::PDEFoamDecisionTree. TMVA::PDEFoamEvent; ←. TMVA::PDEFoamMultiTarget. TMVA::PDEFoamTarget. TMVA::PDEFoamCell. TMVA::PDEFoamDecisionTree. TMVA::PDEFoamDecisionTreeDensity. TMVA::PDEFoamDensityBase←. TMVA::PDEFoamDecisionTreeDensity. TMVA::PDEFoamDiscriminantDensity. TMVA::PDEFoamEventDensity. TMVA::PDEFoamTargetDensity. TMVA::PDEFoamDiscriminant←. TMVA::PDEFoamDecisionTree. TMVA::PDEFoamDiscriminantDensity. TMVA::PDEFoamEvent←. TMVA::PDEFoamMultiTarget. TMVA::PDEFoamEventDensity. TMVA::PDEFoamKernelBase←. TMVA::PDEFoamKernelGauss. TMVA::PDEFoamKernelLinN. TMVA::PDEFoamKernelTrivial. TMVA::PDEFoamKernelGauss. TMVA::PDEFoamKernelLinN. TMVA::PDEFoamKernelTrivial. TMVA::PDEFoamMultiTarget. TMVA::PDEFoamTarget. TMVA::PDEFoamTargetDensity. TMVA::PDEFoamVect. TMVA::PDF. TMVA::Reader. TMVA::RootFinder. TMVA::SdivSqrtSplusB. TMVA::SimulatedAnnealingFitter. TMVA::TActivationIdentity. TMVA::TActivationRadial. TMVA::TActivationSig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassHierarchy.html:72866,Optimiz,OptimizeConfigParameters,72866,root/html530/ClassHierarchy.html,https://root.cern,https://root.cern/root/html530/ClassHierarchy.html,2,['Optimiz'],['OptimizeConfigParameters']
Performance,"A::MethodBase::GetTrainingHistoryvirtual const std::vector< Float_t > & GetTrainingHistory(const char *)Definition MethodBase.h:233; TMVA::MethodBase::fTmpEventconst Event * fTmpEventDefinition MethodBase.h:445; TMVA::MethodBase::fExitFromTrainingbool fExitFromTrainingDefinition MethodBase.h:449; TMVA::MethodBase::SetNormalisedvoid SetNormalised(Bool_t norm)Definition MethodBase.h:497; TMVA::MethodBase::SetTestvarNamevoid SetTestvarName(const TString &v="""")Definition MethodBase.h:341; TMVA::MethodBase::ReadVariablesFromXMLvoid ReadVariablesFromXML(void *varnode)read variable info from XMLDefinition MethodBase.cxx:1837; TMVA::MethodBase::fConstructedFromWeightFileBool_t fConstructedFromWeightFileDefinition MethodBase.h:620; TMVA::MethodBase::fHelpBool_t fHelphelp flagDefinition MethodBase.h:679; TMVA::MethodBase::GetNvarUInt_t GetNvar() constDefinition MethodBase.h:344; TMVA::MethodBase::OptimizeTuningParametersvirtual std::map< TString, Double_t > OptimizeTuningParameters(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")call the Optimizer with the set of parameters and ranges that are meant to be tuned.Definition MethodBase.cxx:623; TMVA::MethodBase::SetTrainTimevoid SetTrainTime(Double_t trainTime)Definition MethodBase.h:161; TMVA::MethodBase::GetXmaxDouble_t GetXmax(Int_t ivar) constDefinition MethodBase.h:357; TMVA::MethodBase::GetMulticlassTrainingEfficiencyvirtual std::vector< Float_t > GetMulticlassTrainingEfficiency(std::vector< std::vector< Float_t > > &purity)Definition MethodBase.cxx:2715; TMVA::MethodBase::fDataSetInfoDataSetInfo & fDataSetInfoDefinition MethodBase.h:607; TMVA::MethodBase::fHasMVAPdfsBool_t fHasMVAPdfsMVA Pdfs are created for this classifier.Definition MethodBase.h:680; TMVA::MethodBase::WriteStateToStreamvoid WriteStateToStream(std::ostream &tf) constgeneral method used in writing the header of the weight files where the used variables,...Definition MethodBase.cxx:1267; TMVA::MethodBase::GetRarityvirtual Double_t GetRarity(Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:58280,Optimiz,OptimizeTuningParametersvirtual,58280,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,4,"['Optimiz', 'tune']","['OptimizeTuningParameters', 'OptimizeTuningParametersvirtual', 'Optimizer', 'tuned']"
Performance,"A::MethodBase::MethodBaseDir() const; TMVA::MethodLikelihoodMethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodLikelihoodMethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromStream(TFile& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLikelihood.html:11407,Optimiz,OptimizeTuningParameters,11407,root/html534/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLikelihood.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"A::MethodBase::MethodBaseDir() const; TMVA::MethodTMlpANNMethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodTMlpANNMethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodTMlpANN.html:9423,Optimiz,OptimizeTuningParameters,9423,root/html534/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodTMlpANN.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:13986,tune,tuneParameters,13986,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,1,['tune'],['tuneParameters']
Performance,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:12355,tune,tuneParameters,12355,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,1,['tune'],['tuneParameters']
Performance,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:12372,tune,tuneParameters,12372,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,1,['tune'],['tuneParameters']
Performance,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodRuleFit.html:11685,tune,tuneParameters,11685,root/html528/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html,1,['tune'],['tuneParameters']
Performance,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html:10943,tune,tuneParameters,10943,root/html528/TMVA__MethodBayesClassifier.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html,11,['tune'],['tuneParameters']
Performance,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); voidTrainMonoTargetRegression(); voidTrainMultiTargetRegression(); voidTrainSeparatedClassification(); voidTrainUnifiedClassification(); TMVA::EKernelUIntToKernel(UInt_t iker); TMVA::ETargetSelec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDEFoam.html:10837,tune,tuneParameters,10837,root/html528/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html,1,['tune'],['tuneParameters']
Performance,"A::MethodPDERSMethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodPDERSMethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromStream(TFile& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDERS.html:10422,Optimiz,OptimizeTuningParameters,10422,root/html530/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDERS.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"A::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__RegressionVariance.html:1717,optimiz,optimized,1717,root/html604/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html604/TMVA__RegressionVariance.html,1,['optimiz'],['optimized']
Performance,"A::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__RegressionVariance.html:1709,optimiz,optimized,1709,root/html602/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html602/TMVA__RegressionVariance.html,1,['optimiz'],['optimized']
Performance,"ACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8py.html:4890,cache,cache,4890,doc/master/rf705__linearmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html,2,['cache'],['cache']
Performance,"ALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidregisterCache(RooAbsCache& cache); voidremoveServer(RooAbsArg& server, Bool_t force = kFALSE); voidreplaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*serverIterator() const; virtual voidserverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidsetACleanADirty(Bool_t flag); voidsetAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:12198,cache,cache,12198,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,1,['cache'],['cache']
Performance,"ALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidregisterCache(RooAbsCache& cache); voidremoveServer(RooAbsArg& server, Bool_t force = kFALSE); voidreplaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*serverIterator() const; virtual voidserverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidsetACleanADirty(Bool_t flag); voidsetAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:12085,cache,cache,12085,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['cache'],['cache']
Performance,"ALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:30299,cache,cache,30299,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,2,['cache'],['cache']
Performance,"ALSE;; 935 MakeZombie();; 936 gDirectory = gROOT;; 937}; 938 ; 939////////////////////////////////////////////////////////////////////////////////; 940/// Close a file.; 941///; 942/// \param[in] option If option == ""R"", all TProcessIDs referenced by this file are deleted.; 943///; 944/// Calling TFile::Close(""R"") might be necessary in case one reads a long list; 945/// of files having TRef, writing some of the referenced objects or TRef; 946/// to a new file. If the TRef or referenced objects of the file being closed; 947/// will not be referenced again, it is possible to minimize the size; 948/// of the TProcessID data structures in memory by forcing a delete of; 949/// the unused TProcessID.; 950 ; 951void TFile::Close(Option_t *option); 952{; 953 TString opt = option;; 954 ; 955 opt.ToLower();; 956 ; 957 if (!IsOpen()) return;; 958 ; 959 if (fIsArchive || !fIsRootFile) {; 960 FlushWriteCache();; 961 SysClose(fD);; 962 fD = -1;; 963 ; 964 if (gMonitoringWriter); 965 gMonitoringWriter->SendFileCloseEvent(this);; 966 ; 967 return;; 968 }; 969 ; 970 if (IsWritable()) {; 971 WriteStreamerInfo();; 972 }; 973 ; 974 // Finish any concurrent I/O operations before we close the file handles.; 975 if (fCacheRead) fCacheRead->Close();; 976 {; 977 TIter iter(fCacheReadMap);; 978 TObject *key = nullptr;; 979 while ((key = iter()) != nullptr) {; 980 TFileCacheRead *cache = dynamic_cast<TFileCacheRead *>(fCacheReadMap->GetValue(key));; 981 cache->Close();; 982 }; 983 }; 984 ; 985 // Delete all supported directories structures from memory; 986 // If gDirectory points to this object or any of the nested; 987 // TDirectoryFile, TDirectoryFile::Close will induce the proper cd.; 988 fMustFlush = kFALSE; // Make sure there is only one Flush.; 989 TDirectoryFile::Close(option);; 990 ; 991 if (IsWritable()) {; 992 TFree *f1 = (TFree*)fFree->First();; 993 if (f1) {; 994 WriteFree(); //*-*- Write free segments linked list; 995 WriteHeader(); //*-*- Now write file header ; this forces a Flu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:35059,concurren,concurrent,35059,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"ANH,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=20,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=G:WeightInitialization=XAVIER:InputLayout=1|1|7:BatchLayout=1|128|7:Layout=DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=20,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""G"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|7"" [The Layout of the input]; : BatchLayout: ""1|128|7"" [The Layout of the batch]; : Layout: ""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:11541,perform,performed,11541,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['perform'],['performed']
Performance,"ANH,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=30,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=G:WeightInitialization=XAVIER:InputLayout=1|1|7:BatchLayout=1|128|7:Layout=DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=30,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""G"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|7"" [The Layout of the input]; : BatchLayout: ""1|128|7"" [The Layout of the batch]; : Layout: ""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:11528,perform,performed,11528,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performed']
Performance,"APTIVESINGULAR; ROOT::Math:::GSLIntegrator. 13.8.2.1 ROOT::Math:::GaussIntegrator; It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian quadrature approximations. It is derived from the DGAUSS routine of the CERNLIB by S. Kolbig. This class Here is an example of using directly the GaussIntegrator class; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; 13.8.2.2 ROOT::Math::GaussLegendreIntegrator; This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration. We can use the example above, but replacing the creation of a ROOT::Math::GaussIntegrator object with ROOT::Math::GaussLegendreIntegrator.; 13.8.2.3 ROOT::Math::GSLIntegrator; This is a wrapper for the QUADPACK integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:705560,perform,performing,705560,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performing']
Performance,"AT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id. ;  ; TGeoMaterial * Mixture (const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid);  Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id. ;  ; void ModifiedPad () const;  Send ""Modified"" signal to painter. ;  ; void Node (const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Double_t *upar, Int_t npar=0);  Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called <mother> (gspos). ;  ; void Node (const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0);  Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called <mother> (gspos). ;  ; void OptimizeVoxels (const char *filename=""tgeovox.C"");  Optimize voxelization type for all volumes. Save best choice in a macro. ;  ; void PopDummy (Int_t ipop=9999);  ; Bool_t PopPath ();  ; Bool_t PopPath (Int_t index);  ; Bool_t PopPoint ();  ; Bool_t PopPoint (Int_t index);  ; void PrintOverlaps () const;  Prints the current list of overlaps. ;  ; Int_t PushPath (Int_t startlevel=0);  ; Int_t PushPoint (Int_t startlevel=0);  ; void RandomPoints (const TGeoVolume *vol, Int_t npoints=10000, Option_t *option="""");  Draw random points in the bounding box of a volume. ;  ; void RandomRays (Int_t nrays=1000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Randomly shoot nrays and plot intersections with surfaces for current top node. ;  ; void RefreshPhysicalNodes (Bool_t lock=kTRUE);  Refresh physical nodes to reflect the actual geometry paths after alignment was applied. ;  ; void RegisterMatrix (const TGeoMatrix *matrix);  Register a matri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:43753,Optimiz,OptimizeVoxels,43753,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['Optimiz'],['OptimizeVoxels']
Performance,ATAROOTDIR/aclocal). CMAKE_INSTALL_ELISPDIR; PATH; Install destination for lisp files (DATAROOTDIR/emacs/site-lisp). CMAKE_INSTALL_CMAKEDIR; PATH; Install destination for cmake modules (DATAROOTDIR/cmake). Additional Variables; A number of additional variables to control the way ROOT is built. Variable; Type; Explanation. LLVM_BUILD_TYPE; STRING; Build type for the bundled LLVM. It is used to set the CMAKE_BUILD_TYPE for the /interpreter/ subdirectory. External Libraries; ROOT requires a number of external libraries that the CMake system needs to locate. The list of externals depends on the build options that have been enabled. CMake will look for these third party products at a number of standard places in your system but the user can influence the search by setting some environment variables before invoking the CMake command or by setting package specific CMake variables to their exact location.; The actual cached values used by CMake for the exact location of libraries and include files of the used external libraries can be inspected and modified using the ccmake utility. Package Name; Variable; Type; Description. AfterImage; AFTERIMAGE_CONFIG_EXECUTABLE; PATH; Full path to afterimage-config program. Alien; ALIEN_DIR; PATH; Directory where Alien is installed (-DALIEN_DIR=$ALIEN_DIR/api). Bonjour; BONJOUR_INCLUDE_DIR; PATH; Directory where to find dns_sd.h. AVAHI_INCLUDE_DIR; PATH; Directory where avahi-client/client.h (Linux). AVAHI_client_LIBRARY; PATH; Full path to libavahi-client.so library. CASTOR; CASTOR_DIR; PATH; Environment variable to the Castor installation. CASTOR_INCLUDE_DIR; PATH; Path to rfio_api.h file. CASTOR_shift_LIBRARY; PATH; Full path to shift library. CFITSIO; CFITSIO; PATH; Installation of CFITSIO. CFITSIO_INCLUDE_DIR; PATH; Directory where to find fitsio.h. CFITSIO_LIBRARIES; PATH; Full path to cfitsio library. FFTW; FFTW_DIR; PATH; Installation of FFTW. FFTW_INCLUDE_DIR; PATH; Directory where to find fftw3.h. FFTW_LIBRARY; PATH; Full path ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:17692,cache,cached,17692,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cached']
Performance,"AbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsTestStatistic.html:23502,cache,cache,23502,root/html530/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"AbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::RooBarlowBeestonLL&operator=(const RooStats::HistFactory::RooBarlowBeestonLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html:19541,optimiz,optimizeCacheMode,19541,root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBinningCategory.html:17354,optimiz,optimizeDirtyHook,17354,root/html530/RooBinningCategory.html,https://root.cern,https://root.cern/root/html530/RooBinningCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"AbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; Double_tfErrorTol; Bool_tfForceSum; Bool_tfHasIssuedConvWarning; Bool_tfHasIssuedSumWarning; Int_tfMaxIters; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxylambda; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNonCentralChiSquare.html:40815,cache,cache,40815,root/html528/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html528/RooNonCentralChiSquare.html,4,['cache'],['cache']
Performance,"AbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:15515,cache,cache,15515,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSecondMoment.html:33401,cache,cache,33401,root/html534/RooSecondMoment.html,https://root.cern,https://root.cern/root/html534/RooSecondMoment.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:33289,cache,cache,33289,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,2,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:33018,cache,cache,33018,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:34059,cache,cache,34059,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TMatrixD_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DMomentMorphFunction.html:34523,cache,cache,34523,root/html534/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo2DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:33386,cache,cache,33386,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRecursiveFraction.html:33214,cache,cache,33214,root/html534/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html534/RooRecursiveFraction.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRecursiveFraction.html:33393,cache,cache,33393,root/html534/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html534/RooRecursiveFraction.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html:34079,cache,cache,34079,root/html534/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDerivative.html:33329,cache,cache,33329,root/html534/RooDerivative.html,https://root.cern,https://root.cern/root/html534/RooDerivative.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not pe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:39127,cache,cache,39127,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:42978,cache,cache,42978,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:41967,cache,cache,41967,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooListProxy_gamma; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistConstraint.html:39731,cache,cache,39731,root/html534/RooHistConstraint.html,https://root.cern,https://root.cern/root/html534/RooHistConstraint.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTFnPdfBinding.html:39675,cache,cache,39675,root/html534/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenericPdf.html:40613,cache,cache,40613,root/html534/RooGenericPdf.html,https://root.cern,https://root.cern/root/html534/RooGenericPdf.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxyRooSimultaneous::_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:41674,cache,cache,41674,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimultaneous.html:40807,cache,cache,40807,root/html534/RooSimultaneous.html,https://root.cern,https://root.cern/root/html534/RooSimultaneous.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExtendedTerm.html:39808,cache,cache,39808,root/html534/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html534/RooExtendedTerm.html,2,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:40783,cache,cache,40783,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,40,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTruthModel.html:41458,cache,cache,41458,root/html534/RooTruthModel.html,https://root.cern,https://root.cern/root/html534/RooTruthModel.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:42072,cache,cache,42072,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:42823,cache,cache,42823,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['cache'],['cache']
Performance,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:40340,cache,cache,40340,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"AbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:43762,cache,cache,43762,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,2,['cache'],['cache']
Performance,AbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:44937,cache,cache,44937,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"AbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; RooRealProxy_xfX*F ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMoment.html:33458,cache,cache,33458,root/html532/RooMoment.html,https://root.cern,https://root.cern/root/html532/RooMoment.html,1,['cache'],['cache']
Performance,"AbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNorm! Assume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHistFunc(); Default constructor. RooHistFunc(const char* na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:35441,cache,cache,35441,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['cache'],['cache']
Performance,"AbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooFit::BidirMMapPipe*_pipe! connection to child; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; Bool_t_retrieveDispatched!; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealMPFE*_updateMaster! Update master; Double_tRooAbsReal::_valueCache for current value of object; vector<Bool_t>_valueChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:36212,cache,cache,36212,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,2,['cache'],['cache']
Performance,"AbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,bool>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3PdfBinding_double_double_double_bool_.html:40420,cache,cache,40420,root/html532/RooCFunction3PdfBinding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3PdfBinding_double_double_double_bool_.html,2,['cache'],['cache']
Performance,"AbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:45066,cache,cache,45066,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,2,['cache'],['cache']
Performance,"AbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:47459,cache,cache,47459,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"AbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:2947,cache,cacheUniqueSuffix,2947,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,['cache'],['cacheUniqueSuffix']
Performance,"AbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:2683,cache,cacheUniqueSuffix,2683,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"AbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:1885,cache,cacheUniqueSuffix,1885,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,4,['cache'],['cacheUniqueSuffix']
Performance,"AbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:2086,cache,cacheUniqueSuffix,2086,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,4,['cache'],['cacheUniqueSuffix']
Performance,"AbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:1922,cache,cacheUniqueSuffix,1922,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['cache'],['cacheUniqueSuffix']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAddition&operator=(const RooAddition&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:19437,optimiz,optimizeCacheMode,19437,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,double,double,bool>&operator=(const RooCFunction3Binding<double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_bool_.html:19838,optimiz,optimizeCacheMode,19838,root/html602/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_bool_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConstVar&operator=(const RooConstVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstVar.html:19214,optimiz,optimizeCacheMode,19214,root/html602/RooConstVar.html,https://root.cern,https://root.cern/root/html602/RooConstVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooErrorVar&operator=(const RooErrorVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:22980,optimiz,optimizeCacheMode,22980,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistFunc&operator=(const RooHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:19334,optimiz,optimizeCacheMode,19334,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLegendre&operator=(const RooLegendre&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:19130,optimiz,optimizeCacheMode,19130,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRealMPFE&operator=(const RooRealMPFE&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:20110,optimiz,optimizeCacheMode,20110,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['optimiz'],['optimizeCacheMode']
Performance,"AbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetIntegratorConfig(); voidsetIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:22344,cache,cache,22344,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['cache'],['cache']
Performance,AbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:38964,cache,cache,38964,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,3,['cache'],['cache']
Performance,"AbsCategory, RooAbsReal, and RooStringVar. ◆ operMode(). OperMode RooAbsArg::operMode ; (; ); const. inline . Query the operation mode of this node. ; Definition at line 456 of file RooAbsArg.h. ◆ operModeHook(). virtual void RooAbsArg::operModeHook ; (; ). inlineprotectedvirtual . Reimplemented in RooCachedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:78527,optimiz,optimizeCacheMode,78527,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizeCacheMode']
Performance,"AbsCategory::_typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char *label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* /*rangeName*/); Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t printError = kTRUE). I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:22214,cache,cached,22214,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,1,['cache'],['cached']
Performance,"AbsCategory::_typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t printError = kTR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:22335,cache,cached,22335,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,2,['cache'],['cached']
Performance,"AbsCategory::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:18490,optimiz,optimizeDirtyHook,18490,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"AbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBinningCategory.html:10320,optimiz,optimizeCacheMode,10320,root/html526/RooBinningCategory.html,https://root.cern,https://root.cern/root/html526/RooBinningCategory.html,10,['optimiz'],['optimizeCacheMode']
Performance,"AbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTruthModel.html:40311,cache,cache,40311,root/html526/RooTruthModel.html,https://root.cern,https://root.cern/root/html526/RooTruthModel.html,2,['cache'],['cache']
Performance,"AbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalphaInterpolation parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdf1First input shape; RooRealProxypdf2Second input shape; RooRealProxyxObservable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:44182,cache,cache,44182,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,2,['cache'],['cache']
Performance,"AbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1PdfBinding_double_int_.html:44827,cache,cache,44827,root/html602/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1PdfBinding_double_int_.html,2,['cache'],['cache']
Performance,"AbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:29929,cache,cache,29929,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,4,['cache'],['cache']
Performance,"AbsReal **gofArray, Int_t nVal) const override;  Method to combined test statistic results calculated into partitions into the global result. ;  ; RooAbsData & data ();  ; const RooAbsData & data () const;  ; RooAbsReal & function ();  ; const RooAbsReal & function () const;  ; bool isDerived () const override;  Does value or shape of this arg depend on any other arg? ;  ; bool isSealed () const;  ; void seal (const char *notice="""");  ; const char * sealNotice () const;  ;  Public Member Functions inherited from RooAbsTestStatistic;  RooAbsTestStatistic (const char *name, const char *title, RooAbsReal &real, RooAbsData &data, const RooArgSet &projDeps, Configuration const &cfg);  Create a test statistic from the given function and the data. ;  ;  RooAbsTestStatistic (const RooAbsTestStatistic &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsTestStatistic () override;  Destructor. ;  ; void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true) override;  Forward constant term optimization management calls to component test statistics. ;  ; void enableOffsetting (bool flag) override;  ; virtual double globalNormalization () const;  ; bool isOffsetting () const override;  ; double offset () const override;  ; virtual double offsetCarry () const;  ; GOFOpMode operMode () const;  ; bool setData (RooAbsData &data, bool cloneData=true) override;  Change dataset that is used to given one. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:6452,optimiz,optimization,6452,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['optimiz'],['optimization']
Performance,"AbsReal binding to external C functions; RooCFunction3PdfBinding<double,unsigned int,double,double> RooAbsReal binding to external C functions; RooCFunction3PdfBinding<double,unsigned int,double,unsigned int> RooAbsReal binding to external C functions; RooCFunction3PdfBinding<double,unsigned int,unsigned int,double> RooAbsReal binding to external C functions; RooCFunction3Ref<double,double,double,bool> Persistable reference to C function pointer; RooCFunction3Ref<double,double,double,double> Persistable reference to C function pointer; RooCFunction3Ref<double,double,int,int> Persistable reference to C function pointer; RooCFunction3Ref<double,unsigned int,double,double> Persistable reference to C function pointer; RooCFunction3Ref<double,unsigned int,double,unsigned int> Persistable reference to C function pointer; RooCFunction3Ref<double,unsigned int,unsigned int,double> Persistable reference to C function pointer; RooCFunction4Binding<double,double,double,double,bool> RooAbsReal binding to external C functions; RooCFunction4Binding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4Binding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,bool> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4Ref<double,double,double,double,bool> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,double> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,int> Persistable reference to C function pointer; RooCacheManager<RooAbsCacheElement> Cache Manager class generic objects; RooCacheManager<vector<double,allocator<double> > > Cache Manager class generic objects; RooCachedPdf P.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:30618,Cache,Cache,30618,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,4,['Cache'],['Cache']
Performance,AbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooAbsReal*_funcInt! Function integral; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_t_integrateIs integration over the bin volume requested; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:40177,cache,cache,40177,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,AbsReal.h. ◆ _hideOffset. bool RooAbsReal::_hideOffset = true. staticprotected . Offset hiding flag. ; Definition at line 556 of file RooAbsReal.h. ◆ _label. TString RooAbsReal::_label. protected . Plot label for objects value. ; Definition at line 545 of file RooAbsReal.h. ◆ _lastNormSetId. RooFit::UniqueId<RooArgSet>::Value_t RooAbsReal::_lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval. mutableprotected . Component selection flag for RooAbsPdf::plotCompOn. ; ! ; Definition at line 550 of file RooAbsReal.h. ◆ _plotBins. Int_t RooAbsReal::_plotBins = 100. protected . Number of plot bins. ; Definition at line 542 of file RooAbsReal.h. ◆ _plotMax. double RooAbsReal::_plotMax = 0.0. protected . Maximum of plot range. ; Definition at line 541 of file RooAbsReal.h. ◆ _plotMin. double RooAbsReal::_plotMin = 0.0. protected . Minimum of plot range. ; Definition at line 540 of file RooAbsReal.h. ◆ _selectComp. bool RooAbsReal::_selectComp = true. protected . A buffer for reading values from trees. ; Definition at line 549 of file RooAbsReal.h. ◆ _specIntegratorConfig. std::unique_ptr<RooNumIntConfig> RooAbsReal::_specIntegratorConfig. protected . Definition at line 547 of file RooAbsReal.h. ◆ _treeReadBuffer. std::unique_ptr<TreeReadBuffer> RooAbsReal::_treeReadBuffer. protected . Definition at line 548 of file RooAbsReal.h. ◆ _unit. TString RooAbsReal::_unit. protected . Unit for objects value. ; Definition at line 544 of file RooAbsReal.h. ◆ _value. double RooAbsReal::_value = 0.0. mutableprotected . Cache for current value of object. ; Definition at line 543 of file RooAbsReal.h. Libraries for RooAbsReal:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAbsReal.h; roofit/roofitcore/src/RooAbsReal.cxx; /home/sftnight/build/workspace/root-makedoc-v632/rootspi/rdoc/v632_TMP/pyzdoc/_roofit.pyzdoc. RooAbsReal. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:17 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:156794,Cache,Cache,156794,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['Cache'],['Cache']
Performance,"AbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extended; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_first!; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:34907,cache,cache,34907,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['cache'],['cache']
Performance,"AbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSpHarmonic.html:33592,cache,cache,33592,root/html532/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html532/RooSpHarmonic.html,2,['cache'],['cache']
Performance,"AbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealIntegral.html:34095,cache,cache,34095,root/html528/RooRealIntegral.html,https://root.cern,https://root.cern/root/html528/RooRealIntegral.html,2,['cache'],['cache']
Performance,"AbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html:36667,cache,cache,36667,root/html602/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html,4,['cache'],['cache']
Performance,"AbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LinInterpVar(); Default constructor. LinInterpVar(const char* name, const char* title, const RooArgList& _paramL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__LinInterpVar.html:34829,cache,cache,34829,root/html534/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__LinInterpVar.html,2,['cache'],['cache']
Performance,"AbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:3025,Cache,CacheModeRooAbsArg,3025,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"AbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:2819,Cache,CacheModeRooAbsArg,2819,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"Access the parameter values. ;  ; virtual void SetParameters (const double *p)=0;  Set the parameter values. ;  . Private Member Functions; double DoEval (double x) const override;  Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values. ;  ; virtual double DoEvalPar (double x, const double *p) const =0;  Implementation of the evaluation function using the x value and the parameters. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionOneDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef IBaseFunctionOneDim ROOT::Math::IParametricFunctionOneDim::BaseFunc. Definition at line 166 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). double ROOT::Math::IParametricFunctionOneDim::DoEval ; (; double ; x); const. inlineoverrideprivatevirtual . Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values. ; Implements ROOT::Math::IBaseFunctionOneDim.; Reimplemented in ROOT::Math::WrappedTF1, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile.; Definition at line 203 of file IParamFunction.h. ◆ DoEvalPar(). virtual double ROOT::Math::IParametricFunctionOneDim::DoEvalPar ; (; double ; x, . const double * ; p . ); const. privatepure virtual . Implementation of the evaluation function using the x value and the parameters. ; Must be implemented by derived classes ; Implemented in ROOT::Math::WrappedTF1, ROOT::Math::Polynomial, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile. ◆ operator()() [1/2]. double ROOT::Math::IParametricFunctionOneDim::operator() ; (; const double * ; x, . const double * ; p . ); const. inline . multidim-like interface ; Definition at line 187 of file IParamFunction.h. ◆ operator()() [2/2]. double ROOT::Math::IP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html:2906,cache,cached,2906,doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance,"Accessing the Python interpreter from C++.Definition TPython.h:44; TPython::ExecScriptstatic void ExecScript(const char *name, int argc=0, const char **argv=nullptr)Execute a python stand-alone script, with argv CLI arguments.Definition TPython.cxx:381; TPython::Importstatic Bool_t Import(const char *name)Import the named python module and create Cling equivalents for its classes and methods.Definition TPython.cxx:237; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TPython::Execstatic Bool_t Exec(const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"")Executes a Python command within the current Python environment.Definition TPython.cxx:425; TPython::Evalstatic const TPyReturn Eval(const char *expr) R__DEPRECATED(6Evaluate a python expression (e.g.Definition TPython.cxx:465; TPython::Initializestatic Bool_t Initialize()Initialization method: setup the python interpreter and load the ROOT module.Definition TPython.cxx:137; bool; CPyCppyy::Instance_CheckExactCPYCPPYY_EXTERN bool Instance_CheckExact(PyObject *pyobject)Definition API.cxx:177; CPyCppyy::Overload_CheckCPYCPPYY_EXTERN bool Overload_Check(PyObject *pyobject)Definition API.cxx:236; CPyCppyy::Overload_CheckExactCPYCPPYY_EXTERN bool Overload_CheckExact(PyObject *pyobject)Definition API.cxx:247; CPyCppyy::ImportCPYCPPYY_EXTERN bool Import(const std::string &name)Definition API.cxx:259; CPyCppyy::ExecScriptCPYCPPYY_EXTERN void ExecScript(const std::string &name, const std::vector< std::string > &args)Definition API.cxx:318; CPyCppyy::Instance_CheckCPYCPPYY_EXTERN bool Instance_Check(PyObject *pyobject)Definition API.cxx:166; CPyCppyy::Instance_FromVoidPtrCPYCPPYY_EXTERN PyObject * Instance_FromVoidPtr(void *addr, const std::string &classname, bool python_owns=false)Definition API.cxx:121; CPyCppyy::Instance_AsVoidPtrCPYCPPYY_EXTERN void * Instance_AsVoidPtr(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:24226,load,load,24226,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['load'],['load']
Performance,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:15813,optimiz,optimized,15813,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,6,"['cache', 'optimiz']","['cache', 'optimized']"
Performance,"Add the variable carrying the regression target; 170 dataloader->AddTarget( ""fvalue"" );; 171 ; 172 // It is also possible to declare additional targets for multi-dimensional regression, ie:; 173 // factory->AddTarget( ""fvalue2"" );; 174 // BUT: this is currently ONLY implemented for MLP; 175 ; 176 // Read training and test data (see TMVAClassification for reading ASCII files); 177 // load the signal and background event samples from ROOT trees; 178 TFile *input(0);; 179 TString fname = ""./tmva_reg_example.root"";; 180 if (!gSystem->AccessPathName( fname )) {; 181 input = TFile::Open( fname ); // check if file in local directory exists; 182 }; 183 else {; 184 TFile::SetCacheFileDir(""."");; 185 input = TFile::Open(""http://root.cern/files/tmva_reg_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 186 }; 187 if (!input) {; 188 std::cout << ""ERROR: could not open data file"" << std::endl;; 189 exit(1);; 190 }; 191 std::cout << ""--- TMVARegression : Using input file: "" << input->GetName() << std::endl;; 192 ; 193 // Register the regression tree; 194 ; 195 TTree *regTree = (TTree*)input->Get(""TreeR"");; 196 ; 197 // global event weights per tree (see below for setting event-wise weights); 198 Double_t regWeight = 1.0;; 199 ; 200 // You can add an arbitrary number of regression trees; 201 dataloader->AddRegressionTree( regTree, regWeight );; 202 ; 203 // This would set individual event weights (the variables defined in the; 204 // expression need to exist in the original TTree); 205 dataloader->SetWeightExpression( ""var1"", ""Regression"" );; 206 ; 207 // Apply additional cuts on the signal and background samples (can be different); 208 TCut mycut = """"; // for example: TCut mycut = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; 209 ; 210 // tell the DataLoader to use all remaining events in the trees after training for testing:; 211 dataloader->PrepareTrainingAndTestTree( mycut,; 212 ""nTrain_Regression=1000:nTest_Regression=0:SplitMode=Random:NormMode=NumEvents:!V"" );; 213 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:7023,CACHE,CACHEREAD,7023,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['CACHE'],['CACHEREAD']
Performance,"AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT, which has been re-designed and re-implemented in the C++ language. It is integrated in ROOT. In addition, an optimized package for describing small matrices and vector with fixed sizes and their operation has been developed (SMatrix). The structure is shown in the following picture. Math libraries and packages. 13.1 MathCore Library; MathCore provides a collection of functions and C++ classes for numerical computing. This library includes only the basic mathematical functions and algorithms and not all the functionality required by the physics community. A more advanced mathematical functionality is provided by the MathMore library. The current set of included classes, which are provided in the ROOT::Math namespace are:. Basic special functions like the gamma, beta and error function.; Mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf’s).; Generic function classes and interfaces for evaluating one-dimensional (ROOT::Math::IBaseFunctiononeDim) and multi-dimensional functions (ROOT::Math::IBaseFunctionMultiDim) and parametric function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:655672,optimiz,optimized,655672,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"AfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:13441,cache,cache,13441,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,3,['cache'],['cache']
Performance,"All contents are RRV; Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool ; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSetProxy.html:13540,Perform,Perform,13540,root/html534/RooSetProxy.html,https://root.cern,https://root.cern/root/html534/RooSetProxy.html,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,"AllocationCount() constDefinition TTree.h:443; TTree::FlushBasketsImplInt_t FlushBasketsImpl() constInternal implementation of the FlushBaskets algorithm.Definition TTree.cxx:5146; TTree::GetDebugMinLong64_t GetDebugMin() constDefinition TTree.h:461; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fTreeIndexTVirtualIndex * fTreeIndexPointer to the tree Index (if any)Definition TTree.h:129; TTree::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TTree.cxx:9714; TTree::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TTree.h:559; TTree::GetEventInt_t GetEvent(Long64_t entry, Int_t getall=0)Definition TTree.h:509; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::BranchImpvirtual TBranch * BranchImp(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch() with added check that addobj matches className.Definition TTree.cxx:1554; TTree::GetListOfClonesvirtual TList * GetListOfClones()Definition TTree.h:527; TTree::fCacheSizeLong64_t fCacheSize! Maximum size of file buffersDefinition TTree.h:105; TTree::fClonesTList * fClones! List of cloned trees which share our addressesDefinition TTree.h:135; TTree::fTotalBuffersstd::atomic< Long64_t > fTotalBuffers! Total number of bytes in branch buffersDefinition TTree.h:108; TTree::ELockStatusBitsELockStatusBitsDefinition TTree.h:211; TTree::kFindBranch@ kFindBranchDefinition TTree.h:212; TTree::kFindLeaf@ kFindLeafDefinition TTree.h:213; TTree::kGetEntryWithIndex@ kGetEntryWithIndexDefinition TTree.h:217; TTree::kPrint@ kPrintDefinition TTree.h:222; TTree::kGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:81267,load,loading,81267,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['load'],['loading']
Performance,"AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), which is slow and does error checking. ;  . Friends; class AddCacheElem;  ; class BatchInterfaceAccessor;  ; class RooAddHelpers;  ; class RooAddModel;  ; class RooAddPdf;  ; class RooFit::EvalContext;  ; class RooRealBinding;  ; class RooRealSumFunc;  ; class RooRealSumPdf;  ; class RooVectorDataStore;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <RooAbsReal.h>. Inheritance diagram for RooAbsReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ EvalErrorIter. typedef std::map<constRooAbsArg*,std::pair<std::string,std::lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:60967,cache,cache,60967,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['cache']
Performance,"AnaConvPdf::getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsAnaConvPdf::makeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPEffDecay.html:36723,optimiz,optimizeDirtyHook,36723,root/html602/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPEffDecay.html,12,['optimiz'],['optimizeDirtyHook']
Performance,"And; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<std::string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Short_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to mak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:14397,cache,cache,14397,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,3,['cache'],['cache']
Performance,"And; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<std::string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Short_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimension",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:14639,cache,cache,14639,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,1,['cache'],['cache']
Performance,"Archive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tfNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique id",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:21596,cache,cache,21596,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,4,['cache'],['cache']
Performance,"Arg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,double,double,bool>&operator=(const RooCFunction3Binding<double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_bool_.html:19910,optimiz,optimizeCacheMode,19910,root/html602/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_bool_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"Arg* formatCmd = 0); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; virtual Bool_tRooResolutionModel::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateCoefficients(RooAddModel::CacheElem& cache, const RooArgSet* nset) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:39483,Cache,CacheElem,39483,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,6,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"Arg.; Definition at line 410 of file RooAbsCachedPdf.cxx. ◆ createCache(). virtual PdfCacheElem * RooAbsCachedPdf::createCache ; (; const RooArgSet * ; nset); const. inlineprotectedvirtual . Reimplemented in RooIntegralMorph, and RooFFTConvPdf.; Definition at line 101 of file RooAbsCachedPdf.h. ◆ DeclFileName(). static const char * RooAbsCachedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 137 of file RooAbsCachedPdf.h. ◆ disableCache(). void RooAbsCachedPdf::disableCache ; (; bool ; flag). inlineprotected . Definition at line 116 of file RooAbsCachedPdf.h. ◆ doEval(). void RooAbsCachedPdf::doEval ; (; RooFit::EvalContext & ; ctx); const. overrideprotectedvirtual . Base function for computing multiple values of a RooAbsReal. ; Parameters. ctxAn evaluation context object . Reimplemented from RooAbsReal.; Definition at line 403 of file RooAbsCachedPdf.cxx. ◆ fillCacheObject(). virtual void RooAbsCachedPdf::fillCacheObject ; (; PdfCacheElem & ; cache); const. protectedpure virtual . Implemented in RooIntegralMorph, RooFFTConvPdf, and RooCachedPdf. ◆ forceAnalyticalInt(). bool RooAbsCachedPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. overridevirtual . Force RooRealIntegral to offer all our actual observable for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 322 of file RooAbsCachedPdf.cxx. ◆ getAnalyticalIntegralWN(). int RooAbsCachedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Advertises internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 334 of file RooAbsCachedPdf.cxx. ◆ getCache(). RooAbsCachedPdf::PdfCacheElem * RooAbsCachedPdf::getCache ; (; const RooArgSet * ; nset, . bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:80504,cache,cache,80504,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"Arg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooDataHist_dataSet; RooListProxy_dataVarsThe RooRealVars; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:33880,cache,cache,33880,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"Arg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:36404,cache,cache,36404,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,6,['cache'],['cache']
Performance,Arg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTruthModel.html:38464,cache,cache,38464,root/html526/RooTruthModel.html,https://root.cern,https://root.cern/root/html526/RooTruthModel.html,1,['cache'],['cache']
Performance,Arg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTruthModel.html:38846,cache,cache,38846,root/html528/RooTruthModel.html,https://root.cern,https://root.cern/root/html528/RooTruthModel.html,3,['cache'],['cache']
Performance,"Arg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:31363,cache,cache,31363,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,2,['cache'],['cache']
Performance,"Arg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:33729,cache,cache,33729,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,3,['cache'],['cache']
Performance,"Arg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgSet& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Thu Dec 2 00:31:37 2010 » Last generated: 2010-12-02 00:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:34336,cache,cache,34336,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,1,['cache'],['cache']
Performance,"Arg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:6671,cache,cacheObservables,6671,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,1,['cache'],['cacheObservables']
Performance,"Arg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFFTConvPdf.html:6671,cache,cacheObservables,6671,root/html528/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html528/RooFFTConvPdf.html,2,['cache'],['cacheObservables']
Performance,"Arg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset, 				 const RooNumIntConfig* cfg, const char* rangeName); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:35889,perform,performed,35889,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['perform'],['performed']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooUnblindCPAsymVar(); RooUnblindCPAsymVar(const RooUnblindCPAsymVar& other, const char* name = 0); RooUnblindCPAsymVar(const char* name, const char* title, const char* blindString, RooAbsReal& cpasym); RooUnblindCPAsymVar(const char* name, const char* title, const char* blindString, RooAbsReal& cpasym, RooAbsCategory& blindState); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:23310,cache,cache,23310,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,2,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooUnblindOffset(); RooUnblindOffset(const RooUnblindOffset& other, const char* name = 0); RooUnblindOffset(const char* name, const char* title, const char* blindString, Double_t scale, RooAbsReal& blindValue); RooUnblindOffset(const char* name, const char* title, const char* blindString, Double_t scale, RooAbsReal& blindValue, RooAbsCategory& blindState); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:23283,cache,cache,23283,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,2,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooUnblindPrecision(); RooUnblindPrecision(const RooUnblindPrecision& other, const char* name = 0); RooUnblindPrecision(const char* name, const char* title, const char* blindString, Double_t centralValue, Double_t scale, RooAbsReal& blindValue, Bool_t sin2betaMode = kFALSE); RooUnblindPrecision(const char* name, const char* title, const char* blindString, Double_t centralValue, Double_t scale, RooAbsReal& blindValue, RooAbsCategory& blindState, Bool_t sin2betaMode = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindPrecision.html:23307,cache,cache,23307,root/html602/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html602/RooUnblindPrecision.html,2,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooUnblindUniform(); RooUnblindUniform(const RooUnblindUniform& other, const char* name = 0); RooUnblindUniform(const char* name, const char* title, const char* blindString, Double_t scale, RooAbsReal& blindValue); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:22756,cache,cache,22756,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,2,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooUnblindCPAsymVar.html:21847,cache,cache,21847,root/html528/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html528/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindCPAsymVar.html:21753,cache,cache,21753,root/html526/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html526/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUnblindCPAsymVar.html:22323,cache,cache,22323,root/html532/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html532/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindCPAsymVar.html:23664,cache,cache,23664,root/html534/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html534/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"Arg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsHiddenReal::printValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsHiddenReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooUnblindCPAsymVar.html:22240,cache,cache,22240,root/html530/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"Arg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsHiddenReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindCPAsymVar.html:26948,cache,cache,26948,root/html534/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html534/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"Arg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:29723,cache,cache,29723,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,1,['cache'],['cache']
Performance,"ArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:37770,perform,perform,37770,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['perform'],['perform']
Performance,"ArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:35755,Perform,Perform,35755,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,2,['Perform'],['Perform']
Performance,"ArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:36590,Perform,Perform,36590,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['Perform'],['Perform']
Performance,"ArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void recalculateCache(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& b); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:15742,cache,cachedVars,15742,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,3,['cache'],"['cache', 'cachedVars']"
Performance,"ArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringRooAbsCachedPdf::histNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:37147,optimiz,optimizeDirtyHook,37147,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"ArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3PdfBinding_double_double_double_double_.html:38995,cache,cache,38995,root/html526/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3PdfBinding_double_double_double_double_.html,4,['cache'],['cache']
Performance,"ArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyrho1; RooRealProxyrho2; RooRealProxysigp; RooRealProxyx; RooRealProxyxi.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBukinPdf.html:39737,cache,cache,39737,root/html530/RooBukinPdf.html,https://root.cern,https://root.cern/root/html530/RooBukinPdf.html,2,['cache'],['cache']
Performance,"ArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:37809,cache,cache,37809,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,4,['cache'],['cache']
Performance,"Args(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }. » Last changed: Thu Sep 23 20:01:27 2010 » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:17790,cache,cacheOwner,17790,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,1,['cache'],['cacheOwner']
Performance,"Array * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definition TTree.cxx:2074; TTree::GetCacheAutoSizeLong64_t GetCacheAutoSize(bool withDefault=false)Used for automatic sizing of the cache.Definition TTree.cxx:5407; TTree::BranchRefvirtual TBranch * BranchRef()Build the optional branch supporting the TRefTable.Definition TTree.cxx:2328; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::fAliasesTList * fAliasesList of aliases for expressions based on the tree branches.Definition TTree.h:124; TTree::CopyTreevirtual TTree * CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Copy a tree with selection.Definition TTree.cxx:3719; TTree::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTree.cxx:1142; TTree::Fitvirtual Int_t Fit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Fit a projected item(s) from a tree.Definition TTree.cxx:5079; TTree::fClusterRangeEndLong64_t * fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.Definition TTree.h:103; TTree::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TTree.cxx:9545; TTree::fIMTZipBytesstd::atomic< Long64_t > fIMTZipBytes! Zip bytes for the IMT flush baskets.Definition TTree.h:161; TTree::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:440224,cache,cache,440224,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"Array * fArrayPNEDefinition TGeoManager.h:139; TGeoManager::TestOverlapsvoid TestOverlaps(const char *path="""")Geometry overlap checker based on sampling.Definition TGeoManager.cxx:1950; TGeoManager::GetDefaultUnitsstatic EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::RemoveMaterialvoid RemoveMaterial(Int_t index)Remove material at given index.Definition TGeoManager.cxx:3086; TGeoManager::Matrixvoid Matrix(Int_t index, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3)Create rotation matrix named 'mat<index>'.Definition TGeoManager.cxx:1276; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:180588,load,loaded,180588,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['load'],['loaded']
Performance,"Array contents. ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Additional Inherited Members;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObjArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; void Init (Int_t s, Int_t lowerBound);  Initialize a TObjArray. ;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TClonesArray.h>. Inheritance diagram for TClonesArray:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TClonesArray::EStatusBits. Saved copies of pointers to objects. . EnumeratorkBypassStreamer ; kForgetBits . Definition at line 36 of file TClonesArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:26291,perform,perform,26291,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['perform'],['perform']
Performance,"Array into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space in a file, create I/O buffers, to fill them, (un)compress them. More...;  ; clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__IO.html:3795,cache,cache,3795,doc/master/group__IO.html,https://root.cern,https://root.cern/doc/master/group__IO.html,1,['cache'],['cache']
Performance,"Array::AddBefore ; (; const TObject * ; , . TObject * ;  . ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 62 of file TClonesArray.h. ◆ AddFirst(). void TClonesArray::AddFirst ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 56 of file TClonesArray.h. ◆ AddLast(). void TClonesArray::AddLast ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 57 of file TClonesArray.h. ◆ AddrAt(). TObject * TClonesArray::AddrAt ; (; Int_t ; idx). inline . Definition at line 86 of file TClonesArray.h. ◆ BypassStreamer(). void TClonesArray::BypassStreamer ; (; Bool_t ; bypass = kTRUE). When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::WriteBuffer. ; Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However there is a drawback: When a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfo of the class in the array being optimized, one cannot use later the TClonesArray with split>0. For example, there is a problem with the following scenario:; A class Foo has a TClonesArray of Bar objects; The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.; In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1; When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:31419,optimiz,optimized,31419,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['optimiz'],['optimized']
Performance,"Arrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::SaveArrayTString SaveArray(std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr)Save array as C++ code Returns name of created array.Definition TGraph.cxx:2175; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:33241,perform,perform,33241,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"Assembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960645,perform,performance,960645,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],"['performance', 'performing']"
Performance,"At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:33424,cache,cache,33424,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['cache'],['cache']
Performance,"AttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TMatrixD_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DMomentMorphFunction.html:36304,cache,cache,36304,root/html602/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo2DMomentMorphFunction.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"Attributes |; List of all members ; RooStats::UpperLimitMCSModule Class ReferenceRooFit » RooStats. ; This class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated. ; Definition at line 27 of file UpperLimitMCSModule.h. Public Member Functions;  UpperLimitMCSModule (const RooArgSet *poi, double CL=0.95);  ;  UpperLimitMCSModule (const UpperLimitMCSModule &other);  Copy constructor. ;  ;  ~UpperLimitMCSModule () override;  Destructor. ;  ; RooDataSet * finalizeRun () override;  Return auxiliary dataset with results of delta(-log(L)) calculations of this module so that it is merged with RooMCStudy::fitParDataSet() by RooMCStudy. ;  ; bool initializeInstance () override;  Initialize module after attachment to RooMCStudy object. ;  ; bool initializeRun (Int_t) override;  Initialize module at beginning of RooCMStudy run. ;  ; TClass * IsA () const override;  ; bool processBetweenGenAndFit (Int_t) override;  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual bool processAfterFit (Int_t);  Method called after fit has been performed. ;  ; virtual bool processBeforeGen (Int_t);  Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html:1330,perform,performed,1330,doc/master/classRooStats_1_1UpperLimitMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html,1,['perform'],['performed']
Performance,"Attributes; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:57623,Cache,Cache,57623,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['Cache'],['Cache']
Performance,"Aux< double >;  NHFitInterface;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types: Stores the coordinates and the DataOptions ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ;  CSparseData;  CUnBinDataClass describing the unbinned data sets (just x coordinates values) of any dimensions ;  NGLTutorials;  ►NInternal;  ►NExecutorUtils;  CResultCaster;  CResultCaster< TObject *, F >;  ►NRDF;  ►NGraphDrawing;  CGraphCreatorHelper;  CGraphNode;  CDisplayHelper;  CPassAsVecHelper;  CPassAsVecHelper< std::index_sequence< N.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:29442,perform,performing,29442,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['perform'],['performing']
Performance,"Avg ; (; ); const. inline . Definition at line 107 of file TProofPerfAnalysis.h. ◆ GetMBRateAvgMax(). Double_t TProofPerfAnalysis::GetMBRateAvgMax ; (; ); const. inline . Definition at line 105 of file TProofPerfAnalysis.h. ◆ GetWrkFileList(). void TProofPerfAnalysis::GetWrkFileList ; (; TList * ; wl, . TList * ; sl . ). private . Fill file info. ; Definition at line 586 of file TProofPerfAnalysis.cxx. ◆ IsA(). TClass * TProofPerfAnalysis::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 118 of file TProofPerfAnalysis.h. ◆ IsValid(). Bool_t TProofPerfAnalysis::IsValid ; (; ); const. inline . Definition at line 88 of file TProofPerfAnalysis.h. ◆ LatencyPlot(). void TProofPerfAnalysis::LatencyPlot ; (; const char * ; wrks = 0). Show event processing or MB processing rate plot vs time Create the histograms. ; Definition at line 1606 of file TProofPerfAnalysis.cxx. ◆ LoadTree(). void TProofPerfAnalysis::LoadTree ; (; TDirectory * ; dir). private . Load tree fTreeName from directory 'dir'. ; If not found, look for the first TTree in the directory (and sub-directories) with the name containing fTreeName. The tree pointer is saved in fTree. ; Definition at line 364 of file TProofPerfAnalysis.cxx. ◆ PrintFileInfo() [1/2]. void TProofPerfAnalysis::PrintFileInfo ; (; const char * ; fn, . const char * ; opt = ""P"", . const char * ; out = 0 . ). Print information for file 'fn' (path including directory) or server 'fn'. ; Multiple specifications separated by ',' or ' ' are supported, as well as wildcards '*', e.g. 'pippo.root, h4mu*,lxb10*"" ; Definition at line 909 of file TProofPerfAnalysis.cxx. ◆ PrintFileInfo() [2/2]. void TProofPerfAnalysis::PrintFileInfo ; (; Int_t ; showlast = 10, . const char * ; opt = """", . const char * ; out = 0 . ). Print information for all or the slowest showlast workers. ; Use showlast < 0 to print all ; Definition at line 886 of file TProofPerfAnalysis.cxx. ◆ PrintWrk",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis.html:20659,Load,LoadTree,20659,doc/master/classTProofPerfAnalysis.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis.html,1,['Load'],['LoadTree']
Performance,"Axis, Int_t chunkSize = 1024*16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnBase* CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnBase.html:11755,perform,performed,11755,root/html534/THnBase.html,https://root.cern,https://root.cern/root/html534/THnBase.html,2,['perform'],"['performance', 'performed']"
Performance,"B for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LineToVertex(TEveVectorD& v); Propag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:26027,cache,cache,26027,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,2,['cache'],['cache']
Performance,"B for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:27105,cache,cache,27105,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,1,['cache'],['cache']
Performance,"B"",100,125*sq2,125*sq2);; TGeoTube *stub = new TGeoTube(""T"",0,100,250);; TGeoPgon *spgon = new TGeoPgon(""P"",0.,360.,6,2);; spgon->DefineSection(0,-250,0,80);; spgon->DefineSection(1,250,0,80);. // define some rotations; TGeoRotation *r1 = new TGeoRotation(""r1"",90,0,0,180,90,90);; r1->RegisterYourself();; TGeoRotation *r2 = new TGeoRotation(""r2"",90,0,45,90,45,270);; r2->RegisterYourself();; // create a composite; TGeoCompositeShape *cs = new TGeoCompositeShape(""cs"",; ""((T+T:r1)-(P+P:r1))*B:r2"");; TGeoVolume *comp = new TGeoVolume(""COMP"",cs);; comp->SetLineColor(5);. // put it in the top volume; top->AddNode(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();. A composite shape example. Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided.; 18.3.4 Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:920988,Perform,Performed,920988,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Performed']
Performance,BDTG on training sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.00616 sec ; : Creating xml weight file: datasetcv/weights/TMVACrossValidation_BDTG.weights.xml; : Creating standalone class: datasetcv/weights/TMVACrossValidation_BDTG.class.C; <WARNING> <WARNING> : MakeClassSpecificHeader not implemented for CrossValidation; <WARNING> <WARNING> : MakeClassSpecific not implemented for CrossValidation; : Elapsed time for training with 1998 events: 3.81e-06 sec ; <HEADER> Fisher : [datasetcv] : Evaluation of Fisher on training sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.000313 sec ; : Creating xml weight file: datasetcv/weights/TMVACrossValidation_Fisher.weights.xml; : Creating standalone class: datasetcv/weights/TMVACrossValidation_Fisher.class.C; <WARNING> <WARNING> : MakeClassSpecificHeader not implemented for CrossValidation; <WARNING> <WARNING> : MakeClassSpecific not implemented for CrossValidation; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG for Classification performance; : ; <HEADER> BDTG : [datasetcv] : Evaluation of BDTG on testing sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.00612 sec ; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [datasetcv] : Evaluation of Fisher on testing sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.000313 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: BDTG; : ; <HEADER> BDTG : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: -0.014284 1.4061 [ -4.1075 4.0969 ]; : y: -0.0066370 1.4204 [ -4.8520 4.0761 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [datasetcv] : Loop over test ev,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:15651,perform,performance,15651,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['perform'],['performance']
Performance,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:11869,cache,cache,11869,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,6,['cache'],['cache']
Performance,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cach,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:18597,cache,cache,18597,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,BSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19141,cache,cache,19141,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:12555,cache,cache,12555,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,12,['cache'],['cache']
Performance,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cach,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19185,cache,cache,19185,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,"BUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invalid configuration option value: %s"",; 19806 config_options[CONNECTION_QUEUE_SIZE].name);; 19807 }; 19808 free_context(ctx);; 19809 pthread_setspecific(sTlsKey, NULL);; 19810 return NULL;; 19811 }; 19812 ctx->squeue =; 19813 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:590898,Queue,Queue,590898,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Queue'],['Queue']
Performance,"BUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:590931,Queue,Queue,590931,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Queue'],['Queue']
Performance,BarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; TGColorSelect*fYAxisColorY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:45941,optimiz,optimization,45941,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['optimiz'],['optimization']
Performance,"Base &covMatrix);  ;  RooMultiVarGaussian (const char *name, const char *title, const RooArgList &xvec, const TVectorD &mu, const TMatrixDBase &covMatrix);  ;  RooMultiVarGaussian (const RooMultiVarGaussian &other, const char *name=nullptr);  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Handle full integral here. ;  ; TObject * clone (const char *newname) const override;  ; const TMatrixDSym & covarianceMatrix () const;  ; void generateEvent (Int_t code) override;  Retrieve generator config from cache. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Special case: generate all observables. ;  ; void initGenerator (Int_t code) override;  Clear the GenData cache as its content is not invariant under changes in the mu vector. ;  ; TClass * IsA () const override;  ; const RooArgList & muVec () const;  ; void setAnaIntZ (double z);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; const RooArgList & xVec () const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:1961,cache,cache,1961,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"Base:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RFilterBase(). RFilterBase::RFilterBase ; (; RLoopManager * ; df, . std::string_view ; name, . const unsigned int ; nSlots, . const RDFInternal::RColumnRegister & ; colRegister, . const ColumnNames_t & ; columns, . const std::vector< std::string > & ; prevVariations, . const std::string & ; variation = ""nominal"" . ). Definition at line 19 of file RFilterBase.cxx. ◆ ~RFilterBase(). RFilterBase::~RFilterBase ; (; ). override . Definition at line 38 of file RFilterBase.cxx. Member Function Documentation. ◆ FillReport(). void RFilterBase::FillReport ; (; ROOT::RDF::RCutFlowReport & ; rep); const. virtual . Reimplemented in ROOT::Detail::RDF::RJittedFilter.; Definition at line 50 of file RFilterBase.cxx. ◆ FinalizeSlot(). virtual void ROOT::Detail::RDF::RFilterBase::FinalizeSlot ; (; unsigned int ; slot). pure virtual . Clean-up operations to be performed at the end of a task. ; Implemented in ROOT::Detail::RDF::RFilter< FilterF, PrevNodeRaw >, ROOT::Detail::RDF::RFilterWithMissingValues< PrevNodeRaw >, and ROOT::Detail::RDF::RJittedFilter. ◆ GetName(). std::string RFilterBase::GetName ; (; ); const. Definition at line 45 of file RFilterBase.cxx. ◆ HasName(). bool RFilterBase::HasName ; (; ); const. Definition at line 40 of file RFilterBase.cxx. ◆ InitNode(). void RFilterBase::InitNode ; (; ). virtual . Reimplemented in ROOT::Detail::RDF::RJittedFilter.; Definition at line 59 of file RFilterBase.cxx. ◆ InitSlot(). virtual void ROOT::Detail::RDF::RFilterBase::InitSlot ; (; TTreeReader * ; r, . unsigned int ; slot . ). pure virtual . Implemented in ROOT::Detail::RDF::RFilter< FilterF, PrevNodeRaw >, ROOT::Detail::RDF::RFilterWithMissingValues< PrevNodeRaw >, and ROOT::Detail::RDF::RJittedFilter. ◆ operator=(). RFilterBase & ROOT::Detail::RDF::RFilterBase::operator= ; (; const RFilterBase & ; ). delete . ◆ ResetReportCount(). virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilterBase.html:4281,perform,performed,4281,doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilterBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilterBase.html,1,['perform'],['performed']
Performance,Base::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MinuitFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MinuitFitter.html:7749,perform,performs,7749,root/html528/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html,2,['perform'],['performs']
Performance,"Base::MethodCompositeBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); TMVA::MethodCompositeBaseTMVA::MethodCompositeBase::MethodCompositeBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodBoost&operator=(const TMVA::MethodBoost&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidTMVA::MethodCompositeBase::ReadWeightsFromStream(istream& istr); virtual voidTMVA::MethodCompositeBase::ReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:10519,Optimiz,OptimizeTuningParameters,10519,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"BaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::ClassBeginvirtual void ClassBegin(const TClass *, Version_t=-1)=0; TBuffer::SetByteCountvirtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion=kFALSE)=0; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::WriteObjectAnyvirtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ClassMembervirtual void ClassMember(const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0; TBuffer::GetVersionOwnervirtual Int_t GetVersionOwner() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassRef::Resetvoid Reset()Definition TClassRef.h:67; TClassStreamerDefinition TClassStreamer.h:26; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:247702,cache,cacheReuse,247702,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['cache'],['cacheReuse']
Performance,"BaseDir = 0); TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodDTMethodDT(const TMVA::MethodDT&); TMVA::MethodDTMethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodDTMethodDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodDT&operator=(const TMVA::MethodDT&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); Double_tPruneTree(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodDT.html:12840,Optimiz,OptimizeTuningParameters,12840,root/html602/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodDT.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"BaseDir() const; TMVA::MethodHMatrixMethodHMatrix(const TMVA::MethodHMatrix&); TMVA::MethodHMatrixMethodHMatrix(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodHMatrixMethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodHMatrix&operator=(const TMVA::MethodHMatrix&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodHMatrix.html:10513,Optimiz,OptimizeTuningParameters,10513,root/html602/TMVA__MethodHMatrix.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodHMatrix.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"BaseDir() const; TMVA::MethodRuleFitMethodRuleFit(const TMVA::MethodRuleFit&); TMVA::MethodRuleFitMethodRuleFit(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodRuleFitMethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodRuleFit&operator=(const TMVA::MethodRuleFit&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodRuleFit.html:10597,Optimiz,OptimizeTuningParameters,10597,root/html602/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodRuleFit.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"BaseMethodBase(const TMVA::MethodBase&); TMVA::MethodBaseMethodBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& dsi, const TString& weightFile, TDirectory* theBaseDir = 0); TMVA::MethodBaseMethodBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = """", TDirectory* theBaseDir = 0); TDirectory*MethodBaseDir() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodBase&operator=(const TMVA::MethodBase&); virtual map<TString,Double_t>OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidReadStateFromFile(); voidReadStateFromStream(istream& tf); voidReadStateFromStream(TFile& rf); voidReadStateFromXMLString(const char* xmlstr); virtual voidTObject::RecursiveRemove(TObject* obj); voidRerouteTransformationHandler(TMVA::TransformationHandler* fTargetTransformation); virtual voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBase.html:9813,Optimiz,OptimizeTuningParameters,9813,root/html602/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBase.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"BaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstrac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:339426,load,loaded,339426,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"BaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4507; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6855; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6881; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6912; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:7012; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4154; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4350; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstrac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:342064,load,loaded,342064,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"BasketSize(const char *bname, Int_t buffsize=16000)TTreevirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr) overrideTChainvirtual; SetBranchAddress(const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr) overrideTChainvirtual; SetBranchAddress(const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr) overrideTChainvirtual; SetBranchAddress(const char *bname, T **add, TBranch **ptr=nullptr)TChaininline; SetBranchAddress(const char *bname, T *add, TBranch **ptr=nullptr)TChaininline; SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)TTreeprotected; SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr) overrideTChainvirtual; SetBranchStyle(Int_t style=1)TTreestatic; SetCacheEntryRange(Long64_t first, Long64_t last)TTreevirtual; SetCacheLearnEntries(Int_t n=10)TTreevirtual; SetCacheSize(Long64_t cacheSize=-1) overrideTChainvirtual; SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)TTreeprotected; SetChainOffset(Long64_t offset=0)TTreeinlinevirtual; SetCircular(Long64_t maxEntries)TTreevirtual; SetClusterPrefetch(bool enabled)TTreeinlinevirtual; SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)TTreevirtual; SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting=false)TTreevirtual; SetDirectory(TDirectory *dir) overrideTChainvirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEntries(Long64_t n=-1)TTreevirtual; SetEntryList(TEntryList *elist, Option_t *opt="""") overrideTChainvirtual; SetEntryListFile(const char *filename="""", Option_t *opt="""")TChainvirtual; SetEstimate(Long64_t nentries=1000000)TTreevirtual; SetEventList(TEventList *evlist) overrideTChainvirtual; SetFileNumber(Int_t number=0)TTreevirtual; SetFillAttributes()TAttFillvirtual; SetFillColor(Color_t fcolor)TAttFillinlinevirtual; SetFillColorAlpha(Col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain-members.html:23270,cache,cacheSize,23270,doc/master/classTChain-members.html,https://root.cern,https://root.cern/doc/master/classTChain-members.html,1,['cache'],['cacheSize']
Performance,"BckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrd1Editor.html:21996,Perform,Perform,21996,root/html604/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html604/TGeoTrd1Editor.html,1,['Perform'],['Perform']
Performance,"BckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1Editor.html:21996,Perform,Perform,21996,root/html602/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1Editor.html,1,['Perform'],['Perform']
Performance,"Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:149121,cache,cache,149121,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"BeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the constructi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__FeldmanCousins.html:3580,perform,perform,3580,root/html528/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html528/RooStats__FeldmanCousins.html,1,['perform'],['perform']
Performance,"BinError (Int_t bin, Int_t, Int_t) const override;  ; TClass * IsA () const override;  ; void Reset (Option_t *option="""") override;  Reset. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out Note the following restrictions in the code generated: ;  ; void SetKOrd (Int_t k);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual void AddBinContent (Int_t bin);  Increment bin content by 1. ;  ; virtual void AddBinContent (Int_t bin, Double_t w);  Increment bin content by a weight w. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Int_t BufferEmpty (Int_t action=0);  Fill histogram with all entries in the buffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1K.html:2948,Perform,Performs,2948,doc/master/classTH1K.html,https://root.cern,https://root.cern/doc/master/classTH1K.html,1,['Perform'],['Performs']
Performance,"Binning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Store given binning with this variable under the given name. void setMin(const char* name, Double_t value); Set the lower bound of the range with the given name to the given value; If name is a null pointer, set the lower bound of the default range. void setMax(const char* name, Double_t value); Set the upper bound of the range with the given name to the given value; If name is a null pointer, set the upper bound of the default range. void setRange(const char* name, Double_t min, Double_t max); Set the upper and lower lower bound of the range with the given name to the given values; If name is a null pointer, set the upper and lower bounds of the default range. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write value to stream. void syncCache(const RooArgSet* set = 0); Force the internal value cache to be up to date. inline RooErrorVar(); Constructors, assignment etc. TObject* clone(const char* newname) const; { return new RooErrorVar(*this,newname); }. Double_t evaluate() const; return error of input RooRealVar. void setVal(Double_t value); Set error of input RooRealVar to value. Bool_t isFundamental() const; Return kTRUE as we implement a fundamental type of AbsArg that can be stored in a dataset. void setMin(Double_t value); Set/get finite fit range limits. void setMax(Double_t value); Set upper bound of default range to value. void setRange(Double_t min, Double_t max); Set default ranges to [min,max]. void setBins(Int_t nBins); Set default binning to nBins uniform bins. void removeMin(const char* name = 0); Set infinite fit range limits. void removeMax(const char* name = 0); Remove upper bound from named binning, or default binning if name is null. void removeRange(const char* name = 0); Remove both upper and lower bounds from named binning, or; def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:42709,cache,cache,42709,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,3,['cache'],['cache']
Performance,"Bit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpCode(RooAbsReal& param, int code); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html:23393,cache,cache,23393,root/html532/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html,1,['cache'],['cache']
Performance,"Bit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:22666,cache,cache,22666,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['cache'],['cache']
Performance,"BitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_actual! Set of actual dependents; Bool_t_compiledFlag set if formula is compiled; Bool_t_isOKIs internal state OK?; RooLinkedList_labelListList of label names for category objects ; static Int_tRooPrintable::_nameLength; RooArgSet*_nset; RooLinkedList_origList! Original list of dependents; RooLinkedList_useList! List of actual dependents ; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayTFormula::fFunctionsArray of function calls to make; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormula.html:12497,cache,cache,12497,root/html526/RooFormula.html,https://root.cern,https://root.cern/root/html526/RooFormula.html,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,Bits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringfBasicUrlbasic url without authentication and options; TStringfBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfHTTP11true if server support HTTP/1.1; Bool_tfHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure arc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:19009,cache,cache,19009,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,2,['cache'],['cache']
Performance,"Bits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UShort_tfCurrent! to fasten Contains() in list mode; UShort_t*fIndices[fN]; Int_tfLastIndexQueried! to optimize GetEntry() in a loop; Int_tfLastIndexReturned! to optimize GetEntry() in a loop; Int_tfNsize of fIndices for I/O =fNPassed for list, fBlockSize for bits; Int_tfNPassednumber of entries in the entry list (if fPassing=0 - number of entries; Bool_tfPassing1 - stores entries that belong to the list; Int_tfType0 - bits, 1 - list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryListBlock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListBlock.html:15166,optimiz,optimized,15166,root/html528/TEntryListBlock.html,https://root.cern,https://root.cern/root/html528/TEntryListBlock.html,3,['optimiz'],['optimized']
Performance,"BitsEStatusBitsDefinition TLeaf.h:94; TLeaf::kNewValue@ kNewValueSet if we own the value buffer and so must delete it ourselves.Definition TLeaf.h:96; TLeaf::kIndirectAddress@ kIndirectAddressData member is a pointer to an array of basic types.Definition TLeaf.h:95; TLeaf::SetLeafCountvirtual void SetLeafCount(TLeaf *leaf)Set the leaf count of this leaf.Definition TLeaf.cxx:465; TLeaf::SetUnsignedvirtual void SetUnsigned()Definition TLeaf.h:166; TLeaf::GetFullNamevirtual TString GetFullName() constReturn the full name (including the parent's branch names) of the leaf.Definition TLeaf.cxx:224; TLeaf::CanGenerateOffsetArrayvirtual bool CanGenerateOffsetArray()Definition TLeaf.h:112; TLeaf::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::ReadBasketvirtual void ReadBasket(TBuffer &)Definition TLeaf.h:152; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::GenerateOffsetArrayvirtual Int_t * GenerateOffsetArray(Int_t base, Int_t events)Definition TLeaf.h:115; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Importvirtual void Import(TClonesArray *, Int_t)Definition TLeaf.h:147; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; double; int; TLeaf::GetValueHelper< Long64_t >::Execstatic Long64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:173; TLeaf::GetValueHelper< LongDouble_t >::Execstatic LongDo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8h_source.html:18090,Cache,Cache,18090,doc/master/TLeaf_8h_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html,1,['Cache'],['Cache']
Performance,"BitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*fFirst! pointer to first entry in linked list; TObjLink*fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TList(); Delete the list. Objects are not deleted unless the TList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TList.html:11263,cache,cache,11263,root/html602/TList.html,https://root.cern,https://root.cern/root/html602/TList.html,2,['cache'],['cache']
Performance,"BitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; TFile*fFilecurrently open file; TStringTEntryList::fFileNamename of the file, where the tree is; TObjArray*fFileNames! points to the fFiles data member of the corresponding chain; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TStringfListFileNamefrom this string names of all files can be found; TStringfListNamename of the list; Long64_t*fListOffset[fNFiles] numbers of entries in ind. lists; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; Int_tfNFilestotal number of files; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListFromFile.html:9422,optimiz,optimize,9422,root/html602/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html602/TEntryListFromFile.html,4,['optimiz'],['optimize']
Performance,"BitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const; Inform the user what we are about to stream. TConfiguredAction(); assignment operator must be the default because the 'copy' constructor is actually a move constructor and must be used. {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move constructor ... TConfiguredAction & operator=(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move assignment!. TConfiguredAction(TStreamerInfoAction_t action, TConfiguration *conf); Usual constructor. TConfiguredAction(TStreamerInfoVecPtrLoopAction_t action, TConfiguration *conf); Usual constructor. TConfiguredAction(TStreamerInfoLoopAction_t action, TConfiguration *conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerInfoActions__TConfiguredAction.html:7767,optimiz,optimized,7767,root/html604/TStreamerInfoActions__TConfiguredAction.html,https://root.cern,https://root.cern/root/html604/TStreamerInfoActions__TConfiguredAction.html,2,['optimiz'],['optimized']
Performance,"BitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoManager*fGeoManagerbase geometry; Bool_tfIsClosed! Closed flag; TGeoPhysicalNode*fLastState! Last PN touched; TStringTNamed::fNameobject identifier; TObjArray*fPathsarray of paths; TObjArray*fPhysical! array of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParallelWorld.html:7857,optimiz,optimization,7857,root/html604/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html604/TGeoParallelWorld.html,1,['optimiz'],['optimization']
Performance,"Bool_t TGraph::CtorAllocate ; (; ). protected . In constructors set fNpoints than call this method. ; Return kFALSE if the graph will contain no points. Note: This function should be called only from the constructor since it does not delete previously existing arrays ; Definition at line 805 of file TGraph.cxx. ◆ DeclFileName(). static const char * TGraph::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 203 of file TGraph.h. ◆ DistancetoPrimitive(). Int_t TGraph::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute distance from point px,py to a graph. ; Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units. ; Reimplemented from TObject.; Definition at line 879 of file TGraph.cxx. ◆ DoMerge(). Bool_t TGraph::DoMerge ; (; const TGraph * ; g). protectedvirtual . protected function to perform the merge operation of a graph ; Reimplemented in TGraphAsymmErrors, TGraphBentErrors, TGraphErrors, and TGraphMultiErrors.; Definition at line 2676 of file TGraph.cxx. ◆ Draw(). void TGraph::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw this graph with its current attributes. ; The options to draw a graph are described in TGraphPainter class. ; Reimplemented from TObject.; Reimplemented in TGraphPolar.; Definition at line 831 of file TGraph.cxx. ◆ DrawGraph() [1/3]. void TGraph::DrawGraph ; (; Int_t ; n, . const Double_t * ; x = nullptr, . const Double_t * ; y = nullptr, . Option_t * ; option = """" . ). virtual . Draw this graph with new attributes. ; Definition at line 915 of file TGraph.cxx. ◆ DrawGraph() [2/3]. void TGraph::DrawGraph ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y, . Option_t * ; option = """" . ). virtual . Draw this graph with new attributes. ; Definition at line 902 of file TGraph.cxx. ◆ DrawGraph() [3/3]. void TGraph::DrawGraph ; (; Int_t ; n, . const Int_t * ; x, . const Int_t * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:41902,perform,perform,41902,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['perform'],['perform']
Performance,"Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the rig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:15603,perform,performance,15603,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,6,['perform'],['performance']
Performance,"Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual Double_tvolume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsRealLValue.html:27914,cache,cache,27914,root/html528/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsRealLValue.html,2,['cache'],['cache']
Performance,"Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:22722,cache,cache,22722,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"Bool_t ignore=kTRUE);  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void Openlog (const char *name, Int_t options, ELogFacility facility);  Open connection to system log daemon. ;  ; virtual FILE * OpenPipe (const char *command, const char *mode);  Open a pipe. ;  ; virtual const char * PrependPathName (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebSystem.html:12318,Load,Load,12318,doc/master/classTWebSystem.html,https://root.cern,https://root.cern/doc/master/classTWebSystem.html,2,['Load'],['Load']
Performance,"Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:23680,load,load,23680,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooMultiCategory(); RooMultiCategory(const RooMultiCategory& other, const char* name = 0); RooMultiCategory(const char* name, const char* title, const RooArgSet& inputCatList); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:15077,cache,cache,15077,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['cache'],['cache']
Performance,"Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAlwaysStartFromMin(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:23287,cache,cache,23287,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,1,['cache'],['cache']
Performance,"Bool_t splitCutRange = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:25372,cache,cache,25372,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidsetCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidsetHideOffset(Bool_t flag); voidsetIntegratorConfig(); voidsetIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetParameterizeIntegral(const RooArgSet& paramVars); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:23313,cache,cache,23313,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,1,['cache'],['cache']
Performance,"Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); static Bool_tImport(const char* name); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static Bool_tMethodProxy_Check(PyObject* pyobject); static Bool_tMethodProxy_CheckExact(PyObject* pyobject); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname, Bool_t python_owns = kFALSE); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TPython(); TPython(const TPython&). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. Bool_t Import(const char* name); Import the named python module and create Cling equivalents for its classes; and methods. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create Cling equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPython.html:3456,load,load,3456,root/html604/TPython.html,https://root.cern,https://root.cern/root/html604/TPython.html,1,['load'],['load']
Performance,"Bool_tHasDictionarySelection(const char* clname); virtual ULong_tTNamed::Hash() const; Bool_tHasInterpreterInfo() const; Bool_tHasInterpreterInfoInMemory() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); static TClass*LoadClass(const char* requestedname, Bool_t silent); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:9570,Load,Load,9570,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['Load'],['Load']
Performance,"Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_pidPID of child process; Int_t_pipeToClient[2]Pipe to client process; Int_t_pipeToServer[2]Pipe to server process; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:33272,cache,cache,33272,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,2,['cache'],['cache']
Performance,"Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4Binding<double,double,double,double,int>&operator=(const RooCFunction4Binding<double,double,double,double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html:19946,optimiz,optimizeCacheMode,19946,root/html602/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_double_int_int_.html:32533,cache,cache,32533,root/html526/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_double_int_int_.html,2,['cache'],['cache']
Performance,"Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConstraintSum.html:32239,cache,cache,32239,root/html530/RooConstraintSum.html,https://root.cern,https://root.cern/root/html530/RooConstraintSum.html,1,['cache'],['cache']
Performance,"Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); virtual voidsetExpensiveObjectCache(RooE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:34957,optimiz,optimizeDirtyHook,34957,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:33191,optimiz,optimizeDirtyHook,33191,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,9,['optimiz'],['optimizeDirtyHook']
Performance,"Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:30673,optimiz,optimizeDirtyHook,30673,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,16,['optimiz'],['optimizeDirtyHook']
Performance,"Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveArrowGL.html:1828,cache,cached,1828,root/html528/TEveArrowGL.html,https://root.cern,https://root.cern/root/html528/TEveArrowGL.html,9,['cache'],['cached']
Performance,"Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. private:. Double_tfDz; TGLVector3fHighPlaneNorm; TGLVector3fLowPlaneNorm; Double_tfPhi1; Double_tfPhi2; Double_tfR1; Double_tfR2; Double_tfR3; Double_tfR4; Bool_tfSegMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLCylinder(const TBuffer3DTube& buffer); Copy out relevant parts of buffer - we create and delete mesh; parts on demand in DirectDraw() and they are DL cached. ~TGLCylinder(); destructor. UInt_t DLOffset(Short_t lod) const; Return display-list offset for given LOD.; Calculation based on what is done in virtual QuantizeShapeLOD below. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Factor in scene/viewer LOD and quantize. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. TGLCylinder(const TBuffer3DTube& buffer). ELODAxes SupportedLODAxes() const; Cylinders support LOD (tesselation quality) adjustment along; X/Y axes (round the cylinder radius), but not along length (Z). { return ELODAxes(kLODAxesX | kLODAxesY); }. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLCylinder.html:4271,cache,cached,4271,root/html604/TGLCylinder.html,https://root.cern,https://root.cern/root/html604/TGLCylinder.html,1,['cache'],['cached']
Performance,"Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. private:. Double_tfDz; TGLVector3fHighPlaneNorm; TGLVector3fLowPlaneNorm; Double_tfPhi1; Double_tfPhi2; Double_tfR1; Double_tfR2; Double_tfR3; Double_tfR4; Bool_tfSegMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLCylinder(const TBuffer3DTube& buffer); Copy out relevant parts of buffer - we create and delete mesh; parts on demand in DirectDraw() and they are DL cached. ~TGLCylinder(); destructor. UInt_t DLOffset(Short_t lod) const; Return display-list offset for given LOD.; Calculation based on what is done in virtual QuantizeShapeLOD below. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Factor in scene/viewer LOD and quantize. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. TGLCylinder(const TBuffer3DTube& buffer). ELODAxes SupportedLODAxes() const; Cylinders support LOD (tesselation quality) adjustment along; X/Y axes (round the cylinder radius), but not along length (Z). { return ELODAxes(kLODAxesX | kLODAxesY); }. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLCylinder.html:4271,cache,cached,4271,root/html602/TGLCylinder.html,https://root.cern,https://root.cern/root/html602/TGLCylinder.html,1,['cache'],['cached']
Performance,"Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsString&operator=(const RooAbsString&); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:10436,optimiz,optimizeCacheMode,10436,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['optimiz'],['optimizeCacheMode']
Performance,"Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_t>_sigma; Double_t_sigmaAvgR; TVectorD*_sigmaR; vector<iiVec>_sortIdcs!; vector<itVec>_sortTVIdcs!; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Double_t_sqrt2pi; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooListProxy_varList; vector<string>_varName; Bool_t_verbose; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; map<Int_t,Double_t>_wMap; vector<vector<Double_t> >*_weights!; vector<vector<Double_t> >_weights0; vector<vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_xVarHiP3s; vector<Double_t>_xVarLo; vector<Double_t>_xVarLoM3s; vector<Double_t>_xVarLoP3s;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:47523,cache,cache,47523,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['cache'],['cache']
Performance,"Bool_tfgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t bas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:5666,cache,cached,5666,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,1,['cache'],['cached']
Performance,"Bool_t ; = kFALSE . ). inlinevirtual . Definition at line 90 of file TGrid.h. ◆ Class(). static TClass * TGrid::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGrid::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGrid::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 125 of file TGrid.h. ◆ Command(). virtual TGridResult * TGrid::Command ; (; const char * ; , . Bool_t ; = kFALSE, . UInt_t ; = 2 . ). inlinevirtual . Definition at line 72 of file TGrid.h. ◆ Connect(). TGrid * TGrid::Connect ; (; const char * ; grid, . const char * ; uid = nullptr, . const char * ; pw = nullptr, . const char * ; options = nullptr . ). static . The grid should be of the form: <grid>://<host>[:<port>], e.g.: alien://alice.cern.ch The uid is the username and pw the password that should be used for the connection. ; Depending on the <grid> the shared library (plugin) for the selected system will be loaded. When the connection could not be opened 0 is returned. For AliEn the supported options are: -domain=<domain name> -debug=<debug level from 1 to 10> Example: ""-domain=cern.ch -debug=5"" ; Definition at line 49 of file TGrid.cxx. ◆ DeclFileName(). static const char * TGrid::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 125 of file TGrid.h. ◆ GetGrid(). const char * TGrid::GetGrid ; (; ); const. inline . Definition at line 60 of file TGrid.h. ◆ GetHomeDirectory(). virtual const char * TGrid::GetHomeDirectory ; (; ). inlinevirtual . Definition at line 88 of file TGrid.h. ◆ GetHost(). const char * TGrid::GetHost ; (; ); const. inline . Definition at line 61 of file TGrid.h. ◆ GetJDLGenerator(). virtual TGridJDL * TGrid::GetJDLGenerator ; (; ). inlinevirtual . Definition at line 104 of file TGrid.h. ◆ GetOptions(). const char * TGrid::GetOptions ; (; ); const. inline . Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGrid.html:13316,load,loaded,13316,doc/master/classTGrid.html,https://root.cern,https://root.cern/doc/master/classTGrid.html,1,['load'],['loaded']
Performance,"BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; map<pair<string,int>,BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; vector<Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:40008,cache,cache,40008,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,"BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; map<pair<string,int>,BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNDKeysPdf.html:40390,cache,cache,40390,root/html528/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,"BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; map<pair<string,int>,BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNDKeysPdf.html:40859,cache,cache,40859,root/html530/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html530/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,"BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; map<pair<string,int>,BoxInfo*>_rangeBoxInfo; Double_tRooAbsPdf::_rawValue; vector<Double_t>_rho; TMatrixD*_rotMat; Bool_t_rotate; vector<Int_t>_sIdcs; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNDKeysPdf.html:41262,cache,cache,41262,root/html532/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html532/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,"Branches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:337897,cache,cachesize,337897,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cachesize']
Performance,"Branches(); -- Return a pointer to the list of branches of the current tree. Warning: May set current tree!. Returns 1 on success and 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:36826,load,load,36826,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['load'],['load']
Performance,"Browsable::RElementPath_t DecomposePath(const std::string &path, bool relative_to_work_element)Decompose path to elements Returns array of names for each element in the path, first element either ...Definition RBrowserData.cxx:155; ROOT::RBrowserData::fLastAllChildsbool fLastAllChilds! if all chlds were extractedDefinition RBrowserData.hxx:50; ROOT::RBrowserData::~RBrowserDatavirtual ~RBrowserData()Destructor.Definition RBrowserData.cxx:78; ROOT::RBrowserData::ProcessBrowserRequestbool ProcessBrowserRequest(const RBrowserRequest &request, RBrowserReply &reply)Process browser request.Definition RBrowserData.cxx:171; ROOT::RBrowserData::GetElementFromTopstd::shared_ptr< Browsable::RElement > GetElementFromTop(const Browsable::RElementPath_t &path)Returns element with path, specified as Browsable::RElementPath_t.Definition RBrowserData.cxx:300; ROOT::RBrowserData::fLastSortMethodstd::string fLastSortMethod! last sort methodDefinition RBrowserData.hxx:52; ROOT::RBrowserData::ClearCachevoid ClearCache()Clear internal objects cache.Definition RBrowserData.cxx:370; ROOT::RBrowserData::ProcessRequeststd::string ProcessRequest(const RBrowserRequest &request)Process browser request, returns string with JSON of RBrowserReply data.Definition RBrowserData.cxx:269; ROOT::RBrowserData::fLastItemsstd::vector< std::unique_ptr< Browsable::RItem > > fLastItems! created browser items - used in requestsDefinition RBrowserData.hxx:49; ROOT::RBrowserData::fLastPathBrowsable::RElementPath_t fLastPath! path to last used elementDefinition RBrowserData.hxx:47; ROOT::RBrowserData::SetWorkingPathvoid SetWorkingPath(const Browsable::RElementPath_t &path)set working directory relative to top elementDefinition RBrowserData.cxx:98; ROOT::RBrowserData::fTopElementstd::shared_ptr< Browsable::RElement > fTopElement! top elementDefinition RBrowserData.hxx:41; ROOT::RBrowserData::GetElementstd::shared_ptr< Browsable::RElement > GetElement(const std::string &str)Returns element with path, specified as st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:17678,cache,cache,17678,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['cache'],['cache']
Performance,"Browser*fBrowserselected browser (if exist); TObject*fCalledObjectobject to call; TContextMenuImp*fContextMenuImp!Context menu system specific implementation; TStringTNamed::fNameobject identifier; TVirtualPad*fSelectedCanvasselected canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TContextMenu.html:8309,perform,performed,8309,root/html528/TContextMenu.html,https://root.cern,https://root.cern/root/html528/TContextMenu.html,6,['perform'],['performed']
Performance,"Browser. ;  ; Browsable::RElementPath_t DecomposePath (const std::string &path, bool relative_to_work_element);  Decompose path to elements Returns array of names for each element in the path, first element either ""/"" or ""."" If returned array empty - it is error. ;  ; std::shared_ptr< Browsable::RElement > GetElement (const std::string &str);  Returns element with path, specified as string. ;  ; std::shared_ptr< Browsable::RElement > GetElementFromTop (const Browsable::RElementPath_t &path);  Returns element with path, specified as Browsable::RElementPath_t. ;  ; std::shared_ptr< Browsable::RElement > GetSubElement (const Browsable::RElementPath_t &path);  Returns sub-element starting from top, using cached data. ;  ; const Browsable::RElementPath_t & GetWorkingPath () const;  ; std::string ProcessRequest (const RBrowserRequest &request);  Process browser request, returns string with JSON of RBrowserReply data. ;  ; bool RemoveFromCache (const Browsable::RElementPath_t &path);  Remove path (and all sub-paths) from cache Returns true if any element was removed. ;  ; bool RemoveFromCache (void *obj);  Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any element was removed. ;  ; void SetTopElement (std::shared_ptr< Browsable::RElement > elem);  set top element for browsing ;  ; void SetWorkingPath (const Browsable::RElementPath_t &path);  set working directory relative to top element ;  . Private Member Functions; bool ProcessBrowserRequest (const RBrowserRequest &request, RBrowserReply &reply);  Process browser request. ;  ; void ResetLastRequestData (bool with_element);  Reset all data correspondent to last request. ;  . Private Attributes; std::vector< std::pair< Browsable::RElementPath_t, std::shared_ptr< Browsable::RElement > > > fCache;  ! already requested elements ;  ; std::unique_ptr< TObject > fCleanupHandle;  ! cleanup handle for RecursiveRemove ;  ; bool fLastAllChilds {false};  ! if all chlds were extracted ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html:1755,cache,cache,1755,doc/v632/classROOT_1_1RBrowserData.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html,2,['cache'],['cache']
Performance,Buffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooMomentMorphFuncND::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 162 of file RooMomentMorphFuncND.h. ◆ sumFunc(). RooMomentMorphFuncND::Base_t * RooMomentMorphFuncND::sumFunc ; (; const RooArgSet * ; nset). protected . Definition at line 522 of file RooMomentMorphFuncND.cxx. ◆ useHorizontalMorphing(). void RooMomentMorphFuncND::useHorizontalMorphing ; (; bool ; val). inline . Definition at line 127 of file RooMomentMorphFuncND.h. Friends And Related Symbol Documentation. ◆ CacheElem. friend class CacheElem. friend . Definition at line 140 of file RooMomentMorphFuncND.h. ◆ Grid2. friend class Grid2. friend . Definition at line 141 of file RooMomentMorphFuncND.h. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooMomentMorphFuncND::_cacheMgr. mutableprotected . ! Transient cache manager ; Definition at line 143 of file RooMomentMorphFuncND.h. ◆ _curNormSet. RooArgSet* RooMomentMorphFuncND::_curNormSet = nullptr. mutableprotected . ! Transient cache manager ; Definition at line 144 of file RooMomentMorphFuncND.h. ◆ _isPdfMode. bool RooMomentMorphFuncND::_isPdfMode = false. protected . Definition at line 158 of file RooMomentMorphFuncND.h. ◆ _M. std::unique_ptr<TMatrixD> RooMomentMorphFuncND::_M. mutableprotected . Definition at line 151 of file RooMomentMorphFuncND.h. ◆ _MSqr. std::unique_ptr<TMatrixD> RooMomentMorphFuncND::_MSqr. mutableprotected . Definition at line 152 of file RooMomentMorphFuncND.h. ◆ _obsList. RooSetProxy RooMomentMorphFuncND::_obsList. protected . Definition at line 147 of file RooMomentMorphFuncND.h. ◆ _parList. RooListProxy RooMomentMorphFuncND::_parList. protected . Definition at line 146 of file RooMomentMorphFuncND.h. ◆ _pdfList. RooListProxy RooMomentMorphFuncND::_pdfList. protected . Definition at line 149 of file RooMomentMorphFuncND.h. ◆ _referenceGri,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:67975,cache,cache,67975,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['cache'],['cache']
Performance,"Buffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:3544,cache,cache,3544,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"Buffer to convert data to SQL statements or read data from SQL tables; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCivetweb http server implementation, based on civetweb embedded server; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw classes inheritance tree and relations; TClonesArray An array of clone objects; TCollection Collection abstract base class; TCollectionClassStreamer ; TCollectionMemberStreamer ; TCollectionMethodBrowsable Helper object to browse a collection's methods; TCollectionPropertyBrowsable Helper object to add browsable collection properties; TCollectionProxyFactory ; TCollectionStreamer ; TColor Color defined by RGB or HLS; TColorGradient Gradient fill.; TColorWheel The ROOT Color Wheel; TColumnView Helper to represent one TTable column; TComplex Complex Class; TCondition Condition variable class; TConditionImp Condition variable implementation ABC; TCondor Interface to the Condor System; TCondorSlave Describes a claimed slave; TConfidenceLevel output for TLimit functions; TContextMenu Context sensitive popup menu; TContextMenuImp Context sensitive popup menu implementation; TControlBar Control bar; TControlBarButton The Control bar butt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:53435,cache,cache,53435,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['cache'],['cache']
Performance,BufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19627,cache,cache,19627,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,"BuildEmulatedRealData("""", 0, this, isTransient);; 2054 return;; 2055 }; 2056 ; 2057 // return early on string; 2058 static TClassRef clRefString(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 210",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:77951,load,loading,77951,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],"['loaded', 'loading']"
Performance,"BuildEmulatedRealData("""", 0, this, isTransient);; 2121 return;; 2122 }; 2123 ; 2124 // return early on string; 2125 static TClassRef clRefString(""std::string"");; 2126 if (clRefString == this) {; 2127 return;; 2128 }; 2129 ; 2130 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2131 // pair where we will build .first, .second just fine; 2132 // and those for which the user explicitly requested a dictionary.; 2133 if (!isTransient && GetState() != kHasTClassInit; 2134 && TClassEdit::IsStdClass(GetName()); 2135 && !TClassEdit::IsStdPair(GetName())) {; 2136 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2137 }; 2138 ; 2139 // The following statement will recursively call; 2140 // all the subclasses of this class.; 2141 fRealData = new TList;; 2142 TBuildRealData brd(pointer, this);; 2143 ; 2144 // CallShowMember will force a call to InheritsFrom, which indirectly; 2145 // calls TClass::GetClass. It forces the loading of new typedefs in; 2146 // case some of them were not yet loaded.; 2147 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2148 if ( isTransient ) {; 2149 // This is a transient data member, so it is probably fine to not have; 2150 // access to its content. However let's no mark it as definitively setup,; 2151 // since another class might use this class for a persistent data member and; 2152 // in this case we really want the error message.; 2153 delete fRealData;; 2154 fRealData = nullptr;; 2155 } else {; 2156 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2157 }; 2158 }; 2159 ; 2160 // Take this opportunity to build the real data for base classes.; 2161 // In case one base class is abstract, it would not be possible later; 2162 // to create the list of real data for this abstract class.; 2163 TBaseClass* base = nullptr;; 2164 TIter next(GetListOfBases());; 2165 while ((base = (TBaseClass*) next())) {; 2166 if (base->IsSTLContainer()) {; 2167 continue;; 2168 }; 216",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:80702,load,loading,80702,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],"['loaded', 'loading']"
Performance,"By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?""; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();. Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:110397,tune,tune,110397,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['tune'],['tune']
Performance,"BytesReadExtra ; (; ); const. inlinevirtual . Definition at line 242 of file TFile.h. ◆ GetBytesToPrefetch(). Int_t TFile::GetBytesToPrefetch ; (; ); const. virtual . Max number of bytes to prefetch. ; By default this is 75% of the read cache size. But specific TFile implementations may need to change it ; Definition at line 5222 of file TFile.cxx. ◆ GetBytesWritten(). Long64_t TFile::GetBytesWritten ; (; ); const. virtual . Return the total number of bytes written so far to the file. ; Definition at line 4566 of file TFile.cxx. ◆ GetCacheFileDir(). const char * TFile::GetCacheFileDir ; (; ). static . Get the directory where to locally stage/cache remote files. ; Definition at line 4654 of file TFile.cxx. ◆ GetCacheRead(). TFileCacheRead * TFile::GetCacheRead ; (; const TObject * ; tree = nullptr); const. Return a pointer to the current read cache. ; Definition at line 1262 of file TFile.cxx. ◆ GetCacheWrite(). TFileCacheWrite * TFile::GetCacheWrite ; (; ); const. Return a pointer to the current write cache. ; Definition at line 1279 of file TFile.cxx. ◆ GetClassIndex(). TArrayC * TFile::GetClassIndex ; (; ); const. inline . Definition at line 226 of file TFile.h. ◆ GetCompressionAlgorithm(). Int_t TFile::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 385 of file TFile.h. ◆ GetCompressionFactor(). Float_t TFile::GetCompressionFactor ; (; ). Return the file compression factor. ; Add total number of compressed/uncompressed bytes for each key. Returns the ratio of the two. ; Definition at line 1202 of file TFile.cxx. ◆ GetCompressionLevel(). Int_t TFile::GetCompressionLevel ; (; ); const. inline . Definition at line 391 of file TFile.h. ◆ GetCompressionSettings(). Int_t TFile::GetCompressionSettings ; (; ); const. inline . Definition at line 397 of file TFile.h. ◆ GetEND(). virtual Long64_t TFile::GetEND ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 231 of file TFile.h. ◆ GetEndpointUrl() [1/2]. virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:63533,cache,cache,63533,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['cache'],['cache']
Performance,"C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.\n""; 1346 "" Use Backspace if you mistyped (but not arrows).\n""; 1347 "" Press Ctrl+R (Ctrl+S) repeateadly to navigate matches in reverse (forward) order"");; 1348 Printf("" Arrow_Right : after Ctrl+R (Ctrl+S), select current match of the history search\n""; 1349 "" [Ctrl+O] [Enter] [Ctrl+J] [Ctrl+M] [Arrow_Left] [Esc,Esc].\n""; 1350 "" Use Ctrl+F or Ctrl+G to cancel search and revert original line"");; 1351 ; 1352 return;; 1353 }; 1354 // We call the function what handles the extended "".help scopeName"" command.; 1355 OpenReferenceGuideFor(strippedCommand);; 1356 }; 1357}; 1358 ; 1359/// Load shared libs necessary for graphics. These libraries are only; 1360/// loaded when gROOT->IsBatch() is kFALSE.; 1361 ; 1362void TApplication::LoadGraphicsLibs(); 1363{; 1364 if (gROOT->IsBatch()); 1365 return;; 1366 ; 1367 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPad"")); 1368 if (h->LoadPlugin() == -1); 1369 return;; 1370 ; 1371 TString name;; 1372 TString title1 = ""ROOT interface to "";; 1373 TString nativex, title;; 1374 ; 1375#ifdef R__WIN32; 1376 nativex = ""win32gdk"";; 1377 name = ""Win32gdk"";; 1378 title = title1 + ""Win32gdk"";; 1379#elif defined(R__HAS_COCOA); 1380 nativex = ""quartz"";; 1381 name = ""quartz"";; 1382 title = title1 + ""Quartz"";; 1383#else; 1384 nativex = ""x11"";; 1385 name = ""X11"";; 1386 title = title1 + ""X11"";; 1387#endif; 1388 ; 1389 TString guiBackend = gEnv->GetValue(""Gui.Backend"", ""native"");; 1390 guiBackend.ToLower();; 1391 if (guiBackend == ""native"") {; 1392 guiBackend = nativex;; 1393 } else {; 1394 name = guiBackend;; 1395 title = title1 + guiBackend;; 1396 }; 1397 ; 1398 if (auto h = gROOT->GetPluginManager()->Fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:55082,load,loaded,55082,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['load'],['loaded']
Performance,"C source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCacheElement.html:923,cache,cacheList,923,root/html534/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html,1,['cache'],['cacheList']
Performance,"C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Return file stat information. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; virtual Int_t SysWrite (Int_t fd, const void *buf, Int_t len);  Interface to system write. All arguments like in POSIX write(). ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:33538,cache,cache,33538,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,6,['cache'],['cache']
Performance,"C)->collectAllContexts(allDeclContexts);; 4413 for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(), declEnd = allDeclContexts.end();; 4414 declIter != declEnd; ++declIter) {; 4415 // Iterate on all decls for each context.; 4416 for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),; 4417 DE = (*declIter)->decls_end(); DI != DE; ++DI) {; 4418 if (const clang::EnumDecl* ED = dyn_cast<clang::EnumDecl>(*DI)) {; 4419 // Get name of the enum type.; 4420 std::string buf;; 4421 PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());; 4422 llvm::raw_string_ostream stream(buf);; 4423 // Don't trigger fopen of the source file to count lines:; 4424 Policy.AnonymousTagLocations = false;; 4425 ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);; 4426 stream.flush();; 4427 // If the enum is unnamed we do not add it to the list of enums i.e unusable.; 4428 if (!buf.empty()) {; 4429 const char* name = buf.c_str();; 4430 // Add the enum to the list of loaded enums.; 4431 enumList.Get(ED, name);; 4432 }; 4433 }; 4434 }; 4435 }; 4436 }; 4437}; 4438 ; 4439////////////////////////////////////////////////////////////////////////////////; 4440/// Create list of pointers to function templates for TClass cl.; 4441 ; 4442void TCling::LoadFunctionTemplates(TClass* cl) const; 4443{; 4444 R__LOCKGUARD(gInterpreterMutex);; 4445 ; 4446 const Decl * D;; 4447 TListOfFunctionTemplates* funcTempList;; 4448 if (cl) {; 4449 D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();; 4450 funcTempList = (TListOfFunctionTemplates*)cl->GetListOfFunctionTemplates(false);; 4451 }; 4452 else {; 4453 D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 4454 funcTempList = (TListOfFunctionTemplates*)gROOT->GetListOfFunctionTemplates();; 4455 }; 4456 // Iterate on the decl of the class and get the enums.; 4457 if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {; 4458 cling::Interpreter::PushTransactionRAII deserRAI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:172243,load,loaded,172243,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:40980,load,loaded,40980,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['load'],['loaded']
Performance,"CBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; vector<TEveCaloData::vCellId_t*>fCellLists; vector<TEveCaloData::vCellId_t*>fCellListsHighlighted; vector<TEveCaloData::vCellId_t*>fCellListsSelected; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tTEveCaloViz::fEndCapPosBbackward end cap z coordinate in cm (should be < 0); Float_tTEveCaloViz::fEndCapPosFforward end cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCalo2D.html:21656,cache,cache,21656,root/html534/TEveCalo2D.html,https://root.cern,https://root.cern/root/html534/TEveCalo2D.html,1,['cache'],['cache']
Performance,"CBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; vector<TEveCaloData::vCellId_t*>fCellLists; vector<TEveCaloData::vCellId_t*>fCellListsHighlighted; vector<TEveCaloData::vCellId_t*>fCellListsSelected; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tTEveCaloViz::fEndCapPosend cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main trans",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCalo2D.html:21050,cache,cache,21050,root/html528/TEveCalo2D.html,https://root.cern,https://root.cern/root/html528/TEveCalo2D.html,3,['cache'],['cache']
Performance,"CERN in the ROOT development team. Axel is leading the ROOT project since 2017.; ; . Bertrand Bellenot ; ; Bertrand was primary working in Aluminum industry as process engineer, developing software for data acquisition, data analysis, statistical process control (SPC) and for X-Ray spectrometry. He has been involved in ROOT development since 2001 by porting ROOT to Windows. Bertrand is a member of the ROOT development team at CERN since August 2005. He's currently working on GUI (Graphical User Interface), core (mainly Windows support), and JavaScript Root (JSROOT).; ; . Danilo Piparo ; ; Danilo is a particle Physicist and scientific software enthusiast. He obtained his Ph.D at the Karlsruhe Institute of Technology, Germany. He joined CERN as member of the CMS collaboration, to then move to the SFT group in 2012. He is a member of the ROOT team since 2013 and contributed to many of its areas: I/O, reflection, math and statistics. He is mainly involved in the aspects of ROOT which are relative to parallelism, performance and programming model.; ; . Enric Tejedor ; ; Enric Tejedor received his Ph.D. from the Technical University of Catalonia (UPC, Spain) in 2013. He conducted his doctorate research as a member of the Grid Computing and Clusters group of the Barcelona Supercomputing Center, where his researched focused on parallel programming models for distributed infrastructures and where he participated in several EU research projects. As part of his Ph.D., he also carried out two internships at the IBM T.J. Watson Research Center (NY, USA).; In 2015 he joined the CERN EP-SFT group as a senior fellow and later became a staff member. He is currently working on ROOT parallelization, the ROOT Python bindings and the SWAN service. He is also one of the administrators of the Google Summer of Code student program (GSoC) at CERN-HEP Software Foundation.; ; . Enrico Guiraud ; ; Enrico is a physicist turned computer scientist. His first experience at CERN was as Openlab summe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:3493,perform,performance,3493,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['perform'],['performance']
Performance,"CHOrModuleValidation =; 1541 DisableValidationForModuleKind::All;; 1542 ; 1543 // Until we can disable AutoLoading during Sema::CorrectTypo() we have; 1544 // to disable spell checking.; 1545 fInterpreter->getCI()->getLangOpts().SpellChecking = false;; 1546 ; 1547 // Sync modules on/off between clang and us: clang turns it on for C++ >= 20.; 1548 auto isModulesArg = [](const char* arg) { return !strcmp(arg, ""-fmodules""); };; 1549 bool hasModulesArg = std::find_if(interpArgs.begin(), interpArgs.end(), isModulesArg) != interpArgs.end();; 1550 fInterpreter->getCI()->getLangOpts().Modules = hasModulesArg;; 1551 ; 1552 // We need stream that doesn't close its file descriptor, thus we are not; 1553 // using llvm::outs. Keeping file descriptor open we will be able to use; 1554 // the results in pipes (Savannah #99234).; 1555 static llvm::raw_fd_ostream fMPOuts (STDOUT_FILENO, /*ShouldClose*/false);; 1556 fMetaProcessor = std::make_unique<cling::MetaProcessor>(*fInterpreter, fMPOuts);; 1557 ; 1558 RegisterCxxModules(*fInterpreter);; 1559 RegisterPreIncludedHeaders(*fInterpreter);; 1560 ; 1561 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 1562 fNormalizedCtxt = new ROOT::TMetaUtils::TNormalizedCtxt(fInterpreter->getLookupHelper());; 1563 fLookupHelper = new ROOT::TMetaUtils::TClingLookupHelper(*fInterpreter, *fNormalizedCtxt,; 1564 TClingLookupHelper__ExistingTypeCheck,; 1565 TClingLookupHelper__AutoParse,; 1566 &fIsShuttingDown);; 1567 TClassEdit::Init(fLookupHelper);; 1568 ; 1569 // Disallow auto-parsing in rootcling; 1570 fIsAutoParsingSuspended = fromRootCling;; 1571 ; 1572 ResetAll();; 1573 ; 1574 // Enable dynamic lookup; 1575 if (!fromRootCling) {; 1576 fInterpreter->enableDynamicLookup();; 1577 }; 1578 ; 1579 // Enable ClinG's DefinitionShadower for ROOT.; 1580 fInterpreter->getRuntimeOptions().AllowRedefinition = 1;; 1581 auto &Policy = const_cast<clang::PrintingPolicy &>(fInterpreter->getCI()->getASTContext().getPrintingPolicy());; 15",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:58147,load,loaded,58147,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"CHi2 structure; ; struct GlobalChi2 {; GlobalChi2(ROOT::Math::IMultiGenFunction &f1, ROOT::Math::IMultiGenFunction &f2) : fChi2_1(&f1), fChi2_2(&f2) {}; ; // parameter vector is first background (in common 1 and 2); // and then is signal (only in 2); double operator()(const double *par) const; {; double p1[2];; for (int i = 0; i < 2; ++i); p1[i] = par[iparB[i]];; ; double p2[5];; for (int i = 0; i < 5; ++i); p2[i] = par[iparSB[i]];; ; return (*fChi2_1)(p1) + (*fChi2_2)(p2);; }; ; const ROOT::Math::IMultiGenFunction *fChi2_1;; const ROOT::Math::IMultiGenFunction *fChi2_2;; };; ; void combinedFit(); {; ; TH1D *hB = new TH1D(""hB"", ""histo B"", 100, 0, 100);; TH1D *hSB = new TH1D(""hSB"", ""histo S+B"", 100, 0, 100);; ; TF1 *fB = new TF1(""fB"", ""expo"", 0, 100);; fB->SetParameters(1, -0.05);; hB->FillRandom(""fB"");; ; TF1 *fS = new TF1(""fS"", ""gaus"", 0, 100);; fS->SetParameters(1, 30, 5);; ; hSB->FillRandom(""fB"", 2000);; hSB->FillRandom(""fS"", 1000);; ; // perform now global fit; ; TF1 *fSB = new TF1(""fSB"", ""expo + gaus(2)"", 0, 100);; ; ROOT::Math::WrappedMultiTF1 wfB(*fB, 1);; ROOT::Math::WrappedMultiTF1 wfSB(*fSB, 1);; ; ROOT::Fit::DataOptions opt;; ROOT::Fit::DataRange rangeB;; // set the data range; rangeB.SetRange(10, 90);; ROOT::Fit::BinData dataB(opt, rangeB);; ROOT::Fit::FillData(dataB, hB);; ; ROOT::Fit::DataRange rangeSB;; rangeSB.SetRange(10, 50);; ROOT::Fit::BinData dataSB(opt, rangeSB);; ROOT::Fit::FillData(dataSB, hSB);; ; ROOT::Fit::Chi2Function chi2_B(dataB, wfB);; ROOT::Fit::Chi2Function chi2_SB(dataSB, wfSB);; ; GlobalChi2 globalChi2(chi2_B, chi2_SB);; ; ROOT::Fit::Fitter fitter;; ; const int Npar = 6;; double par0[Npar] = {5, 5, -0.1, 100, 30, 10};; ; // create before the parameter settings in order to fix or set range on them; fitter.Config().SetParamsSettings(6, par0);; // fix 5-th parameter; fitter.Config().ParSettings(4).Fix();; // set limits on the third and 4-th parameter; fitter.Config().ParSettings(2).SetLimits(-10, -1.E-4);; fitter.Config().ParSettings(3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8C.html:2344,perform,perform,2344,doc/master/combinedFit_8C.html,https://root.cern,https://root.cern/doc/master/combinedFit_8C.html,1,['perform'],['perform']
Performance,"CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimInterface (abstract class) for param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:37813,perform,performing,37813,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performing']
Performance,"CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:39155,perform,performing,39155,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['perform'],['performing']
Performance,"CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxillary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimInterface (abstract class) for param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:33745,perform,performing,33745,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['perform'],['performing']
Performance,"CMAKE_INSTALL_xxxDIR, wherexxx isBIN,LIB,INCLUDE, etc. The full list is described in the variables section.; To use the location independent installation requires to set environment variables PATH and LD_LIBRARY_PATH. This is done by sourcing the script (depending on the shell family) source bin/thisroot.sh. While to use the fix location installation you do not need to set any environment to run root.; Do the installation of ROOT from the build directory:; $ cmake --build . --target install. The --target option with install parameter in addition to the --build option tells cmake to build the 'install' target. This is equivalent to make install for Unix systems. ; It is possible to set a different install prefix at installation time by invoking the cmake_install.cmake script generated in the build directory:; $ cmake -DCMAKE_INSTALL_PREFIX=/tmp/root -P cmake_install.cmake. Build Options; Each build option is a boolean variable that can be turned ON or OFF. The current value is recorded in the CMake cache (CMakeCache.txt file on the build directory) and therefore it is not needed to be specified on the cmake command each time. Please note that some of the options might be turned OFF automatically for some platforms or if the required external library or component can not be satisfied. The user can view and edit the full list of options using the ccmake utility or cmake-gui for Windows. Note that some of the options are not yet implemented.; The user can set any CMake variable or option that controls the build process from the cmake command line. The command using the option -D <var>:<type>=<value> creates an entry in the CMake cache. This is the list of the ROOT specific CMake options:. option name; default value; description. afdsmgrd; OFF; Dataset manager for PROOF-based analysis facilities. afs; OFF; AFS support, requires AFS libs and objects. alien; ON; AliEn support, requires libgapiUI from ALICE. all; OFF; Enable all optional components. asimage; ON; Image proce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:6249,cache,cache,6249,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance,"CN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types: Stores the coordinates and the DataOptions ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ;  CSparseData;  CUnBinDataClass describing the unbinned data sets (just x coordinates values) of any dimensions ;  ►NInternal;  ►NExecutorUtils;  CResultCaster;  CResultCaster< TObject *, F >;  ►NRDF;  CRAction;  CRActionBase;  CTColumnValueHelper class that updates and returns TTree branches as well as RDataFrame temporary columns ;  CTRDFValueTuple;  CTRDFValueTuple< TypeList< BranchTypes.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:24586,perform,performing,24586,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['perform'],['performing']
Performance,"CNBase&); virtual voidROOT::Minuit2::FCNBase::SetErrorDef(double); virtual doubleROOT::Minuit2::FCNBase::Up() const; virtual doubleValue() const. protected:. vector<double>&Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id$ » Last ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__FumiliFCNBase.html:2641,cache,cached,2641,root/html534/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,"CNBase&); virtual voidROOT::Minuit2::FCNBase::SetErrorDef(double); virtual doubleROOT::Minuit2::FCNBase::Up() const; virtual doubleValue() const. protected:. vector<double>&Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id: FumiliFCN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__FumiliFCNBase.html:2639,cache,cached,2639,root/html528/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__FumiliFCNBase.html,3,['cache'],['cached']
Performance,"CStudy object. ; Definition at line 300 of file RooMCStudy.cxx. ◆ calcPulls(). void RooMCStudy::calcPulls ; (; ). protected . Calculate the pulls for all fit parameters in the fit results data set, and add them to that dataset. ; Definition at line 727 of file RooMCStudy.cxx. ◆ Class(). static TClass * RooMCStudy::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooMCStudy::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooMCStudy::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 152 of file RooMCStudy.h. ◆ DeclFileName(). static const char * RooMCStudy::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 152 of file RooMCStudy.h. ◆ doFit(). RooFit::OwningPtr< RooFitResult > RooMCStudy::doFit ; (; RooAbsData * ; genSample). protected . Internal function. Performs actual fit according to specifications. ; Definition at line 588 of file RooMCStudy.cxx. ◆ fit() [1/2]. bool RooMCStudy::fit ; (; Int_t ; nSamples, . const char * ; asciiFilePat . ). Fit 'nSamples' datasets, which are read from ASCII files. ; The ascii file pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat"" and should contain one integer field that encodes the sample serial number. ; Definition at line 542 of file RooMCStudy.cxx. ◆ fit() [2/2]. bool RooMCStudy::fit ; (; Int_t ; nSamples, . TList & ; dataSetList . ). Fit 'nSamples' datasets, as supplied in 'dataSetList'. ; Definition at line 557 of file RooMCStudy.cxx. ◆ fitParams(). const RooArgSet * RooMCStudy::fitParams ; (; Int_t ; sampleNum); const. Return an argset with the fit parameters for the given sample number. ; NB: The fit parameters are only stored for successful fits, thus the maximum sampleNum can be less that the number of generated samples and if so, the indices will be out of synch with genD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:24247,Perform,Performs,24247,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['Perform'],['Performs']
Performance,"CTAxisEditor;  CTBackCompFitterBackward compatible implementation of TVirtualFitter ;  CTBase64This code implements the Base64 encoding and decoding ;  CTBaseClassEach class (see TClass) has a linked list of its base class(es) ;  CTBasketManages buffers for branches of a Tree ;  CTBasketSQLImplement TBasket for a SQL backend ;  CTBenchmarkThis class is a ROOT utility to help benchmarking applications ;  CTBinomialEfficiencyFitterBinomial fitter for the division of two histograms ;  ►CTBitsContainer of bits ;  CTReference;  CTBonjourBrowser;  CTBonjourRecord;  CTBonjourRegistrar;  CTBonjourResolver;  CTBoxCreate a Box ;  CTBranchA TTree is a list of TBranches ;  CTBranchClonesA Branch for the case of an array of clone objects ;  CTBranchElementA Branch for the case of an object ;  CTBranchObjectA Branch for the case of an object ;  CTBranchRefA branch containing and managing a TRefTable for TRef autoloading ;  ►CTBranchSTLA Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while storing them in split mode ;  CElementBranchHelper_t;  CTBRIKA box with faces perpendicular to the axes ;  CTBrowserUsing a TBrowser one can browse all ROOT objects ;  CTBrowserImpABC describing GUI independent browser implementation protocol ;  CTBrowserPlugin;  CTBtInnerNodeInner node of a TBtree ;  CTBtItemItem stored in inner nodes of a TBtree ;  CTBtLeafNodeLeaf node of a TBtree ;  CTBtNodeAbstract base class (ABC) of a TBtree node ;  CTBtreeB-tree class ;  CTBtreeIterIterator of btree ;  CTBufferBuffer base class used for serializing objects ;  CTBuffer3DGeneric 3D primitive description class ;  CTBuffer3DCutTubeCut tube segment description class - see TBuffer3DTypes for producer classes ;  CTBuffer3DSphereSphere description class - see TBuffer3DTypes for producer classes Supports hollow and cut spheres ;  CTBuffer3DTubeComplete tube description class - see TBuffer3DTypes for producer classes ;  CTBuffer3DTubeSegTube segment description class - see T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:90410,queue,queues,90410,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['queue'],['queues']
Performance,"Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24662,cache,cache,24662,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified bra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22771,cache,cache,22771,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['cache'],['cache']
Performance,"Cache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:13862,cache,cache,13862,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,1,['cache'],['cache']
Performance,"Cache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:14762,cache,cache,14762,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,7,['cache'],['cache']
Performance,Cache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for abov,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:38147,cache,cache,38147,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,1,['cache'],['cache']
Performance,Cache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStrin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedPdf.html:38577,cache,cache,38577,root/html528/RooCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooCachedPdf.html,3,['cache'],['cache']
Performance,Cache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:41967,cache,cache,41967,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"Cache.; Definition at line 948 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 962 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 502 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Long64_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; The buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 360 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 376 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:34835,cache,cache,34835,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"Cache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:43591,Perform,Perform,43591,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['Perform'],['Perform']
Performance,"Cache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2251 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:43595,Perform,Perform,43595,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['Perform'],['Perform']
Performance,"CacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4183,cache,cache,4183,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,2,['cache'],['cache']
Performance,"CacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxydm; RooRealProxydm0; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDstD0BG.html:44242,cache,cache,44242,root/html602/RooDstD0BG.html,https://root.cern,https://root.cern/root/html602/RooDstD0BG.html,2,['cache'],['cache']
Performance,"CacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:40327,cache,cache,40327,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,44,['cache'],['cache']
Performance,"CacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; TString_sigCatNameName of accept state of accept/reject category; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEfficiency.html:39726,cache,cache,39726,root/html532/RooEfficiency.html,https://root.cern,https://root.cern/root/html532/RooEfficiency.html,1,['cache'],['cache']
Performance,"CacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:32007,cache,cached,32007,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,3,['cache'],['cached']
Performance,"CacheRead.cxx. ◆ SetEnablePrefetching(). void TFileCacheRead::SetEnablePrefetching ; (; Bool_t ; setPrefetching = kFALSE). virtual . Set the prefetching mode of this file. ; If 'setPrefetching', enable the asynchronous prefetching (using TFilePrefetch) and if the gEnv and rootrc variable Cache.Directory is set, also enable the local caching of the prefetched blocks. if 'setPrefetching', the old prefetcher is enabled is the gEnv and rootrc variable is TFile.AsyncReading ; Definition at line 774 of file TFileCacheRead.cxx. ◆ SetEnablePrefetchingImpl(). void TFileCacheRead::SetEnablePrefetchingImpl ; (; Bool_t ; setPrefetching = kFALSE). protected . TFileCacheRead implementation of SetEnablePrefetching. ; This function is called from the constructor and should not be virtual. ; Definition at line 784 of file TFileCacheRead.cxx. ◆ SetFile(). void TFileCacheRead::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). virtual . Set the file using this cache and reset the current blocks (if any). ; Reimplemented in TTreeCache.; Definition at line 545 of file TFileCacheRead.cxx. ◆ SetSkipZip(). virtual void TFileCacheRead::SetSkipZip ; (; Bool_t ; = kTRUE). inlinevirtual . Definition at line 112 of file TFileCacheRead.h. ◆ Sort(). void TFileCacheRead::Sort ; (; ). virtual . Sort buffers to be prefetched in increasing order of positions. ; Merge consecutive blocks if necessary. ; Definition at line 572 of file TFileCacheRead.cxx. ◆ Streamer(). void TFileCacheRead::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TTreeCache, and TTreeCacheUnzip. ◆ StreamerNVirtual(). void TFileCacheRead::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 119 of file TFileCacheRead.h. ◆ WaitFinishPrefetch(). void TFileCacheRead::WaitFinishPrefetch ; (; ). virtual . Definition at line 691 of file TFileCacheRead.cxx. Member Data Documentation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:24844,cache,cache,24844,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cache']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:2979,cache,cacheUniqueSuffix,2979,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:2759,cache,cacheUniqueSuffix,2759,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:2360,cache,cacheUniqueSuffix,2360,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,4,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:3659,cache,cacheUniqueSuffix,3659,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:2759,cache,cacheUniqueSuffix,2759,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:2360,cache,cacheUniqueSuffix,2360,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,3,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:5961,cache,cacheUniqueSuffix,5961,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:2773,cache,cacheUniqueSuffix,2773,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:2773,cache,cacheUniqueSuffix,2773,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConvCoefVar.html:2302,cache,cacheUniqueSuffix,2302,root/html534/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html534/RooConvCoefVar.html,4,['cache'],['cacheUniqueSuffix']
Performance,"CacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConvCoefVar.html:2302,cache,cacheUniqueSuffix,2302,root/html532/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html532/RooConvCoefVar.html,1,['cache'],['cacheUniqueSuffix']
Performance,"CacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:14565,queue,queue,14565,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,6,['queue'],['queue']
Performance,CacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * fExternalFriends;  ! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned. ;  ; Int_t fFileNumber;  ! current file number (if file extensions) ;  ; Long64_t fFlushedBytes;  Number of auto-flushed bytes. ;  ; UInt_t fFriendLockStatus;  ! Record which method is locking the friend recursion ;  ; TList * fFriends;  pointer to list of friend elements ;  ; bool fIMTEnabled;  ! true if implicit multi-threading is enabled for this tree ;  ; TArrayI fIndex;  Index of sorted values. ;  ; TArrayD fIndexValues;  Sorted index values. ;  ; TIOFeatures fIOFeatures {0};  IO features to define for newly-written baskets and branches. ;  ; TObjArray fLeaves;  Direct pointers to individual branch leaves. ;  ; Int_t fMakeClass;  ! not zero when processing code generated by MakeClass ;  ; Int_t fMaxClusterRange;  ! Memory allocated for the cluster range. ;  ; Long64_t fMaxEntries;  Maximum number of entries in case of circular buffers. ;  ; Long64_t fMaxEntryLoop;  Maxim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:40974,Load,LoadTree,40974,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,9,['Load'],['LoadTree']
Performance,"Cached covariance matrix (NxN) ;  ; std::shared_ptr< ROOT::Fit::FitData > fFitData;  ! Data of the fit ;  ; std::shared_ptr< ROOT::Fit::Fitter > fFitter;  ! Pointer to fitter object ;  ; ROOT::Math::Minimizer * fMinimizer;  ; ROOT::Math::IParamMultiFunction * fModelFunc;  ; ROOT::Math::IMultiGenFunction * fObjFunc;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TVirtualFitter; Double_t * fCache;  [fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words) ;  ; Int_t fCacheSize;  Size of the fCache array. ;  ; void(* fFCN )(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  ; TMethodCall * fMethodCall;  Pointer to MethodCall in case of interpreted function. ;  ; Int_t fNpoints;  Number of points to fit. ;  ; TObject * fObjectFit;  Pointer to object being fitted. ;  ; Foption_t fOption;  Struct with the fit options. ;  ; Int_t fPointSize;  Number of words per point in the cache. ;  ; TObject * fUserFunc;  Pointer to user theoretical function (a TF1*) ;  ; Int_t fXfirst;  First bin on X axis. ;  ; Int_t fXlast;  Last bin on X axis. ;  ; Int_t fYfirst;  First bin on Y axis. ;  ; Int_t fYlast;  Last bin on Y axis. ;  ; Int_t fZfirst;  First bin on Z axis. ;  ; Int_t fZlast;  Last bin on Z axis. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TBackCompFitter.h>. Inheritance diagram for TBackCompFitter:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TBackCompFitter::EStatusBits. EnumeratorkCanDeleteLast . Definition at line 52 of file TBackCompFitter.h. Constructor & Destructor Documentation. ◆ TBackCompFitter() [1/2]. TBackCompFitter::TBackCompFitter ; (; ). Constructor needed by TVirtualFitter interface. ; Same behavior as default constructor. initialize setting name and the globa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBackCompFitter.html:22571,cache,cache,22571,doc/master/classTBackCompFitter.html,https://root.cern,https://root.cern/doc/master/classTBackCompFitter.html,1,['cache'],['cache']
Performance,"CachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:58682,Cache,Cache,58682,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,3,['Cache'],['Cache']
Performance,"CameraXOZ!; TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStereoEyeOffsetFac!; Float_tfStereoFrustumAsymFac!; Float_tfStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectfViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad viewer i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:21789,cache,cache,21789,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,4,['cache'],['cache']
Performance,"CanCreateObjects {kTRUE};  ! indicates if canvas allowed to create extra objects for interactive painting ;  ; Long64_t fCanvVersion {1};  ! actual canvas version, changed with every new Modified() call ;  ; UInt_t fClientBits {0};  ! latest status bits from client like editor visible or not ;  ; UInt_t fColorsHash {0};  ! last hash of colors/palette ;  ; Long64_t fColorsVersion {0};  ! current colors/palette version, checked every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique_ptr< ROOT::RWebDisplayHandle > > fHelpHandles;  ! array of handles for help widgets ;  ; Int_t fJsonComp {0};  ! compression factor for messages send to the client ;  ; Bool_t fLongerPolling {kFALSE};  ! when true, make longer polling in blocking operations ;  ; ObjectSelectSignal_t fObjSelectSignal;  ! signal emitted when new object selected in the pad ;  ; PadClickedSignal_t fPadClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; PadClickedSignal_t fPadDblClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; std::map< TPad *, PadStatus > fPadsStatus;  ! map of pads in canvas and their status flags ;  ; Int_t fPaletteDelivery {1};  ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ;  ; Int_t fPrimitivesMerge {100};  ! number of PS primitives, which will be merged together ;  ; Bool_t fProcessingData {kFALSE};  ! flag used to prevent blocking methods when process data is invoked ;  ; Bool_t fReadOnly {kFALSE};  !< configured display ;  ; Int_t fStyleDelivery {0};  ! gStyle delivery to clients: 0:never, 1:once, 2:always ;  ; UInt_t fStyleHash {0};  ! last hash of gStyle ;  ; Long64_t fStyleVersion {0};  ! current gStyle object version, checked every time when new snapshot created ;  ; Int_t fTF1UseSave {1};  ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ;  ; TWebCanvasTimer * fTimer {nullptr};  ! timer to submit control messages ;  ; Updat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:14873,perform,performed,14873,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['perform'],['performed']
Performance,"CanNotBeExtended. ; Reimplemented from RooAbsPdf.; Definition at line 59 of file RooNormalizedPdf.h. ◆ forceAnalyticalInt(). bool RooNormalizedPdf::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 46 of file RooNormalizedPdf.h. ◆ getAnalyticalIntegralWN(). Int_t RooNormalizedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; , . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Forward determination of analytical integration capabilities to input p.d.f. ; Reimplemented from RooAbsReal.; Definition at line 48 of file RooNormalizedPdf.h. ◆ getValV(). double RooNormalizedPdf::getValV ; (; const RooArgSet * ; nset); const. inlineoverrideprotectedvirtual . Return current value, normalized by integrating over the observables in nset. ; If nset is 0, the unnormalized value is returned. All elements of nset must be lvalues.; Unnormalized values are not cached. Doing so would be complicated as _norm->getVal() could spoil the cache and interfere with returning the cached return value. Since unnormalized calls are typically done in integration calls, there is no performance hit. ; Reimplemented from RooAbsPdf.; Definition at line 79 of file RooNormalizedPdf.h. ◆ selfNormalized(). bool RooNormalizedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 44 of file RooNormalizedPdf.h. ◆ translate(). void RooNormalizedPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNormalizedPdf.html:77037,cache,cached,77037,doc/master/classRooNormalizedPdf.html,https://root.cern,https://root.cern/doc/master/classRooNormalizedPdf.html,1,['cache'],['cached']
Performance,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQueryResult.html:7259,load,loaded,7259,root/html528/TQueryResult.html,https://root.cern,https://root.cern/root/html528/TQueryResult.html,6,['load'],['loaded']
Performance,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Old WMIN,WMAX .; BinLow,B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THLimitsFinder.html:6739,optimiz,optimized,6739,root/html528/THLimitsFinder.html,https://root.cern,https://root.cern/root/html528/THLimitsFinder.html,2,['optimiz'],['optimized']
Performance,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Original axis limits; Bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THLimitsFinder.html:6808,optimiz,optimized,6808,root/html532/THLimitsFinder.html,https://root.cern,https://root.cern/root/html532/THLimitsFinder.html,2,['optimiz'],['optimized']
Performance,"CannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. ←; TSortedList. Function documentation; void Add(TObject* obj); Add object in sorted list. Uses object Compare() member to find right; position. void Add(TObject* obj, Option_t* opt); Add object in sorted list. Uses object Compare() member to find right; position and also store option. See TList::Add for explanation of; usage of option. TSortedList(Bool_t order = kSortAscending); { fAscending = order; }. Bool_t IsSorted() const; { return kTRUE; }. void AddFirst(TObject* obj); ---- the following methods are overridden to preserve sorting order. { Add(obj); }. void AddFirst(TObject* obj, Option_t* opt); { Add(obj, opt); }. void AddLast(TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSortedList.html:10162,cache,cache,10162,root/html602/TSortedList.html,https://root.cern,https://root.cern/root/html602/TSortedList.html,2,['cache'],['cache']
Performance,"CannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridResult(); { SetOwner(kTRUE); }. virtual ~TGridResult(); { }. const char * GetFileName(UInt_t ) const; { MayNotUse(""GetFileName""); return 0; }. const char * GetFileNamePath(UInt_t ) const; { MayNotUse(""GetFileNamePath""); return 0; }. const char * GetPath(UInt_t ) const; { MayNotUse(""GetPath""); return 0; }. const TEntryList * GetEntryList(UInt_t ) const; { MayNotUse(""GetEntryList""); return 0; }. const char * GetKey(UInt_t , const char* ) const; { MayNotUse(""GetKey""); return 0; }. Bool_t SetKey(UInt_t , const char* , const char* ); { MayNotUse(""SetKey""); return 0; }. TList * GetFileInfoList() const; { MayNotUse(""GetFileInfoList""); retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGridResult.html:10558,cache,cache,10558,root/html602/TGridResult.html,https://root.cern,https://root.cern/root/html602/TGridResult.html,2,['cache'],['cache']
Performance,"CannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObjOptLink * findLink(const char* name, const char* caller = 0) const; Find the link corresponding to the named object in this list.; Return 0 if the object is not found or does not have an Option_t; string associated with its link. Also print a warning message; if caller is non-zero. Bool_t moveBefore(const char* before, const char* target, const char* caller = 0); Move the target object immediately before the specified object,; preserving any Option_t associated with the target link. Bool_t moveAfter(const char* after, const char* target, const char* caller = 0); Move the target object immediately after the specified object,; preservin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooList.html:10415,cache,cache,10415,root/html602/RooList.html,https://root.cern,https://root.cern/root/html602/RooList.html,2,['cache'],['cache']
Performance,"CannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. TList*fDontShowlist of reg expression defining what should not be shown. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofOutputList(const char* dontshow = ""PROOF_*""); Constructor. ~TProofOutputList(); Destructor. void AttachList(TList* alist); Attach to list 'alist'. void ls(Option_t* option = """") const; List the content of the list. void Print(Option_t* option = """") const; Print the content of the list. TProofOutputList(const char* dontshow = ""PROOF_*""). TProofOutputList(TObject* o); { }. void Print(Option_t* option = """") const. void Print(Option_t* option, Int_t recurse) const; { TCollection::Print(option, recurse); }. void Print(Option_t* option, const char* wildcard",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofOutputList.html:10291,cache,cache,10291,root/html602/TProofOutputList.html,https://root.cern,https://root.cern/root/html602/TProofOutputList.html,2,['cache'],['cache']
Performance,"Canvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop. A conveniece definition kOnce is provided to make this fact more expressive in user code (see snippet below). Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will be executed sequentially. Callbacks are executed in the order they were registered. The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g. auto h = tdf.Histo1D(""x"");; // h.kOnce is 0; // decltype(h)::Value_t is TH1D; When implicit multi-threading is enabled, the callback:; will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from one call to the next; might be executed by a different worker thread at different times: the value of std::this_thread::get_id() might change between calls. To register a callback that is called by each worker thread (concurrently) every N events one can use OnPartialResultSlot(). ; Definition at line 318 of file RResultPtr.hxx. ◆ OnPartialResultSlot(). template<typename T > . RResultPtr< T > & ROOT::RDF::RResultPtr< T >::OnPartialResultSlot ; (; ULong64_t ; everyNEvents, . std::function< void(unsigned int, T &)> ; callback . ). inline . Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ; Parameters. [in]everyNEventsFrequency at which the callback will be called by each thread, as a number of events processed ; [in]callbackA callable with signature void(unsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:11269,multi-thread,multi-thread,11269,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['multi-thread'],['multi-thread']
Performance,"CanvasImp.h. ◆ InitWindow(). virtual Int_t TCanvasImp::InitWindow ; (; ). inlinevirtual . Reimplemented in TRootCanvas, and TWebCanvas.; Definition at line 68 of file TCanvasImp.h. ◆ IsA(). virtual TClass * TCanvasImp::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented in TRootCanvas, and TWebCanvas.; Definition at line 90 of file TCanvasImp.h. ◆ IsLocked(). virtual Bool_t TCanvasImp::IsLocked ; (; ). inlineprotectedvirtual . Reimplemented in TWebCanvas.; Definition at line 46 of file TCanvasImp.h. ◆ IsWeb(). virtual Bool_t TCanvasImp::IsWeb ; (; ); const. inlineprotectedvirtual . Reimplemented in TWebCanvas.; Definition at line 48 of file TCanvasImp.h. ◆ Lock(). virtual void TCanvasImp::Lock ; (; ). inlineprotectedvirtual . Reimplemented in TWebCanvas.; Definition at line 44 of file TCanvasImp.h. ◆ operator=(). TCanvasImp & TCanvasImp::operator= ; (; const TCanvasImp & ; ci). inlineprotected . Definition at line 37 of file TCanvasImp.h. ◆ PerformUpdate(). virtual Bool_t TCanvasImp::PerformUpdate ; (; Bool_t ; ). inlineprotectedvirtual . Reimplemented in TWebCanvas.; Definition at line 49 of file TCanvasImp.h. ◆ RaiseWindow(). virtual void TCanvasImp::RaiseWindow ; (; ). inlinevirtual . Reimplemented in TRootCanvas, and TWebCanvas.; Definition at line 77 of file TCanvasImp.h. ◆ ReallyDelete(). virtual void TCanvasImp::ReallyDelete ; (; ). inlinevirtual . Reimplemented in TRootCanvas.; Definition at line 78 of file TCanvasImp.h. ◆ SetCanvasSize(). virtual void TCanvasImp::SetCanvasSize ; (; UInt_t ; w, . UInt_t ; h . ). inlinevirtual . Reimplemented in TRootCanvas, and TWebCanvas.; Definition at line 73 of file TCanvasImp.h. ◆ SetStatusText(). virtual void TCanvasImp::SetStatusText ; (; const char * ; text = nullptr, . Int_t ; partidx = 0 . ). inlinevirtual . Reimplemented in TRootCanvas.; Definition at line 69 of file TCanvasImp.h. ◆ SetWindowPosition(). virtual void TCanvasImp::SetWindowPosition ; (; Int_t ; x, . Int_t ; y . )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvasImp.html:7010,Perform,PerformUpdate,7010,doc/master/classTCanvasImp.html,https://root.cern,https://root.cern/doc/master/classTCanvasImp.html,1,['Perform'],['PerformUpdate']
Performance,"CatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategoryLValue.html:18238,optimiz,optimizeDirtyHook,18238,root/html530/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"CatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:19501,optimiz,optimizeDirtyHook,19501,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"Category(); RooThresholdCategory(const RooThresholdCategory& other, const char* name = 0); RooThresholdCategory(const char* name, const char* title, RooAbsReal& inputVar, const char* defCatName = ""Default"", Int_t defCatIdx = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:15029,cache,cache,15029,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['cache'],['cache']
Performance,"CategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:20718,Cache,CacheMode,20718,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['Cache'],['CacheMode']
Performance,"Chain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646449,load,loads,646449,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"Chain.cxx. ◆ InPlaceClone(). bool TChain::InPlaceClone ; (; TDirectory * ; newdirectory, . const char * ; options = """" . ). overridevirtual . Move content to a new file. (NOT IMPLEMENTED for TChain) ; Reimplemented from TTree.; Definition at line 1233 of file TChain.cxx. ◆ InvalidateCurrentTree(). void TChain::InvalidateCurrentTree ; (; ). protected . Set the TTree to be reloaded as soon as possible. ; In particular this is needed when adding a Friend.; If the tree has clones, copy them into the chain clone list so we can change their branch addresses when necessary.; This is to support the syntax: TTree* clone = chain->GetTree()->CloneTree(0);; cloneTObject * clone(const char *newname) const overrideDefinition RooChi2Var.h:9. Definition at line 1252 of file TChain.cxx. ◆ IsA(). TClass * TChain::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 173 of file TChain.h. ◆ LoadBaskets(). Int_t TChain::LoadBaskets ; (; Long64_t ; maxmemory). overridevirtual . Dummy function. ; It could be implemented and load all baskets of all trees in the chain. For the time being use TChain::Merge and TTree::LoadBasket on the resulting tree. ; Reimplemented from TTree.; Definition at line 1270 of file TChain.cxx. ◆ LoadTree(). Long64_t TChain::LoadTree ; (; Long64_t ; entry). overridevirtual . Find the tree which contains entry, and set it as the current tree. ; Returns the entry number in that tree.; The input argument entry is the entry serial number in the whole chain.; In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number is less than zero or too large for the chain.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or the TTree is missing from the file.; -5: Internal error, please report the circumstance when this happen as a ROOT issu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:80319,Load,LoadBaskets,80319,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['Load'],['LoadBaskets']
Performance,"Check if we have to skip the branch; 1537 if (!drawDaughters || last || !daughter->IsVisDaughters()); 1538 next.Skip();; 1539 }; 1540 }; 1541 if (fPlugin); 1542 fPlugin->SetIterator(nullptr);; 1543 fGeoManager->SetMatrixReflection(kFALSE);; 1544 fVisLock = kTRUE;; 1545}; 1546 ; 1547////////////////////////////////////////////////////////////////////////////////; 1548/// Paint the supplied shape into the current 3D viewer; 1549 ; 1550Bool_t TGeoPainter::PaintShape(const TGeoShape &shape, Option_t *option) const; 1551{; 1552 Bool_t addDaughters = kTRUE;; 1553 ; 1554 TVirtualViewer3D *viewer = gPad->GetViewer3D();; 1555 ; 1556 if (!viewer || shape.IsA() == TGeoShapeAssembly::Class()) {; 1557 return addDaughters;; 1558 }; 1559 ; 1560 // For non-composite shapes we are the main paint method & perform the negotiation; 1561 // with the viewer here; 1562 if (!shape.IsComposite()) {; 1563 // Does viewer prefer local frame positions?; 1564 Bool_t localFrame = viewer->PreferLocalFrame();; 1565 // Perform first fetch of buffer from the shape and try adding it; 1566 // to the viewer; 1567 const TBuffer3D &buffer =; 1568 shape.GetBuffer3D(TBuffer3D::kCore | TBuffer3D::kBoundingBox | TBuffer3D::kShapeSpecific, localFrame);; 1569 Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; 1570 ; 1571 // If the viewer requires additional sections fetch from the shape (if possible); 1572 // and add again; 1573 if (reqSections != TBuffer3D::kNone) {; 1574 shape.GetBuffer3D(reqSections, localFrame);; 1575 viewer->AddObject(buffer, &addDaughters);; 1576 }; 1577 }; 1578 // Composite shapes have their own internal hierarchy of shapes, each; 1579 // of which generate a filled TBuffer3D. Therefore we can't pass up a; 1580 // single buffer to here. So as a special case the TGeoCompositeShape; 1581 // performs it's own painting & negotiation with the viewer.; 1582 else {; 1583 const TGeoCompositeShape *composite = static_cast<const TGeoCompositeShape *>(&shape);; 1584 ; 1585 // We need the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:50338,Perform,Perform,50338,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['Perform'],['Perform']
Performance,"CheckModuleBuildClient::HandleDiagnosticvirtual void HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel, const clang::Diagnostic &Info) overrideDefinition rootcling_impl.cxx:3586; CheckModuleBuildClient::clearvirtual void clear() overrideDefinition rootcling_impl.cxx:3648; CheckModuleBuildClient::IncludeInDiagnosticCountsvirtual bool IncludeInDiagnosticCounts() const overrideDefinition rootcling_impl.cxx:3672; CheckModuleBuildClient::fMapclang::ModuleMap & fMapDefinition rootcling_impl.cxx:3572; CheckModuleBuildClient::EndSourceFilevirtual void EndSourceFile() overrideDefinition rootcling_impl.cxx:3660; CheckModuleBuildClient::fOwnsChildbool fOwnsChildDefinition rootcling_impl.cxx:3571; ClassSelectionRuleDefinition ClassSelectionRule.h:34; ClassSelectionRule::GetFieldSelectionRulesconst std::list< VariableSelectionRule > & GetFieldSelectionRules() constDefinition ClassSelectionRule.cxx:32; LinkdefReaderDefinition LinkdefReader.h:41; LinkdefReader::LoadIncludesbool LoadIncludes(std::string &extraInclude)Definition LinkdefReader.cxx:511; LinkdefReader::Parsebool Parse(SelectionRules &sr, llvm::StringRef code, const std::vector< std::string > &parserArgs, const char *llvmdir)Definition LinkdefReader.cxx:1050; ROOT::Internal::DictSelectionReaderDefinition DictSelectionReader.h:238; ROOT::Internal::RStl::GenerateTClassForvoid GenerateTClassFor(const char *requestedName, const clang::CXXRecordDecl *stlClass, const cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt)Definition RStl.cxx:130; ROOT::Internal::RStl::Instancestatic RStl & Instance()Definition RStl.cxx:40; ROOT::Internal::RStl::WriteClassInitvoid WriteClassInit(std::ostream &strm, const cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, const ROOT::TMetaUtils::RConstructorTypes &, bool &needCollectionProxy, void(*emitStreamerInfo)(const char *))Definition RStl.cxx:206; ROOT::TMetaUtils::AnnotatedRecordDeclDefinition TClingUtils.h:191; ROOT::TMetaUtils",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:253574,Load,LoadIncludesbool,253574,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,2,['Load'],"['LoadIncludes', 'LoadIncludesbool']"
Performance,"CheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooIntegralMorph(); RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); RooIntegralMorph(const char* name, const char* title, RooAbsReal& _pdf1, RooAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetCacheAlpha(Bool_t flag); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:32030,cache,cacheAlpha,32030,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,2,['cache'],['cacheAlpha']
Performance,"Chi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooArgSet& projDeps, RooChi2Var::FuncMode funcMode, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooDataHist::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const RooChi2Var& other, const char* name = 0); Copy constructor. ~RooChi2Var(); Destructor. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. TObject* clone(const char* newname) const; { return new RooChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, Bool_t = kFALSE); Virtual constructor. Double_t def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:49066,load,load,49066,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['load'],['load']
Performance,"Cint::GetTopLevelMacroName() << std::endl;; }. mymacro.C. #include <iostream>; #include ""inclfile.h""; void mymacro() {; std::cout << ""In mymacro.C"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; std::cout << "" Now calling inclfunc..."" << std::endl;; inclfunc();; }. Running mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload libr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:27400,Load,LoadLibraryMap,27400,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,8,['Load'],"['Load', 'LoadLibraryMap']"
Performance,"Cint::GetTopLevelMacroName() << std::endl;; }. mymacro.C. #include <iostream>; #include ""inclfile.h""; void mymacro() {; std::cout << ""In mymacro.C"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; std::cout << "" Now calling inclfunc..."" << std::endl;; inclfunc();; }. Running mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if successful. Int_t UnloadLibraryMap(const char* library); Unload lib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:28917,Load,LoadLibraryMap,28917,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['Load'],"['Load', 'LoadLibraryMap']"
Performance,"Class (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:118122,load,loadedcl,118122,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClassDefault', 'loadedcl']"
Performance,"Class (if one is requested for the pair).; 3164 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3165 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3166 ; 3167 TClass *loadedcl = nullptr;; 3168 if (checkTable) {; 3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be pertinent to the normalization of the name.; 3174 // For example it might contain or be a typedef for which we don't; 3175 // have a forward declaration (eg. typedef to instance of class; 3176 // template with default parameters). So let's redo the normalization; 3177 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3178 // lead to a different value.; 3179 {; 3180 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3186 if (e); 3187 return nullptr;; 3188 // Maybe this was a typedef: let's try to see if this is the case; 3189 if (!loadedcl && !ispair && !ispairbase) {; 3190 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3191 // We have a typedef: we get the name of the underlying type; 3192 auto underlyingTypeName = theDataType->GetTypeName();; 3193 // We see if we can bootstrap a class with it; 3194 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3195 if (underlyingTypeDict){; 3196 loadedcl = underlyingTypeDict();; 3197 }; 3198 ; 3199 }; 3200 }; 3201 }; 3202 if (loadedcl) return loadedcl;; 3203 ; 3204 // See if the TClassGenerator can produce the TClass we need.; 3205 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3206 if (loadedcl) return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:120873,load,loadedcl,120873,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClassDefault', 'loadedcl']"
Performance,"Class * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fFixedSize {false};  if canvas draw size is fixed ;  ; bool fHighlightConnect {false};  does HighlightConnect has connection ;  ; std::string fScripts;  custom scripts to load ;  ;  Protected Attributes inherited from TPadWebSnapshot; bool fActive {false};  true when pad is active ;  ; bool fBatchMode {false};  ! if object created for image generation ;  ; bool fHasExecs {false};  if true, more interactive events will be delivered from client ;  ; std::vector< std::unique_ptr< TWebSnapshot > > fPrimitives;  list of all primitives, drawn in the pad ;  ; bool fReadOnly {true};  when canvas or pad are in readonly mode ;  ; bool fSetObjectIds {true};  ! set objects ids ;  ; bool fWithoutPrimitives {false};  true when primitives not send while there are no modifications ;  ;  Protected Attributes inherited from TWebSnapshot; Int_t fKind {0};  kind of snapshots ;  ; std::string fObjectID;  object identifier ;  ; std::string fOption;  object draw option ;  ; Bool_t fOwner {kFALSE};  ! if objected owned ;  ; TObject * fSnapshot {nullptr};  snapshot data ;  . Additional Inherited Members;  Public Types inherited from TWebSnapshot; enum  { ;   kNone = 0; , kObject = 1; , kSVG = 2; , kSubPad = 3; , ;   kColors = 4; , kStyle = 5; , kFont = 6. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); ,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvasWebSnapshot.html:11304,load,load,11304,doc/master/classTCanvasWebSnapshot.html,https://root.cern,https://root.cern/doc/master/classTCanvasWebSnapshot.html,1,['load'],['load']
Performance,"Class * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; void Init (Int_t s, Int_t lowerBound);  Initialize a TObjArray. ;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TObject ** fCont;  ; Int_t fLast;  ; Int_t fLowerBound;  Array contents. ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Friends; class TClonesArray;  ; class TObjArrayIter;  . Additional Inherited Members;  Protected Types inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjArray.html:19166,perform,perform,19166,doc/master/classTObjArray.html,https://root.cern,https://root.cern/doc/master/classTObjArray.html,1,['perform'],['perform']
Performance,"Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawGraph Class Reference. . Definition at line 203 of file TProofDraw.h. Public Member Functions;  TProofDrawGraph ();  ; void Init (TTree *tree) override;  See TProofDraw::Init(). ;  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawGraph.html:1051,load,loaded,1051,doc/master/classTProofDrawGraph.html,https://root.cern,https://root.cern/doc/master/classTProofDrawGraph.html,1,['load'],['loaded']
Performance,"Class describing this class . ◆ Class_Name(). static const char * RooRealVar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooRealVar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 173 of file RooRealVar.h. ◆ cleanup(). void RooRealVar::cleanup ; (; ). static . Explicitly deletes the shared properties list on exit to avoid problems with the initialization order. ; Meant to be only used internally in RooFit by RooSentinel. ; Definition at line 75 of file RooRealVar.cxx. ◆ clone(). TObject * RooRealVar::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 48 of file RooRealVar.h. ◆ copyCache(). void RooRealVar::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache Warning: This function copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Reimplemented from RooAbsRealLValue.; Definition at line 1193 of file RooRealVar.cxx. ◆ copyCacheFast(). void RooRealVar::copyCacheFast ; (; const RooRealVar & ; other, . bool ; setValDirty = true . ). inline . Definition at line 131 of file RooRealVar.h. ◆ DeclFileName(). static const char * RooRealVar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 173 of file RooRealVar.h. ◆ defaultPrintContents(). Int_t RooRealVar::defaultPrintContents ; (; Option_t * ; opt); const. overridevirtual . Mapping of Print() option string to RooPrintable contents specifications. ; Reimplemented from RooAbsArg.; Definition at line 820 of file RooRealVar.cxx. ◆ deleteSharedProperties(). void RooRealVar::deleteSharedProperties ; (; ). Stop sharing properties. ; Definition at line 1318 of file RooRealVar.cxx. ◆ errorVar(). RooErrorVar * RooRealVar::er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:76993,cache,cached,76993,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,4,['cache'],"['cache', 'cached']"
Performance,"Class directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:23849,load,load,23849,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"Class for the given class.; 4665 ; 4666TClass *TCling::GenerateTClass(ClassInfo_t *classinfo, Bool_t silent /* = kFALSE */); 4667{; 4668 TClingClassInfo *info = (TClingClassInfo*)classinfo;; 4669 if (!info || !info->IsValid()) {; 4670 Fatal(""GenerateTClass"",""Requires a valid ClassInfo object"");; 4671 return nullptr;; 4672 }; 4673 // We are in the case where we have AST nodes for this class.; 4674 TClass *cl = nullptr;; 4675 std::string classname;; 4676 info->FullName(classname,*fNormalizedCtxt); // Could we use Name()?; 4677 if (TClassEdit::IsSTLCont(classname)) {; 4678#if 0; 4679 Info(""GenerateTClass"",""Will (try to) generate the compiled TClass for %s."",classname.c_str());; 4680 // We need to build up the list of required headers, by; 4681 // looking at each template arguments.; 4682 TString includes;; 4683 GenerateTClass_GatherInnerIncludes(fInterpreter,includes,info);; 4684 ; 4685 if (0 == GenerateDictionary(classname.c_str(),includes)) {; 4686 // 0 means success.; 4687 cl = TClass::LoadClass(classnam.c_str(), silent);; 4688 if (cl == 0) {; 4689 Error(""GenerateTClass"",""Even though the dictionary generation for %s seemed successful we can't find the TClass bootstrap!"",classname.c_str());; 4690 }; 4691 }; 4692#endif; 4693 if (cl == nullptr) {; 4694 int version = TClass::GetClass(""TVirtualStreamerInfo"")->GetClassVersion();; 4695 cl = new TClass(classinfo, version, nullptr, nullptr, -1, -1, silent);; 4696 }; 4697 } else {; 4698 // For regular class, just create a TClass on the fly ...; 4699 // Not quite useful yet, but that what CINT used to do anyway.; 4700 cl = new TClass(classinfo, 1, nullptr, nullptr, -1, -1, silent);; 4701 }; 4702 // Add the new TClass to the map of declid and TClass*.; 4703 if (cl) {; 4704 TClass::AddClassToDeclIdMap(((TClingClassInfo*)classinfo)->GetDeclId(), cl);; 4705 }; 4706 return cl;; 4707}; 4708 ; 4709////////////////////////////////////////////////////////////////////////////////; 4710/// Generate the dictionary for the C++ classes liste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:182420,Load,LoadClass,182420,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadClass']
Performance,"Class instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetPersistentRefTClass *const * GetPersistentRef() constDefinition TClass.h:481; TClass::GetCheckSumUInt_t GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6505; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::fObjectVersionRepositoryRepoCont_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:42035,load,load,42035,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance,"Class instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetPersistentRefTClass *const * GetPersistentRef() constDefinition TClass.h:481; TClass::GetCheckSumUInt_t GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6572; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::fObjectVersionRepositoryRepoCont_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3853; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1403; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7095; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:41863,load,load,41863,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance,"Class(); static voidcleanup(); static RooComplexComplexErrFunc(const RooComplex& z); static RooComplexComplexErrFunc(Double_t re, Double_t im = 0); static Double_terf(Double_t x); static Double_terfc(Double_t x); static RooComplexFastComplexErrFunc(const RooComplex& z); static Double_tFastComplexErrFuncIm(const RooComplex& z); static Double_tFastComplexErrFuncRe(const RooComplex& z); static Double_tinterpolate(Double_t* yArr, Int_t nOrder, Double_t x); static Double_tinterpolate(Double_t* xa, Double_t* ya, Int_t n, Double_t x); virtual TClass*IsA() const; static RooComplexITPComplexErrFunc(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncIm(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); RooMath&operator=(const RooMath&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static const char*cacheFileName(); static voidinitFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); static Bool_tloadCache(); static voidstoreCache(). Data Members; private:. static Bool_t_cacheTableSwitch activating use of file cache for CERF-LUT; static Int_t_imBinsNumber of grid points in imaginary dimension of CERF-LUT ; static double**_imCerfArrayLookup table for Im part of complex error function; static Double_t_imMaxHigh edge of imaginary dimension of CERF-LUT; static Double_t_imMinLow edge of imaginary dimension of CERF-LUT; static Double_t_imRangeRange in imaginary dimension of CERF-LUT; static Double_t_imStepGrid spacing in imaginary dimension of CERF-LUT; static Int_t_reBinsNumber of grid points in real dimension of CERF-LUT; static double**_reCerfArrayLookup table for Re part of complex error function; static Double_t_reMaxHigh edge of real dimension of CERF-LUT; static Double_t_reMinLow edge of real dimension of CERF-LUT; static Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMath.html:1392,cache,cacheFileName,1392,root/html526/RooMath.html,https://root.cern,https://root.cern/root/html526/RooMath.html,1,['cache'],['cacheFileName']
Performance,"Class*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TPerfStats&operator=(const TPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetMemValues(); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidSetup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPerfStats.html:4079,latency,latency,4079,root/html602/TPerfStats.html,https://root.cern,https://root.cern/root/html602/TPerfStats.html,2,['latency'],['latency']
Performance,"Class.h. ◆ fInstanceCount. UInt_t TClass::fInstanceCount. private . Definition at line 217 of file TClass.h. ◆ fIsA. TVirtualIsAProxy* TClass::fIsA. private . Definition at line 229 of file TClass.h. ◆ fIsAMethod. std::atomic<TMethodCall*> TClass::fIsAMethod. mutableprivate . Definition at line 231 of file TClass.h. ◆ fIsOffsetStreamerSet. std::atomic<Bool_t> TClass::fIsOffsetStreamerSet. mutableprivate . Indicates whether the ClassInfo is supposed to be available. ; Definition at line 261 of file TClass.h. ◆ fIsSyntheticPair. Bool_t TClass::fIsSyntheticPair. private . Indicates whether this class can be split or not. Values are -1, 0, 1, 2. ; Indicates whether this class represents a pair and was not created from a dictionary nor interpreter info but has compiler compatible offset and size (and all the info is in the StreamerInfo per se) ; Definition at line 250 of file TClass.h. ◆ fLastReadInfo. std::atomic<TVirtualStreamerInfo*> TClass::fLastReadInfo. mutableprivate . cached current streamer info. ; Definition at line 279 of file TClass.h. ◆ fMerge. ROOT::MergeFunc_t TClass::fMerge. private . saved info to call a IsA member function ; Definition at line 233 of file TClass.h. ◆ fMethod. std::atomic<TListOfFunctions*> TClass::fMethod. private . Definition at line 207 of file TClass.h. ◆ fNew. ROOT::NewFunc_t TClass::fNew. private . Definition at line 235 of file TClass.h. ◆ fNewArray. ROOT::NewArrFunc_t TClass::fNewArray. private . Definition at line 236 of file TClass.h. ◆ fNoInfoOrEmuOrFwdDeclNameRegistry. TClass::TDeclNameRegistry TClass::fNoInfoOrEmuOrFwdDeclNameRegistry. staticprivate . Definition at line 328 of file TClass.h. ◆ fObjectVersionRepository. RepoCont_t TClass::fObjectVersionRepository. mutableprivate . Definition at line 344 of file TClass.h. ◆ fOffsetStreamer. Longptr_t TClass::fOffsetStreamer. mutableprivate . Properties that can only be evaluated at run-time. ; Definition at line 275 of file TClass.h. ◆ fOnHeap. UInt_t TClass::fOnHeap. private ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:129543,cache,cached,129543,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['cache'],['cached']
Performance,"Class::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:58607,Load,LoadClassstatic,58607,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,2,['Load'],"['LoadClass', 'LoadClassstatic']"
Performance,"Class::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:324074,Load,LoadClassstatic,324074,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['Load'],"['LoadClass', 'LoadClassstatic']"
Performance,"Class::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7538; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6261; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2179; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:58435,Load,LoadClassstatic,58435,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['Load'],"['LoadClass', 'LoadClassstatic']"
Performance,"Class::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7538; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6261; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2179; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:326712,Load,LoadClassstatic,326712,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['Load'],"['LoadClass', 'LoadClassstatic']"
Performance,"ClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4258 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:103114,Load,LoadClassInfo,103114,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['Load'],['LoadClassInfo']
Performance,"ClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4325 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:103115,Load,LoadClassInfo,103115,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['Load'],['LoadClassInfo']
Performance,"ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; indentstatic void indent(ostringstream &buf, int indent_level)Definition TClingCallFunc.cxx:89; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; UniqueId.h; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsCacheElementAbstract base class for objects to be stored in RooAbsCache cache manager objects.Definition RooAbsCacheElement.h:26; RooAbsCacheElement::ActionActionDefinition RooAbsCacheElement.h:39; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsGenContextAbstract base class for generator contexts of RooAbsPdf objects.Definition RooAbsGenContext.h:26; RooAbsPdf::CacheElemNormalization set with for above integral.Definition RooAbsPdf.h:322; RooAbsPdf::CacheElem::_normstd::unique_ptr< RooAbsReal > _normDefinition RooAbsPdf.h:327; RooAbsPdf::CacheElem::~CacheElem~CacheElem() overrideDestructor of normalization cache element.Definition RooAbsPdf.cxx:2430; RooAbsPdf::CacheElem::CacheElemCacheElem(RooAbsReal &norm)Definition RooAbsPdf.h:324; RooAbsPdf::CacheElem::containedArgsRooArgList containedArgs(Action) overrideDefinition RooAbsPdf.h:326; RooAbsPdf::GenSpecDefinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:18199,cache,cache,18199,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['cache'],['cache']
Performance,"ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); function to read class from buffer, used in old-style streamers. void WriteClass(const TClass* cl); function to write class into buffer, used in old-style streamers. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. void CheckVersionBuf(); ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferXML.html:34280,Perform,PerformPreProcessing,34280,root/html534/TBufferXML.html,https://root.cern,https://root.cern/root/html534/TBufferXML.html,2,['Perform'],['PerformPreProcessing']
Performance,"ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as data member; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(fObj);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; See ClassBegin() method for more details. void PerformPostProcessing(); Function is converts TObject and TString structures to more compact representation. void PerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); Function is unpack TObject and TString structures to be able read; them from custom streamers of this objects. void BeforeIOoperation(); Function is called before any IO operation of TBuffer; Now is used to store version value if no proper calls are discovered. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. void CheckVersionBuf(); checks buffer, filled by WriteVersion; if next data is arriving, vers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferXML.html:35037,Perform,PerformPreProcessing,35037,root/html602/TBufferXML.html,https://root.cern,https://root.cern/root/html602/TBufferXML.html,1,['Perform'],['PerformPreProcessing']
Performance,"ClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:22729,load,load,22729,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Private Member Functions; double calculate (const RooProdPdf::CacheElem &cache, bool verbose=false) const;  Calculate running product of pdfs terms, using the supplied normalization set in 'normSetList' for each component. ;  ; CacheMode canNodeBeCached () const override;  ; std::unique_ptr< CacheElem > createCacheElem (const RooArgSet *nset, const RooArgSet *iset, const char *isetRangeName=nullptr) const;  ; void doEvalImpl (RooAbsArg const *caller, const RooProdPdf::CacheElem &cache, RooFit::EvalContext &) const;  Evaluate product of PDFs in batch mode. ;  ; double evaluate () const override;  Calculate current value of object. ;  ; void factorizeProduct (const RooArgSet &normSet, const RooArgSet &intSet, RooLinkedList &termList, RooLinkedList &normList, RooLinkedList &impDepList, RooLinkedList &crossDepList, RooLinkedList &intList) const;  Factorize product in irreducible terms for given choice of integration/normalization. ;  ; std::unique_ptr< RooArgSet > fillNormSetForServer (RooArgSet const &normSet, RooAbsArg const &server) const;  ; RooAbsGenContext * genContext (const RooArgSet &vars,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:62358,Cache,CacheElem,62358,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"Class_Version ();  ; static const char * DeclFileName ();  ; static TRInterface & Instance ();  static method to get an TRInterface instance reference ;  ; static TRInterface * InstancePtr ();  static method to get an TRInterface instance pointer ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; RInside * fR;  ; TThread * th;  . Private Member Functions;  TRInterface (const Int_t argc=0, const Char_t *argv[]=NULL, const Bool_t loadRcpp=true, const Bool_t verbose=false, const Bool_t interactive=true);  The command line arguments are by default argc=0 and argv=NULL, The verbose mode is by default disabled but you can enable it to show procedures information in stdout/stderr. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:16861,load,loadRcpp,16861,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['load'],['loadRcpp']
Performance,"Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:38506,cache,cache,38506,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],['cache']
Performance,"Classification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); 56 ; 57# Store model to file; 58model.save('modelClassification.h5'); 59model.summary(); 60 ; 61# Book methods; 62factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; 63 '!H:!V:Fisher:VarTransform=D,G'); 64factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 65 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); 66 ; 67# Run training, test and evaluation; 68factory.TrainAllMethods(); 69factory.TestAllMethods(); 70factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py_source.html:1936,optimiz,optimizer,1936,doc/master/ClassificationKeras_8py_source.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html,1,['optimiz'],['optimizer']
Performance,"Clean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:38321,cache,cache,38321,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"Clean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMultiVarGaussian.html:38703,cache,cache,38703,root/html528/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html528/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"Clean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMultiVarGaussian.html:39172,cache,cache,39172,root/html530/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html530/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"Cleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TXMLSetup::EXMLLayout { kSpecialized; kGeneralized; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of file ; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:22393,cache,cache,22393,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,1,['cache'],['cache']
Performance,"Client; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber; static const QMetaObjectQObject::staticQtMetaObject. private:. static const QMetaObjectExtraDatastaticMetaObjectExtraData. Class Charts. Inheritance Chart:. QObject. ←; TQtClientFilter. Function documentation; Bool_t IsGrabSelected(UInt_t selectEventMask); return the selection by ""grabButton"" / ""grabPointer"". ~TQtClientFilter(). void AddKeyEvent(const QKeyEvent& event, TQtClientWidget* widget); Map and and to the ROOT event queue Qt KeyBoard event mapped to the ROOT Event_t; For ""dest"" widget. bool SelectGrab(Event_t& event, UInt_t selectEventMask, QMouseEvent& me); Select Event: -- 04.12.2005 --. bool eventFilter(QObject* o, QEvent* e); Dispatch The Qt event from event queue to Event_t structure; Not all of the event fields are valid for each event type,; except fType and fWindow. void GrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); Set the X11 style active grabbing for ROOT TG widgets. TQtPointerGrabber * PointerGrabber(); { return fgGrabber; }. TQtClientWidget * GetPointerGrabber(); { return fgPointerGrabber; }. TQtClientWidget * GetButtonGrabber(); { return fgButtonGrabber; }. void SetButtonGrabber(TQtClientWidget* grabber); { fgButtonGrabber = grabber; }. void AppendButtonGrab(TQtClientWidget* ); { fButtonGrabList.append(widget); }. void RemoveButtonGrab(QObject* ). TQtEventQueue * Queue(). void operator=(const TQtClientFilter& ). TQtClientFilter(const TQtClientFilter& ). void SetKeyGrabber(TQtClientWidget* grabber); { fKeyGrabber = grabber;}. void UnSetKeyGrabber(TQtClientWidget* grabber); { if (fKeyGrabber == grabber) fKeyGrabber = 0; }. void RestoreLostGrabbing(Event_t& ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtClientFilter.html:5723,queue,queue,5723,root/html602/TQtClientFilter.html,https://root.cern,https://root.cern/root/html602/TQtClientFilter.html,2,['queue'],['queue']
Performance,"Cling.cxx. ◆ Load(). Int_t TCling::Load ; (; const char * ; filename, . Bool_t ; system = kFALSE . ). finalvirtual . Load a library file in cling's memory. ; if 'system' is true, the library is never unloaded. Return 0 on success, -1 on failure. ; Implements TInterpreter.; Definition at line 3515 of file TCling.cxx. ◆ LoadEnums(). void TCling::LoadEnums ; (; TListOfEnums & ; cl); const. finalvirtual . Create list of pointers to enums for TClass cl. ; Implements TInterpreter.; Definition at line 4395 of file TCling.cxx. ◆ LoadFile(). int TCling::LoadFile ; (; const char * ; path); const. finalvirtual . Load a source file or library called path into the interpreter. ; Reimplemented from TInterpreter.; Definition at line 7500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:113581,Load,LoadLibraryMap,113581,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadLibraryMap']
Performance,"Cling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to load a PCM from TFile; returns true on success. ; Definition at line 1696 of file TCling.cxx. ◆ LoadText(). Bool_t TCling::LoadText ; (; const char * ; text); const. finalvirtual . Load the declarations from text into the interpreter. ; Note that this cannot be (top level) statements; text must contain top level declarations. Returns true on success, false on failure. ; Reimplemented from TInterpreter.; Definition at line 7515 of file TCling.cxx. ◆ MakeInterpreterValue(). std::unique_ptr< TInterpreterValue > TCling::MakeInterpreterValue ; (; ); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7663 of file TCling.cxx. ◆ MapCppName(). const char * TCling::MapCppName ; (; const char * ; name); const. finalvirtual . Interface to cling function. ; Reimplemented from TInterpreter.; Definition at line 7523 of file TCling.cxx. ◆ MethodArgInfo_DefaultValue(). const char * TCling::MethodArgInfo_DefaultValue ; (; MethodArgInfo_t * ; marginfo); const. finalvirtual . Reimplemented from TInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:114588,load,load,114588,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['load']
Performance,"ClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program’s performance. The standard test program $ROOTSYS/test/Event was used in various configurations with 400 events. The data file contains a TTree. The program was invoked with:; Event 400 comp split. comp = 0 means: no compression at all.; comp = 1 means: compress everything if split = 0.; comp = 1 means: compress only the tree branches with integers if split = 1.; comp = 2 means: compress everything if split=1.; split = 0 : the full event is serialized into one single buffer.; split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:648171,perform,performance,648171,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"Cluster > > ROOT::Experimental::Internal::RPageSource::LoadClusters ; (; std::span< RCluster::RKey > ; clusterKeys). pure virtual . Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been loaded, LoadClusters()must mark them withSetColumnAvailable(). That includes the ones from thecolumnsthat don't have pages; otherwise subsequent requests for the cluster would assume an incomplete cluster and trigger loading again. LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs concurrently to other methods of the page source. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadPage() [1/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . NTupleSize_t ; globalIndex . ). virtual . Allocates and fills a page that contains the index-th element. ; The default implementation searches the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 319 of file RPageStorage.cxx. ◆ LoadPage() [2/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . RClusterIndex ; clusterIndex . ). virtual . Another version of LoadPage that allows to specify cluster-relative indexes. ; Returns a default-constructed RPage for suppressed columns. ; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 353 of file RPageStorage.cxx. ◆ LoadPageImpl(). virtual RPageRef ROOT::Experimental::Internal::RPageSource::LoadPageImpl ; (; ColumnHandle_t ; columnHandle, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:14978,Load,LoadPage,14978,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadPage']
Performance,"CmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(),const RooCmdArg& arg8=RooCmdArg::none()). RooCmdArg Title(const char* name); RooAbsRealLValue::frame arguments. RooCmdArg Bins(Int_t nbin). RooCmdArg AutoSymRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoSymBinning(Int_t nbins=100, Double_t marginFactor=0.1); RooAbsData::createHistogram arguments. RooCmdArg AutoBinning(Int_t nbins=100, Double_t marginFactor=0.1). RooCmdArg IntegratedObservables(const RooArgSet& intObs); RooAbsReal::fillHistogram arguments. RooCmdArg SelectVars(const RooArgSet& vars); RooAbsData::reduce arguments. RooCmdArg EventRange(Int_t nStart, Int_t nStop). RooCmdArg FitOptions(const char* opts); RooAbsPdf::fitTo arguments. RooCmdArg Optimize(Int_t flag=2). RooCmdArg ProjectedObservables(const RooArgSet& set). RooCmdArg ConditionalObservables(const RooArgSet& set). RooCmdArg Verbose(Bool_t flag=kTRUE). RooCmdArg Save(Bool_t flag=kTRUE). RooCmdArg Timer(Bool_t flag=kTRUE). RooCmdArg PrintLevel(Int_t code). RooCmdArg Warnings(Bool_t flag=kTRUE). RooCmdArg Strategy(Int_t code). RooCmdArg InitialHesse(Bool_t flag=kTRUE). RooCmdArg Hesse(Bool_t flag=kTRUE). RooCmdArg Minos(Bool_t flag=kTRUE). RooCmdArg Minos(const RooArgSet& minosArgs). RooCmdArg SplitRange(Bool_t flag=kTRUE). RooCmdArg SumCoefRange(const char* rangeName). RooCmdArg Constrain(const RooArgSet& params). RooCmdArg Constrained(). RooCmdArg ExternalConstraints(const RooArgSet& constraintPdfs). RooCmdArg PrintEvalErrors(Int_t numErrors). RooCmdArg EvalErrorWall(Bool_t flag). RooCmdArg SumW2Error(Bool_t flag). RooCmdArg CloneData(Bool_t flag). RooCmdArg Integrate(Bool_t flag). RooCmdArg Minimizer(const char* type, const char* alg=0). RooCmdArg Label(const char* str)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFit.html:23821,Optimiz,Optimize,23821,root/html532/RooFit.html,https://root.cern,https://root.cern/root/html532/RooFit.html,1,['Optimiz'],['Optimize']
Performance,"CmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(),const RooCmdArg& arg8=RooCmdArg::none()). RooCmdArg Title(const char* name); RooAbsRealLValue::frame arguments. RooCmdArg Bins(Int_t nbin). RooCmdArg AutoSymRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoSymBinning(Int_t nbins=100, Double_t marginFactor=0.1); RooAbsData::createHistogram arguments. RooCmdArg AutoBinning(Int_t nbins=100, Double_t marginFactor=0.1). RooCmdArg IntegratedObservables(const RooArgSet& intObs); RooAbsReal::fillHistogram arguments. RooCmdArg SelectVars(const RooArgSet& vars); RooAbsData::reduce arguments. RooCmdArg EventRange(Int_t nStart, Int_t nStop). RooCmdArg FitOptions(const char* opts); RooAbsPdf::fitTo arguments. RooCmdArg Optimize(Int_t flag=2). RooCmdArg ProjectedObservables(const RooArgSet& set). RooCmdArg ConditionalObservables(const RooArgSet& set). RooCmdArg Verbose(Bool_t flag=kTRUE). RooCmdArg Save(Bool_t flag=kTRUE). RooCmdArg Timer(Bool_t flag=kTRUE). RooCmdArg PrintLevel(Int_t code). RooCmdArg Warnings(Bool_t flag=kTRUE). RooCmdArg Strategy(Int_t code). RooCmdArg InitialHesse(Bool_t flag=kTRUE). RooCmdArg Hesse(Bool_t flag=kTRUE). RooCmdArg Minos(Bool_t flag=kTRUE). RooCmdArg Minos(const RooArgSet& minosArgs). RooCmdArg SplitRange(Bool_t flag=kTRUE). RooCmdArg SumCoefRange(const char* rangeName). RooCmdArg Constrain(const RooArgSet& params). RooCmdArg GlobalObservables(const RooArgSet& globs). RooCmdArg GlobalObservablesTag(const char* tagName). RooCmdArg Constrained(). RooCmdArg ExternalConstraints(const RooArgSet& constraintPdfs). RooCmdArg PrintEvalErrors(Int_t numErrors). RooCmdArg EvalErrorWall(Bool_t flag). RooCmdArg SumW2Error(Bool_t flag). RooCmdArg CloneData(Bool_t flag). RooCmdArg Integrat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFit.html:25382,Optimiz,Optimize,25382,root/html534/RooFit.html,https://root.cern,https://root.cern/root/html534/RooFit.html,1,['Optimiz'],['Optimize']
Performance,"Code* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. Bool_t LoadText(const char* ) const; {return kFALSE;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void(*)() ) const; {;}. void SetAllocunlockfunc(void(*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. int SetClassAutoparsing(int ); {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {return 0;}. TInterpreterValue * CreateTemporary(); { return 0; }. EReturnType MethodCallReturnType(TFunction* func) const; core/meta helper functions. ULong64_t GetInterpreterStateMarker() const. DeclId_t GetDeclId(CallFunc_t* info) const. DeclId_t GetDeclId(ClassInfo_t* info) const. DeclId_t GetDeclId(DataMemberInfo_t* info) const. DeclId_t GetDeclId(FuncTempInfo_t* info) const. DeclId_t GetDeclId(MethodInfo_t* info) const. DeclId_t GetDeclId(TypedefInfo_t* info) const. void SetDeclAttr(TInterpreter::DeclId_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:30802,Load,LoadText,30802,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Load'],['LoadText']
Performance,"Collection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void DecrNofKeys ();  ; Int_t IdxAdd (const TObject &obj);  Add object and return its index in the tree. ;  ; void IncrNofKeys ();  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void Init (Int_t i);  Initialize a B-tree. ;  ; void RootIsEmpty ();  If root is empty clean up its space. ;  ; void RootIsFull ();  The root of the tree is full. ;  . Private Attributes; Int_t fInnerLowWaterMark;  ; Int_t fInnerMaxIndex;  ; Int_t fLeafLowWaterMark;  ; Int_t fLeafMaxIndex;  ; Int_t fOrder;  ; Int_t fOrder2; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:24286,perform,perform,24286,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,1,['perform'],['perform']
Performance,"Collection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TString fName;  ; Int_t fSize;  . Private Member Functions;  TCollection (const TCollection &)=delete;  ; void operator= (const TCollection &)=delete;  . Static Private Attributes; static TCollection * fgCurrentCollection = nullptr;  ; static Bool_t fgEmptyingGarbage = kFALSE;  ; static TObjectTable * fgGarbageCollection = nullptr;  ; static Int_t fgGarbageStack = 0;  . #include <TCollection.h>. Inheritance di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:13641,perform,perform,13641,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['perform'],['perform']
Performance,"Collection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:7376,load,load,7376,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←. TNetSystem; ←. TXNetSystem. TNetXNGSystem. TUnixSystem. TWebSystem. Function docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:17139,Cache,Cache,17139,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,1,['Cache'],['Cache']
Performance,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:16526,Cache,Cache,16526,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,2,['Cache'],['Cache']
Performance,"Color:!Silent"" );; TMVA::Reader *reader1 = new TMVA::Reader( ""!Color:!Silent"" );; TMVA::Reader *reader2 = new TMVA::Reader( ""!Color:!Silent"" );; ; reader0->AddVariable( ""var1"", &var1 );; reader0->AddVariable( ""var2"", &var2 );; reader0->AddVariable( ""var3"", &var3 );; reader0->AddVariable( ""var4"", &var4 );; ; reader1->AddVariable( ""var1"", &var1 );; reader1->AddVariable( ""var2"", &var2 );; reader1->AddVariable( ""var3"", &var3 );; reader1->AddVariable( ""var4"", &var4 );; ; reader2->AddVariable( ""var1"", &var1 );; reader2->AddVariable( ""var2"", &var2 );; reader2->AddVariable( ""var3"", &var3 );; reader2->AddVariable( ""var4"", &var4 );; ; // load the weight files for the readers; TString method = ""BDT method"";; reader0->BookMVA( ""BDT method"", ""datasetBkg0/weights/TMVAMultiBkg0_BDTG.weights.xml"" );; reader1->BookMVA( ""BDT method"", ""datasetBkg1/weights/TMVAMultiBkg1_BDTG.weights.xml"" );; reader2->BookMVA( ""BDT method"", ""datasetBkg2/weights/TMVAMultiBkg2_BDTG.weights.xml"" );; ; // load the input file; TFile *input(0);; TString fname = ""./tmva_example_multiple_background.root"";; input = TFile::Open( fname );; ; TTree* theTree = NULL;; ; // loop through signal and all background trees; for( int treeNumber = 0; treeNumber < 4; ++treeNumber ) {; if( treeNumber == 0 ){; theTree = (TTree*)input->Get(""TreeS"");; std::cout << ""--- Select signal sample"" << std::endl;; // theTree->SetBranchAddress( ""weight"", &weight );; weight = 1;; classID = 0;; }else if( treeNumber == 1 ){; theTree = (TTree*)input->Get(""TreeB0"");; std::cout << ""--- Select background 0 sample"" << std::endl;; // theTree->SetBranchAddress( ""weight"", &weight );; weight = 1;; classID = 1;; }else if( treeNumber == 2 ){; theTree = (TTree*)input->Get(""TreeB1"");; std::cout << ""--- Select background 1 sample"" << std::endl;; // theTree->SetBranchAddress( ""weight"", &weight );; weight = 1;; classID = 2;; }else if( treeNumber == 3 ){; theTree = (TTree*)input->Get(""TreeB2"");; std::cout << ""--- Select background 2 sample"" << std::endl;; // t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html:38717,load,load,38717,doc/master/TMVAMultipleBackgroundExample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html,1,['load'],['load']
Performance,"Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArray*fMatricesglobal transformation matrices; TGeoHMatrix*fMatrixOrigoriginal local matrix of the last node in the path; TStringTNamed::fNameobject identifier; TObjArray*fNodesbranch of nodes; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPhysicalNode(); Default constructor. TGeoPhysicalNode(const char* path); Constructor. TGeoPhysicalNode(const TGeoPhysicalNode& ); copy constructor. TGeoPhysicalNode& operator=(const TGeoPhysicalNode& ); assignment operator. ~TGeoPhysicalNode(); Destructor. void Align(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); Align a physical node with a new relative matrix/shape.; Example: /TOP_1/A_1/B_1/C_1; node->Align(transl_1, box) will perform:; - change RELATIVE translation of C_1 node (with respect to its; container volume B) to transl_1; - change the shape of the C volume; *NOTE* The operations will affect ONLY the LAST node in the branch. All; volumes/nodes in the branch represented by this physical node are; CLONED so the operation does not affect other possible replicas. void cd() const. void Draw(Option_t* option = """"); Draw this node. TGeoNode * GetMother(Int_t levup = 1) const; Return parent at LEVUP generation. TGeoHMatrix * GetMatrix(Int_t level = -1) const; Return global matrix for node at LEVEL. TGeoNode * GetNode(Int_t level = -1) const; Return node in branch at LEVEL. If not specified, return last leaf. TGeoVolume * GetVolume(Int_t level = -1) const; Return volume associated with node at LEVEL in the branch. TGeoShape * GetShape(Int_t level = -1) const; Return shape associated with volume. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void Print(Option_t* option = """") const; Print info about this node. void Refresh();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPhysicalNode.html:9410,perform,perform,9410,root/html528/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html,3,['perform'],['perform']
Performance,"ColumnNames_t &columnList); 1460 {; 1461 auto staticSeq = std::make_index_sequence<sizeof...(ColumnTypes)>();; 1462 return CacheImpl<ColumnTypes...>(columnList, staticSeq);; 1463 }; 1464 ; 1465 ////////////////////////////////////////////////////////////////////////////; 1466 /// \brief Save selected columns in memory.; 1467 /// \param[in] columnList columns to be cached in memory; 1468 /// \return a `RDataFrame` that wraps the cached dataset.; 1469 ///; 1470 /// See the previous overloads for more information.; 1471 RInterface<RLoopManager> Cache(const ColumnNames_t &columnList); 1472 {; 1473 // Early return: if the list of columns is empty, just return an empty RDF; 1474 // If we proceed, the jitted call will not compile!; 1475 if (columnList.empty()) {; 1476 auto nEntries = *this->Count();; 1477 RInterface<RLoopManager> emptyRDF(std::make_shared<RLoopManager>(nEntries));; 1478 return emptyRDF;; 1479 }; 1480 ; 1481 std::stringstream cacheCall;; 1482 auto upcastNode = RDFInternal::UpcastNode(fProxiedPtr);; 1483 RInterface<TTraits::TakeFirstParameter_t<decltype(upcastNode)>> upcastInterface(fProxiedPtr, *fLoopManager,; 1484 fColRegister);; 1485 // build a string equivalent to; 1486 // ""(RInterface<nodetype*>*)(this)->Cache<Ts...>(*(ColumnNames_t*)(&columnList))""; 1487 RInterface<RLoopManager> resRDF(std::make_shared<ROOT::Detail::RDF::RLoopManager>(0));; 1488 cacheCall << ""*reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RLoopManager>*>(""; 1489 << RDFInternal::PrettyPrintAddr(&resRDF); 1490 << "") = reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RNodeBase>*>(""; 1491 << RDFInternal::PrettyPrintAddr(&upcastInterface) << "")->Cache<"";; 1492 ; 1493 const auto columnListWithoutSizeColumns = RDFInternal::FilterArraySizeColNames(columnList, ""Cache"");; 1494 ; 1495 const auto validColumnNames =; 1496 GetValidatedColumnNames(columnListWithoutSizeColumns.size(), columnListWithoutSizeColumns);; 1497 const auto colTypes = GetValidatedArgTypes(validColumnNames, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:82378,cache,cacheCall,82378,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,"['Cache', 'cache']","['Cache', 'cacheCall']"
Performance,"CombinedCalculator::fNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetRooStats::CombinedCalculator::fPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*RooStats::CombinedCalculator::fPdf; Double_tRooStats::CombinedCalculator::fSizesize of the test (eg. specified rate of Type I error); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default dummy constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from the data, a model pdf and the parameter of Interest.; If nuisance parameters are present they should be specified as part of the model; i.e. the model pdf is a combined pdf for the poi and the nuisance; The default test size used is 0.05 ( for a 95% interval); A set for the null parameters (it must be a copied set) can be specified which will be used for; performing the hypothesis test. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from the data and a model configuration (ModelConfig class); If the model configuration contains a Prior pdf it will be included in the full model; used by the profile likelihood calculator.; The default test size used is 0.05 ( for a 95% interval). ~ProfileLikelihoodCalculator(); destructor (delete the contained result of the fit). void DoReset() const; private method to reset and clear fit results; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; private method to perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html:10735,perform,performing,10735,root/html526/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__ProfileLikelihoodCalculator.html,1,['perform'],['performing']
Performance,"CommitteeMethodCommittee(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); TMVA::MethodCommitteeMethodCommittee(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption, TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void*); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCommittee.html:9854,Optimiz,OptimizeTuningParameters,9854,root/html530/TMVA__MethodCommittee.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCommittee.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"CompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumRunningInt.html:34615,cache,cache,34615,root/html532/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html532/RooNumRunningInt.html,1,['cache'],['cache']
Performance,"CompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:33455,cache,cache,33455,root/html530/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,1,['cache'],['cache']
Performance,"CompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:33455,cache,cache,33455,root/html530/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,1,['cache'],['cache']
Performance,CompareSeek. friend class CompareSeek. friend . Definition at line 83 of file TTreeCloner.h. Member Data Documentation. ◆ fBasketBranchNum. UInt_t* TTreeCloner::fBasketBranchNum. private . [fMaxBaskets] Index of the branch(es) of the basket. ; Definition at line 46 of file TTreeCloner.h. ◆ fBasketEntry. Long64_t* TTreeCloner::fBasketEntry. private . [fMaxBaskets] list of basket start entries. ; Definition at line 50 of file TTreeCloner.h. ◆ fBasketIndex. UInt_t* TTreeCloner::fBasketIndex. private . [fMaxBaskets] ordered list of basket indices to be written. ; Definition at line 51 of file TTreeCloner.h. ◆ fBasketNum. UInt_t* TTreeCloner::fBasketNum. private . [fMaxBaskets] index of the basket within the branch. ; Definition at line 47 of file TTreeCloner.h. ◆ fBasketSeek. Long64_t* TTreeCloner::fBasketSeek. private . [fMaxBaskets] list of basket position to be read. ; Definition at line 49 of file TTreeCloner.h. ◆ fCacheSize. Long64_t TTreeCloner::fCacheSize. private . Requested size of the file cache. ; Definition at line 58 of file TTreeCloner.h. ◆ fCloneMethod. UInt_t TTreeCloner::fCloneMethod. private . Indicates which cloning method was selected. ; Definition at line 55 of file TTreeCloner.h. ◆ fFileCache. TFileCacheRead* TTreeCloner::fFileCache. private . File Cache used to reduce the number of individual reads. ; Definition at line 59 of file TTreeCloner.h. ◆ fFromBranches. TObjArray TTreeCloner::fFromBranches. private . Definition at line 42 of file TTreeCloner.h. ◆ fFromTree. TTree* TTreeCloner::fFromTree. private . Definition at line 37 of file TTreeCloner.h. ◆ fIsValid. bool TTreeCloner::fIsValid. private . Definition at line 34 of file TTreeCloner.h. ◆ fMaxBaskets. UInt_t TTreeCloner::fMaxBaskets. private . Definition at line 45 of file TTreeCloner.h. ◆ fMethod. Option_t* TTreeCloner::fMethod. private . Definition at line 41 of file TTreeCloner.h. ◆ fNeedConversion. bool TTreeCloner::fNeedConversion. private . True if the fast merge is not possible but a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:13322,cache,cache,13322,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['cache'],['cache']
Performance,"CompressionSettings ; (; ); const. inlineprotected . Definition at line 348 of file TBufferXML.h. ◆ GetInfo(). TVirtualStreamerInfo * TBufferXML::GetInfo ; (; ). finalvirtual . Return current streamer info element. ; Implements TBuffer.; Definition at line 3171 of file TBufferXML.cxx. ◆ GetIOVersion(). Int_t TBufferXML::GetIOVersion ; (; ); const. inline . Definition at line 65 of file TBufferXML.h. ◆ IncrementLevel(). void TBufferXML::IncrementLevel ; (; TVirtualStreamerInfo * ; info). finalvirtual . Function is called from TStreamerInfo WriteBuffer and ReadBuffer functions and indent new level in xml structure. ; This call indicates, that TStreamerInfo functions starts streaming object data of correspondent class ; Implements TBuffer.; Definition at line 855 of file TBufferXML.cxx. ◆ IsA(). TClass * TBufferXML::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBufferText.; Definition at line 332 of file TBufferXML.h. ◆ PerformPostProcessing(). void TBufferXML::PerformPostProcessing ; (; ). protected . Function is converts TObject and TString structures to more compact representation. ; Definition at line 1203 of file TBufferXML.cxx. ◆ PerformPreProcessing(). void TBufferXML::PerformPreProcessing ; (; const TStreamerElement * ; elem, . XMLNodePointer_t ; elemnode . ). protected . Function is unpack TObject and TString structures to be able read them from custom streamers of this objects. ; Definition at line 1321 of file TBufferXML.cxx. ◆ PopStack(). TXMLStackObj * TBufferXML::PopStack ; (; ). protected . Remove one level from xml stack. ; Definition at line 312 of file TBufferXML.cxx. ◆ ProcessPointer(). Bool_t TBufferXML::ProcessPointer ; (; const void * ; ptr, . XMLNodePointer_t ; node . ). protected . Add ""ptr"" attribute to node, if ptr is null or if ptr is pointer on object, which is already saved in buffer Automatically add ""ref"" attribute to node, where referenced object is stored. ; Definition at line 52",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:62492,Perform,PerformPostProcessing,62492,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['Perform'],['PerformPostProcessing']
Performance,"Compute a running mean of events/s.; 162double ProgressHelper::EvtPerSec() const; 163{; 164 if (fEventsPerSecondStatisticsIndex < fEventsPerSecondStatistics.size()); 165 return std::accumulate(fEventsPerSecondStatistics.begin(),; 166 fEventsPerSecondStatistics.begin() + fEventsPerSecondStatisticsIndex, 0.) /; 167 fEventsPerSecondStatisticsIndex;; 168 else; 169 return std::accumulate(fEventsPerSecondStatistics.begin(), fEventsPerSecondStatistics.end(), 0.) /; 170 fEventsPerSecondStatistics.size();; 171}; 172 ; 173/// Record current event counts and time stamp, populate evts/s statistics array.; 174std::pair<std::size_t, std::chrono::seconds> ProgressHelper::RecordEvtCountAndTime(); 175{; 176 using namespace std::chrono;; 177 ; 178 auto currentEventCount = fProcessedEvents.load();; 179 auto eventsPerTimeInterval = currentEventCount - fLastProcessedEvents;; 180 fLastProcessedEvents = currentEventCount;; 181 ; 182 auto oldPrintTime = fLastPrintTime;; 183 auto newPrintTime = system_clock::now();; 184 fLastPrintTime = newPrintTime;; 185 ; 186 duration<double> secondsCurrentInterval = newPrintTime - oldPrintTime;; 187 fEventsPerSecondStatistics[fEventsPerSecondStatisticsIndex++ % fEventsPerSecondStatistics.size()] =; 188 eventsPerTimeInterval / secondsCurrentInterval.count();; 189 ; 190 return {currentEventCount, duration_cast<seconds>(newPrintTime - fBeginTime)};; 191}; 192 ; 193namespace {; 194 ; 195struct RestoreStreamState {; 196 RestoreStreamState(std::ostream &stream) : fStream(stream), fFlags(stream.flags()), fFillChar(stream.fill()) {}; 197 ~RestoreStreamState(); 198 {; 199 fStream.flags(fFlags);; 200 fStream.fill(fFillChar);; 201 }; 202 ; 203 std::ostream &fStream;; 204 std::ios_base::fmtflags fFlags;; 205 std::ostream::char_type fFillChar;; 206};; 207 ; 208/// Format std::chrono::seconds as `1:30m`.; 209std::ostream &operator<<(std::ostream &stream, std::chrono::seconds elapsedSeconds); 210{; 211 RestoreStreamState restore(stream);; 212 auto h = std::chrono::durat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8cxx_source.html:6581,load,load,6581,doc/master/RDFHelpers_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html,1,['load'],['load']
Performance,"ConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:6309,load,load,6309,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['load'],['load']
Performance,"ConfigParameters.cxx. ◆ GetSigEffAtBkgEff(). Double_t TMVA::OptimizeConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. priva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:9504,Optimiz,OptimizeConfigParameters,9504,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,2,"['Optimiz', 'optimiz']","['OptimizeConfigParameters', 'optimizeScan']"
Performance,"ConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:9575,optimiz,optimization,9575,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimization']
Performance,"Constant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumFunc.html:50936,cache,cache,50936,doc/master/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/master/classRooRealSumFunc.html,1,['cache'],['cache']
Performance,"Constructor for 2-samples tests. ;  ;  GoFTest (size_t sampleSize, const Double_t *sample, const IGenFunction &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Constructor for 1-sample tests with a user specified distribution implementing the ROOT::Math::IGenFunction interface. ;  ; template<class Dist > ;  GoFTest (size_t sampleSize, const Double_t *sample, Dist &dist, EUserDistribution userDist=kPDF, Double_t xmin=1, Double_t xmax=0);  Templated constructor for 1-sample tests with a user specified distribution as a functor object implementing double operator()(double x). ;  ;  GoFTest (size_t sampleSize, const Double_t *sample, EDistribution dist=kUndefined, const std::vector< double > &distParams={});  Constructor for 1-sample tests with a specified distribution. ;  ; virtual ~GoFTest ();  ; Double_t AndersonDarling2SamplesTest (const Char_t *option=""p"") const;  Anderson-Darling 2-Sample Test. ;  ; void AndersonDarling2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Performs the Anderson-Darling 2-Sample Test. ;  ; Double_t AndersonDarlingTest (const Char_t *option=""p"") const;  Anderson-Darling 2-Sample Test. ;  ; void AndersonDarlingTest (Double_t &pvalue, Double_t &testStat) const;  Performs the Anderson-Darling 1-Sample Test. ;  ; Double_t KolmogorovSmirnov2SamplesTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; void KolmogorovSmirnov2SamplesTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 2-Samples Test. ;  ; Double_t KolmogorovSmirnovTest (const Char_t *option=""p"") const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void KolmogorovSmirnovTest (Double_t &pvalue, Double_t &testStat) const;  Kolmogorov-Smirnov 1-Sample Test. ;  ; void operator() (ETestType test, Double_t &pvalue, Double_t &testStat) const;  The class's unary functions performing the gif test according to the ETestType provided. ;  ; Double_t operator() (ETestType test=kAD, const Char_t *option=""p"") const;  Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html:3119,Perform,Performs,3119,doc/master/classROOT_1_1Math_1_1GoFTest.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GoFTest.html,1,['Perform'],['Performs']
Performance,Contains the buttons. ; Definition at line 61 of file TGTable.h. ◆ fCanvas. TGCanvas* TGTable::fCanvas. protected . Canvas that will contains the cells. ; Definition at line 49 of file TGTable.h. ◆ fCellHeight. UInt_t TGTable::fCellHeight. protected . Default cell width. ; Definition at line 51 of file TGTable.h. ◆ fCellHintsList. TList* TGTable::fCellHintsList. protected . Definition at line 91 of file TGTable.h. ◆ fCellWidth. UInt_t TGTable::fCellWidth. protected . Default cell width. ; Definition at line 50 of file TGTable.h. ◆ fCHdrFrame. TGTableHeaderFrame* TGTable::fCHdrFrame. protected . Frame that contains the row headers. ; Definition at line 55 of file TGTable.h. ◆ fCHdrHintsList. TList* TGTable::fCHdrHintsList. protected . Definition at line 93 of file TGTable.h. ◆ fColumnHeaders. TObjArray* TGTable::fColumnHeaders. protected . Array of column headers. ; Definition at line 39 of file TGTable.h. ◆ fCurrentRange. TTableRange* TGTable::fCurrentRange. protected . Range of data currently loaded. ; Definition at line 45 of file TGTable.h. ◆ fDataRange. TTableRange* TGTable::fDataRange. protected . Full range of the data set. ; Definition at line 46 of file TGTable.h. ◆ fEvenRowBackground. Pixel_t TGTable::fEvenRowBackground. protected . Background color for even numbered rows. ; Definition at line 80 of file TGTable.h. ◆ fFirstCellEntry. TGTextEntry* TGTable::fFirstCellEntry. protected . TextEntry for the range frame. ; Definition at line 76 of file TGTable.h. ◆ fFirstCellLabel. TGLabel* TGTable::fFirstCellLabel. protected . Label for the range frame. ; Definition at line 74 of file TGTable.h. ◆ fGotoButton. TGTextButton* TGTable::fGotoButton. protected . Button to goto a new range. ; Definition at line 69 of file TGTable.h. ◆ fGotoRange. TTableRange* TGTable::fGotoRange. protected . Range used by Goto frame. ; Definition at line 47 of file TGTable.h. ◆ fHeaderBackground. Pixel_t TGTable::fHeaderBackground. protected . Background color for headers. ; Definition,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:58049,load,loaded,58049,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['load'],['loaded']
Performance,"Context& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:35477,optimiz,optimizeDirtyHook,35477,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"ContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TApplication::EStatusBitsTApplication::kProcessRemotely; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0). » Author: Guy Barrand 30/05/2001 » Copyright (C) 2001, Guy Barrand. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGApplication.html:13390,Load,LoadGraphicsLibs,13390,root/html604/TGApplication.html,https://root.cern,https://root.cern/root/html604/TGApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance,"ContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TApplication::EStatusBitsTApplication::kProcessRemotely; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0). » Author: Guy Barrand 30/05/2001 » Copyright (C) 2001, Guy Barrand. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGApplication.html:13390,Load,LoadGraphicsLibs,13390,root/html602/TGApplication.html,https://root.cern,https://root.cern/root/html602/TGApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance,"ContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAllTri!True if FindAllTriangles() has been performed on fGraph2D; Double_t*fDist!Array used to order mass points by distance; TGraph2D*fGraph2D!2D graph containing the user data; Int_t*fHullPoints!Hull points of size fNhull; Bool_tfInit!True if CreateTrianglesDataStructure() and FindHull() have been performed; Int_t*fMTried!; Int_tfMaxIter!Maximum number of iterations to find Delaunay triangles; Int_t*fNTried!Delaunay triangles storage of size fNdt; TStringTNamed::fNameobject identifier; Int_tfNdt!Number of Delaunay triangles found; Int_tfNhull!Number of points in the hull; Int_tfNpoints!Number of data points in fGraph2D; Int_t*fOrder!Array used to order mass points by distance; Int_t*fPTried!; TStringTNamed::fTitleobject title; Int_tfTriedSize!Real size of the fxTried arrays; Double_t*fX!Pointer to fGraph2D->fX; Double_t*fXN!fGraph2D vectors normalized of size fNpoints; Double_tfXNmax!Maximum value of fXN; Double_tfXNmin!Minimum value of fXN; Double_tfXScaleFactor!; Double_tfXoffset!; Double_t*fY!Pointer to fGraph2D->fY; Double_t*fYN!fGraph2D vectors normalized of size fNpoints; Double_tfYNmax!Maximum value of fYN; Double_tfYNmin!Minimum value of fYN; Double_tfYScaleFactor!; Double_tfYoffset!Parameters used to normalize user data; Double_t*fZ!Pointer to fGraph2D->fZ; Double_tfZout!Histogram bin height for points lying outside the convex hull. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphDelaunay(); TGraphDelaunay default constructor. TGraphDelaunay(TGraph2D* g); TGraphDelaunay normal constructor. ~TGraphDelaunay(); TGraphDelaunay destructor. Double_t ComputeZ(Double_t x, Double_t y); Return the z va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphDelaunay.html:7802,perform,performed,7802,root/html602/TGraphDelaunay.html,https://root.cern,https://root.cern/root/html602/TGraphDelaunay.html,4,['perform'],['performed']
Performance,"Control() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tTSystem::Init(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual Int_tLocate(const char* path, TString& endurl); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* dir); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* dir); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); static voidTObject::operator delete(void* ptr); static voidTObject::ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGSystem.html:9018,Load,Load,9018,root/html534/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html534/TNetXNGSystem.html,1,['Load'],['Load']
Performance,"Control() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tTSystem::Init(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual Int_tLocate(const char* path, TString& endurl); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* dir); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* dir); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGSystem.html:9004,Load,Load,9004,root/html602/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html602/TNetXNGSystem.html,2,['Load'],['Load']
Performance,"Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:13043,cache,cache,13043,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,3,['cache'],['cache']
Performance,"Counter; kCharStar; kChar; kShort; kInt; kLong; kFloat; kDouble; kDouble32; kUChar; kUShort; kUInt; kULong; kBits; kLong64; kULong64; kBool; kFloat16; kObject; kAny; kObjectp; kObjectP; kTString; kTObject; kTNamed; kAnyp; kAnyP; kAnyPnoVT; kSTLp; kSkip; kSkipL; kSkipP; kConv; kConvL; kConvP; kSTL; kSTLstring; kStreamer; kStreamLoop; kCache; kArtificial; kCacheNew; kCacheDelete; kMissing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualStreamerInfo::fIsCompiled! true if the StreamerInfo has been compiled (i.e. fully built, ready to use for streaming).; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tTVirtualStreamerInfo::fgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*TVirtualStreamerInfo::fgInfoFactory; static Bool_tTVirtualStreamerInfo::fgOptimizeTrue if optimization on; static Bool_tTVirtualStreamerInfo::fgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). private:. UInt_tfCheckSumchecksum of original class; TClass*fClass!pointer to class; Int_tfClassVersionClass version identifier; TStreamerInfo::TCompInfo*fComp![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; TStreamerInfo::TCompInfo**fCompFull![fElements->GetEntries()]; TStreamerInfo::TCompInfo**fCompOpt![fNdata]; TObjArray*fElementsArray of TStreamerElements; ULong_tfLiveCount! Number of outstanding pointer to this StreamerInfo.; Int_tfNVirtualInfoLoc! Number of virtual info location to update.; Int_tfNdata!number of optimized elements; Int_tfNfulldata!number of elements; Int_tfNslots!total numbrer of slots in fComp.; Int_tfNumber!Unique identifier; Version_tfOldVersion! Version of the TStreamerInfo object read from the file; Int_tfOnFileClassVersion!Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:13559,optimiz,optimization,13559,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,1,['optimiz'],['optimization']
Performance,"Courier New"" 1 8; *-* 12 : symbol-medium-r-normal ""Symbol"" 0 6; *-* 13 : times-medium-r-normal ""Times New Roman"" 0 5; *-* 14 : ""Wingdings"" 0 5. void SetTextSize(Float_t textsize); Set current text size*-*-; *-* =====================. void UpdateWindow(Int_t mode); Update display.; mode : (1) update; (0) sync. Int_t WriteGIF(char* name). Writes the current active window into pixmap file.; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no extension is provided the ""png"" format is used by default. Returns 1 in case of success,; 0 otherwise; Note: this method may not produce the expected result been called; ---- from the ROOT prompt by simple reason:; The active window will be console window; rather the last selected ROOT canvas. void WritePixmap(Int_t wid, UInt_t w, UInt_t h, char* pxname); Write the pixmap wd in the bitmap file pxname in JPEG.; wd : Pixmap address; w,h : Width and height of the pixmap.; if w = h = -1 the size of the pimxap is equal the size the wd size; pxname : pixmap file name; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no or some unknown extension is provided then; the ""png"" format is used by default; --; Take in account the special ROOT filename syntax 26.12.2006 vf; ""gif+NN"" - an animated GIF file is produced, where NN is delay in 10ms units. Int_t LoadQt(const char* shareLibFileName); Make sure we load the GUI DLL from the gui thread. Int_t processQtEvents(Int_t maxtime = 300); Force processing the Qt events only without entering the ROOT event loop. void operator=(const TGQt& ). TGQt(). Bool_t IsHandleValid(Window_t id). » Author: Valeri Fine 21/01/2002 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/qt:$Id: TGQt.h 30386 2009-09-23 19:06:28Z brun $ » Last generated: 2010-10-11 11:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGQt.html:34700,Load,LoadQt,34700,root/html528/TGQt.html,https://root.cern,https://root.cern/root/html528/TGQt.html,2,"['Load', 'load']","['LoadQt', 'load']"
Performance,"Courier New"" 1 8; *-* 12 : symbol-medium-r-normal ""Symbol"" 0 6; *-* 13 : times-medium-r-normal ""Times New Roman"" 0 5; *-* 14 : ""Wingdings"" 0 5. void SetTextSize(Float_t textsize); Set current text size*-*-; *-* =====================. void UpdateWindow(Int_t mode); Update display.; mode : (1) update; (0) sync. Int_t WriteGIF(char* name). Writes the current active window into pixmap file.; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no extension is provided the ""png"" format is used by default. Returns 1 in case of success,; 0 otherwise; Note: this method may not produce the expected result been called; ---- from the ROOT prompt by simple reason:; The active window will be console window; rather the last selected ROOT canvas. void WritePixmap(Int_t wid, UInt_t w, UInt_t h, char* pxname); Write the pixmap wd in the bitmap file pxname in JPEG.; wd : Pixmap address; w,h : Width and height of the pixmap.; if w = h = -1 the size of the pimxap is equal the size the wd size; pxname : pixmap file name; The format is defined by the file name extension; like ""png"",""jpg"",""bmp"" . . .; If no or some unknown extension is provided then; the ""png"" format is used by default; --; Take in account the special ROOT filename syntax 26.12.2006 vf; ""gif+NN"" - an animated GIF file is produced, where NN is delay in 10ms units. Int_t LoadQt(const char* shareLibFileName); Make sure we load the GUI DLL from the gui thread. Int_t processQtEvents(Int_t maxtime = 300); Force processing the Qt events only without entering the ROOT event loop. void operator=(const TGQt& ). TGQt(). Bool_t IsHandleValid(Window_t id). » Author: Valeri Fine 21/01/2002 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/qt:$Id: TGQt.h 30386 2009-09-23 19:06:28Z brun $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGQt.html:34810,Load,LoadQt,34810,root/html532/TGQt.html,https://root.cern,https://root.cern/root/html532/TGQt.html,2,"['Load', 'load']","['LoadQt', 'load']"
Performance,"Create a new ROOT binary machine independent file.; # Note that this file may contain any kind of ROOT objects, histograms,; # pictures, graphics objects, detector geometries, tracks, events, etc..; # This file is now becoming the current directory.; ; hfile = gROOT.FindObject( 'py-hsimple.root' ); if hfile:; hfile.Close(); hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); ; # Create some histograms, a profile histogram and an ntuple; hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); ; # Set canvas/frame attributes.; hpx.SetFillColor( 48 ); ; gBenchmark.Start( 'hsimple' ); ; # Initialize random number generator.; gRandom.SetSeed(); rannor, rndm = gRandom.Rannor, gRandom.Rndm; ; # For speed, bind and cache the Fill member functions,; histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly.; px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); kUPDATE = 1000; for i in range( 25000 ):; # Generate random values. Use ctypes to pass doubles by reference; rannor( px_ref, py_ref ); # Retrieve the generated values; px = px_ref.value; py = py_ref.value; ; pz = px*px + py*py; random = rndm(1); ; # Fill histograms.; hpx.Fill( px ); hpxpy.Fill( px, py ); hprof.Fill( px, pz ); ntuple.Fill( px, py, pz, random, i ); ; # Update display every kUPDATE events.; if i and i%kUPDATE == 0:; if i == kUPDATE:; hpx.Draw(); ; c1.Modified(); c1.Update(); ; if gSystem.ProcessEvents(): # allow user interrupt; break; ; # Destroy member functions cache.; for name in histos:; exec('del %sFill' % name); del histos; ; gBenchmark.Show( 'hsimple' ); ; # Save all objects in this file.; hpx.SetFillColor( 0 ); hfile.Write(); hpx.SetFillColor( 48 ); c1.Modified(); c1.Update(); ; # Not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py.html:1756,cache,cache,1756,doc/master/hsimple_8py.html,https://root.cern,https://root.cern/doc/master/hsimple_8py.html,1,['cache'],['cache']
Performance,Create custom cache element for running integral calculations. ; Reimplemented from RooAbsCachedReal.; Definition at line 285 of file RooNumRunningInt.cxx. ◆ DeclFileName(). static const char * RooNumRunningInt::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooNumRunningInt.h. ◆ evaluate(). double RooNumRunningInt::evaluate ; (; ); const. overrideprotectedvirtual . Dummy function that is never called. ; Implements RooAbsReal.; Definition at line 294 of file RooNumRunningInt.cxx. ◆ fillCacheObject(). void RooNumRunningInt::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache object by calling its calculate() method. ; Implements RooAbsCachedReal.; Definition at line 248 of file RooNumRunningInt.cxx. ◆ inputBaseName(). const char * RooNumRunningInt::inputBaseName ; (; ); const. overrideprotectedvirtual . Return unique name for RooAbsCachedPdf cache components constructed from input function name. ; Implements RooAbsCachedReal.; Definition at line 88 of file RooNumRunningInt.cxx. ◆ IsA(). TClass * RooNumRunningInt::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 63 of file RooNumRunningInt.h. ◆ payloadUniqueSuffix(). const char * RooNumRunningInt::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 55 of file RooNumRunningInt.h. ◆ Streamer(). void RooNumRunningInt::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedReal. ◆ StreamerNVirtual(). void RooNumRunningInt::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooNumRunningInt.h. Friends And Related Symbol Documentation. ◆ RICacheElem. friend class RICacheElem. friend . Definition at line 46 of ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:66762,cache,cache,66762,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,CreateBranches ; (; ). virtual . Create internal VSD branches. ; Definition at line 101 of file TEveVSD.cxx. ◆ CreateTrees(). void TEveVSD::CreateTrees ; (; ). virtual . Create internal trees. ; Definition at line 71 of file TEveVSD.cxx. ◆ DeclFileName(). static const char * TEveVSD::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 67 of file TEveVSD.h. ◆ DeleteTrees(). void TEveVSD::DeleteTrees ; (; ). virtual . Delete internal trees. ; Definition at line 87 of file TEveVSD.cxx. ◆ DisableTObjectStreamersForVSDStruct(). void TEveVSD::DisableTObjectStreamersForVSDStruct ; (; ). static . Disable TObject streamers for those VSD structs that inherit from TObject directly. ; Definition at line 203 of file TEveVSD.cxx. ◆ IsA(). TClass * TEveVSD::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 67 of file TEveVSD.h. ◆ LoadTrees(). void TEveVSD::LoadTrees ; (; ). virtual . Load internal trees from directory. ; Definition at line 148 of file TEveVSD.cxx. ◆ operator=(). TEveVSD & TEveVSD::operator= ; (; const TEveVSD & ; ). private . ◆ SetBranchAddresses(). void TEveVSD::SetBranchAddresses ; (; ). virtual . Set branche addresses of internal trees. ; Definition at line 121 of file TEveVSD.cxx. ◆ SetDirectory(). void TEveVSD::SetDirectory ; (; TDirectory * ; dir). virtual . Set directory in which the trees are (or will be) created. ; Definition at line 63 of file TEveVSD.cxx. ◆ Streamer(). void TEveVSD::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEveVSD::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 67 of file TEveVSD.h. ◆ WriteTrees(). void TEveVSD::WriteTrees ; (; ). virtual . Does nothing here ... reimplemented in sub-classes. ; Definition at line 141 of file TEveVSD.cxx. Member Data D,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveVSD.html:13555,Load,LoadTrees,13555,doc/master/classTEveVSD.html,https://root.cern,https://root.cern/doc/master/classTEveVSD.html,1,['Load'],['LoadTrees']
Performance,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:10292,cache,cached,10292,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cached']
Performance,"Curve class understands.; NoteYou own the retured pointer. ; Definition at line 762 of file Factory.cxx. ◆ GetROCCurve() [1/4]. TGraph * TMVA::Factory::GetROCCurve ; (; DataLoader * ; loader, . TString ; theMethodName, . Bool_t ; setTitles = kTRUE, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ; It is ignored for binary classification.; Returns a ROC graph for a given method, or nullptr on error.; Note: Evaluation of the given method must have been run prior to ROC generation through Factory::EvaluateAllMetods.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 912 of file Factory.cxx. ◆ GetROCCurve() [2/4]. TCanvas * TMVA::Factory::GetROCCurve ; (; TMVA::DataLoader * ; loader, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Draws ROC curves for all methods booked with the factory for a given class onto a canvas. ; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 1061 of file Factory.cxx. ◆ GetROCCurve() [3/4]. TGraph * TMVA::Factory::GetROCCurve ; (; TString ; datasetname, . TString ; theMethodName, . Bool_t ; setTitles = kTRUE, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ; It is ignored for binary classification.; Returns a ROC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:27285,load,loader,27285,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:22685,perform,perform,22685,root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,4,['perform'],['perform']
Performance,"D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 1D histogram ; Definition at line 3504 of file TH3.cxx. ◆ DoProject2D() [1/2]. TH2D * TH3::DoProject2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method performing the projection to a 2D histogram called from TH3::Project3D ; Definition at line 2103 of file TH3.cxx. ◆ DoProject2D() [2/2]. TH2D * TH3::DoProject2D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 2D histogram ; Definition at line 3513 of file TH3.cxx. ◆ DoProjectProfile2D(). TProfile2D * TH3::DoProjectProfile2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method to project to a 2D Profile called from TH3::Project3DProfile ; Reimplemented in TProfile3D.; Definition at line 2576 of file TH3.cxx. ◆ Fill() [1/15]. Int_t TH3::Fill ; (; const char * ; , . const char * ; , . Double_t ;  . ). inlineprotected . Definition at line 63 of file TH3.h. ◆ Fill() [2/15]. Int_t TH3::Fill ; (; const char * ; namex, . Double_t ; w . ). inlineoverrideprotectedvirtual . Increment bin with namex with a weight w. ; if x is less than the low-edge of the first bin, the Underflow bin is incremented if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented; If the weight is not equal to 1, the storage of the sum of squares of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:68175,perform,performing,68175,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['perform'],['performing']
Performance,"D"", . const char * ; title = """" . ). Constructor. ; Definition at line 27 of file REveVSD.cxx. ◆ ~REveVSD(). REveVSD::~REveVSD ; (; ). override . Destructor. ; Definition at line 58 of file REveVSD.cxx. Member Function Documentation. ◆ ClassDefOverride(). ROOT::Experimental::REveVSD::ClassDefOverride ; (; REveVSD ; , . 1 ;  . ). ◆ CreateBranches(). void REveVSD::CreateBranches ; (; ). virtual . Create internal VSD branches. ; Definition at line 103 of file REveVSD.cxx. ◆ CreateTrees(). void REveVSD::CreateTrees ; (; ). virtual . Create internal trees. ; Definition at line 73 of file REveVSD.cxx. ◆ DeleteTrees(). void REveVSD::DeleteTrees ; (; ). virtual . Delete internal trees. ; Definition at line 89 of file REveVSD.cxx. ◆ DisableTObjectStreamersForVSDStruct(). void REveVSD::DisableTObjectStreamersForVSDStruct ; (; ). static . Disable TObject streamers for those VSD structs that inherit from TObject directly. ; Definition at line 190 of file REveVSD.cxx. ◆ LoadTrees(). void REveVSD::LoadTrees ; (; ). virtual . Load internal trees from directory. ; Definition at line 150 of file REveVSD.cxx. ◆ operator=(). REveVSD & ROOT::Experimental::REveVSD::operator= ; (; const REveVSD & ; ). privatedelete . ◆ SetBranchAddresses(). void REveVSD::SetBranchAddresses ; (; ). virtual . Set branche addresses of internal trees. ; Definition at line 123 of file REveVSD.cxx. ◆ SetDirectory(). void REveVSD::SetDirectory ; (; TDirectory * ; dir). virtual . Set directory in which the trees are (or will be) created. ; Definition at line 65 of file REveVSD.cxx. ◆ WriteTrees(). void REveVSD::WriteTrees ; (; ). virtual . Does nothing here ... reimplemented in sub-classes. ; Definition at line 143 of file REveVSD.cxx. Member Data Documentation. ◆ fBuffSize. Int_t ROOT::Experimental::REveVSD::fBuffSize {0}. protected . Definition at line 33 of file REveVSD.hxx. ◆ fC. REveCluster ROOT::Experimental::REveVSD::fC. Definition at line 48 of file REveVSD.hxx. ◆ fCC. REveRecCascade ROOT::Experimental::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveVSD.html:12873,Load,LoadTrees,12873,doc/master/classROOT_1_1Experimental_1_1REveVSD.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveVSD.html,1,['Load'],['LoadTrees']
Performance,"D() [4/4]. TProfile3D::TProfile3D ; (; const TProfile3D & ; profile). Copy constructor. ; Definition at line 157 of file TProfile3D.cxx. ◆ ~TProfile3D(). TProfile3D::~TProfile3D ; (; ). override . Default destructor for Profile3D histograms. ; Definition at line 86 of file TProfile3D.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TProfile3D::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). overridevirtual . Replace contents of this profile3D by the addition of h1 and h2. ; this = c1*h1 + c2*h2 ; Reimplemented from TH1.; Definition at line 200 of file TProfile3D.cxx. ◆ Add() [2/3]. Bool_t TProfile3D::Add ; (; const TH1 * ; h1, . Double_t ; c1 = 1 . ). overridevirtual . Performs the operation: this = this + c1*h1 . ; Reimplemented from TH1.; Definition at line 181 of file TProfile3D.cxx. ◆ Add() [3/3]. Bool_t TProfile3D::Add ; (; TF1 * ; h1, . Double_t ; c1 = 1, . Option_t * ; option = """" . ). overridevirtual . Performs the operation: this = this + c1*f1 . ; Reimplemented from TH1.; Definition at line 172 of file TProfile3D.cxx. ◆ Approximate(). void TProfile3D::Approximate ; (; Bool_t ; approx = kTRUE). static . Set the fgApproximate flag. ; When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only. the number of bins in the profile3D is less than 10404 (eg 100x100x100); the bin number of entries is small ( <5); the estimated bin error is extremely small compared to the bin content (see TProfile3D::GetBinError) . Definition at line 231 of file TProfile3D.cxx. ◆ BufferEmpty(). Int_t TProfile3D::BufferEmpty ; (; Int_t ; action = 0). overridevirtual . Fill histogram with all entries in the buffer. . action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted The buffer is automatically dele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:69754,Perform,Performs,69754,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['Perform'],['Performs']
Performance,"D() [7/7]. TProfile2D::TProfile2D ; (; const TProfile2D & ; profile). Copy constructor. ; Definition at line 206 of file TProfile2D.cxx. ◆ ~TProfile2D(). TProfile2D::~TProfile2D ; (; ). override . Default destructor for Profile2D histograms. ; Definition at line 98 of file TProfile2D.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TProfile2D::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). overridevirtual . Replace contents of this profile2D by the addition of h1 and h2. ; this = c1*h1 + c2*h2 ; Reimplemented from TH1.; Definition at line 249 of file TProfile2D.cxx. ◆ Add() [2/3]. Bool_t TProfile2D::Add ; (; const TH1 * ; h1, . Double_t ; c1 = 1 . ). overridevirtual . Performs the operation: this = this + c1*h1 . ; Reimplemented from TH1.; Definition at line 230 of file TProfile2D.cxx. ◆ Add() [3/3]. Bool_t TProfile2D::Add ; (; TF1 * ; h1, . Double_t ; c1 = 1, . Option_t * ; option = """" . ). overridevirtual . Performs the operation: this = this + c1*f1 . ; Reimplemented from TH1.; Definition at line 221 of file TProfile2D.cxx. ◆ Approximate(). void TProfile2D::Approximate ; (; Bool_t ; approx = kTRUE). static . Static function, set the fgApproximate flag. ; When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only; the number of bins in the profile2D is less than 10404 (eg 100x100); the bin number of entries is small ( <5); the estimated bin error is extremely small compared to the bin content (see TProfile2D::GetBinError) . Definition at line 277 of file TProfile2D.cxx. ◆ BufferEmpty(). Int_t TProfile2D::BufferEmpty ; (; Int_t ; action = 0). overridevirtual . Fill histogram with all entries in the buffer. . action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted The buffer is autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:71382,Perform,Performs,71382,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['Perform'],['Performs']
Performance,"D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); voidSetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DistSampler(); default constructor. {}. virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DistSampler.html:2304,cache,cached,2304,root/html602/ROOT__Math__DistSampler.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DistSampler.html,2,['cache'],['cached']
Performance,"D(const TEveVSD&); TEveVSD&operator=(const TEveVSD&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TEveClusterfC; TEveRecCascadefCC; TEveMCRecCrossReffGI; TEveHitfH; TEveMCTrackfK; TEveRecKinkfKK; TEveRecTrackfR; TTree*fTreeC! Clusters.; TTree*fTreeCC! Cascades.; TTree*fTreeGI! Sim-Rec cross references.; TTree*fTreeH! Hits.; TTree*fTreeK! Kinematics.; TTree*fTreeKK! Kinks.; TTree*fTreeR! Reconstructed tracks.; TTree*fTreeV0! VO's.; TEveRecV0fV0; TEveCluster*fpC!; TEveRecCascade*fpCC!; TEveMCRecCrossRef*fpGI!; TEveHit*fpH!; TEveMCTrack*fpK!; TEveRecKink*fpKK!; TEveRecTrack*fpR!; TEveRecV0*fpV0!. protected:. Int_tfBuffSize!; TDirectory*fDirectory!; TFile*fFile!; Int_tfVerbose!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveVSD(const char* name = ""TEveVSD"", const char* title = """"); Constructor. ~TEveVSD(); Destructor. void SetDirectory(TDirectory* dir); Set directory in which the trees are (or will be) created. void CreateTrees(); Create internal trees. void DeleteTrees(); Delete interal trees. void CreateBranches(); Create internal VSD branches. void SetBranchAddresses(); Set branche addresses of internal trees. void WriteTrees(); Does nothing here ... reimplemented in sub-classes. void LoadTrees(); Load internal trees from directory. void DisableTObjectStreamersForVSDStruct(); Disble TObject streamers for those VSD structs that inherit from; TObject directly. TEveVSD(const TEveVSD& ). TEveVSD& operator=(const TEveVSD& ). » Last changed: root/eve:$Id: TEveVSD.h 31363 2009-11-21 11:31:07Z matevz $ » Last generated: 2010-09-23 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveVSD.html:6559,Load,LoadTrees,6559,root/html528/TEveVSD.html,https://root.cern,https://root.cern/root/html528/TEveVSD.html,2,['Load'],"['Load', 'LoadTrees']"
Performance,"D(const TEveVSD&); TEveVSD&operator=(const TEveVSD&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TEveClusterfC; TEveRecCascadefCC; TEveMCRecCrossReffGI; TEveHitfH; TEveMCTrackfK; TEveRecKinkfKK; TEveRecTrackfR; TTree*fTreeC! Clusters.; TTree*fTreeCC! Cascades.; TTree*fTreeGI! Sim-Rec cross references.; TTree*fTreeH! Hits.; TTree*fTreeK! Kinematics.; TTree*fTreeKK! Kinks.; TTree*fTreeR! Reconstructed tracks.; TTree*fTreeV0! VO's.; TEveRecV0fV0; TEveCluster*fpC!; TEveRecCascade*fpCC!; TEveMCRecCrossRef*fpGI!; TEveHit*fpH!; TEveMCTrack*fpK!; TEveRecKink*fpKK!; TEveRecTrack*fpR!; TEveRecV0*fpV0!. protected:. Int_tfBuffSize!; TDirectory*fDirectory!; TFile*fFile!; Int_tfVerbose!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveVSD(const char* name = ""TEveVSD"", const char* title = """"); Constructor. ~TEveVSD(); Destructor. void SetDirectory(TDirectory* dir); Set directory in which the trees are (or will be) created. void CreateTrees(); Create internal trees. void DeleteTrees(); Delete interal trees. void CreateBranches(); Create internal VSD branches. void SetBranchAddresses(); Set branche addresses of internal trees. void WriteTrees(); Does nothing here ... reimplemented in sub-classes. void LoadTrees(); Load internal trees from directory. void DisableTObjectStreamersForVSDStruct(); Disble TObject streamers for those VSD structs that inherit from; TObject directly. TEveVSD(const TEveVSD& ). TEveVSD& operator=(const TEveVSD& ). » Last changed: root/eve:$Id: TEveVSD.h 31363 2009-11-21 11:31:07Z matevz $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveVSD.html:6628,Load,LoadTrees,6628,root/html530/TEveVSD.html,https://root.cern,https://root.cern/root/html530/TEveVSD.html,2,['Load'],"['Load', 'LoadTrees']"
Performance,"D(const TEveVSD&); TEveVSD&operator=(const TEveVSD&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TEveClusterfC; TEveRecCascadefCC; TEveMCRecCrossReffGI; TEveHitfH; TEveMCTrackfK; TEveRecKinkfKK; TEveRecTrackfR; TTree*fTreeC! Clusters.; TTree*fTreeCC! Cascades.; TTree*fTreeGI! Sim-Rec cross references.; TTree*fTreeH! Hits.; TTree*fTreeK! Kinematics.; TTree*fTreeKK! Kinks.; TTree*fTreeR! Reconstructed tracks.; TTree*fTreeV0! VO's.; TEveRecV0fV0; TEveCluster*fpC!; TEveRecCascade*fpCC!; TEveMCRecCrossRef*fpGI!; TEveHit*fpH!; TEveMCTrack*fpK!; TEveRecKink*fpKK!; TEveRecTrack*fpR!; TEveRecV0*fpV0!. protected:. Int_tfBuffSize!; TDirectory*fDirectory!; TFile*fFile!; Int_tfVerbose!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveVSD(const char* name = ""TEveVSD"", const char* title = """"); Constructor. ~TEveVSD(); Destructor. void SetDirectory(TDirectory* dir); Set directory in which the trees are (or will be) created. void CreateTrees(); Create internal trees. void DeleteTrees(); Delete interal trees. void CreateBranches(); Create internal VSD branches. void SetBranchAddresses(); Set branche addresses of internal trees. void WriteTrees(); Does nothing here ... reimplemented in sub-classes. void LoadTrees(); Load internal trees from directory. void DisableTObjectStreamersForVSDStruct(); Disble TObject streamers for those VSD structs that inherit from; TObject directly. TEveVSD(const TEveVSD& ). TEveVSD& operator=(const TEveVSD& ). » Last changed: root/eve:$Id: TEveVSD.h 31363 2009-11-21 11:31:07Z matevz $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveVSD.html:6628,Load,LoadTrees,6628,root/html532/TEveVSD.html,https://root.cern,https://root.cern/root/html532/TEveVSD.html,2,['Load'],"['Load', 'LoadTrees']"
Performance,"D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments. TH1D* GetD() const; Returns d vector (for choosing appropriate regularisation). TH1D* GetSV() const; Returns singular values vector. TH2D* GetXtau() const; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSVDUnfold.html:8110,Perform,Perform,8110,root/html530/TSVDUnfold.html,https://root.cern,https://root.cern/root/html530/TSVDUnfold.html,3,['Perform'],['Perform']
Performance,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:18511,perform,performs,18511,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,2,['perform'],['performs']
Performance,"D, TMVA::MethodLikelihood, TMVA::MethodMLP, TMVA::MethodPDEFoam, TMVA::MethodPDERS, TMVA::MethodRuleFit, TMVA::MethodSVM, and TMVA::MethodTMlpANN.; Definition at line 520 of file MethodBase.h. ◆ MakeClassSpecificHeader(). virtual void TMVA::MethodBase::MakeClassSpecificHeader ; (; std::ostream & ; , . const TString & ; = """" . ); const. inlineprotectedvirtual . Reimplemented in TMVA::MethodBDT, TMVA::MethodCrossValidation, TMVA::MethodCFMlpANN, and TMVA::MethodLikelihood.; Definition at line 523 of file MethodBase.h. ◆ MethodBaseDir(). TDirectory * TMVA::MethodBase::MethodBaseDir ; (; ); const. returns the ROOT directory where all instances of the corresponding MVA method are stored ; Definition at line 2020 of file MethodBase.cxx. ◆ NoErrorCalc(). void TMVA::MethodBase::NoErrorCalc ; (; Double_t *const ; err, . Double_t *const ; errUpper . ). protected . Definition at line 837 of file MethodBase.cxx. ◆ OptimizeTuningParameters(). std::map< TString, Double_t > TMVA::MethodBase::OptimizeTuningParameters ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). virtual . call the Optimizer with the set of parameters and ranges that are meant to be tuned. ; Reimplemented in TMVA::MethodBDT, and TMVA::MethodSVM.; Definition at line 623 of file MethodBase.cxx. ◆ PrintHelpMessage(). void TMVA::MethodBase::PrintHelpMessage ; (; ); const. virtual . prints out method-specific help method ; Implements TMVA::IMethod.; Definition at line 3264 of file MethodBase.cxx. ◆ ProcessBaseOptions(). void TMVA::MethodBase::ProcessBaseOptions ; (; ). private . the option string is decoded, for available options see ""DeclareOptions"" ; Definition at line 540 of file MethodBase.cxx. ◆ ProcessOptions(). virtual void TMVA::MethodBase::ProcessOptions ; (; ). pure virtual . Implements TMVA::IMethod.; Implemented in TMVA::MethodPyAdaBoost, TMVA::MethodPyGTB, TMVA::MethodPyKeras, TMVA::MethodPyRandomForest, TMVA::MethodPyTorch, TMVA::MethodC50, TMVA::MethodRSNNS, TMVA::MethodRSVM, TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:64284,Optimiz,OptimizeTuningParameters,64284,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"DDrop (TDNDData *data) override;  Handle Drop event. ;  ; Atom_t HandleDNDEnter (Atom_t *typelist) override;  Handle Drag Enter event. ;  ; Bool_t HandleDNDLeave () override;  Handle Drag Leave event. ;  ; Atom_t HandleDNDPosition (Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot) override;  Handle Drag position event. ;  ; Bool_t HandleDoubleClick (Event_t *event) override;  handle double click ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion event in the text editor widget. ;  ; Bool_t HandleSelectionClear (Event_t *event) override;  Handle selection clear event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle request to send current clipboard contents to requestor window. ;  ; Bool_t HandleTimer (TTimer *t) override;  Handle scroll timer. ;  ; Bool_t IsMarked () const;  ; Bool_t IsReadOnly () const;  ; virtual Bool_t IsSaved ();  ; void Layout () override;  Layout the components of view. ;  ; virtual Bool_t LoadBuffer (const char *txtbuf);  Load text from a text buffer. Return false in case of failure. ;  ; virtual Bool_t LoadFile (const char *fname, long startpos=0, long length=-1);  Load a file in the text view widget. ;  ; virtual void Marked (Bool_t mark);  ; virtual Long_t ReturnHeighestColHeight ();  ; virtual Long_t ReturnLineCount ();  ; virtual Long_t ReturnLineLength (Long_t line);  ; virtual Long_t ReturnLongestLine ();  ; virtual Long_t ReturnLongestLineWidth ();  Return width of longest line. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save a text edit widget as a C++ statement(s) on output stream out. ;  ; virtual Bool_t Search (const char *string, Bool_t direction, Bool_t caseSensitive);  Search for string in text. ;  ; virtual Bool_t SelectAll ();  Select all text in the viewer. ;  ; virtual void SetBackground (Pixel_t p);  set background color ;  ; virtual void SetFont (FontStruct_t font);  Changes text entry font. ;  ; void SetForegroundColor (Pixel_t) override;  Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextViewostream.html:3540,Load,LoadBuffer,3540,doc/master/classTGTextViewostream.html,https://root.cern,https://root.cern/doc/master/classTGTextViewostream.html,2,['Load'],"['Load', 'LoadBuffer']"
Performance,"DEFoam for Regression; : ; : Build mono target regression foam; : Elapsed time: 0.613 sec ; : Elapsed time for training with 1000 events: 0.62 sec ; : Dataset[datasetreg] : Create results for training; : Dataset[datasetreg] : Evaluation of PDEFoam on training sample; : Dataset[datasetreg] : Elapsed time for evaluation of 1000 events: 0.00639 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: ␛[0;36mdatasetreg/weights/TMVARegression_PDEFoam.weights.xml␛[0m; : writing foam MonoTargetRegressionFoam to file; : Foams written to file: ␛[0;36mdatasetreg/weights/TMVARegression_PDEFoam.weights_foams.root␛[0m; Factory : Training finished; : ; Factory : Train method: KNN for Regression; : ; KNN : <Train> start...; : Reading 1000 events; : Number of signal events 1000; : Number of background events 0; : Creating kd-tree with 1000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 2 variables with 1000 values; : <Fill> Class 1 has 1000 events; : Elapsed time for training with 1000 events: 0.0013 sec ; : Dataset[datasetreg] : Create results for training; : Dataset[datasetreg] : Evaluation of KNN on training sample; : Dataset[datasetreg] : Elapsed time for evaluation of 1000 events: 0.00935 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: ␛[0;36mdatasetreg/weights/TMVARegression_KNN.weights.xml␛[0m; Factory : Training finished; : ; Factory : Train method: LD for Regression; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +42.509; : var2: +44.738; : (offset): -88.627; : -----------------------; : Elapsed time for training with 1000 events: 0.00036 sec ; : Dataset[datasetreg] : Create results for training; : Data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:8062,Optimiz,Optimizing,8062,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['Optimiz'],['Optimizing']
Performance,"DLGradientDescent< Architecture_t >::SetTestInterval ; (; size_t ; interval). inline . Definition at line 154 of file DLMinimizers.h. ◆ Step() [1/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 182 of file DLMinimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; master, . std::vector< DeepNet_t > & ; nets, . std::vector< TTensorBatch< Architecture_t > > & ; batches . ). Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 246 of file DLMinimizers.h. ◆ StepLoss(). template<typename Architecture_t > . auto TMVA::DNN::TDLGradientDescent< Architecture_t >::StepLoss ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Same as Step(...) but also evaluate the loss on the given training data. ; Note that this requires synchronization between host and device. ; Definition at line 212 of file DLMinimizers.h. ◆ StepMomentum(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::StepMomentum ; (; DeepNet_t & ; master, . std::vector< DeepNet_t > & ; nets, . std::vector< TTensorBatch< A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:8635,Perform,Perform,8635,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,"DM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<std::string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Short_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:15264,optimiz,optimization,15264,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,1,['optimiz'],['optimization']
Performance,"Data (TKeySQL *key);  Add entry into keys table. ;  ; Bool_t WriteSpecialObject (Long64_t keyid, TObject *obj, const char *name, const char *title);  write special kind of object like streamer infos or file itself keys for that objects should exist in tables but not indicated in list of keys, therefore users can not get them with TDirectoryFile::Get() method ;  ;  Protected Member Functions inherited from TFile; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:50137,cache,cache,50137,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['cache'],['cache']
Performance,"Data(),"""");; 5100 return;; 5101 }; 5102 ; 5103 //==============Save pad/canvas as a XML file================================; 5104 if (strstr(opt,""xml"")) {; 5105 // Plugin XML driver; 5106 if (gDirectory) gDirectory->SaveObjectAs(this,psname.Data(),"""");; 5107 return;; 5108 }; 5109 ; 5110 //==============Save pad/canvas as a JSON file================================; 5111 if (strstr(opt,""json"")) {; 5112 if (gDirectory) gDirectory->SaveObjectAs(this,psname.Data(),"""");; 5113 return;; 5114 }; 5115 ; 5116 //==============Save pad/canvas as a SVG file================================; 5117 if (strstr(opt,""svg"")) {; 5118 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5119 ; 5120 Bool_t noScreen = kFALSE;; 5121 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5122 noScreen = kTRUE;; 5123 GetCanvas()->SetBatch(kTRUE);; 5124 }; 5125 ; 5126 TContext ctxt(this, kTRUE);; 5127 ; 5128 if (!gVirtualPS) {; 5129 // Plugin Postscript/SVG driver; 5130 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPS"", ""svg"")) {; 5131 if (h->LoadPlugin() == -1); 5132 return;; 5133 h->ExecPlugin(0);; 5134 }; 5135 }; 5136 ; 5137 // Create a new SVG file; 5138 if (gVirtualPS) {; 5139 gVirtualPS->SetName(psname);; 5140 gVirtualPS->Open(psname);; 5141 gVirtualPS->SetBit(kPrintingPS);; 5142 gVirtualPS->NewPage();; 5143 }; 5144 Paint();; 5145 if (noScreen); 5146 GetCanvas()->SetBatch(kFALSE);; 5147 ; 5148 if (!gSystem->AccessPathName(psname)); 5149 Info(""Print"", ""SVG file %s has been created"", psname.Data());; 5150 ; 5151 delete gVirtualPS;; 5152 gVirtualPS = nullptr;; 5153 ; 5154 return;; 5155 }; 5156 ; 5157 //==============Save pad/canvas as a TeX file================================; 5158 if (strstr(opt,""tex"") || strstr(opt,""Standalone"")) {; 5159 gVirtualPS = (TVirtualPS*)gROOT->GetListOfSpecials()->FindObject(psname);; 5160 ; 5161 Bool_t noScreen = kFALSE;; 5162 if (!GetCanvas()->IsBatch() && GetCanvas()->GetCanvasID() == -1) {; 5163 noScreen = kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:165541,Load,LoadPlugin,165541,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"Data(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); voidTProof::SetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset); Int_tTProof::VerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:22217,cache,cachedir,22217,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['cache'],['cachedir']
Performance,"DataSet ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; obs . ). overrideprotectedvirtual . Create an empty dataset to hold the events that will be generated. ; Reimplemented from RooAbsGenContext.; Definition at line 175 of file RooSimGenContext.cxx. ◆ DeclFileName(). static const char * RooSimGenContext::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooSimGenContext.h. ◆ generateEvent(). void RooSimGenContext::generateEvent ; (; RooArgSet & ; theEvent, . Int_t ; remaining . ). overrideprotectedvirtual . Generate event appropriate for current index state. ; The index state is taken either from the prototype or is generated from the fraction threshold table. ; Implements RooAbsGenContext.; Definition at line 208 of file RooSimGenContext.cxx. ◆ initGenerator(). void RooSimGenContext::initGenerator ; (; const RooArgSet & ; theEvent). overrideprotectedvirtual . Perform one-time initialization of generator context. ; Reimplemented from RooAbsGenContext.; Definition at line 152 of file RooSimGenContext.cxx. ◆ IsA(). TClass * RooSimGenContext::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsGenContext.; Definition at line 63 of file RooSimGenContext.h. ◆ printMultiline(). void RooSimGenContext::printMultiline ; (; std::ostream & ; os, . Int_t ; content, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Detailed printing interface. ; Reimplemented from RooAbsGenContext.; Definition at line 291 of file RooSimGenContext.cxx. ◆ setProtoDataOrder(). void RooSimGenContext::setProtoDataOrder ; (; Int_t * ; lut). overridevirtual . Set the traversal order of the prototype data to that in the given lookup table. ; This information is passed to all component generator contexts ; Reimplemented from RooAbsGenContext.; Definition at line 278 of file RooSimGenContext.cxx. ◆ Streamer(). void RooS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimGenContext.html:20569,Perform,Perform,20569,doc/master/classRooSimGenContext.html,https://root.cern,https://root.cern/doc/master/classRooSimGenContext.html,1,['Perform'],['Perform']
Performance,"DataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:38552,optimiz,optimizeDirtyHook,38552,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"DataStore::hasAsymError ; (; RooAbsReal * ; real). protected . Definition at line 1292 of file RooVectorDataStore.cxx. ◆ hasError(). bool RooVectorDataStore::hasError ; (; RooAbsReal * ; real). protected . Definition at line 1280 of file RooVectorDataStore.cxx. ◆ hasFilledCache(). bool RooVectorDataStore::hasFilledCache ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsDataStore.; Definition at line 562 of file RooVectorDataStore.h. ◆ IsA(). TClass * RooVectorDataStore::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsDataStore.; Definition at line 591 of file RooVectorDataStore.h. ◆ isFullReal(). bool RooVectorDataStore::isFullReal ; (; RooAbsReal * ; real). protected . Definition at line 1268 of file RooVectorDataStore.cxx. ◆ isWeighted(). bool RooVectorDataStore::isWeighted ; (; ); const. inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 122 of file RooVectorDataStore.h. ◆ loadValues(). void RooVectorDataStore::loadValues ; (; const RooAbsDataStore * ; tds, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 494 of file RooVectorDataStore.cxx. ◆ merge(). RooAbsDataStore * RooVectorDataStore::merge ; (; const RooArgSet & ; allVars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Merge columns of supplied data set(s) with this data set. ; All data sets must have equal number of entries. In case of duplicate columns the column of the last dataset in the list prevails ; Implements RooAbsDataStore.; Definition at line 679 of file RooVectorDataStore.cxx. ◆ numEntries(). Int_t RooVectorDataStore::numEntries ; (; ); const. inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 141 of file RooVectorDataStore.h. ◆ realfStoreList(). std::vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:32922,load,loadValues,32922,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['load'],['loadValues']
Performance,"Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; Bool_t_init! Is object initialized ; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; Bool_t_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:35501,cache,cache,35501,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"Decay &other, const char *name=nullptr);  Copy constructor. ;  ; TObject * clone (const char *newname) const override;  ; double coefAnalyticalIntegral (Int_t coef, Int_t code, const char *rangeName=nullptr) const override;  Default implementation of function implementing advertised integrals. ;  ; double coefficient (Int_t basisIndex) const override;  ; RooFit::OwningPtr< RooArgSet > coefVars (Int_t coefIdx) const override;  Return set of parameters with are used exclusively by the coefficient functions. ;  ; void generateEvent (Int_t code) override;  Interface for generation of an event using the algorithm corresponding to the specified code. ;  ; Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Default implementation of function advertising integration capabilities. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsAnaConvPdf;  RooAbsAnaConvPdf ();  Default constructor, required for persistence. ;  ;  RooAbsAnaConvPdf (const char *name, const char *title, const RooResolutionModel &model, RooRealVar &convVar);  Constructor. ;  ;  RooAbsAnaConvPdf (const RooAbsAnaConvPdf &other, const char *name=nullptr);  ;  ~RooAbsAnaConvPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral defined by given code, which is returned by getAnalyticalIntegralWN() ;  ; virtual bool changeModel (const RooResolutionModel &newModel);  Change ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBDecay.html:3665,Load,Load,3665,doc/master/classRooBDecay.html,https://root.cern,https://root.cern/doc/master/classRooBDecay.html,1,['Load'],['Load']
Performance,"Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:2243,perform,performed,2243,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,5,['perform'],['performed']
Performance,"Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; ; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLikelihood.html:2243,perform,performed,2243,root/html534/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLikelihood.html,1,['perform'],['performed']
Performance,"Defaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::SaveAsvoid SaveAs(const char *filename="""", Option_t *option="""") const overrideSave this object to filename.Definition TTreePerfStats.cxx:647; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; then, in a root interactive session, one can do: root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();; The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MBytes per RT second; ReadUZCP = Unipped MBytes per CP second; ReadRT = Zipped MBytes per RT second; ReadCP = Zipped MBytes per CP second. NOTE 1 :; The ReadTotal value indicates the effective number of zipped bytes returned to the application. The physical number of bytes read from the device (as measured for example with strace) is ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. NOTE 2 :; A consequence of NOTE1, the Disk I/O speed corresponds to the effective number of bytes returned to the application per second. The Physical disk speed is DiskIO + DiskIO*ReadExtra/100. ; Definition at line 38 of file TTreePerfStats.h. Classes; struct  BasketInfo;  . Public Types; using BasketList_t = std::vector< std::pair< TBranch *, std::vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats.html:2447,cache,cache,2447,doc/master/classTTreePerfStats.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats.html,1,['cache'],['cache']
Performance,"Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooAbsReal.h:535; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * plotSamplingHint(RooAbsRealLValue &obs, double xlo, double xhi) constInterface for returning an optional hint for initial sampling points when constructing a curve projec...Definition RooAbsReal.cxx:3571; RooAbsReal::setPlotLabelvoid setPlotLabel(const char *label)Set the label associated with this variable.Definition RooAbsReal.cxx:416; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:52396,cache,cache,52396,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['cache'],['cache']
Performance,"Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:217101,cache,cache,217101,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:175527,Perform,Performs,175527,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['Perform'],['Performs']
Performance,"Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:195094,Perform,Performs,195094,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['Perform'],['Performs']
Performance,"Definition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::SaveAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the c...Definition TH1.cxx:4611; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:457742,Perform,Performs,457742,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['Perform'],['Performs']
Performance,"Definition at line 241 of file DecisionTree.h. ◆ fgDebugLevel. const Int_t TMVA::DecisionTree::fgDebugLevel = 0. staticprivate . debug level determining some printout/control plots etc. ; Definition at line 236 of file DecisionTree.h. ◆ fgRandomSeed. const Int_t TMVA::DecisionTree::fgRandomSeed = 0. staticprivate . Definition at line 69 of file DecisionTree.h. ◆ fMaxDepth. UInt_t TMVA::DecisionTree::fMaxDepth. private . max depth ; Definition at line 234 of file DecisionTree.h. ◆ fMinLinCorrForFisher. Double_t TMVA::DecisionTree::fMinLinCorrForFisher. private . the minimum linear correlation between two variables demanded for use in fisher criterium in node splitting ; Definition at line 208 of file DecisionTree.h. ◆ fMinNodeSize. Double_t TMVA::DecisionTree::fMinNodeSize. private . min fraction of training events in node ; Definition at line 215 of file DecisionTree.h. ◆ fMinSepGain. Double_t TMVA::DecisionTree::fMinSepGain. private . min number of separation gain to perform node splitting ; Definition at line 216 of file DecisionTree.h. ◆ fMinSize. Double_t TMVA::DecisionTree::fMinSize. private . min number of events in node ; Definition at line 214 of file DecisionTree.h. ◆ fMyTrandom. TRandom3* TMVA::DecisionTree::fMyTrandom. private . random number generator for randomised trees ; Definition at line 230 of file DecisionTree.h. ◆ fNCuts. Int_t TMVA::DecisionTree::fNCuts. private . number of grid point in variable cut scans ; Definition at line 206 of file DecisionTree.h. ◆ fNNodesBeforePruning. Int_t TMVA::DecisionTree::fNNodesBeforePruning. private . remember this one (in case of pruning, it allows to monitor the before/after ; Definition at line 222 of file DecisionTree.h. ◆ fNodePurityLimit. Double_t TMVA::DecisionTree::fNodePurityLimit. private . purity limit to decide whether a node is signal ; Definition at line 224 of file DecisionTree.h. ◆ fNvars. UInt_t TMVA::DecisionTree::fNvars. private . number of variables used to separate S and B ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:28589,perform,perform,28589,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['perform'],['perform']
Performance,"Definition at line 250 of file Util.h. ◆ operator!=(). template<typename T = double, unsigned int N = 1> . template<typename U , unsigned int M> . bool ROOT::Math::KahanSum< T, N >::operator!= ; (; KahanSum< U, M > const & ; other); const. inline . Definition at line 310 of file Util.h. ◆ operator+=() [1/2]. template<typename T = double, unsigned int N = 1> . template<typename U , unsigned int M> . KahanSum< T, N > & ROOT::Math::KahanSum< T, N >::operator+= ; (; const KahanSum< U, M > & ; other). inline . Add other KahanSum into accumulator. ; Does not vectorise.; Based on KahanIncrement from: Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12. Note that while Tian et al. add the carry in the first step, we subtract the carry, in accordance with the Add(Indexed) implementation(s) above. This is purely an implementation choice that has no impact on performance.; NoteTake care when using += (and -=) to add other KahanSums into a zero-initialized KahanSum. The operator behaves correctly in this case, but the result may be slightly off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum and x another KahanSum). In particular, x's carry term may get lost. This doesn't just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry test case in the testKahan unittest for other examples. This behavior is internally consistent: the carry also gets lost if you switch the operands and it also happens with other KahanSum operators. ; Definition at line 277 of file Util.h. ◆ operator+=() [2/2]. template<typename T = double, unsigned int N = 1> . KahanSum< T, N > & ROOT::Math::KahanSum< T, N >::operator+= ; (; T ; arg). inline . Add arg into accumulator. Does not vectorise. ; Definition at line 255 of file Util.h. ◆ operator-(). template<typename T = double, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html:11089,perform,performance,11089,doc/master/classROOT_1_1Math_1_1KahanSum.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html,1,['perform'],['performance']
Performance,"Definition at line 59 of file TMacro.h. ◆ Exec(). Longptr_t TMacro::Exec ; (; const char * ; params = nullptr, . Int_t * ; error = nullptr . ). virtual . Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine(). Returns the result of the macro (return value or value of the last expression), cast to a Long_t. ; Reimplemented in TEveMacro.; Definition at line 262 of file TMacro.cxx. ◆ GetLineWith(). TObjString * TMacro::GetLineWith ; (; const char * ; text); const. virtual . Search the first line containing text. ; Definition at line 297 of file TMacro.cxx. ◆ GetListOfLines(). TList * TMacro::GetListOfLines ; (; ); const. inline . Definition at line 51 of file TMacro.h. ◆ IsA(). TClass * TMacro::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 59 of file TMacro.h. ◆ Load(). Bool_t TMacro::Load ; (; ); const. virtual . Load the macro into the interpreter. ; Return true in case the loading was successful. ; Definition at line 244 of file TMacro.cxx. ◆ operator=(). TMacro & TMacro::operator= ; (; const TMacro & ; macro). Copy constructor. ; Definition at line 120 of file TMacro.cxx. ◆ Paint(). void TMacro::Paint ; (; Option_t * ; option = """"). overridevirtual . Execute this macro (called by TPad::Paint). ; Reimplemented from TObject.; Definition at line 311 of file TMacro.cxx. ◆ Print(). void TMacro::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print contents of this macro. ; Reimplemented from TObject.; Definition at line 319 of file TMacro.cxx. ◆ ReadFile(). Int_t TMacro::ReadFile ; (; const char * ; filename). virtual . Read lines in filename in this macro. ; Definition at line 329 of file TMacro.cxx. ◆ SavePrimitive(). void TMacro::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save macro source on stream out.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:18443,Load,Load,18443,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['Load'],['Load']
Performance,"Definition at line 5912 of file TClass.cxx. ◆ IsStartingWithTObject(). Bool_t TClass::IsStartingWithTObject ; (; ); const. Returns true if this class inherits from TObject and if the start of the TObject parts is at the very beginning of the objects. ; Concretely this means that the following code is proper for this class: ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from TObject. ; Definition at line 5929 of file TClass.cxx. ◆ IsSyntheticPair(). Bool_t TClass::IsSyntheticPair ; (; ); const. inline . Definition at line 521 of file TClass.h. ◆ IsTObject(). Bool_t TClass::IsTObject ; (; ); const. Return kTRUE is the class inherits from TObject. ; Definition at line 5938 of file TClass.cxx. ◆ IsVersioned(). Bool_t TClass::IsVersioned ; (; ); const. inline . Definition at line 522 of file TClass.h. ◆ Load(). TClass * TClass::Load ; (; TBuffer & ; b). static . Load class description from I/O buffer and return class object. ; Definition at line 5715 of file TClass.cxx. ◆ LoadClass(). TClass * TClass::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5749 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:101446,Load,Load,101446,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['Load'],['Load']
Performance,"Definition at line 5979 of file TClass.cxx. ◆ IsStartingWithTObject(). Bool_t TClass::IsStartingWithTObject ; (; ); const. Returns true if this class inherits from TObject and if the start of the TObject parts is at the very beginning of the objects. ; Concretely this means that the following code is proper for this class: ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from TObject. ; Definition at line 5996 of file TClass.cxx. ◆ IsSyntheticPair(). Bool_t TClass::IsSyntheticPair ; (; ); const. inline . Definition at line 521 of file TClass.h. ◆ IsTObject(). Bool_t TClass::IsTObject ; (; ); const. Return kTRUE is the class inherits from TObject. ; Definition at line 6005 of file TClass.cxx. ◆ IsVersioned(). Bool_t TClass::IsVersioned ; (; ); const. inline . Definition at line 522 of file TClass.h. ◆ Load(). TClass * TClass::Load ; (; TBuffer & ; b). static . Load class description from I/O buffer and return class object. ; Definition at line 5782 of file TClass.cxx. ◆ LoadClass(). TClass * TClass::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5816 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:101447,Load,Load,101447,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['Load'],['Load']
Performance,"Definition at line 79 of file PdfProposal.h. ◆ SetOwnsPdf(). virtual void RooStats::PdfProposal::SetOwnsPdf ; (; bool ; ownsPdf). inlinevirtual . set whether we own the PDF that serves as the proposal density function By default, when constructed, PdfProposal does NOT own the PDF. ; Definition at line 91 of file PdfProposal.h. ◆ SetPdf(). virtual void RooStats::PdfProposal::SetPdf ; (; RooAbsPdf & ; pdf). inlinevirtual . Set the PDF to be the proposal density function. ; Definition at line 49 of file PdfProposal.h. ◆ Streamer(). void RooStats::PdfProposal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooStats::PdfProposal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 118 of file PdfProposal.h. Member Data Documentation. ◆ fCache. std::unique_ptr<RooDataSet> RooStats::PdfProposal::fCache. protected . our position in the cached proposal data set ; Definition at line 109 of file PdfProposal.h. ◆ fCachePosition. Int_t RooStats::PdfProposal::fCachePosition = 0. protected . how many points to generate each time ; Definition at line 108 of file PdfProposal.h. ◆ fCacheSize. Int_t RooStats::PdfProposal::fCacheSize = 1. protected . the last point we were at ; Definition at line 107 of file PdfProposal.h. ◆ fIt. std::map<RooRealVar*,RooAbsReal*>::iterator RooStats::PdfProposal::fIt. protected . map of values in pdf to update ; Definition at line 105 of file PdfProposal.h. ◆ fLastX. RooArgSet RooStats::PdfProposal::fLastX. protected . pdf iterator ; Definition at line 106 of file PdfProposal.h. ◆ fMap. std::map<RooRealVar*, RooAbsReal*> RooStats::PdfProposal::fMap. protected . the proposal density function ; Definition at line 104 of file PdfProposal.h. ◆ fMaster. RooArgSet RooStats::PdfProposal::fMaster. protected . the cached proposal data set ; Definition at line 110 of file PdfProposal.h. ◆ fOwnsPdf. bool RooStats::PdfProposal::fOwn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:19726,cache,cached,19726,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,1,['cache'],['cached']
Performance,"Definition at line 84 of file TProofBenchDataSet.cxx. ◆ DeclFileName(). static const char * TProofBenchDataSet::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 47 of file TProofBenchDataSet.h. ◆ Handle(). Int_t TProofBenchDataSet::Handle ; (; const char * ; dset, . TObject * ; type . ). protected . Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 111 of file TProofBenchDataSet.cxx. ◆ IsA(). TClass * TProofBenchDataSet::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 47 of file TProofBenchDataSet.h. ◆ IsProof(). Bool_t TProofBenchDataSet::IsProof ; (; TProof * ; p). inline . Definition at line 41 of file TProofBenchDataSet.h. ◆ ReleaseCache(). Int_t TProofBenchDataSet::ReleaseCache ; (; const char * ; dset). Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ; Definition at line 46 of file TProofBenchDataSet.cxx. ◆ RemoveFiles(). Int_t TProofBenchDataSet::RemoveFiles ; (; const char * ; dset). Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 63 of file TProofBenchDataSet.cxx. ◆ Streamer(). void TProofBenchDataSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TProofBenchDataSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 47 of file TProofBenchDataSet.h. Member Data Documentation. ◆ fProof. TProof* TProofBenchDataSet::fProof. protected . Definition at line 32 of file TProofBenchDataSet.h. proof/proofbench/inc/TProofBenchDataSet.h; proof/proofbench/src/TProofBenchDataSet.cxx. TProofBenchDataSet. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:13 (GVA ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBenchDataSet.html:12674,cache,cache,12674,doc/master/classTProofBenchDataSet.html,https://root.cern,https://root.cern/doc/master/classTProofBenchDataSet.html,1,['cache'],['cache']
Performance,"Delete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TRInterface.h>. Inheritance diagram for ROOT::R::TRInterface:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TRInterface(). TRInterface::TRInterface ; (; const Int_t ; argc = 0, . const Char_t * ; argv[] = NULL, . const Bool_t ; loadRcpp = true, . const Bool_t ; verbose = false, . const Bool_t ; interactive = true . ). private . The command line arguments are by default argc=0 and argv=NULL, The verbose mode is by default disabled but you can enable it to show procedures information in stdout/stderr. ; Notesome time can produce so much noise in the output ; Parameters. argcdefault 0 ; argvdefault null ; loadRcppdefault true ; verbosedefault false ; interactivedefault true . Definition at line 33 of file TRInterface.cxx. ◆ ~TRInterface(). TRInterface::~TRInterface ; (; ). Definition at line 71 of file TRInterface.cxx. Member Function Documentation. ◆ Assign() [1/3]. template<typename T > . void ROOT::R::TRInterface::Assign ; (; const T & ; var, . const TString & ; name . ). inline . Template method to assign C++ variables into R environment. ; Parameters. varany R wrappable datatype ; namename of the variable in R's environment . Definition at line 258 of file TRInterface.h. ◆ Assign() [2/3]. void TRInterface::A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:18415,load,loadRcpp,18415,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['load'],['loadRcpp']
Performance,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char *pool); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char *cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char *vmname, const char *cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char *pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCondor.html:6465,perform,performance,6465,root/html526/TCondor.html,https://root.cern,https://root.cern/root/html526/TCondor.html,1,['perform'],['performance']
Performance,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBrowser*fBrowserselected browser (if exist); TObject*fCalledObjectobject to call; TContextMenuImp*fContextMenuImp!Context menu system specific implementation; TStringTNamed::fNameobject identifier; TVirtualPad*fSelectedCanvasselected canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject *object, TMethod *method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem *menuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject *object, TToggle *toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject *object, TFunction *method, const char *params); Execute method with specified arguments for specified object. void Execute(TObject *object, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TContextMenu.html:8091,perform,performed,8091,root/html526/TContextMenu.html,https://root.cern,https://root.cern/root/html526/TContextMenu.html,1,['perform'],['performed']
Performance,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBrowser*fBrowserselected browser (if exist); TObject*fCalledObjectobject to call; TContextMenuImp*fContextMenuImp!Context menu system specific implementation; TStringTNamed::fNameobject identifier; TVirtualPad*fSelectedCanvasselected canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TContextMenu.html:8077,perform,performed,8077,root/html528/TContextMenu.html,https://root.cern,https://root.cern/root/html528/TContextMenu.html,4,['perform'],['performed']
Performance,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Double_t*_coefThresh[_nComp] Array of coefficient thresholds ; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_isModelAre we generating from a RooAddPdf or a RooAddModel; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooAddModel::CacheElem*_mcache! RooAddModel cache element; Int_t_nCompNumber of PDF components; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooAddPdf::CacheElem*_pcache! RooAddPdf cache element; RooAbsPdf*_pdfPointer to cloned p.d.f; RooArgSet*_pdfSetSet owned all nodes of internal clone of p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; const RooArgSet*_vars; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddGenContext(const RooAddPdf& model, const RooArgSet& vars, const RooDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddGenContext.html:8429,Cache,CacheElem,8429,root/html532/RooAddGenContext.html,https://root.cern,https://root.cern/root/html532/RooAddGenContext.html,10,"['Cache', 'cache', 'load']","['CacheElem', 'cache', 'load']"
Performance,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistPdf.html:39534,cache,cache,39534,root/html534/RooHistPdf.html,https://root.cern,https://root.cern/root/html534/RooHistPdf.html,3,['cache'],"['cache', 'caches']"
Performance,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of observables mapped onto histogram observables; RooExpensiveObjectCache*RooAbsArg::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:32711,cache,cache,32711,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['cache'],"['cache', 'caches']"
Performance,"Delete; };. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char *member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TArchiveFile.html:6706,load,loaded,6706,root/html526/TArchiveFile.html,https://root.cern,https://root.cern/root/html526/TArchiveFile.html,1,['load'],['loaded']
Performance,"Delete; };. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TArchiveFile.html:6692,load,loaded,6692,root/html528/TArchiveFile.html,https://root.cern,https://root.cern/root/html528/TArchiveFile.html,4,['load'],['loaded']
Performance,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheWrite.html:6870,cache,cache,6870,root/html528/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html528/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFileCacheWrite.html:6939,cache,cache,6939,root/html530/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFileCacheWrite.html:6939,cache,cache,6939,root/html532/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"Delta . ); const. Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport (screen) '3D' vector. ; The X()/Y() components of the vector are the horizontal / vertical pixel deltas. The Z() component is the viewport depth delta - for a default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane) See OpenGL gluProject & glDepth documentation; Camera must have valid frustum cache - call Apply() ; Definition at line 426 of file TGLCamera.cxx. ◆ WorldToViewport(). TGLVertex3 TGLCamera::WorldToViewport ; (; const TGLVertex3 & ; worldVertex, . TGLMatrix * ; modviewMat = nullptr . ); const. Convert a 3D world vertex to '3D' viewport (screen) one. ; The X()/Y() components of the viewport vertex are the horizontal/vertical pixel positions. The Z() component is the viewport depth value - for a default depth range this is 0.0 (at near clip plane) to 1.0 (at far clip plane). See OpenGL gluProject & glDepth documentation; Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 403 of file TGLCamera.cxx. ◆ Zoom(). virtual Bool_t TGLCamera::Zoom ; (; Int_t ; delta, . Bool_t ; mod1, . Bool_t ; mod2 . ). pure virtual . Implemented in TGLOrthoCamera, and TGLPerspectiveCamera. Member Data Documentation. ◆ fCacheDirty. Bool_t TGLCamera::fCacheDirty. mutableprotected . Definition at line 95 of file TGLCamera.h. ◆ fCamBase. TGLMatrix TGLCamera::fCamBase. protected . Definition at line 76 of file TGLCamera.h. ◆ fCamTrans. TGLMatrix TGLCamera::fCamTrans. protected . Definition at line 77 of file TGLCamera.h. ◆ fCenter. TGLVector3* TGLCamera::fCenter. protected . Definition at line 84 of file TGLCamera.h. ◆ fClipM. TGLMatrix TGLCamera::fClipM. mutableprotected . modelView matrix (cached) ; Definition at line 100 of file TGLCamera.h. ◆ fDefCenter. TGLVector3 TGLCamera::fDefCenter. protected . Definition at line 82 of file TGLCamera.h. ◆ fDollyDefault. Double_t TGLCamera::fDollyDefault. protected . last a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:40868,cache,cache,40868,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TEveJetConeGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveJetConeGL.html:1853,cache,cached,1853,root/html602/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html602/TEveJetConeGL.html,2,['cache'],['cached']
Performance,"DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveArrowGL.html:1892,cache,cached,1892,root/html534/TEveArrowGL.html,https://root.cern,https://root.cern/root/html534/TEveArrowGL.html,3,['cache'],['cached']
Performance,"DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2GL.html:2177,cache,cached,2177,root/html534/TH2GL.html,https://root.cern,https://root.cern/root/html534/TH2GL.html,2,['cache'],['cached']
Performance,"Detector response matrix; const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHistDistribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHistDistribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1). TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1). TH1D* GetD() const; Returns d vector. TH1D* GetSV() const; Returns singular values vector. void H2V(const TH1D* histo, TVectorD& vec); Fill 1D histogram into vector. void H2Verr(const TH1D* histo, TVectorD& vec); Fill 1D histogram errors into vector. void V2H(const TVectorD& vec, TH1D& histo); Fill vector into 1D histogram. void H2M(const TH2D* histo, TMatrixD& mat); Fill 2D histogram into matrix. TVectorD VecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0); Divide entries of two vectors. TMatrixD MatDivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); Divide matrix entries by vector. TVectorD CompProd(const TVectorD& vec1, const TVectorD& vec2); Multiply entries of two vectors. Double_t GetCurvature(const TVectorD& vec, const TMatrixD& curv); Compute curvature of vector. void FillCurvatureMatrix(TMatrixD& tCur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVDUnfold.html:7275,Perform,Perform,7275,root/html528/TSVDUnfold.html,https://root.cern,https://root.cern/root/html528/TSVDUnfold.html,1,['Perform'],['Perform']
Performance,"Dim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()(double x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricFunctionOneDim.html:2405,cache,cached,2405,root/html528/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance,"Dim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()(double x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html:2407,cache,cached,2407,root/html530/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance,"Dim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()(double x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricFunctionOneDim.html:2407,cache,cached,2407,root/html532/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance,"Dir() const; TMVA::MethodLDMethodLD(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = 0); TMVA::MethodLDMethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLD.html:8885,Optimiz,OptimizeTuningParameters,8885,root/html530/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLD.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"Dir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidSetTestSignalEfficiency(Double_t effS); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:13287,tune,tuneParameters,13287,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,1,['tune'],['tuneParameters']
Performance,"DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TEveArrowGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveArrowGL.html:1877,cache,cached,1877,root/html602/TEveArrowGL.html,https://root.cern,https://root.cern/root/html602/TEveArrowGL.html,2,['cache'],['cached']
Performance,"Director {nullptr};  proxying director ;  ; Long64_t fEndEntry = -1LL;  The end of the entry loop. ;  ; Long64_t fEntry = -1;  Current (non-local) entry of fTree or of fEntryList if set. ;  ; TEntryList * fEntryList = nullptr;  entry list to be used ;  ; EEntryStatus fEntryStatus = kEntryNotLoaded;  status of most recent read request ;  ; std::vector< std::unique_ptr< ROOT::Internal::TFriendProxy > > fFriendProxies;  Proxies to friend trees, created in TTreeReader[Value,Array]::CreateProxy. ;  ; ELoadTreeStatus fLoadTreeStatus = kNoTree;  Indicator on how LoadTree was called 'last' time. ;  ; std::vector< std::string > fMissingProxies {};  ; TNotifyLink< TTreeReader > fNotify;  TTree and TChain will notify this object upon LoadTree, leading to a call to TTreeReader::Notify(). ;  ; NamedProxies_t fProxies;  attached ROOT::TNamedBranchProxies; owned ;  ; bool fProxiesSet = false;  True if the proxies have been set, false otherwise. ;  ; bool fSetEntryBaseCallingLoadTree = false;  True if during the LoadTree execution triggered by SetEntryBase. ;  ; std::vector< std::string > fSuppressErrorsForMissingBranches {};  ; TTree * fTree = nullptr;  tree that's read ;  ; std::deque< ROOT::Internal::TTreeReaderValueBase * > fValues;  readers that use our director ;  ; bool fWarnAboutLongerFriends {true};  . Friends; class ROOT::Internal::TTreeReaderArrayBase;  ; class ROOT::Internal::TTreeReaderValueBase;  . #include <TTreeReader.h>. Inheritance diagram for TTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ iterator. typedef Iterator_t TTreeReader::iterator. Definition at line 150 of file TTreeReader.h. ◆ NamedProxies_t. using TTreeReader::NamedProxies_t = std::unordered_map<std::string, std::unique_ptr<ROOT::Internal::TNamedBranchProxy> >. protected . Definition at line 273 of file TTreeReader.h. Member Enumeration Documentation. ◆ EEntryStatus. enum TTreeReader::EEntryStatus. Enumerator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:21214,Load,LoadTree,21214,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['Load'],['LoadTree']
Performance,"Directory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodPDEFoamMethodPDEFoam(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodPDEFoamMethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); TMVA::PDEFoam*ReadClonedFoamFromFile(TFile*, const TString&); voidReadFoamsFromFile(); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodPDEFoam.html:9893,Optimiz,OptimizeTuningParameters,9893,root/html534/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodPDEFoam.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"Directory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TROOT. Function documentation; TROOT(); Default ctor. TROOT(const char* name, const char* title, VoidFuncPtr_t* initfunc = 0); Initialize the ROOT system. The creation of the TROOT object initializes; the ROOT system. It must be the first ROOT related action that is; performed by a program. The TROOT object must be created on the stack; (can not be called via new since ""operator new"" is protected). The; TROOT object is either created as a global object (outside the main(); program), or it is one of the first objects created in main().; Make sure that the TROOT object stays in scope for as long as ROOT; related actions are performed. TROOT is a so called singleton so; only one instance of it can be created. The single TROOT object can; always be accessed via the global pointer gROOT.; The name and title arguments can be used to identify the running; application. The initfunc argument can contain an array of; function pointers (last element must be 0). These functions are; executed at the end of the constructor. This way one can easily; extend the ROOT system without adding permanent dependencies; (e.g. the graphics system is initialized via such a function). ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:21510,perform,performed,21510,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['perform'],['performed']
Performance,"DirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tfBytesReadNumber of bytes read from this file; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tfBytesWriteNumber of bytes written to this file; TFileCacheRead*fCacheRead!Pointer to the read cache (if any); TMap*fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*fCacheWrite!Pointer to the write cache (if any); TArrayC*fClassIndex!Index of TStreamerInfo classes written to this file; Int_tfCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tfDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tfENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*fFreeFree segments linked list table; TList*fInfoCache!Cached list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:20154,Cache,Cached,20154,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['Cache'],['Cached']
Performance,"Dirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TList_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void setACleanADirty(Bool_t flag); This global switch changes the cache mode of all objects marked as 'always clean'; to 'always dirty'. For internal use in RooRealIntegral. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:17707,cache,cache,17707,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['cache'],['cache']
Performance,"Dirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:26459,cache,cache,26459,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,6,['cache'],['cache']
Performance,"Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf102_dataimportDefinition rf102_dataimport.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; ; -----------------------; Reading data from ASCII; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8C.html:10627,optimiz,optimization,10627,doc/master/rf102__dataimport_8C.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html,3,"['load', 'optimiz']","['loadValues', 'optimization']"
Performance,"Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed. void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precisi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:13209,perform,performed,13209,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,6,['perform'],['performed']
Performance,"DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(const double* x, unsigned int icoord) const. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientMultiDim.html:2178,Optimiz,Optimized,2178,root/html526/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"DoSliderZMoved ();  Slot connected to range settings on z-axis. ;  ; virtual void DoUpdate ();  Easy here! ;  ; virtual void DoUseFuncRange ();  ; virtual void DoUserDialog ();  Open a dialog for getting a user defined method. ;  ; void FillFunctionList (Int_t selected=-1);  Fills the list of functions depending on the type of fit selected. ;  ; void FillMinMethodList (Int_t selected=-1);  Fills the list of methods depending on the minimization library selected. ;  ; Option_t * GetDrawOption () const override;  Get draw options of the selected object. ;  ; TList * GetListOfFittingFunctions (TObject *obj=nullptr);  ; virtual void Hide ();  Hide the fit panel and set it to non-active state. ;  ; void RecursiveRemove (TObject *obj) override;  When obj is deleted, clear fFitObject if fFitObject = obj. ;  ; virtual void SetFitObject (TVirtualPad *pad, TObject *obj, Int_t event);  Slot called when the user clicks on an object inside a canvas. ;  ; virtual void SetFunction (const char *function);  Set the function to be used in performed fit. ;  ; Bool_t SetObjectType (TObject *obj);  Check whether the object suitable for fitting and set its type, dimension and method combo box accordingly. ;  ; virtual void Show (TVirtualPad *pad, TObject *obj);  Show the fit panel (possible only via context menu). ;  ; void ShowObjectName (TObject *obj);  Show object name on the top. ;  ; virtual void Terminate ();  Called to delete the fit panel. ;  ; void UpdateGUI ();  Set the fit panel GUI according to the selected object. ;  ;  Public Member Functions inherited from TGMainFrame;  TGMainFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a top level main frame. ;  ;  ~TGMainFrame () override;  TGMainFrame destructor. ;  ; virtual Bool_t BindKey (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Bind key to a window. ;  ; void DontCallClose ();  Typically call this method in the slot connected to the CloseWindow() signal to prevent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:9473,perform,performed,9473,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['perform'],['performed']
Performance,"Documentation. ◆ AddColumn(). ROOT::Experimental::Internal::RPageStorage::ColumnHandle_t ROOT::Experimental::Internal::RPageSource::AddColumn ; (; DescriptorId_t ; fieldId, . RColumn & ; column . ). overridevirtual . Register a new column. ; When reading, the column must exist in the ntuple on disk corresponding to the meta-data. When writing, every column can only be attached once. ; Implements ROOT::Experimental::Internal::RPageStorage.; Reimplemented in ROOT::Experimental::Internal::RPageSourceFriends.; Definition at line 165 of file RPageStorage.cxx. ◆ Attach(). void ROOT::Experimental::Internal::RPageSource::Attach ; (; ). Open the physical storage container and deserialize header and footer. ; Definition at line 195 of file RPageStorage.cxx. ◆ AttachImpl(). virtual RNTupleDescriptor ROOT::Experimental::Internal::RPageSource::AttachImpl ; (; ). protectedpure virtual . LoadStructureImpl() has been called before AttachImpl() is called ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ Clone(). std::unique_ptr< ROOT::Experimental::Internal::RPageSource > ROOT::Experimental::Internal::RPageSource::Clone ; (; ); const. Open the same storage multiple time, e.g. ; for reading in multiple threads. If the source is already attached, the clone will be attached, too. The clone will use, however, it's own connection to the underlying storage (e.g., file descriptor, XRootD handle, etc.) ; Definition at line 203 of file RPageStorage.cxx. ◆ CloneImpl(). virtual std::unique_ptr< RPageSource > ROOT::Experimental::Internal::RPageSource::CloneImpl ; (; ); const. protectedpure virtual . Returns a new, unattached page source for the same data set. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ Create(). std::unique_ptr< ROOT::Experimental::Internal::R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:9335,Load,LoadStructureImpl,9335,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadStructureImpl']
Performance,"Double_t * GetX() constDefinition TGraph.h:139; TGraph::SaveAsvoid SaveAs(const char *filename=""graph"", Option_t *option="""") const overrideSave the graph as .csv, .tsv or .txt.Definition TGraph.cxx:2093; TGraph::Evalvirtual Double_t Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constInterpolate points in this graph at x using a TSpline.Definition TGraph.cxx:953; TGraph::InitExpovirtual void InitExpo(Double_t xmin=0, Double_t xmax=0)Compute Initial values of parameters for an exponential.Definition TGraph.cxx:1658; TGraph::RemovePointvirtual Int_t RemovePoint()Delete point close to the mouse position Returns index of removed point (or -1 if nothing was changed...Definition TGraph.cxx:2037; TGraph::InitGausvirtual void InitGaus(Double_t xmin=0, Double_t xmax=0)Compute Initial values of parameters for a gaussian.Definition TGraph.cxx:1620; TGraph::IsHighlightvirtual Bool_t IsHighlight() constDefinition TGraph.h:167; TGraph::Addvirtual void Add(TF1 *f, Double_t c1=1)Performs the operation: y = y + c1*f(x,y) Errors are not recalculated.Definition TGraph.cxx:622; TGraph::Applyvirtual void Apply(TF1 *f)Apply function f to all the data points f may be a 1-D function TF1 or 2-d function TF2 The Y values ...Definition TGraph.cxx:638; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2381; TGraph::SetHighlightvirtual void SetHighlight(Bool_t set=kTRUE)Set highlight (enable/disable) mode for the graph by default highlight mode is disable.Definition TGraph.cxx:2311; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetEditableBool_t GetEditable() constReturn kTRUE if kNotEditable bit is not set, kFALSE otherwise.Definition TGraph.cxx:2292; TGraph::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:122041,Perform,Performs,122041,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['Perform'],['Performs']
Performance,"Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::FFTvirtual TH1 * FFT(TH1 *h_output, Option_t *option)This function allows to do discrete Fourier transforms of TH1 and TH2.Definition TH1.cxx:3284; TH1::LabelsInflatevirtual void LabelsInflate(Option_t *axis=""X"")Double the number of bins for axis.Definition TH1.cxx:5315; TH1::ShowBackgroundvirtual TH1 * ShowBackground(Int_t niter=20, Option_t *option=""same"")This function calculates the background spectrum in this histogram.Definition TH1.cxx:9287; TH1::SameLimitsAndNBinsstatic Bool_t SameLimitsAndNBins(const TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:444487,Perform,Performs,444487,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['Perform'],['Performs']
Performance,"Double_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH3.cxx:1390; TH3::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w)Accumulate arguments in buffer.Definition TH3.cxx:339; TH3::SetShowProjectionvirtual void SetShowProjection(const char *option=""xy"", Int_t nbins=1)When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a proj...Definition TH3.cxx:3676; TH3::FillInt_t Fill(const char *, Double_t, Double_t)Definition TH3.h:62; TH3::RebinXTH3 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin3D.Definition TH3.cxx:2906; TH3::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH3.cxx:1191; TH3::DoProject1Dvirtual TH1D * DoProject1D(const char *name, const char *title, int imin1, int imax1, int imin2, int imax2, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, Option_t *option) constinternal method performing the projection to 1D histogram called from TH3::Project3DDefinition TH3.cxx:1829; TH3::TH3TH3(const TH3 &)=delete; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TH3.h:101; TH3::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH3.cxx:3468; TH3::SetBinContentvoid SetBinContent(Int_t bin, Int_t, Double_t content) overrideDefinition TH3.h:131; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::TH3TH3()Default constructor.Definition TH3.cxx:74; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::FitSlicesZvirtual void FitSlicesZ(TF1 *f1=nullptr, Int_t binminx=1, Int_t binmaxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8h_source.html:42523,perform,performing,42523,doc/master/TH3_8h_source.html,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html,1,['perform'],['performing']
Performance,"Double_t TMVA::OptimizeConfigParameters::EstimatorFunction ; (; std::vector< Double_t > & ; pars). privatevirtual . return the estimator (from current FOM) for the fitting interface ; Implements TMVA::IFitterTarget.; Definition at line 307 of file OptimizeConfigParameters.cxx. ◆ GetBkgEffAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgEffAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 546 of file OptimizeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 583 of file OptimizeConfigParameters.cxx. ◆ GetFOM(). Double_t TMVA::OptimizeConfigParameters::GetFOM ; (; ). private . Return the Figure of Merit (FOM) used in the parameter optimization process. ; Definition at line 350 of file OptimizeConfigParameters.cxx. ◆ GetMethod(). MethodBase * TMVA::OptimizeConfigParameters::GetMethod ; (; ). inlineprivate . Definition at line 72 of file OptimizeConfigParameters.h. ◆ GetMVADists(). void TMVA::OptimizeConfigParameters::GetMVADists ; (; ). private . fill the private histograms with the mva distributions for sig/bkg ; Definition at line 393 of file OptimizeConfigParameters.cxx. ◆ GetROCIntegral(). Double_t TMVA::OptimizeConfigParameters::GetROCIntegral ; (; ). private . calculate the area (integral) under the ROC curve as a overall quality measure of the classification ; making pdfs out of the MVA-output distributions doesn't work reliably for cases where the MVA-output isn't a smooth distribution. this happens ""frequently"" in BDTs for example when the number of trees is small resulting in only some discrete possible MVA out",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:6827,Optimiz,OptimizeConfigParameters,6827,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPainter.html:20279,perform,performed,20279,root/html534/TGeoPainter.html,https://root.cern,https://root.cern/root/html534/TGeoPainter.html,3,['perform'],['performed']
Performance,"Double_t xup, Int_t nY, Double_t ylow, Double_t yup); Constructor with specified name and boundaries and partition cell number. ~TH2Poly(); Destructor. Int_t AddBin(TObject* poly); Adds a new bin to the histogram. It can be any object having the method; IsInside(). It returns the bin number in the histogram. It returns 0 if; it failed to add. To allow the histogram limits to expand when a bin; outside the limits is added, call SetFloat() before adding the bin. Int_t AddBin(Int_t n, const Double_t* x, const Double_t* y); Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. Bool_t Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. TObject* Clone(const char* newname = """") const; Make a complete copy of the underlying object. If 'newname' is set,; the copy's name will be set to that name. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned area",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:35132,Perform,Performs,35132,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,2,['Perform'],['Performs']
Performance,"Double_t xup, Int_t nY, Double_t ylow, Double_t yup); Constructor with specified name and boundaries and partition cell number. ~TH2Poly(); Destructor. Int_t AddBin(TObject* poly); Adds a new bin to the histogram. It can be any object having the method; IsInside(). It returns the bin number in the histogram. It returns 0 if; it failed to add. To allow the histogram limits to expand when a bin; outside the limits is added, call SetFloat() before adding the bin. Int_t AddBin(Int_t n, const Double_t* x, const Double_t* y); Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. Bool_t Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; the histogram (also called ""the sea""). The third parameter can be left; blank.; The overflow/unde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2Poly.html:33369,Perform,Performs,33369,root/html534/TH2Poly.html,https://root.cern,https://root.cern/root/html534/TH2Poly.html,1,['Perform'],['Performs']
Performance,"Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:3856,cache,cacheUniqueSuffix,3856,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,1,['cache'],['cacheUniqueSuffix']
Performance,"Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; const RooArgSet&bestFitObs() const; const RooArgSet&bestFitParams() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:2447,Cache,CacheModeRooAbsArg,2447,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:81037,load,load,81037,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['load'],['load']
Performance,"Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TEveTriangleSetGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTriangleSetGL.html:1941,cache,cached,1941,root/html602/TEveTriangleSetGL.html,https://root.cern,https://root.cern/root/html602/TEveTriangleSetGL.html,2,['cache'],['cached']
Performance,"DrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetLocalNoDirtyInhibit(Bool_t flag) const; virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; RooFItershapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&transientAttributes() const; voidtreeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidunRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*valueClientIterator() const; RooFItervalueClientMIterator() const; static voidverboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidwireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:14472,cache,cache,14472,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,2,['cache'],['cache']
Performance,"Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf210_angularconvDefinition rf210_angularconv.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d599f000 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8C.html:6324,cache,cache,6324,doc/master/rf210__angularconv_8C.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html,1,['cache'],['cache']
Performance,"E in case of failure. ; Definition at line 566 of file TWebFile.cxx. ◆ ReOpen(). Int_t TWebFile::ReOpen ; (; Option_t * ; mode). overridevirtual . Reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. ; Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. A TWebFile cannot be reopened in update mode. ; Reimplemented from TFile.; Definition at line 394 of file TWebFile.cxx. ◆ Seek(). void TWebFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). overridevirtual . Set position from where to start reading. ; Reimplemented from TFile.; Definition at line 989 of file TWebFile.cxx. ◆ SetMaxFullCacheSize(). void TWebFile::SetMaxFullCacheSize ; (; Long64_t ; sz). static . Static method, set maxmimal size of full cache,. ; Definition at line 1449 of file TWebFile.cxx. ◆ SetMsgReadBuffer10(). void TWebFile::SetMsgReadBuffer10 ; (; const char * ; redirectLocation = nullptr, . Bool_t ; tempRedirect = kFALSE . ). protectedvirtual . Set GET command for use by ReadBuffer(s)10(), handle redirection if needed. ; Give full URL so Apache's virtual hosts solution works. ; Reimplemented in TS3WebFile.; Definition at line 268 of file TWebFile.cxx. ◆ SetProxy(). void TWebFile::SetProxy ; (; const char * ; url). static . Static method setting global proxy URL. ; Definition at line 1404 of file TWebFile.cxx. ◆ Streamer(). void TWebFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TFile. ◆ StreamerNVirtual(). void TWebFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 95 of file TWebFile.h. Friends And Related Symbol Documentation. ◆ TWebSocket. friend class TWebSocket. friend . Definition at line 35 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:56091,cache,cache,56091,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cache']
Performance,"E return a true frustum (truncated square based pyramid). If asBox == kTRUE return a true box, using the far clipping plane intersection projected back to the near plane.; Camera must have valid frustum cache - call Apply() after last modification, before using; Note: TGLBoundingBox is not really valid when filled with truncated pyramid; this is used as a visual debug aid only so ok. . Definition at line 171 of file TGLCamera.cxx. ◆ FrustumCenter(). TGLVertex3 TGLCamera::FrustumCenter ; (; ); const. Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 251 of file TGLCamera.cxx. ◆ FrustumOverlap(). Rgl::EOverlap TGLCamera::FrustumOverlap ; (; const TGLBoundingBox & ; box); const. Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 275 of file TGLCamera.cxx. ◆ FrustumPlane(). const TGLPlane & TGLCamera::FrustumPlane ; (; EFrustumPlane ; plane); const. inline . Definition at line 219 of file TGLCamera.h. ◆ GetCamBase(). const TGLMatrix & TGLCamera::GetCamBase ; (; ); const. inline . Definition at line 166 of file TGLCamera.h. ◆ GetCamTrans(). const TGLMatrix & TGLCamera::GetCamTrans ; (; ); const. inline . Definition at line 167 of file TGLCamera.h. ◆ GetCenterVec(). Double_t * TGLCamera::GetCenterVec ; (; ). inline . Definition at line 157 of file TGLCamera.h. ◆ GetExternalCenter(). Bool_t TGLCamera::GetExternalCenter ; (; ). inline . Definition at line 153 of file TGLCamera.h. ◆ GetFarClip(). Double_t TGLCamera::GetFarClip ; (; ); const. inline . Definition at line 164 of file TGLCamera.h. ◆ GetFixDefCenterVec(). Double_t * TGLCamera::GetFixDefCenterVec ; (; ). inline . Definition at line 161 of file TGLCamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:25254,cache,cache,25254,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"E) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:6890,load,load,6890,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"E); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:32227,cache,cache,32227,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['cache'],['cache']
Performance,"E); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenericPdf.html:30024,cache,cache,30024,root/html528/RooGenericPdf.html,https://root.cern,https://root.cern/root/html528/RooGenericPdf.html,2,['cache'],['cache']
Performance,"E); voidRooAbsReal::setPlotLabel(const char* label); voidsetPositiveDefinite(bool flag = true); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:24789,cache,cache,24789,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"E, . Bool_t ; verbose = kTRUE . ). Set the otuput file Return 0 on success, -1 on error. ; Definition at line 261 of file TProofBench.cxx. ◆ ReleaseCache(). Int_t TProofBench::ReleaseCache ; (; const char * ; dset). Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ; Definition at line 1303 of file TProofBench.cxx. ◆ RemoveDataSet(). Int_t TProofBench::RemoveDataSet ; (; const char * ; dset). Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 1315 of file TProofBench.cxx. ◆ RunCPU(). Int_t TProofBench::RunCPU ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1, . Int_t ; step = -1 . ). Perform the CPU run Return 0 on success, -1 on error. ; Definition at line 336 of file TProofBench.cxx. ◆ RunCPUx(). Int_t TProofBench::RunCPUx ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1 . ). Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ; Definition at line 365 of file TProofBench.cxx. ◆ RunDataSet(). Int_t TProofBench::RunDataSet ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1, . Int_t ; step = 1 . ). Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ; Definition at line 897 of file TProofBench.cxx. ◆ RunDataSetx(). Int_t TProofBench::RunDataSetx ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1 . ). Perform a test using dataset 'dset' scanning over the number of workers per node. ; Return 0 on success, -1 on error Open the file for the results ; Definition at line 932 of file TProofBench.cxx. ◆ SetCPUPar(). void TProofBench::SetCPUPar ; (; const char * ; par). inline . Definition at line 121 of file TProofBench.h. ◆ SetCPUSel(). void TProofBench::SetCPUSel ; (; const char * ; sel). inline . Definition at line 120 of file TProofBench.h. ◆ SetDataGenP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:21480,Perform,Perform,21480,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['Perform'],['Perform']
Performance,"E, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:26830,load,load,26830,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"E, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) final;  Return the cling mangled name for a method of a class with a certain prototype, i.e. ;  ; TEnv * GetMapfile () const final;  ; std::set< TClass * > & GetModTClasses ();  ; Int_t GetMore () const final;  Return whether we are waiting for more input either because the collected input contains unbalanced braces or last seen token was a \ (backslash-newline) ;  ; const ROOT::TMetaUtils::TNormalizedCtxt & GetNormalizedContext () const;  ; TObject * GetObjectAddress (const char *Name, void *&LookupCtx);  If the interpreter encounters Name, check whether that is an object ROOT could retrieve. ;  ; char * GetPrompt () final;  ; TObjArray * GetRootMapFiles () const final;  ; int GetSecurityError () const final;  Interface to cling function. ;  ; const char * GetSharedLibDeps (const char *lib, bool tryDyld=false) final;  Get the list a libraries on which the specified lib depends. ;  ; const char * GetSharedLibs () final;  Return the list of shared libraries loaded into the process. ;  ; virtual const char * GetSTLIncludePath () const final;  Return the directory containing CINT's stl cintdlls. ;  ; const char * GetTopLevelMacroName () const final;  Return the file name of the current un-included interpreted file. ;  ; std::vector< std::string > GetUsingNamespaces (ClassInfo_t *cl) const final;  Get the scopes representing using declarations of namespace. ;  ; void HandleNewDecl (const void *DV, bool isDeserialized, std::set< TClass * > &modifiedClasses);  ; Bool_t HasPCMForLibrary (const char *libname) const final;  Return true if ROOT has cxxmodules pcm for a given library name. ;  ; virtual void Initialize () final;  Initialize the interpreter, once TROOT::fInterpreter is set. ;  ; void InspectMembers (TMemberInspector &, const void *obj, const TClass *cl, Bool_t isTransient) final;  Visit all members over members, recursing over base classes. ;  ; void InvalidateGlobal (const clang::Decl *D);  Invalidate cac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:21291,load,loaded,21291,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance,"E-5 around current point. ;  ; void SetBombFactors (Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) override;  Set cartesian and radial bomb factors for translations. ;  ; void SetCheckedNode (TGeoNode *node) override;  Select a node to be checked for overlaps. ;  ; void SetClippingShape (TGeoShape *shape) override;  ; void SetExplodedView (Int_t iopt=0) override;  Set type of exploding view. ;  ; void SetGeoManager (TGeoManager *geom) override;  ; void SetIteratorPlugin (TGeoIteratorPlugin *plugin) override;  ; void SetNmeshPoints (Int_t npoints) override;  Set number of points to be generated on the shape outline when checking for overlaps. ;  ; void SetNsegments (Int_t nseg=20) override;  Set number of segments to approximate circles. ;  ; void SetRaytracing (Bool_t flag=kTRUE) override;  ; void SetTopVisible (Bool_t vis=kTRUE) override;  Set top geometry volume as visible. ;  ; void SetTopVolume (TGeoVolume *vol) override;  ; void SetVisLevel (Int_t level=3) override;  Set default level down to which visualization is performed. ;  ; void SetVisOption (Int_t option=0) override;  Set drawing mode : ;  ; Int_t ShapeDistancetoPrimitive (const TGeoShape *shape, Int_t numpoints, Int_t px, Int_t py) const override;  Returns distance between point px,py on the pad an a shape. ;  ; void Test (Int_t npoints, Option_t *option) override;  Check time of finding ""Where am I"" for n points. ;  ; void TestOverlaps (const char *path) override;  Geometry overlap checker based on sampling. ;  ; Bool_t TestVoxels (TGeoVolume *vol) override;  Check voxels efficiency per volume. ;  ; void UnbombTranslation (const Double_t *tr, Double_t *bombtr) override;  Get the new 'unbombed' translation vector according current exploded view mode. ;  ; Double_t Weight (Double_t precision, Option_t *option=""v"") override;  Compute weight [kg] of the current volume. ;  ;  Public Member Functions inherited from TVirtualGeoPainter;  TVirtualGeoPainter (TGeoManager *manage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:8896,perform,performed,8896,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,1,['perform'],['performed']
Performance,"EAAnyNumber, //input value filter; TGNumberFormat::kNELLimitMinMax, //specify limits; -1.,1.); //limit values; TGNumberEntryField is a number entry input widget.; Nent = new TGNumberEntryField(hgrunf2, kNENT_ID, 0.6,; TGNumberFormat::kNESRealThree,; TGNumberFormat::kNEAAnyNumber);; TGNumberEntryField is a plain vanilla entry field, whereas TGNumberEntry adds two small buttons to increase and decrease the numerical value in the field. The number entry widgets also support using the up and down cursor keys to change the numerical values. The step size can be selected with control and shift keys:. –small step (1 unit/factor of 3); Shift medium step (10 units/factor of 10); Controllarge step (100 units/factor of 30); Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set when the entry field is created, but it can be changed by pressing the alt key at the same time.; 25.8.4 Menus; Menus provide a list of commands or options helping the user to select and to perform a task. The menu system classes are TGMenuBar, TGMenuTitle, TGPopupMenu, and TGMenuEntry.; The TGMenuBar class implements a menu bar widget. It is used to specify and provide access to common and frequently used application actions described in menu titles, implemented by TGMenuTitle class. The menu bar is the highest-level of the menu system and it is a starting point for all interactions. Also, it is always visible and allows using the keyboard equivalents. The geometry of the menu bar is automatically set to the parent widget, i.e. the menu bar automatically resizes itself so that it has the same width as its parent (typically TGMainFrame).; The menu bar is as a container for its menus - objects of the type TGPopupMenu. Popup menus can appear in a menu bar. They can be a sub-menu of another popup menu (cascading menus) or can be standalone (as a context menu). They are made of one or more menu items choices. When displayed, the menu items ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1189471,perform,perform,1189471,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"EAlgorithm::EValues ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:24240,multi-thread,multi-threading,24240,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"EAlgorithm::EValues ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:31237,multi-thread,multi-threading,31237,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"EDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTreePerfStats; 13#define ROOT_TTreePerfStats; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TTreePerfStats //; 18// //; 19// TTree I/O performance measurement //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23 ; 24#include ""TVirtualPerfStats.h""; 25#include ""TString.h""; 26#include <vector>; 27#include <unordered_map>; 28 ; 29class TBrowser;; 30class TFile;; 31class TTree;; 32class TStopwatch;; 33class TPaveText;; 34class TGraphErrors;; 35class TGaxis;; 36class TText;; 37 ; 38class TTreePerfStats : public TVirtualPerfStats {; 39 ; 40public:; 41 struct BasketInfo {; 42 UInt_t fUsed = {0}; ///< Number of times the basket was requested from the disk.; 43 UInt_t fLoaded = {0}; ///< Number of times the basket was put in the primary TTreeCache; 44 UInt_t fLoadedMiss = {0}; ///< Number of times the basket was put in the secondary cache; 45 UInt_t fMissed = {0}; ///< Number of times the basket was read directly from the file.; 46 };; 47 ; 48 using BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t>>>;; 49 ; 50protected:; 51 Int_t fTreeCacheSize; ///< TTreeCache buffer size; 52 Int_t fNleaves; ///< Number of leaves in the tree; 53 Int_t fReadCalls; ///< Number of read calls; 54 Int_t fReadaheadSize; ///< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:1586,cache,cache,1586,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['cache'],['cache']
Performance,"EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:47987,cache,cache,47987,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,9,['cache'],['cache']
Performance,"EFunctionMatchMode mode = ROOT::kConversionMatch); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found.; See TClass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable proper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:45302,load,loaded,45302,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loaded']
Performance,"ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, const Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveJetConeGL.html:4593,cache,cache,4593,root/html604/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html604/TEveJetConeGL.html,1,['cache'],['cache']
Performance,"ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, const Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveJetConeGL.html:4593,cache,cache,4593,root/html602/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html602/TEveJetConeGL.html,1,['cache'],['cache']
Performance,"EMENTED for TChain) ; Reimplemented from TTree.; Definition at line 1259 of file TChain.cxx. ◆ InvalidateCurrentTree(). void TChain::InvalidateCurrentTree ; (; ). protected . Set the TTree to be reloaded as soon as possible. ; In particular this is needed when adding a Friend.; If the tree has clones, copy them into the chain clone list so we can change their branch addresses when necessary.; This is to support the syntax: TTree* clone = chain->GetTree()->CloneTree(0);; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557. Definition at line 1278 of file TChain.cxx. ◆ IsA(). TClass * TChain::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 173 of file TChain.h. ◆ LoadBaskets(). Int_t TChain::LoadBaskets ; (; Long64_t ; maxmemory). overridevirtual . Dummy function. ; It could be implemented and load all baskets of all trees in the chain. For the time being use TChain::Merge and TTree::LoadBasket on the resulting tree. ; Reimplemented from TTree.; Definition at line 1296 of file TChain.cxx. ◆ LoadTree(). Long64_t TChain::LoadTree ; (; Long64_t ; entry). overridevirtual . Find the tree which contains entry, and set it as the current tree. ; Returns the entry number in that tree.; The input argument entry is the entry serial number in the whole chain.; In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number is less than zero or too large for the chain.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or the TTree is missing from the file.; -5: Internal error, please report the circumstance when this happen as a ROOT issue.; -6: An error occurred within th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:80902,Load,LoadBaskets,80902,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['Load'],['LoadBaskets']
Performance,"ENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIterUnit(); TEventIterUnit(const TEventIterUnit&); TEventIterUnit(TDSet* dset, TSelector* sel, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tTEventIter::LoadDir(); voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TEventIter::EIterTypeTEventIter::kData; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tTEventIter::fCurcurrent entry; TDSet*TEventIter::fDSetdata set over which to iterate; TDirectory*TEven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterUnit.html:5445,Load,LoadDir,5445,root/html602/TEventIterUnit.html,https://root.cern,https://root.cern/root/html602/TEventIterUnit.html,2,['Load'],['LoadDir']
Performance,EParUnzipMode { kEnable; kDisable; kForce; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. queue<Int_t>fActiveBlksThe blocks which are active now; Bool_tfActiveThreadUsed to terminate gracefully the unzippers; Bool_tfAsyncReading; Bool_tTFileCacheRead::fAsyncReading; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Int_tfCycle; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:7982,queue,queue,7982,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,9,"['cache', 'queue']","['cache', 'queue']"
Performance,"ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofSuperMaster.html:21571,cache,cachedir,21571,root/html602/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofSuperMaster.html,1,['cache'],['cachedir']
Performance,"ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:21721,cache,cachedir,21721,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,1,['cache'],['cachedir']
Performance,"EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. static Int_tRooPrintable::_nameLength; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooClassFactory(); Default constructor. ~RooClassFactory(); Destructor. Bool_t makeAndCompilePdf(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0). Bool_t makeAndCompileFunction(const char* name, const char* expression, const RooArgList& args, const char* intExpression = 0); Write, compile and load code for a RooAbsReal implementation with; class name 'name', taking all elements of 'vars' as constructor; arguments. The initial value expression is taken to be; 'expression' which can be any one-line C++ expression in terms of; variables that occur in 'vars'. You can add optional expressions; for analytical integrals to be advertised by your class in the; syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsReal* makeFunctionInstance(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0); Write, compile and load code and instantiate object for a; RooAbsReal implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooClassFactory.html:8889,load,load,8889,root/html526/RooClassFactory.html,https://root.cern,https://root.cern/root/html526/RooClassFactory.html,5,['load'],['load']
Performance,"EStatusBits { kOutputRequested; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSlaveLite.html:7744,perform,performance,7744,root/html534/TSlaveLite.html,https://root.cern,https://root.cern/root/html534/TSlaveLite.html,1,['perform'],['performance']
Performance,"EStatusBits { kOutputRequested; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSlave(const char* url, const char* ord, Int_t perf, const char* image",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSlave.html:7913,perform,performance,7913,root/html534/TXSlave.html,https://root.cern,https://root.cern/root/html534/TXSlave.html,1,['perform'],['performance']
Performance,"ETreeType type = Types::kTesting);; 173 TCanvas *GetROCCurve(TString datasetname, UInt_t iClass = 0, Types::ETreeType type = Types::kTesting);; 174 ; 175 private:; 176 ; 177 // the beautiful greeting message; 178 void Greetings();; 179 ; 180 //evaluate the simple case that is removing 1 variable at time; 181 TH1F* EvaluateImportanceShort( DataLoader *loader,Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 182 //evaluate all variables combinations; 183 TH1F* EvaluateImportanceAll( DataLoader *loader,Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 184 //evaluate randomly given a number of seeds; 185 TH1F* EvaluateImportanceRandom( DataLoader *loader,UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 186 ; 187 TH1F* GetImportance(const int nbits,std::vector<Double_t> importances,std::vector<TString> varNames);; 188 ; 189 // Helpers for public facing ROC methods; 190 ROCCurve *GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass = 0,; 191 Types::ETreeType type = Types::kTesting);; 192 ROCCurve *GetROC(TString datasetname, TString theMethodName, UInt_t iClass = 0,; 193 Types::ETreeType type = Types::kTesting);; 194 ; 195 void WriteDataInformation(DataSetInfo& fDataSetInfo);; 196 ; 197 void SetInputTreesFromEventAssignTrees();; 198 ; 199 MethodBase* BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile);; 200 ; 201 private:; 202 ; 203 // data members; 204 ; 205 TFile* fgTargetFile; ///<! ROOT output file; 206 ; 207 ; 208 std::vector<TMVA::VariableTransformBase*> fDefaultTrfs; ///<! list of transformations on default DataSet; 209 ; 210 // cd to local directory; 211 TString fOptions; ///<! option string given by construction (presently only ""V""); 212 TString fTransformations; ///<! list of transformations to test; 213 Bool_t fVerbose; ///<! verbose mode; 214 TString fVerboseLevel; ///<! verbosity level, controls granularity of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:8613,load,loader,8613,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"EType. EnumeratorkBRENT ; kGSL_BISECTION ; kGSL_FALSE_POS ; kGSL_BRENT ; kGSL_NEWTON ; kGSL_SECANT ; kGSL_STEFFENSON . Definition at line 77 of file RootFinder.h. Constructor & Destructor Documentation. ◆ RootFinder() [1/3]. ROOT::Math::RootFinder::RootFinder ; (; RootFinder::EType ; type = RootFinder::kBRENT). Construct a Root-Finder algorithm. ; Definition at line 40 of file RootFinder.cxx. ◆ ~RootFinder(). ROOT::Math::RootFinder::~RootFinder ; (; ). virtual . Definition at line 142 of file RootFinder.cxx. ◆ RootFinder() [2/3]. ROOT::Math::RootFinder::RootFinder ; (; const RootFinder & ; ). delete . ◆ RootFinder() [3/3]. ROOT::Math::RootFinder::RootFinder ; (; RootFinder && ; ). delete . Member Function Documentation. ◆ Iterate(). int ROOT::Math::RootFinder::Iterate ; (; ). inline . Perform a single iteration and return the Status. ; Definition at line 148 of file RootFinder.h. ◆ Iterations(). int ROOT::Math::RootFinder::Iterations ; (; ); const. inline . Return the number of iteration performed to find the Root. ; Definition at line 141 of file RootFinder.h. ◆ Name(). const char * ROOT::Math::RootFinder::Name ; (; ); const. inline . Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms) ; Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms) Get Name of the Root-finding solver algorithm ; Definition at line 185 of file RootFinder.h. ◆ operator=() [1/2]. RootFinder & ROOT::Math::RootFinder::operator= ; (; const RootFinder & ; rhs). delete . ◆ operator=() [2/2]. RootFinder & ROOT::Math::RootFinder::operator= ; (; RootFinder && ; rhs). delete . ◆ Root(). double ROOT::Math::RootFinder::Root ; (; ); const. inline . Return the current and latest estimate of the Root. ; Definition at line 155 of file RootFinder.h. ◆ SetFunction() [1/2]. bool ROOT::Math::RootFinder::SetFunction ; (; const IGenFunction & ; f, . double ; xlow, . double ; xup . ). inline .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RootFinder.html:4332,perform,performed,4332,doc/master/classROOT_1_1Math_1_1RootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RootFinder.html,1,['perform'],['performed']
Performance,"EX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single shape, only one volume is added to the family and; 312positioned N times inside the divided volume, otherwise, each slice will be; 313represented by a distinct volume in the family.; 314 Divisions can be also performed in a given range of one axis. For that, one; 315have to specify also the starting coordinate value and the step:; 316 ; 317~~~ {.cpp}; 318 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; 319~~~; 320 ; 321A check is always done on the resulting division range : if not fitting into; 322the container limits, an error message is posted. If we will browse the divided; 323volume we will notice that it will contain N nodes starting with index 1 upto; 324N. The first one has the lower X limit at START position, while the last one; 325will have the upper X limit at START+N*STEP. The resulting slices cannot; 326be positioned inside an other volume (they are by default positioned inside the; 327divided one) but can be further divided and may contain other volumes:; 328 ; 329~~~ {.cpp}; 330 TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; 331 slicey->AddNode(other_vol, index, some_matrix);; 332~~~; 333 ; 334 When doing that, we have to remember that SLICEY represents a fa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:16079,perform,performed,16079,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['perform'],['performed']
Performance,"EXEC:"" in case a TExec with a same name does not already exist.; The action to be executed via this TExec can be specified with:. a call to the TExec constructor, if the constructor is called before opening the file.; a call to TExec::SetAction at any time. One can compute a pointer to an existing TExec with a name with: TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; gROOT#define gROOTDefinition TROOT.h:406; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TExec::SetActionvirtual void SetAction(const char *action)Definition TExec.h:37; where actionCommand is a string containing a C++ instruction. Examples: myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be automatically executed. In the function/script being executed, one or more of the following actions can be executed:. load a file containing the referenced object. This function typically looks in the file catalog (GRID).; compute a pointer to the referenced object and communicate this pointer back to the calling function TRef::GetObject via: TRef::SetStaticObject(object).; TRef::SetStaticObjectstatic void SetStaticObject(TObject *obj)Static function to set the object found on the Action on Demand function.Definition TRef.cxx:478; When the TExec is called, it has access to the dereferencing TRef by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this"" before the call to TExec). This can be useful for accessing the TRef's fUniqueID. As soon as an object is returned to GetObject, the fUniqueID of the TRef is set to the fUniqueID of the referenced object. At the next call to GetObject, the pointer stored in fPid:fObjects[fUniqueID] will be returned directly.; An example of action on demand is shown in $ROOTSYS/test/Event.h with the member: TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:6903,load,load,6903,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['load'],['load']
Performance,"EditScaleedit scale; Bool_tfEditTransedit transformation in TGedFrame; Double32_tfM[16]; Bool_tfUseTransuse transformation matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrans(); Default constructor. TEveTrans(const TEveTrans& t); Constructor. TEveTrans(const Double_t arr[16]); Constructor. TEveTrans(const Float_t arr[16]); Constructor. void UnitTrans(); Reset matrix to unity. void ZeroTrans(Double_t w = 1.0); Reset matrix to zero, only the perspective scaling is set to w; (1 by default). void UnitRot(); Reset rotation part of the matrix to unity. void SetTrans(const TEveTrans& t, Bool_t copyAngles = kTRUE); Set matrix from another,. void SetFromArray(const Double_t arr[16]); Set matrix from Double_t array. void SetFromArray(const Float_t arr[16]); Set matrix from Float_t array. void SetupRotation(Int_t i, Int_t j, Double_t f); Setup the matrix as an elementary rotation.; Optimized versions of left/right multiplication with an elementary; rotation matrix are implemented in RotatePF/RotateLF.; Expects identity matrix. void SetupFromToVec(const TEveVector& from, const TEveVector& to); A function for creating a rotation matrix that rotates a vector called; ""from"" into another vector called ""to"".; Input : from[3], to[3] which both must be *normalized* non-zero vectors; Output: mtx[3][3] -- a 3x3 matrix in colum-major form; Authors: Tomas M�ller, John Hughes; ""Efficiently Building a Matrix to Rotate One Vector to Another""; Journal of Graphics Tools, 4(4):1-4, 1999. void MultLeft(const TEveTrans& t); Multiply from left: this = t * this. void MultRight(const TEveTrans& t); Multiply from right: this = this * t. TEveTrans operator*(const TEveTrans& t); Copy, multiply from right and return product.; Avoid unless necessary. void TransposeRotationPart(); Transpose 3x3 rotation sub-matrix. void MoveLF(Int_t ai, Double_t amount); Move in local-frame along axis with index ai. void Move3LF(Double_t x, Double_t y, Double_t z); G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrans.html:10287,Optimiz,Optimized,10287,root/html528/TEveTrans.html,https://root.cern,https://root.cern/root/html528/TEveTrans.html,4,['Optimiz'],['Optimized']
Performance,"Editor::DoSelectMedium2 ; (; ). Slot for selecting an existing medium for making a volume. ; Definition at line 1408 of file TGeoManagerEditor.cxx. ◆ DoSelectShape(). void TGeoManagerEditor::DoSelectShape ; (; ). Slot for selecting an existing shape. ; Definition at line 1338 of file TGeoManagerEditor.cxx. ◆ DoSelectShape2(). void TGeoManagerEditor::DoSelectShape2 ; (; ). Slot for selecting a shape for making a volume. ; Definition at line 1352 of file TGeoManagerEditor.cxx. ◆ DoSelectTopVolume(). void TGeoManagerEditor::DoSelectTopVolume ; (; ). Slot for setting top geometry volume. ; Definition at line 1436 of file TGeoManagerEditor.cxx. ◆ DoSelectVolume(). void TGeoManagerEditor::DoSelectVolume ; (; ). Slot for selecting an existing volume. ; Definition at line 1422 of file TGeoManagerEditor.cxx. ◆ DoSetTopVolume(). void TGeoManagerEditor::DoSetTopVolume ; (; ). Set top volume for the geometry. ; Definition at line 1256 of file TGeoManagerEditor.cxx. ◆ LoadLib(). void TGeoManagerEditor::LoadLib ; (; ). static . Dummy static function, used to load plugin. ; Definition at line 1527 of file TGeoManagerEditor.cxx. ◆ SelectedSlot(). void TGeoManagerEditor::SelectedSlot ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; event . ). virtual . Connected to TCanvas::Selected. ; TGeoManagerEditor takes this function from TGedEditor and only uses it if obj is a TGeoVolume. ; Definition at line 708 of file TGeoManagerEditor.cxx. ◆ SetModel(). void TGeoManagerEditor::SetModel ; (; TObject * ; obj). overridevirtual . Refresh editor according the selected obj. ; Implements TGedFrame.; Definition at line 795 of file TGeoManagerEditor.cxx. ◆ ShowSelectMaterial(). void TGeoManagerEditor::ShowSelectMaterial ; (; Bool_t ; show = kTRUE). protected . Show/hide interface for material selection. ; Definition at line 1491 of file TGeoManagerEditor.cxx. ◆ ShowSelectMatrix(). void TGeoManagerEditor::ShowSelectMatrix ; (; Bool_t ; show = kTRUE). protected . Show/hide interface for matrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManagerEditor.html:47918,Load,LoadLib,47918,doc/master/classTGeoManagerEditor.html,https://root.cern,https://root.cern/doc/master/classTGeoManagerEditor.html,1,['Load'],['LoadLib']
Performance,"Eff (Double_t sigEff=0.5);  calculate the background efficiency for a given signal efficiency ;  ; Double_t GetBkgRejAtSigEff (Double_t sigEff=0.5);  calculate the background rejection for a given signal efficiency ;  ; Double_t GetFOM ();  Return the Figure of Merit (FOM) used in the parameter optimization process. ;  ; MethodBase * GetMethod ();  ; void GetMVADists ();  fill the private histograms with the mva distributions for sig/bkg ;  ; Double_t GetROCIntegral ();  calculate the area (integral) under the ROC curve as a overall quality measure of the classification ;  ; std::vector< int > GetScanIndices (int val, std::vector< int > base);  helper function to scan through the all the combinations in the parameter space ;  ; Double_t GetSeparation ();  return the separation between the signal and background MVA ouput distribution ;  ; Double_t GetSigEffAtBkgEff (Double_t bkgEff=0.1);  calculate the signal efficiency for a given background efficiency ;  ; MsgLogger & Log () const;  ; void optimizeFit ();  ; void optimizeScan ();  do the actual optimization using a simple scan method, i.e. ;  . Private Attributes; std::map< std::vector< Double_t >, Double_t > fAlreadyTrainedParCombination;  save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ;  ; TString fFOMType;  the FOM type (Separation, ROC integra.. whatever you implemented.. ;  ; std::vector< Float_t > fFOMvsIter;  graph showing the development of the Figure Of Merit values during the fit ;  ; MsgLogger * fLogger;  ! message logger ;  ; MethodBase *const fMethod;  The MVA method to be evaluated. ;  ; TH1D * fMvaBkg;  MVA distribution for bakgr. events, used for spline fit. ;  ; TH1D * fMvaBkgFineBin;  MVA distribution for bakgr. events. ;  ; TH1D * fMvaSig;  MVA distribution for signal events, used for spline fit. ;  ; TH1D * fMvaSigFineBin;  MVA distribution for signal events. ;  ; Bool_t fNotDoneYet;  flat to indicate of Method Transformations have been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:2900,optimiz,optimizeFit,2900,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,3,['optimiz'],"['optimization', 'optimizeFit', 'optimizeScan']"
Performance,"Eff = dynamic_cast<TH1*>(numerator->Clone(""heff""));; hEff->Divide(hEff, denominator, 1.0, 1.0, ""B"");; hEff->Draw(""E"");; eff->Draw(""same"");; }; }; f#define f(i)Definition RSha256.hxx:104; TBinomialEfficiencyFitterBinomial fitter for the division of two histograms.Definition TBinomialEfficiencyFitter.h:42; TBinomialEfficiencyFitter::TBinomialEfficiencyFitterTBinomialEfficiencyFitter()default constructorDefinition TBinomialEfficiencyFitter.cxx:101; TF11-Dim function classDefinition TF1.h:233; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1333; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; int; Note that this method cannot be expected to yield reliable results when using weighted histograms (because the likelihood computation will be incorrect). ; Definition at line 42 of file TBinomialEfficiencyFitter.h. Public Member Functions;  TBinomialEfficiencyFitter ();  default constructor ;  ;  TBinomialEfficiencyFitter (const TH1 *numerator, const TH1 *denominator);  Constructor. ;  ;  ~TBinomialEfficiencyFitter () override;  destructor ;  ; Double_t EvaluateFCN (const Double_t *par);  ; TFitResultPtr Fit (TF1 *f1, Option_t *option="""");  Carry out the fit of the given function to the given histograms. ;  ; ROOT::Fit::Fitter * GetFitter ();  Provide access to the underlying fitter object. ;  ; TClass * IsA () const override;  ; void Set (const TH1 *numerato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:3663,Perform,Performs,3663,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['Perform'],['Performs']
Performance,"El=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. Filename formats are similar to TChain::Add. Wildcards are not; applied. urls may also contain query and fragment identifiers; where the tree name can be specified in the url fragment. eg.; root://machine/path/file_name.root?query#tree_name. If tree_name is given as a part of the file name it is used to; as the name of the tree to load from the file. Otherwise if tname; argument is specified the chain will load the tree named tname from; the file, otherwise the original treename specified in the TChain; constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:32678,load,load,32678,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,3,['load'],['load']
Performance,"Element *el=nullptr);  Propagate visualization parameters from element el (defaulting to this) to all children. ;  ; virtual void PropagateVizParamsToProjecteds ();  Propagate visualization parameters to dependent elements. ;  ; virtual REveTrans * PtrMainTrans (Bool_t create=kTRUE);  Return pointer to main transformation. ;  ; void RecheckImpliedSelections ();  Call this if it is possible that implied-selection or highlight has changed for this element or for implied-selection this element is member of and you want to maintain consistent selection state. ;  ; AuntList_t & RefAunts ();  ; const AuntList_t & RefAunts () const;  ; List_t & RefChildren ();  ; const List_t & RefChildren () const;  ; virtual REveTrans & RefMainTrans ();  Return reference to main transformation. ;  ; virtual void RemoveAunt (REveAunt *au);  Remove el from the list of aunts. ;  ; virtual void RemoveElement (REveElement *el);  Remove el from the list of children. ;  ; virtual void RemoveElementLocal (REveElement *el);  Perform additional local removal of el. ;  ; virtual void RemoveElements ();  Remove all elements. ;  ; virtual void RemoveElementsLocal ();  Perform additional local removal of all elements. ;  ; virtual bool RequiresExtraSelectionData () const;  ; void ResetAllCSCBits ();  ; void ResetCSCBits (UChar_t f);  ; void SaveVizParams (std::ostream &out, const TString &tag, const TString &var);  Save visualization parameters for this element with given tag. ;  ; void SetChildClass (TClass *c);  ; void SetCompound (REveCompound *c);  ; void SetCSCBits (UChar_t f);  ; void SetDestroyOnZeroRefCnt (Bool_t d);  Sets the state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; void SetEditMainColor (Bool_t x);  ; void SetEditMainTransparency (Bool_t x);  ; void SetMainAlpha (Float_t alpha);  Set main-transparency via float alpha variable. ;  ; virtual void SetMainColor (Color_t color);  Set main color of the element. ;  ; void SetMainColorPixel (P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveLine.html:11832,Perform,Perform,11832,doc/master/classROOT_1_1Experimental_1_1REveLine.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveLine.html,3,['Perform'],['Perform']
Performance,"Element *el=nullptr);  Propagate visualization parameters from element el (defaulting to this) to all children. ;  ; virtual void PropagateVizParamsToProjecteds ();  Propagate visualization parameters to dependent elements. ;  ; virtual REveTrans * PtrMainTrans (Bool_t create=kTRUE);  Return pointer to main transformation. ;  ; void RecheckImpliedSelections ();  Call this if it is possible that implied-selection or highlight has changed for this element or for implied-selection this element is member of and you want to maintain consistent selection state. ;  ; AuntList_t & RefAunts ();  ; const AuntList_t & RefAunts () const;  ; List_t & RefChildren ();  ; const List_t & RefChildren () const;  ; virtual REveTrans & RefMainTrans ();  Return reference to main transformation. ;  ; virtual void RemoveAunt (REveAunt *au);  Remove el from the list of aunts. ;  ; virtual void RemoveElement (REveElement *el);  Remove el from the list of children. ;  ; virtual void RemoveElementLocal (REveElement *el);  Perform additional local removal of el. ;  ; virtual void RemoveElements ();  Remove all elements. ;  ; virtual void RemoveElementsLocal ();  Perform additional local removal of all elements. ;  ; virtual bool RequiresExtraSelectionData () const;  ; void ResetAllCSCBits ();  ; void ResetCSCBits (UChar_t f);  ; void SaveVizParams (std::ostream &out, const TString &tag, const TString &var);  Save visualization parameters for this element with given tag. ;  ; void SetChildClass (TClass *c);  ; void SetCompound (REveCompound *c);  ; void SetCSCBits (UChar_t f);  ; void SetDestroyOnZeroRefCnt (Bool_t d);  Sets the state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; void SetEditMainColor (Bool_t x);  ; void SetEditMainTransparency (Bool_t x);  ; void SetMainAlpha (Float_t alpha);  Set main-transparency via float alpha variable. ;  ; void SetMainColorPixel (Pixel_t pixel);  Convert pixel to Color_t and call SetMainColor(). ;  ; void SetM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html:11950,Perform,Perform,11950,doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,1,['Perform'],['Perform']
Performance,"Emit pad Cleared signal.Definition TCanvas.cxx:770; TCanvas::GetWwUInt_t GetWw() const overrideDefinition TCanvas.h:163; TCanvas::OpaqueMovingBool_t OpaqueMoving() const overrideDefinition TCanvas.h:180; TCanvas::GetWhUInt_t GetWh() const overrideDefinition TCanvas.h:164; TCanvas::Classstatic TClass * Class(); TCanvas::SetSelectedvoid SetSelected(TObject *obj) overrideSet selected canvas.Definition TCanvas.cxx:2146; TCanvas::GetEventInt_t GetEvent() const overrideDefinition TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid SetBatch(Bool_t batch=kTRUE) overrideToggle batch mode.Definition TCanvas.cxx:1957; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3879; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:274259,load,load,274259,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['load'],['load']
Performance,"EnabledPackagesOnClientlist of packages enabled on client; TList*fEnabledPackagesOnClusterlist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; TList*fFeedbacklist of names to be returned as feedback; map<TString,TProof::MD5Mod_t,less<TString>,allocator<pair<const TString,TProof::MD5Mod_t> > >fFileMapmap keeping track of a file's md5 and mod time; Bool_tfFinalizationRunning; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupPROOF group of this user; TList*fInactiveSlaveslist of inactive slaves (good but not used for processing); TList*fInputDataInput data objects sent over via file; TStringfInputDataFileFile with input data objects; TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfIsPollingWorkerswill be set to kFALSE to prevent recursive dyn workers check in dyn mode; Bool_tfIsWaitingtrue if queries have been enqueued; Int_tfLastAssignedMerger; Long64_tfLastPollWorkers_stimestamp (in seconds) of last poll for workers, -1 if never checked; TList*fLoadedMacrosList of loaded macros (just file names); TStringfLogFileNamename of the temp file for redirected logs; FILE*fLogFileRtemp file to read redirected logs; FILE*fLogFileWtemp file to redirect logs; Int_tfLogLevelserver debug logging level; Bool_tfLogToWindowOnlysend log to window only; TMacrofMacroLogMacro with the saved (last) log; TStringfMastermaster server ("""" if a master); used in the browser; Int_tfMaxDrawQueriesmax number of draw queries kept; TProofMergePrgfMergePrgMerging progress; TList*fMergers; Bool_tfMergersByHostMergers assigned by host name; Int_tfMergersCount; Bool_tfMergersSetIndicates, if the following variables have been initialized properly; TList*fNonUniqueMasterslist of all active masters with a nonunique file system; Int_tfNotIdleNumber of non-idle sub-nodes; Int_tfOtherQueriesnumber of queries in list from previous sessions; TProofOutputListfOutputListTList implementation filtering ls(.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:32178,load,loaded,32178,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['loaded']
Performance,"EndpointUrl ; (; ); const. inlinevirtual . Reimplemented in TNetFile.; Definition at line 235 of file TFile.h. ◆ GetEndpointUrl() [2/2]. const TUrl * TFile::GetEndpointUrl ; (; const char * ; name). static . Get final URL for file being opened asynchronously. ; Returns 0 is the information is not yet available. ; Definition at line 4945 of file TFile.cxx. ◆ GetErrno(). Int_t TFile::GetErrno ; (; ); const. virtual . Method returning errno. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1246 of file TFile.cxx. ◆ GetFd(). Int_t TFile::GetFd ; (; ); const. inline . Definition at line 234 of file TFile.h. ◆ GetFileBytesRead(). Long64_t TFile::GetFileBytesRead ; (; ). static . Static function returning the total number of bytes read from all files. ; Definition at line 4574 of file TFile.cxx. ◆ GetFileBytesWritten(). Long64_t TFile::GetFileBytesWritten ; (; ). static . Static function returning the total number of bytes written to all files. ; Does not take into account what might still be in the write caches. ; Definition at line 4583 of file TFile.cxx. ◆ GetFileCounter(). Long64_t TFile::GetFileCounter ; (; ). static . Definition at line 4617 of file TFile.cxx. ◆ GetFileReadCalls(). Int_t TFile::GetFileReadCalls ; (; ). static . Static function returning the total number of read calls from all files. ; Definition at line 4591 of file TFile.cxx. ◆ GetListOfFree(). TList * TFile::GetListOfFree ; (; ); const. inline . Definition at line 237 of file TFile.h. ◆ GetListOfProcessIDs(). TObjArray * TFile::GetListOfProcessIDs ; (; ); const. inline . Definition at line 236 of file TFile.h. ◆ GetNbytesFree(). virtual Int_t TFile::GetNbytesFree ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 249 of file TFile.h. ◆ GetNbytesInfo(). virtual Int_t TFile::GetNbytesInfo ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 248 of file TFile.h. ◆ GetNewUrl(). virtual TString TFile::GetNewUrl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:65633,cache,caches,65633,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['caches']
Performance,"Entries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsGenContextAbstract base class for generator contexts of RooAbsPdf objects.Definition RooAbsGenContext.h:26; RooAbsGenContext::setExpectedDatavirtual void setExpectedData(bool)Definition RooAbsGenContext.h:65; RooAbsGenContext::generatevirtual RooDataSet * generate(double nEvents=0, bool skipInit=false, bool extendedMode=false)Generate the specified number of events with nEvents>0 and and return a dataset containing the genera...Definition RooAbsGenContext.cxx:130; RooAbsGenContext::isValidbool isValid() constDefinition RooAbsGenContext.h:33; RooAbsGenContext::setProtoDataOrdervirtual void setProtoDataOrder(Int_t *lut)Set the traversal order of prototype data to that in the lookup tables passed as argument.Definition RooAbsGenContext.cxx:319; RooAbsPdf::CacheElemNormalization set with for above integral.Definition RooAbsPdf.h:322; RooAbsPdf::CacheElem::_normstd::unique_ptr< RooAbsReal > _normDefinition RooAbsPdf.h:327; RooAbsPdf::CacheElem::~CacheElem~CacheElem() overrideDestructor of normalization cache element.Definition RooAbsPdf.cxx:2430; RooAbsPdf::GenSpecDefinition RooAbsPdf.h:72; RooAbsPdf::GenSpec::_genContextstd::unique_ptr< RooAbsGenContext > _genContextDefinition RooAbsPdf.h:83; RooAbsPdf::GenSpec::~GenSpecvirtual ~GenSpec(); RooAbsPdf::GenSpec::_whatVarsRooArgSet _whatVarsDefinition RooAbsPdf.h:84; RooAbsPdf::GenSpec::_initbool _initDefinition RooAbsPdf.h:91; RooAbsPdf::GenSpec::_extendedbool _extendedDefinition RooAbsPdf.h:87; RooAbsPdf::GenSpec::_nGenInt_t _nGenDefinition RooAbsPdf.h:86; RooAbsPdf::GenSpec::GenSpecGenSpec()=default; RooAbsPdf::GenSpec::_randProtobool _randProtoDefinition RooAbsPdf.h:88; RooAbsPdf::GenSpec::_resampleProtobool _resampleProtoDefinition RooAbsPdf.h:89; RooAbsPdf::GenSpec::_protoDataRooDataSet * _protoDataDefinition RooAbsPdf.h:85; RooAbsPdfAbstract interface for all probability density functions.Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:141960,Cache,CacheElem,141960,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['Cache'],['CacheElem']
Performance,"Entries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning pha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:27929,load,loaded,27929,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['load'],['loaded']
Performance,"EntriesFast(). Long64_t TTreeSQL::GetEntriesFast ; (; ); const. overridevirtual . Return the number of entries as of the last check. ; Use GetEntries for a more accurate count. ; Reimplemented from TTree.; Definition at line 721 of file TTreeSQL.cxx. ◆ GetEntry(). Int_t TTreeSQL::GetEntry ; (; Long64_t ; entry = 0, . Int_t ; getall = 0 . ). overridevirtual . Load the data for the entry from the database. ; Reimplemented from TTree.; Definition at line 729 of file TTreeSQL.cxx. ◆ GetTableName(). TString TTreeSQL::GetTableName ; (; ). inline . Definition at line 89 of file TTreeSQL.h. ◆ Init(). void TTreeSQL::Init ; (; ). protected . Initialization routine. ; Definition at line 550 of file TTreeSQL.cxx. ◆ IsA(). TClass * TTreeSQL::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTree.; Definition at line 94 of file TTreeSQL.h. ◆ LoadTree(). Long64_t TTreeSQL::LoadTree ; (; Long64_t ; entry). overridevirtual . Setup the tree to the load the specified entry. ; Reimplemented from TTree.; Definition at line 738 of file TTreeSQL.cxx. ◆ PrepEntry(). Long64_t TTreeSQL::PrepEntry ; (; Long64_t ; entry). virtual . Make sure the server and result set are setup for the requested entry. ; Definition at line 747 of file TTreeSQL.cxx. ◆ Refresh(). void TTreeSQL::Refresh ; (; ). overridevirtual . Refresh contents of this Tree and its branches from the current Tree status in the database One can call this function in case the Tree on its file is being updated by another process. ; Reimplemented from TTree.; Definition at line 796 of file TTreeSQL.cxx. ◆ ResetQuery(). void TTreeSQL::ResetQuery ; (; ). protected . Reset the internal query. ; Definition at line 808 of file TTreeSQL.cxx. ◆ Streamer(). void TTreeSQL::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TTree. ◆ StreamerNVirtual(). void TTreeSQL::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:56985,load,load,56985,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['load'],['load']
Performance,"Entry(h1,""All nations"",""f"");; legend->AddEntry(h2,""French only"",""f"");; legend->Draw();. c1->cd();; delete f;; return c1;; }; To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option; For each cell (i,j) a box is drawn. The size (surface) of the box is; proportional to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:26465,scalab,scalable,26465,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['scalab'],['scalable']
Performance,"Entry(n)__ - returns the n-th entry number; 31- __Next__() - returns next entry number. Note, that this function is; 32 much faster than GetEntry, and it's called when GetEntry() is called; 33 for 2 or more indices in a row.; 34 ; 35## TTree::Draw() and TChain::Draw(); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:2595,Load,LoadTree,2595,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"EntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:208120,cache,cache,208120,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cache']
Performance,"EntryThe first entry of the range that the task will process. This method might be called multiple times per thread per event-loop. . Reimplemented in ROOT::RDF::RArrowDS, ROOT::Experimental::RNTupleDS, and ROOT::Internal::RDF::RRootDS.; Definition at line 210 of file RDataSource.hxx. ◆ SetEntry(). virtual bool ROOT::RDF::RDataSource::SetEntry ; (; unsigned int ; slot, . ULong64_t ; entry . ). pure virtual . Advance the ""cursors"" returned by GetColumnReaders to the selected entry for a particular slot. ; Parameters. [in]slotThe data processing slot that needs to be considered ; [in]entryThe entry which needs to be pointed to by the reader pointers Slots are adopted to accommodate parallel data processing. Different workers will loop over different ranges and will be labelled by different ""slot"" values. Returns true if the entry has to be processed, false otherwise. . Implemented in ROOT::Internal::RDF::RVecDS< ColumnTypes >, ROOT::RDF::RArrowDS, ROOT::RDF::RCsvDS, ROOT::RDF::RLazyDS< ColumnTypes >, ROOT::Internal::RDF::RRootDS, ROOT::RDF::RSqliteDS, ROOT::RDF::RTrivialDS, and ROOT::Experimental::RNTupleDS. ◆ SetNSlots(). virtual void ROOT::RDF::RDataSource::SetNSlots ; (; unsigned int ; nSlots). pure virtual . Inform RDataSource of the number of processing slots (i.e. ; worker threads) used by the associated RDataFrame. Slots numbers are used to simplify parallel execution: RDataFrame guarantees that different threads will always pass different slot values when calling methods concurrently. ; Implemented in ROOT::Internal::RDF::RVecDS< ColumnTypes >, ROOT::RDF::RArrowDS, ROOT::RDF::RCsvDS, ROOT::RDF::RLazyDS< ColumnTypes >, ROOT::Experimental::RNTupleDS, ROOT::Internal::RDF::RRootDS, ROOT::RDF::RSqliteDS, and ROOT::RDF::RTrivialDS. The documentation for this class was generated from the following file:; tree/dataframe/inc/ROOT/RDataSource.hxx. ROOTRDFRDataSource. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html:13917,concurren,concurrently,13917,doc/master/classROOT_1_1RDF_1_1RDataSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html,1,['concurren'],['concurrently']
Performance,"EnvRec* rec;; 5851 TIter next(fMapfile->GetTable());; 5852 while ((rec = (TEnvRec*) next())) {; 5853 TString cls = rec->GetName();; 5854 if (!strncmp(cls.Data(), ""Library."", 8) && cls.Length() > 8) {; 5855 // get the first lib from the list of lib and dependent libs; 5856 TString libs = rec->GetValue();; 5857 if (libs == """") {; 5858 continue;; 5859 }; 5860 TString delim("" "");; 5861 TObjArray* tokens = libs.Tokenize(delim);; 5862 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 5863 // convert ""@@"" to ""::"", we used ""@@"" because TEnv; 5864 // considers ""::"" a terminator; 5865 cls.Remove(0, 8);; 5866 cls.ReplaceAll(""@@"", ""::"");; 5867 // convert ""-"" to "" "", since class names may have; 5868 // blanks and TEnv considers a blank a terminator; 5869 cls.ReplaceAll(""-"", "" "");; 5870 if (gDebug > 6) {; 5871 const char* wlib = gSystem->DynamicPathName(lib, kTRUE);; 5872 if (wlib) {; 5873 Info(""LoadLibraryMap"", ""class %s in %s"", cls.Data(), wlib);; 5874 }; 5875 else {; 5876 Info(""LoadLibraryMap"", ""class %s in %s (library does not exist)"", cls.Data(), lib);; 5877 }; 5878 delete[] wlib;; 5879 }; 5880 delete tokens;; 5881 }; 5882 else if (!strncmp(cls.Data(), ""Declare."", 8) && cls.Length() > 8) {; 5883 cls.Remove(0, 8);; 5884 // convert ""-"" to "" "", since class names may have; 5885 // blanks and TEnv considers a blank a terminator; 5886 cls.ReplaceAll(""-"", "" "");; 5887 fInterpreter->declare(cls.Data());; 5888 }; 5889 }; 5890 ; 5891 // Process the forward declarations collected; 5892 cling::Transaction* T = nullptr;; 5893 auto compRes= fInterpreter->declare(uniqueString.Data(), &T);; 5894 assert(cling::Interpreter::kSuccess == compRes && ""A declaration in a rootmap could not be compiled"");; 5895 ; 5896 if (compRes!=cling::Interpreter::kSuccess){; 5897 Warning(""LoadLibraryMap"",; 5898 ""Problems in %s declaring '%s' were encountered."", rootmapfile, uniqueString.Data()) ;; 5899 }; 5900 ; 5901 if (T) {; 5902 ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);; 5903 for (auto declIt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:228419,Load,LoadLibraryMap,228419,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"Error(). bool TMinuitMinimizer::GetMinosError ; (; unsigned int ; i, . double & ; errLow, . double & ; errUp, . int ; = 0 . ). overridevirtual . minos error for variable i, return false if Minos failed ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 746 of file TMinuitMinimizer.cxx. ◆ GetVariableSettings(). bool TMinuitMinimizer::GetVariableSettings ; (; unsigned int ; ivar, . ROOT::Fit::ParameterSettings & ; var . ); const. overridevirtual . get variable settings in a variable object (like ROOT::Fit::ParamsSettings) ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 411 of file TMinuitMinimizer.cxx. ◆ GlobalCC(). double TMinuitMinimizer::GlobalCC ; (; unsigned int ; i); const. overridevirtual . global correlation coefficient for variable i ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 734 of file TMinuitMinimizer.cxx. ◆ Hesse(). bool TMinuitMinimizer::Hesse ; (; ). overridevirtual . perform a full calculation of the Hessian matrix for error calculation ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 1004 of file TMinuitMinimizer.cxx. ◆ InitTMinuit(). void TMinuitMinimizer::InitTMinuit ; (; int ; ndim). protected . initialize the TMinuit instance ; Definition at line 117 of file TMinuitMinimizer.cxx. ◆ IsA(). virtual TClass * TMinuitMinimizer::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 272 of file TMinuitMinimizer.h. ◆ IsFixedVariable(). bool TMinuitMinimizer::IsFixedVariable ; (; unsigned int ; ivar); const. overridevirtual . query if an existing variable is fixed (i.e. ; considered constant in the minimization) note that by default all variables are not fixed ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 404 of file TMinuitMinimizer.cxx. ◆ MinGradient(). const double * TMinuitMinimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuitMinimizer.html:18287,perform,perform,18287,doc/master/classTMinuitMinimizer.html,https://root.cern,https://root.cern/doc/master/classTMinuitMinimizer.html,1,['perform'],['perform']
Performance,"Error(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; EnableLooseOptions(Bool_t b=kTRUE)TMVA::Configurableinlineprotected; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; EvaluateAllMethods(void)TMVA::Factory; EvaluateAllVariables(DataLoader *loader, TString options="""")TMVA::Factory; EvaluateImportance(DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")TMVA::Factory; EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")TMVA::Factoryprivate; EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")TMVA::Factoryprivate; EvaluateImportanceShort(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")TMVA::Factoryprivate; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Factory(TString theJobName, TFile *theTargetFile, TString theOption="""")TMVA::Factory; Factory(TString theJobName, TString theOption="""")TMVA::Factory; fAnalysisTypeTMVA::Factoryprivate; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fConfigDescriptionTMVA::Configurableprivate; fCorrelationsTMVA::Factoryprivate; fDefaultTrfsTMVA::Factoryprivate; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; fgTargetFileTMVA::Factoryprivate; FillBuffer(char *&buffer)TNamedvirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fJobNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory-members.html:2709,load,loader,2709,doc/master/classTMVA_1_1Factory-members.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory-members.html,5,['load'],['loader']
Performance,"ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Private Member Functions;  TProofLite (const TProofLite &);  ; Int_t CleanupSandbox ();  Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10) ;  ; Int_t CreateSandbox ();  Create the sandbox for this session. ;  ; void FindUniqueSlaves () override;  Add to the fUniqueSlave list the active slaves that have a unique (user) file system image. ;  ; Int_t InitDataSetManager ();  Initialize the dataset manager from directives or from defaults Return 0 on success, -1 on failure. ;  ; void NotifyStartUp (const char *action, Int_t done, Int_t tot);  Notify setting-up operation message. ;  ; void operator= (const TProofLite &);  ; void ResolveKeywords (TString &s, const char *ord, const char *logfile);  Resolve some keywords in 's' <logfilewrk>, <user>, <rootsys>, <cpupin> ;  ; void SendInputDataFile () override;  Make sure that the input data objects are available to the workers in a dedicated file in the cache; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t SetProofServEnv (const char *ord);  Create environment files for worker 'ord'. ;  ; void ShowDataDir (const char *dirname);  List contents of the data directory 'dirname'. ;  . Private Attributes; TString fCacheDir;  ; TProofLockPath * fCacheLock;  ; TString fDataSetDir;  ; TDataSetManager * fDataSetManager;  ; TDataSetManagerFile * fDataSetStgRepo;  ; Int_t fDynamicStartupNMax;  ; Int_t fDynamicStartupStep;  ; Bool_t fForkStartup;  ; Int_t fNWorkers;  ; TQueryResultManager * fQMgr;  ; TString fQueryDir;  ; TProofLockPath * fQueryLock;  ; TPMERegexp * fReInvalid;  ; TString fSandbox;  ; TString fSelection;  ; TServerSocket * fServSock;  ; TString fSockPath;  ; TString fVarExp;  . Static Private Attributes; static Int_t fgWrksMax = -2;  . Friends; class TProofPlayerLite;  . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:40535,cache,cache,40535,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"ErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooRangeBoolean&operator=(const RooRangeBoolean&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:19153,optimiz,optimizeCacheMode,19153,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSecondMoment&operator=(const RooSecondMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:19301,optimiz,optimizeCacheMode,19301,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStepFunction&operator=(const RooStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:19635,optimiz,optimizeCacheMode,19635,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,2,['optimiz'],['optimizeCacheMode']
Performance,"Errors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:10491; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetRMSDouble_t GetRMS(Int_t axis=1) constThis function returns the Standard Deviation (Sigma) of the distribution not the Root Mean Square (RM...Definition TH1.h:319; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TLegendThis class displays a legend box (TPaveText) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TestBinomial_8C.html:60276,Perform,Performs,60276,doc/master/TestBinomial_8C.html,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html,1,['Perform'],['Performs']
Performance,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormulaVar.html:19040,optimiz,optimizeCacheMode,19040,root/html530/RooFormulaVar.html,https://root.cern,https://root.cern/root/html530/RooFormulaVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ParamHistFunc&operator=(const ParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); ParamHistFunc(); ParamHistFunc(const ParamHistFunc& other, const char* name = 0); ParamHistFunc(const char* name, const char* title, const RooArgList& vars, const RooArgList& paramSet); ParamHistFunc(const char* name, const char* title, const RooArgList& vars, const RooArgList& paramSet, const TH1* hist); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:19559,optimiz,optimizeCacheMode,19559,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,2,['optimiz'],['optimizeCacheMode']
Performance,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCachedReal&operator=(const RooCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:19405,optimiz,optimizeCacheMode,19405,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,2,['optimiz'],['optimizeCacheMode']
Performance,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDerivative&operator=(const RooDerivative&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:19308,optimiz,optimizeCacheMode,19308,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,2,['optimiz'],['optimizeCacheMode']
Performance,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:20225,optimiz,optimizeCacheMode,20225,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,2,['optimiz'],['optimizeCacheMode']
Performance,"EvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFnBinding&operator=(const RooTFnBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:19118,optimiz,optimizeCacheMode,19118,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,2,['optimiz'],['optimizeCacheMode']
Performance,"EvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:20615,optimiz,optimizeCacheMode,20615,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,5,['optimiz'],['optimizeCacheMode']
Performance,"Evaluate this formula. ;  ; virtual TString GetExpFormula (Option_t *option="""") const;  Reconstruct the formula expression from the internal TFormula member variables. ;  ; virtual const TObject * GetLinearPart (Int_t i);  Return linear part. ;  ; virtual Int_t GetNdim () const;  ; virtual Int_t GetNpar () const;  ; virtual Int_t GetNumber () const;  ; Double_t GetParameter (const char *name) const;  Return value of parameter named parName. ;  ; Double_t GetParameter (Int_t ipar) const;  Return value of parameter number ipar. ;  ; virtual Double_t * GetParameters () const;  ; virtual void GetParameters (Double_t *params);  ; virtual const char * GetParName (Int_t ipar) const;  Return name of one parameter. ;  ; virtual Int_t GetParNumber (const char *name) const;  Return parameter number by name. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsLinear () const;  ; virtual Bool_t IsNormalized () const;  ; TFormula & operator= (const TFormula &rhs);  Operator =. ;  ; void Optimize ();  MI include. ;  ; void Print (Option_t *option="""") const override;  Dump this formula with its attributes. ;  ; virtual void ProcessLinear (TString &replaceformula);  If the formula is for linear fitting, change the title to normal and fill the LinearParts array. ;  ; virtual void SetNumber (Int_t number);  ; virtual void SetParameter (const char *name, Double_t parvalue);  Initialize parameter number ipar. ;  ; virtual void SetParameter (Int_t ipar, Double_t parvalue);  Initialize parameter number ipar. ;  ; virtual void SetParameters (const Double_t *params);  Initialize array of all parameters. ;  ; virtual void SetParameters (Double_t p0, Double_t p1, Double_t p2=0, Double_t p3=0, Double_t p4=0, Double_t p5=0, Double_t p6=0, Double_t p7=0, Double_t p8=0, Double_t p9=0, Double_t p10=0);  Initialize up to 11 parameters All arguments except THE FIRST TWO are optional In case of a function with only one parameter, call this function with p1=0. ;  ; virtual void SetParName (Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:3210,Optimiz,Optimize,3210,doc/master/structROOT_1_1v5_1_1TF1Data.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html,2,['Optimiz'],['Optimize']
Performance,"EveStraightLineSet::fOwnMarkersIdsFlag specifying if id-objects are owned by the line-set; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveStraightLineSet::fRnrLines; Bool_tTEveStraightLineSet::fRnrMarkers; Bool_tTEveElement::fRnrSelfRender this element.; Float_tfScaleCenter[3]; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveScalableStraightLineSet(const char* n = ""ScalableStraightLineSet"", const char* t = """"); Constructor. void SetScaleCenter(Float_t x, Float_t y, Float_t z); Set scale center. Double_t GetScale() const; Return current scale. void SetScale(Double_t scale); Loop over line parameters and scale coordinates. TEveScalableStraightLineSet(const TEveScalableStraightLineSet& ). TEveScalableStraightLineSet& operator=(const TEveScalableStraightLineSet& ). virtual ~TEveScalableStraightLineSet(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveScalableStraightLineSet.html:27191,Scalab,ScalableStraightLineSet,27191,root/html534/TEveScalableStraightLineSet.html,https://root.cern,https://root.cern/root/html534/TEveScalableStraightLineSet.html,1,['Scalab'],['ScalableStraightLineSet']
Performance,"Event *event)Definition collection_proxies.C:574; CollectionManager::m_collectionsREveScene * m_collectionsDefinition collection_proxies.C:570; CollectionManager::m_scenesstd::vector< REveScene * > m_scenesDefinition collection_proxies.C:565; CollectionManager::finishViewCreatevoid finishViewCreate()Definition collection_proxies.C:737; CollectionManager::m_inEventLoadingbool m_inEventLoadingDefinition collection_proxies.C:571; CollectionManager::FillImpliedSelectedvoid FillImpliedSelected(REveDataItemList *itemList, REveElement::Set_t &impSelSet, const std::set< int > &sec_idcs)Definition collection_proxies.C:765; CollectionManager::ModelChangedvoid ModelChanged(REveDataItemList *itemList, const REveDataCollection::Ids_t &ids)Definition collection_proxies.C:751; CollectionManager::fEventEvent * fEventDefinition collection_proxies.C:563; CollectionManager::m_buildersstd::vector< REveDataProxyBuilderBase * > m_buildersDefinition collection_proxies.C:568; CollectionManager::LoadEventvoid LoadEvent()Definition collection_proxies.C:651; CollectionManager::m_viewContextREveViewContext * m_viewContextDefinition collection_proxies.C:566; CollectionManager::SetDataItemsFromEventvoid SetDataItemsFromEvent(REveDataCollection *collection)Definition collection_proxies.C:627; EventManagerDefinition collection_proxies.C:786; EventManager::fEventEvent * fEventDefinition collection_proxies.C:788; EventManager::fCMngCollectionManager * fCMngDefinition collection_proxies.C:789; EventManager::~EventManager~EventManager() overrideDefinition collection_proxies.C:794; EventManager::EventManagerEventManager(Event *e, CollectionManager *m)Definition collection_proxies.C:792; EventManager::NextEventvirtual void NextEvent()Definition collection_proxies.C:796; EventDefinition collection_proxies.C:172; Event::MakeParticlesvoid MakeParticles(int N)Definition collection_proxies.C:217; Event::eventIdint eventIdDefinition collection_proxies.C:174; Event::N_jetsint N_jetsDefinition collection_proxies",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/collection__proxies_8C_source.html:37449,Load,LoadEventvoid,37449,doc/master/collection__proxies_8C_source.html,https://root.cern,https://root.cern/doc/master/collection__proxies_8C_source.html,2,['Load'],"['LoadEvent', 'LoadEventvoid']"
Performance,"Event(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:10806,cache,cacheList,10806,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,123,['cache'],['cacheList']
Performance,"Event(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:11532,cache,cacheList,11532,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,77,['cache'],['cacheList']
Performance,"Event(QEvent*); voidQObject::destroyed(QObject* = 0); virtual voidQObject::disconnectNotify(const char* signal); voidError(int error); intQObject::receivers(const char* signal) const; QObject*QObject::sender() const; intQObject::senderSignalIndex() const; virtual voidQObject::timerEvent(QTimerEvent*); TQtRootSlot(). private:. voidoperator=(const TQtRootSlot&); static voidqt_static_metacall(QObject*, QMetaObject::Call, int, void**); TQtRootSlot(const TQtRootSlot&). Data Members; public:. static const QMetaObjectstaticMetaObject; static const QMetaObjectQObject::staticMetaObject. protected:. QScopedPointer<QObjectData>QObject::d_ptr; static TQtRootSlot*fgTQtRootSlot; static const QMetaObjectQObject::staticQtMetaObject. private:. static const QMetaObjectExtraDatastaticMetaObjectExtraData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQtRootSlot * CintSlot(); create and return the singleton. void EndOfLine(); slot to perform the standard ""EndOfLine"" ROOT action; it used to update the current gPad. void ProcessLine(const QString& ); execute the arbitrary ROOT /CINt command via; CINT C++ interpreter and emit the result. void ProcessLine(const char* ); execute the arbitrary ROOT /CINt command via; CINT C++ interpreter and emit the result. void Terminate(int status) const; the dedicated slot to terminate the ROOT application; with ""status"". void Terminate() const; the dedicated slot to terminate the ROOT application; and return the ""0"" status. void TerminateAndQuit() const; the dedicated slot to terminate the ROOT application; and quit the Qt Application if any. TQtRootSlot(const TQtRootSlot& ). void operator=(const TQtRootSlot& ). TQtRootSlot(); {}. virtual ~TQtRootSlot(); {}. void Error(int error). » Author: Valery Fine 18/01/2007 » Copyright (C) 2007 by Valeri Fine. Brookhaven National Laboratory.; » Last changed: root/qt:$Id$ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or sugg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQtRootSlot.html:4021,perform,perform,4021,root/html604/TQtRootSlot.html,https://root.cern,https://root.cern/root/html604/TQtRootSlot.html,1,['perform'],['perform']
Performance,"Events, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:38081,optimiz,optimizeDirtyHook,38081,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:17084,perform,perform,17084,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,1,['perform'],['perform']
Performance,"ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:17081,perform,perform,17081,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,2,['perform'],['perform']
Performance,"Exec object. When a file is connected, the dictionary of the classes on the file is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement object is read, a TExec object is automatically created with the name specified after the keyword ""EXEC:"" in case a TExec with a same name does not already exist.; The action to be executed via this TExec can be specified with:. a call to the TExec constructor, if the constructor is called before opening the file.; a call to TExec::SetAction at any time. One can compute a pointer to an existing TExec with a name with: TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; gROOT#define gROOTDefinition TROOT.h:406; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TExec::SetActionvirtual void SetAction(const char *action)Definition TExec.h:37; where actionCommand is a string containing a C++ instruction. Examples: myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be automatically executed. In the function/script being executed, one or more of the following actions can be executed:. load a file containing the referenced object. This function typically looks in the file catalog (GRID).; compute a pointer to the referenced object and communicate this pointer back to the calling function TRef::GetObject via: TRef::SetStaticObject(object).; TRef::SetStaticObjectstatic void SetStaticObject(TObject *obj)Static function to set the object found on the Action on Demand function.Definition TRef.cxx:478; When the TExec is called, it has access to the dereferencing TRef by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this"" before the call to TExec). This can be useful for accessing the TRef's fUniqueID. As soon as an object is returned to GetObject, the fUniqueID of the TRef is set to the fUniqueID of the referenced object. At the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:6668,Load,LoadHits,6668,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['Load'],['LoadHits']
Performance,"ExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494 return 0;; 7495}; 7496 ; 7497////////////////////////////////////////////////////////////////////////////////; 7498/// Load a source file or library called path into the interpreter.; 7499 ; 7500int TCling::LoadFile(const char* path) const; 7501{; 7502 // Modifying the interpreter state needs locking.; 7503 R__LOCKGUARD(gInterpreterMutex);; 7504 cling::Interpreter::CompilationResult compRes;; 7505 HandleInterpreterException(GetMetaProcessorImpl(), TString::Format("".L %s"", path), compRes, /*cling::Value*/nullptr);; 7506 return compRes == cling::Interpreter::kFailure;; 7507}; 7508 ; 7509////////////////////////////////////////////////////////////////////////////////; 7510/// Load the declarations from text into the interpreter.; 7511/// Note that this cannot be (top level) statements; text must contain; 7512/// top level declarations.; 7513/// Returns true on success, false on failure.; 7514 ; 7515Bool_t TCling::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) const; 7524{; 7525 TTHREAD_TLS_DECL(std::string,buffer);; 7526 ROOT::TMetaUtils::GetCppName(buffer,name);; 7527 return buffer.c_str(); // NOLINT; 7528}; 7529 ; 7530////////////////////////////////////////////////////////////////////////////////; 7531/// [Place holder for Mutex Lock]; 7532/// Provide the interpreter with a way to; 7533/// acquire a lock used to pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:293075,Load,Load,293075,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['Load']
Performance,"ExpandIntoListTree. void ExpandIntoListTrees(); Expand children into all list-trees. void ExpandIntoListTreesRecursively(); Expand children into all list-trees recursively.; This is useful if one wants to export extracted shapes. void AddStamp(UChar_t bits); Override from TEveElement.; Process visibility changes and forward them to fNode. Bool_t CanEditMainColor() const; Can edit main-color -- not available for assemblies. void SetMainColor(Color_t color); Set color, propagate to volume's line color. Bool_t CanEditMainTransparency() const; Can edit main transparency -- not available for assemblies. Char_t GetMainTransparency() const; Get transparency -- it is taken from the geo node. void SetMainTransparency(Char_t t); Set transparency, propagate to volume's transparency. void UpdateNode(TGeoNode* node); Updates all reve-browsers having the node in their contents.; All 3D-pads updated if any change found. Should (could?) be optimized with some assumptions about; volume/node structure (search for parent, know the same node can not; reoccur on lower level once found). void UpdateVolume(TGeoVolume* volume); Updates all reve-browsers having the volume in their contents.; All 3D-pads updated if any change found. Should (could?) be optimized with some assumptions about; volume/node structure (search for parent, know the same node can not; reoccur on lower level once found). void Draw(Option_t* option = """"); Draw the object. void Save(const char* file, const char* name = ""Extract"", Bool_t leafs_only = kFALSE); Save TEveGeoShapeExtract tree starting at this node.; This function is obsolete, use SaveExtract() instead. void SaveExtract(const char* file, const char* name, Bool_t leafs_only); Save the shape tree as TEveGeoShapeExtract.; File is always recreated. void WriteExtract(const char* name, Bool_t leafs_only); Write the shape tree as TEveGeoShapeExtract to current directory. TEveGeoShapeExtract* DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeExtract* parent = 0, Bool_t lea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoNode.html:20032,optimiz,optimized,20032,root/html528/TEveGeoNode.html,https://root.cern,https://root.cern/root/html528/TEveGeoNode.html,6,['optimiz'],['optimized']
Performance,"ExpensiveObject(); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(const RooExpensiveObjectCache::ExpensiveObject&); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); virtual TClass*IsA() const; Bool_tmatches(TClass* tc, const RooArgSet& params); RooExpensiveObjectCache::ExpensiveObject&operator=(const RooExpensiveObjectCache::ExpensiveObject&); const char*ownerName() const; const TObject*payload() const; TObject*payload(); voidprint(); voidsetPayload(TObject* obj); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tuid() const. Data Members; protected:. map<TString,Int_t>_catRefParamsNames and values of discrete-valued reference parameters ; TString_ownerNameName of RooAbsArg object that is associated to cache contents; TObject*_payloadPayload; map<TString,Double_t>_realRefParamsNames and values of real-valued reference parameters; Int_t_uidUnique element ID ;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); Construct ExpensiveObject oject for inPayLoad and store reference values; for all RooAbsReal and RooAbsCategory parameters in params. ExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other). ~ExpensiveObject(). Bool_t matches(TClass* tc, const RooArgSet& params); Check object type ;. void print(). ExpensiveObject(); { _payload = 0 ; }. ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter). Int_t uid() const; { return _uid ; }. const TObject* payload() const; { return _payload ; }. TObject* payload(); { return _payload ; }. void setPayload(TObject* obj); { _payload = obj ; }. const char* owne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache__ExpensiveObject.html:1817,cache,cache,1817,root/html528/RooExpensiveObjectCache__ExpensiveObject.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache__ExpensiveObject.html,1,['cache'],['cache']
Performance,"ExpensiveObject(); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(const RooExpensiveObjectCache::ExpensiveObject&); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); virtual TClass*IsA() const; Bool_tmatches(TClass* tc, const RooArgSet& params); RooExpensiveObjectCache::ExpensiveObject&operator=(const RooExpensiveObjectCache::ExpensiveObject&); const char*ownerName() const; const TObject*payload() const; TObject*payload(); voidprint(); voidsetPayload(TObject* obj); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tuid() const. Data Members; protected:. map<TString,Int_t>_catRefParamsNames and values of discrete-valued reference parameters ; TString_ownerNameName of RooAbsArg object that is associated to cache contents; TObject*_payloadPayload; map<TString,Double_t>_realRefParamsNames and values of real-valued reference parameters; Int_t_uidUnique element ID ;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); Construct ExpensiveObject oject for inPayLoad and store reference values; for all RooAbsReal and RooAbsCategory parameters in params. ExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other). ~ExpensiveObject(). Bool_t matches(TClass* tc, const RooArgSet& params); Check object type ;. void print(). ExpensiveObject(); { _uid = 0 ; _payload = 0 ; }. ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter). Int_t uid() const; { return _uid ; }. const TObject* payload() const; { return _payload ; }. TObject* payload(); { return _payload ; }. void setPayload(TObject* obj); { _payload = obj ; }. const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExpensiveObjectCache__ExpensiveObject.html:1817,cache,cache,1817,root/html530/RooExpensiveObjectCache__ExpensiveObject.html,https://root.cern,https://root.cern/root/html530/RooExpensiveObjectCache__ExpensiveObject.html,2,['cache'],['cache']
Performance,"Experimental::RCanvas::Remove(); 226{; 227 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 228 auto &held = GetHeldCanvases();; 229 auto indx = held.size();; 230 while (indx-- > 0) {; 231 if (held[indx].get() == this); 232 held.erase(held.begin() + indx);; 233 }; 234}; 235 ; 236//////////////////////////////////////////////////////////////////////////////////////////////; 237/// Set handle which will be cleared when connection is closed; 238 ; 239void ROOT::Experimental::RCanvas::ClearOnClose(const std::shared_ptr<void> &handle); 240{; 241 if (fPainter); 242 fPainter->SetClearOnClose(handle);; 243}; 244 ; 245//////////////////////////////////////////////////////////////////////////; 246/// Run canvas functionality for the given time (in seconds); 247/// Used to process canvas-related actions in the appropriate thread context.; 248/// Must be regularly called when canvas created and used in extra thread.; 249/// Time parameter specifies minimal execution time in seconds - if default value 0 is used,; 250/// just all pending actions will be performed.; 251/// When canvas is not yet displayed - just performs sleep for given time interval.; 252///; 253/// Example of usage:; 254///; 255/// ~~~ {.cpp}; 256/// void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); 257/// {; 258/// auto canvas = RCanvas::Create(""Canvas title"");; 259/// canvas->Draw(hist)->SetLineColor(RColor::kBlue);; 260/// canvas->Show();; 261/// while (run_loop) {; 262/// pHist->Fill(1);; 263/// canvas->Modified();; 264/// canvas->Update();; 265/// canvas->Run(0.1); // process canvas events; 266/// }; 267///; 268/// canvas->Remove();; 269/// }; 270///; 271/// int main(); 272/// {; 273/// RAxisConfig xaxis(100, -10., 10.);; 274/// auto pHist = std::make_shared<RH1D>(xaxis);; 275/// bool run_loop = true;; 276///; 277/// std::thread thrd(draw_canvas, run_loop, pHist);; 278/// std::this_thread::sleep_for(std::chrono::seconds(100));; 279/// run_loop = false;; 280/// thrd.join();; 281/// retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:8383,perform,performed,8383,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['perform'],['performed']
Performance,"Expr, const char* wgtVarName). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& ads, const char* selExpr, const char* wgtVarName). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree *t, const RooFormulaVar* select, const char* /*rangeName*/, Int_t /*nStart*/, Int_t /*nStop*/); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore *ads, const RooFormulaVar* select, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:12798,cache,cachedVars,12798,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,3,['cache'],"['cache', 'cachedVars']"
Performance,"Extras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstVar.html:30524,cache,cache,30524,root/html532/RooConstVar.html,https://root.cern,https://root.cern/root/html532/RooConstVar.html,5,['cache'],"['cache', 'caches']"
Performance,"E . ). overridevirtual . Finalize a query. ; Returns -1 in case error, 0 otherwise. ; Reimplemented from TProofPlayer.; Definition at line 331 of file TProofPlayerLite.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayerLite::Finalize ; (; TQueryResult * ; qr). inlineoverridevirtual . Finalize query (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 48 of file TProofPlayerLite.h. ◆ HandleTimer(). Bool_t TProofPlayerLite::HandleTimer ; (; TTimer * ; timer). overrideprotectedvirtual . Send feedback objects to client. ; Reimplemented from TObject.; Definition at line 442 of file TProofPlayerLite.cxx. ◆ IsA(). TClass * TProofPlayerLite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofPlayer.; Definition at line 53 of file TProofPlayerLite.h. ◆ MakeSelector(). Int_t TProofPlayerLite::MakeSelector ; (; const char * ; selfile). protected . Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ; Returns 0 and fill fSelector in case of success. Returns -1 and sets fSelector to 0 in case of failure. ; Definition at line 45 of file TProofPlayerLite.cxx. ◆ Process() [1/2]. Long64_t TProofPlayerLite::Process ; (; TDSet * ; dset, . const char * ; selector_file, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProofPlayer.; Definition at line 109 of file TProofPlayerLite.cxx. ◆ Process() [2/2]. Long64_t TProofPlayerLite::Process ; (; TDSet * ; dset, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:29412,cache,cache,29412,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['cache'],['cache']
Performance,"E . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at line 7396 of file TProof.cxx. ◆ ShowDataSet(). void TProof::ShowDataSet ; (; const char * ; dataset = """", . const char * ; opt = ""filter:SsCc"" . ). display meta-info for given dataset usi ; Definition at line 10977 of file TProof.cxx. ◆ ShowDataSetCache(). void TProof::ShowDataSetCache ; (; const char * ; dataset = 0). virtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TProofLite.; Definition at line 10914 of file TProof.cxx. ◆ ShowDataSetQuota(). void TProof::ShowDataSetQuota ; (; Option_t * ; opt = 0). shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-level ; Definition at line 11309 of file TProof.cxx. ◆ ShowDataSets(). void TProof::ShowDataSets ; (; const char * ; uri = """", . const char * ; optStr = """" . ). virtual . Shows datasets in locations that match the uri. ; By default shows the user's datasets and global ones ; Reimplemented in TProofLite.; Definition at line 10846 of file TProof.cxx. ◆ ShowEnabledPackages(). void TProof::ShowEnabledPackages ; (; Bool_t ; all = kFALSE). List which packages are enabled. ; If all is true show enabled packages for all active slaves. If everything is ok all active slaves should have the same packages enabled. ; Definition at line 7818 of file TProof.cxx. ◆ ShowFeedback(). void TProof::ShowFeedback ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:148698,cache,cache,148698,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['cache']
Performance,"F * RooStats::HybridPlot::GetBhisto ; (; ). inline . Get B histo. ; Definition at line 65 of file HybridPlot.h. ◆ GetBIntExtremes(). double * RooStats::HybridPlot::GetBIntExtremes ; (; double ; frac). inline . Get B histo integration extremes to obtain the requested area fraction call delete [] res to release memory. ; Definition at line 73 of file HybridPlot.h. ◆ GetBmean(). double RooStats::HybridPlot::GetBmean ; (; ). inline . Get B histo mean. ; Definition at line 59 of file HybridPlot.h. ◆ GetBrms(). double RooStats::HybridPlot::GetBrms ; (; ). inline . Get B histo RMS. ; Definition at line 62 of file HybridPlot.h. ◆ GetCanvas(). TVirtualPad * RooStats::HybridPlot::GetCanvas ; (; ). inline . Get the pad (or canvas) where it has been drawn. ; Definition at line 95 of file HybridPlot.h. ◆ GetHistoCenter(). double HybridPlot::GetHistoCenter ; (; TH1 * ; histo_orig, . double ; n_rms = 1, . bool ; display_result = false . ). Get the center of the histo. ; Perform 2 times a gaussian fit to fetch the center of the histo.; To get the second fit range get an interval that tries to keep into account the skewness of the distribution. ; Definition at line 238 of file HybridPlot.cxx. ◆ GetHistoPvals(). double * HybridPlot::GetHistoPvals ; (; TH1 * ; histo, . double ; percentage . ). Get the ""effective sigmas"" of the histo, call delete [] res to release memory. ; We let an horizontal bar go down and we stop when we have the integral equal to the desired one. ; Definition at line 301 of file HybridPlot.cxx. ◆ GetMedian(). double HybridPlot::GetMedian ; (; TH1 * ; histo). Get the median of an histogram. ; Definition at line 353 of file HybridPlot.cxx. ◆ GetSBCenter(). double RooStats::HybridPlot::GetSBCenter ; (; double ; n_sigmas = 1, . bool ; display = false . ). inline . Get SB histo center. ; Definition at line 80 of file HybridPlot.h. ◆ GetSBhisto(). TH1F * RooStats::HybridPlot::GetSBhisto ; (; ). inline . Get B histo. ; Definition at line 92 of file HybridPlot.h. ◆ GetSBI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html:16400,Perform,Perform,16400,doc/master/classRooStats_1_1HybridPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html,1,['Perform'],['Perform']
Performance,"F"". Therefore to draw on top; of an existing picture, specify option ""SL"". void DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); Draw formula between xmin,ymin and xmax,ymax. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a F2 is clicked with the locator. Int_t GetContour(Double_t* levels = 0); Return contour values into array levels. The number of contour levels can be returned by getContourLevel. Double_t GetContourLevel(Int_t level) const; Return the number of contour levels. Double_t FindMinMax(Double_t* x, bool findmax) const; return minimum/maximum value of the function; To find the minimum on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMinimumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the minimum value of the function; Return the minimum value of the function; To find the minimum on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:32127,perform,performed,32127,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['perform'],['performed']
Performance,"F(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double * x, double & f, double * df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x ). Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double & f, double & df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html:2367,perform,performances,2367,root/html526/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html,3,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"F1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58345,cache,cache,58345,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"FIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginManager.html:10210,load,loaded,10210,root/html528/TPluginManager.html,https://root.cern,https://root.cern/root/html528/TPluginManager.html,6,['load'],['loaded']
Performance,"Factory' RooDataset; These are stored in a somewhat odd way that makes; them difficult to inspect for humans.; They have the following layout:. ChannelA ChannelB ChannelCat Weight. bin_1_center 0 ChannelA bin_1_height; bin_2_center 0 ChannelA bin_2_height; 0 bin_1_center ChannelB bin_1_height; 0 bin_2_center ChannelB bin_2_height; ...etc... int label_print_width = 20;; int bin_print_width = 12;; Get the Data Histogram for this channel. void PrintModelAndData(RooDataSet* data); Loop over all channels and print model; (including all samples) and compare; it to the supplied dataset. void PrintParameters(bool IncludeConstantParams = false). void PrintChannelParameters(const string& channel, bool IncludeConstantParams = false); Get the list of parameters. void PrintSampleParameters(const string& channel, const string& sample, bool IncludeConstantParams = false); Get the list of parameters. double GetBinValue(int bin, const string& channel); Get the total bin height for the ith bin (ROOT indexing convention); in channel 'channel'; (Could be optimized, it uses an intermediate histogram for now...). double GetBinValue(int bin, const string& channel, const string& sample); Get the total bin height for the ith bin (ROOT indexing convention); in channel 'channel'; (This will be slow if you plan on looping over it.; Could be optimized, it uses an intermediate histogram for now...). std::map< std::string, RooAbsReal*> GetSampleFunctionMap(const string& channel); Get a map of strings to function pointers,; which each function cooresponds to a sample. RooAbsReal* SampleFunction(const string& channel, const string& sample); Return the function object pointer cooresponding; to a particular sample in a particular channel. RooArgSet* GetObservableSet(const string& channel); Get the observables for a particular channel. TH1* GetSampleHist(const string& channel, const string& sample, const string& name = """"); Get a histogram of the expected values for; a particular sample in a particular",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactoryNavigation.html:5550,optimiz,optimized,5550,root/html534/RooStats__HistFactory__HistFactoryNavigation.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactoryNavigation.html,3,['optimiz'],['optimized']
Performance,"FactoryCopy (TypeInfo_t *) const final;  ; void TypeInfo_Init (TypeInfo_t *tinfo, const char *funcname) const final;  ; bool TypeInfo_IsValid (TypeInfo_t *tinfo) const final;  ; const char * TypeInfo_Name (TypeInfo_t *) const final;  ; Long_t TypeInfo_Property (TypeInfo_t *tinfo) const final;  ; void * TypeInfo_QualTypePtr (TypeInfo_t *tinfo) const;  ; int TypeInfo_RefType (TypeInfo_t *) const final;  ; int TypeInfo_Size (TypeInfo_t *tinfo) const final;  ; const char * TypeInfo_TrueName (TypeInfo_t *tinfo) const final;  ; const char * TypeName (const char *typeDesc) final;  Return the absolute type of typeDesc. ;  ; Int_t UnloadAllSharedLibraryMaps () final;  Unload the library map entries coming from all the loaded shared libraries. ;  ; int UnloadFile (const char *path) const final;  ; Int_t UnloadLibraryMap (const char *library) final;  Unload library map entries coming from the specified library. ;  ; void UnRegisterTClassUpdate (const TClass *oldcl) final;  If the dictionary is loaded, we can remove the class from the list (otherwise the class might be loaded twice). ;  ; void UpdateClassInfoWithDecl (const clang::NamedDecl *ND);  Internal function. Inform a TClass about its new TagDecl or NamespaceDecl. ;  ; void UpdateEnumConstants (TEnum *enumObj, TClass *cl) const final;  ; void UpdateListOfDataMembers (TClass *cl) const;  Update the list of pointers to data members for TClass cl This is now a nop. ;  ; void UpdateListOfGlobalFunctions () final;  No op: see TClingCallbacks (used to update the list of global functions) ;  ; void UpdateListOfGlobals () final;  No op: see TClingCallbacks (used to update the list of globals) ;  ; void UpdateListOfMethods (TClass *cl) const final;  Update the list of pointers to method for TClass cl This is now a nop. ;  ; void UpdateListOfTypes () final;  No op: see TClingCallbacks (used to update the list of types) ;  ; void UpdateListsOnCommitted (const cling::Transaction &T);  ; void UpdateListsOnUnloaded (const cling::Transa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:33682,load,loaded,33682,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,2,['load'],['loaded']
Performance,"Families(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer needed. TGFont * MakeFont(TGFont* font, FontStruct_t fontStruct, const char* fontName); Helper for GetNativeFont() and GetFontFromAttributes(). Creates and; intializes a new TGFont object. font -- If non-NULL, store the information in this existing TGFont; object, rather than creating a new one; the existing; contents of the font will be released. If NULL, a new; TGFont object is created.; fontStruct -- information about font.; fontName -- The string passed to TVirtualX::LoadQueryFont() to construct the; fontStruct. FontAttributes_t& operator=(const TGFontPool& fp). TGFontPool(const TGFontPool& fp). » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGFontPool.html:13091,Load,LoadQueryFont,13091,root/html530/TGFontPool.html,https://root.cern,https://root.cern/root/html530/TGFontPool.html,1,['Load'],['LoadQueryFont']
Performance,"Families(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer needed. TGFont * MakeFont(TGFont* font, FontStruct_t fontStruct, const char* fontName); Helper for GetNativeFont() and GetFontFromAttributes(). Creates and; intializes a new TGFont object. font -- If non-NULL, store the information in this existing TGFont; object, rather than creating a new one; the existing; contents of the font will be released. If NULL, a new; TGFont object is created.; fontStruct -- information about font.; fontName -- The string passed to TVirtualX::LoadQueryFont() to construct the; fontStruct. FontAttributes_t& operator=(const TGFontPool& fp). TGFontPool(const TGFontPool& fp). » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 35912 2010-09-30 13:43:06Z couet $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFontPool.html:13091,Load,LoadQueryFont,13091,root/html532/TGFontPool.html,https://root.cern,https://root.cern/root/html532/TGFontPool.html,1,['Load'],['LoadQueryFont']
Performance,"Fields(int n)Definition RFieldVisitor.cxx:59; ROOT::Experimental::RPrintSchemaVisitor::SetFrameSymbolvoid SetFrameSymbol(char s)Definition RFieldVisitor.hxx:142; ROOT::Experimental::RPrintValueVisitorRenders a JSON value corresponding to the field.Definition RFieldVisitor.hxx:176; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; nconst Int_t nDefinition legend1.C:16; ROOT::Experimental::Internal::GetProjectedFieldsOfModelRProjectedFields & GetProjectedFieldsOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:42; ROOT::Experimental::Internal::CallConnectPageSourceOnFieldvoid CallConnectPageSourceOnField(RFieldBase &, RPageSource &)Definition RField.cxx:411; ROOT::Experimental::Internal::GetFieldZeroOfModelRFieldZero & GetFieldZeroOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:36; ROOT::Experimental::ENTupleInfoENTupleInfoListing of the different options that can be printed by RNTupleReader::GetInfo()Definition RNTupleReader.hxx:43; ROOT::Experimental::ENTupleInfo::kSummary@ kSummary; ROOT::Experimental::ENTupleInfo::kMetrics@ kMetrics; ROOT::Experimental::ENTupleInfo::kStorageDetails@ kStorageDetails; ROOT::Experimental::NTupleSize_tstd::uint64_t NTupleSize_tInteger type long enough to hold the maximum number of entries in a column.Definition RNTupleUtil.hxx:115; ROOT::Experimental::DescriptorId_tstd::uint64_t DescriptorId_tDistriniguishes elements of the same type within a descriptor, e.g. different fields.Definition RNTupleUtil.hxx:166; ROOT::Experimental::kInvalidDescriptorIdconstexpr DescriptorId_t kInvalidDescriptorIdDefinition RNTupleUtil.hxx:167; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; whatstatic const char * whatDefinition stlLoader.cc:5; outputstatic void output(). treentuplev7srcRNTupleReader.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8cxx_source.html:17534,multi-thread,multi-threading,17534,doc/master/RNTupleReader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"Fields(prepVisitor.GetNumFields());; 183 ; 184 for (int i = 0; i < width; ++i); 185 output << frameSymbol;; 186 output << ""\n"";; 187 fullModel->GetConstFieldZero().AcceptVisitor(printVisitor);; 188 for (int i = 0; i < width; ++i); 189 output << frameSymbol;; 190 output << std::endl;; 191 break;; 192 }; 193 case ENTupleInfo::kStorageDetails: fSource->GetSharedDescriptorGuard()->PrintInfo(output); break;; 194 case ENTupleInfo::kMetrics: fMetrics.Print(output); break;; 195 default:; 196 // Unhandled case, internal error; 197 R__ASSERT(false);; 198 }; 199}; 200 ; 201ROOT::Experimental::RNTupleReader *ROOT::Experimental::RNTupleReader::GetDisplayReader(); 202{; 203 if (!fDisplayReader); 204 fDisplayReader = Clone();; 205 return fDisplayReader.get();; 206}; 207 ; 208void ROOT::Experimental::RNTupleReader::Show(NTupleSize_t index, std::ostream &output); 209{; 210 auto reader = GetDisplayReader();; 211 const auto &entry = reader->GetModel().GetDefaultEntry();; 212 ; 213 reader->LoadEntry(index);; 214 output << ""{"";; 215 for (auto iValue = entry.begin(); iValue != entry.end();) {; 216 output << std::endl;; 217 RPrintValueVisitor visitor(*iValue, output, 1 /* level */);; 218 iValue->GetField().AcceptVisitor(visitor);; 219 ; 220 if (++iValue == entry.end()) {; 221 output << std::endl;; 222 break;; 223 } else {; 224 output << "","";; 225 }; 226 }; 227 output << ""}"" << std::endl;; 228}; 229 ; 230const ROOT::Experimental::RNTupleDescriptor &ROOT::Experimental::RNTupleReader::GetDescriptor(); 231{; 232 auto descriptorGuard = fSource->GetSharedDescriptorGuard();; 233 if (!fCachedDescriptor || fCachedDescriptor->GetGeneration() != descriptorGuard->GetGeneration()); 234 fCachedDescriptor = descriptorGuard->Clone();; 235 return *fCachedDescriptor;; 236}; 237 ; 238ROOT::Experimental::DescriptorId_t ROOT::Experimental::RNTupleReader::RetrieveFieldId(std::string_view fieldName) const; 239{; 240 auto fieldId = fSource->GetSharedDescriptorGuard()->FindFieldId(fieldName);; 241 if (fieldId == ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8cxx_source.html:8938,Load,LoadEntry,8938,doc/master/RNTupleReader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8cxx_source.html,1,['Load'],['LoadEntry']
Performance,File ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 791 of file MethodPyKeras.cxx. ◆ ReadWeightsFromStream() [1/2]. virtual void TMVA::MethodPyKeras::ReadWeightsFromStream ; (; std::istream & ; ). inlinevirtual . Implements TMVA::PyMethodBase.; Definition at line 67 of file MethodPyKeras.h. ◆ ReadWeightsFromStream() [2/2]. virtual void TMVA::MethodPyKeras::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::PyMethodBase.; Definition at line 68 of file MethodPyKeras.h. ◆ ReadWeightsFromXML(). virtual void TMVA::MethodPyKeras::ReadWeightsFromXML ; (; void * ; ). inlinevirtual . Implements TMVA::PyMethodBase.; Definition at line 66 of file MethodPyKeras.h. ◆ SetupKerasModel(). void MethodPyKeras::SetupKerasModel ; (; Bool_t ; loadTrainedModel). private . Definition at line 323 of file MethodPyKeras.cxx. ◆ SetupKerasModelForEval(). void MethodPyKeras::SetupKerasModelForEval ; (; ). private . Setting up model for evaluation Add here some needed optimizations like disabling eager execution. ; Definition at line 378 of file MethodPyKeras.cxx. ◆ TestClassification(). void MethodPyKeras::TestClassification ; (; ). virtual . initialization ; Reimplemented from TMVA::MethodBase.; Definition at line 653 of file MethodPyKeras.cxx. ◆ Train(). void MethodPyKeras::Train ; (; void ; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 431 of file MethodPyKeras.cxx. ◆ UseTFKeras(). Bool_t TMVA::MethodPyKeras::UseTFKeras ; (; ); const. inline . Definition at line 80 of file MethodPyKeras.h. Member Data Documentation. ◆ fBatchSize. UInt_t TMVA::MethodPyKeras::fBatchSize {0}. private . Definition at line 85 of file MethodPyKeras.h. ◆ fContinueTraining. Bool_t TMVA::MethodPyKeras::fContinueTraining. private . Definition at line 90 of file MethodPyKeras.h. ◆ fFilenameModel. TString TMVA::MethodPyKeras::fFilenameModel. private . Definition at line 84 of file MethodPyKeras.h. ◆ fFilenameTrainedModel. TString TMVA::MethodPyKeras::f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html:36132,optimiz,optimizations,36132,doc/master/classTMVA_1_1MethodPyKeras.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html,1,['optimiz'],['optimizations']
Performance,"File on disk for the given module M. ; Definition at line 1065 of file TCling.cxx. ◆ hasParsedRootmapForLibrary(). static bool hasParsedRootmapForLibrary ; (; llvm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TStreamerInfo is created. ; Definition at line 1664 of file TCling.cxx. ◆ RegisterCxxModules(). static void RegisterCxxModules ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1183 of file TCling.cxx. ◆ RegisterPreIncludedHeaders(). static void RegisterPreIncludedHeaders ; (; cling::Interpreter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:15109,Load,LoadModules,15109,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['Load'],['LoadModules']
Performance,"File::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:172559,cache,cachefile,172559,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cachefile']
Performance,"FileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:339050,cache,cache,339050,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,FileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:10012,cache,cache,10012,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,12,['cache'],['cache']
Performance,"FileCleanup return 0 in case error. ; Definition at line 257 of file TSelEventGen.cxx. ◆ GetOutputList(). TList * TSelEventGen::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 69 of file TSelEventGen.h. ◆ Init(). void TSelEventGen::Init ; (; TTree * ; tree). overridevirtual . Reimplemented from TSelector. ◆ IsA(). TClass * TSelEventGen::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 74 of file TSelEventGen.h. ◆ Notify(). Bool_t TSelEventGen::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Print(). void TSelEventGen::Print ; (; Option_t * ; option = """"); const. overridevirtual . This method must be overridden when a class wants to print itself. ; Reimplemented from TObject.; Definition at line 486 of file TSelEventGen.cxx. ◆ Process(). Bool_t TSelEventGen::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEventGen.html:16496,load,load,16496,doc/master/classTSelEventGen.html,https://root.cern,https://root.cern/doc/master/classTSelEventGen.html,2,['load'],['load']
Performance,"FileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction actio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:212508,cache,cached,212508,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cached']
Performance,"FileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefinition TFile.h:245; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:28414,cache,cached,28414,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cached']
Performance,"FileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TClassRef fClass;  ! pointer to class ;  ; void ** fObjAddress;  ! Address of Pointer to object ;  ; bool fVirtual;  Support for polymorphism, when set classname is written with object. ;  ;  Protected Attributes inherited from TLeaf; TBranch * fBranch;  ! Pointer to supporting branch (we do not own the branch) ;  ; bool fIsRange;  (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement. ;  ; bool fIsUnsigned;  (=true if unsigned, false otherwise) ;  ; TLeaf * fLeafCount;  Pointer to Leaf count if variable length (we do not own the counter) ;  ; LeafCountValues * fLeafCountValues;  ! Cache of collection/array sizes ;  ; Int_t fLen;  Number of fixed length elements in the leaf's data. ;  ; Int_t fLenType;  Number of bytes for this data type. ;  ; Int_t fNdata;  ! Number of elements in fAddress data buffer. ;  ; Int_t fOffset;  Offset in ClonesArray object (if one) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Protected Types inherited from TLeaf; using Counts_t = std::vector< Int_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TLeaf;  TLeaf (const TLeaf &);  Copy constructor. ;  ; Int_t * GenerateOffsetArrayBase (Int_t base, Int_t events) const;  If the class supports it, generate an offset array base. ;  ; TLeaf & operator= (const TLeaf &);  Assignment operator. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafObject.html:15806,Cache,Cache,15806,doc/master/classTLeafObject.html,https://root.cern,https://root.cern/doc/master/classTLeafObject.html,1,['Cache'],['Cache']
Performance,"Files()->FindObject(rootmapNameNoLib.data());; 7269 ; 7270 return false;; 7271}; 7272 ; 7273static bool hasPrecomputedLibraryDeps(llvm::StringRef lib); 7274{; 7275 if (gCling->HasPCMForLibrary(lib.data())); 7276 return true;; 7277 ; 7278 return hasParsedRootmapForLibrary(lib);; 7279}; 7280 ; 7281////////////////////////////////////////////////////////////////////////////////; 7282/// Get the list a libraries on which the specified lib depends. The; 7283/// returned string contains as first element the lib itself.; 7284/// Returns 0 in case the lib does not exist or does not have; 7285/// any dependencies. If useDyld is true, we iterate through all available; 7286/// libraries and try to construct the dependency chain by resolving each; 7287/// symbol.; 7288 ; 7289const char* TCling::GetSharedLibDeps(const char* lib, bool useDyld/* = false*/); 7290{; 7291 if (llvm::sys::path::is_absolute(lib) && !llvm::sys::fs::exists(lib)); 7292 return nullptr;; 7293 ; 7294 if (!hasParsedRootmapForLibrary(lib)) {; 7295 llvm::SmallString<512> rootmapName(lib);; 7296 llvm::sys::path::replace_extension(rootmapName, ""rootmap"");; 7297 if (llvm::sys::fs::exists(rootmapName)) {; 7298 if (gDebug > 0); 7299 Info(""Load"", ""loading %s"", rootmapName.c_str());; 7300 gInterpreter->LoadLibraryMap(rootmapName.c_str());; 7301 }; 7302 }; 7303 ; 7304 if (hasPrecomputedLibraryDeps(lib) && useDyld) {; 7305 if (gDebug > 0); 7306 Warning(""TCling::GetSharedLibDeps"", ""Precomputed dependencies available but scanning '%s'"", lib);; 7307 }; 7308 ; 7309 if (useDyld) {; 7310 std::string libs = GetSharedLibImmediateDepsSlow(lib, GetInterpreterImpl());; 7311 if (!libs.empty()) {; 7312 fAutoLoadLibStorage.push_back(libs);; 7313 return fAutoLoadLibStorage.back().c_str();; 7314 }; 7315 }; 7316 ; 7317 if (!fMapfile || !lib || !lib[0]) {; 7318 return nullptr;; 7319 }; 7320 TString libname(lib);; 7321 Ssiz_t idx = libname.Last('.');; 7322 if (idx != kNPOS) {; 7323 libname.Remove(idx);; 7324 }; 7325 TEnvRec* rec;; 7326 TIte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:285671,Load,Load,285671,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['Load', 'loading']"
Performance,"Files->At(0);; 1512 if (!element) {; 1513 return -4;; 1514 }; 1515 }; 1516 ; 1517 // FIXME: We leak memory here, we've just lost the open file; 1518 // if we did not delete it above.; 1519 {; 1520 TDirectory::TContext ctxt;; 1521 const char *option = fGlobalRegistration ? ""READ"" : ""READ_WITHOUT_GLOBALREGISTRATION"";; 1522 fFile = TFile::Open(element->GetTitle(), option);; 1523 if (fFile && fGlobalRegistration); 1524 fFile->SetBit(kMustCleanup);; 1525 }; 1526 ; 1527 // ----- Begin of modifications by MvL; 1528 Int_t returnCode = 0;; 1529 if (!fFile || fFile->IsZombie()) {; 1530 if (fFile) {; 1531 delete fFile;; 1532 fFile = nullptr;; 1533 }; 1534 // Note: We do *not* own fTree.; 1535 fTree = nullptr;; 1536 returnCode = -3;; 1537 } else {; 1538 if (fPerfStats); 1539 fPerfStats->SetFile(fFile);; 1540 ; 1541 // Note: We do *not* own fTree after this, the file does!; 1542 fTree = dynamic_cast<TTree*>(fFile->Get(element->GetName()));; 1543 if (!fTree) {; 1544 // Now that we do not check during the addition, we need to check here!; 1545 Error(""LoadTree"", ""Cannot find tree with name %s in file %s"", element->GetName(), element->GetTitle());; 1546 delete fFile;; 1547 fFile = nullptr;; 1548 // We do not return yet so that 'fEntries' can be updated with the; 1549 // sum of the entries of all the other trees.; 1550 returnCode = -4;; 1551 } else if (!fGlobalRegistration) {; 1552 fTree->ResetBit(kMustCleanup);; 1553 }; 1554 // Propagate the IMT settings; 1555 if (fTree) {; 1556 fTree->SetImplicitMT(fIMTEnabled);; 1557 }; 1558 }; 1559 ; 1560 fTreeNumber = treenum;; 1561 // FIXME: We own fFile, we must be careful giving away a pointer to it!; 1562 // FIXME: We may set fDirectory to zero here!; 1563 fDirectory = fFile;; 1564 ; 1565 // Reuse cache from previous file (if any).; 1566 if (tpf) {; 1567 if (fFile) {; 1568 // FIXME: fTree may be zero here.; 1569 tpf->UpdateBranches(fTree);; 1570 tpf->ResetCache();; 1571 fFile->SetCacheRead(tpf, fTree);; 1572 } else {; 1573 // FIXME: One of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:55890,Load,LoadTree,55890,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19098,Cache,Cache,19098,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['Cache'],['Cache']
Performance,"Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20964,Cache,Cache,20964,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['Cache'],['Cache']
Performance,"Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21806,Cache,Cache,21806,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['Cache'],['Cache']
Performance,"Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Option_t* option = """") const; Default print for collections, calls Print(option, 1).; This will print the collection header and Print() methods of; all the collection entries. If you want to override Print() for a collection class, first; see if you can accomplish it by overriding the following protected; methods:; void PrintCollectionHeader(Option_t* option) const;; const char* GetCollectionEntryName(TObject* entry) const;; void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const;; Otherwise override the Print(Option_t *option, Int_t); variant. Remember to declare:; using TCollection::Print;; somewhere close to the method declaration. void Print(Option_t* option, Int_t recurse) const; Print the collection header and its elements. If recurse is n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCollection.html:10924,perform,perform,10924,root/html604/TCollection.html,https://root.cern,https://root.cern/root/html604/TCollection.html,1,['perform'],['perform']
Performance,"Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Option_t* option = """") const; Defualt print for collections, calls Print(option, 1).; This will print the collection header and Print() methods of; all the collection entries. If you want to override Print() for a collection class, first; see if you can accomplish it by overriding the following protected; methods:; void PrintCollectionHeader(Option_t* option) const;; const char* GetCollectionEntryName(TObject* entry) const;; void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const;; Otherwise override the Print(Option_t *option, Int_t); variant. Remember to declare:; using TCollection::Print;; somewhere close to the method declaration. void Print(Option_t* option, Int_t recurse) const; Print the collection header and its elements. If recurse is n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollection.html:10117,perform,perform,10117,root/html526/TCollection.html,https://root.cern,https://root.cern/root/html526/TCollection.html,6,['perform'],['perform']
Performance,"FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:40501,cache,cache,40501,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ IntOperMode. enum RooRealIntegral::IntOperMode. protected . EnumeratorHybrid ; Analytic ; PassThrough . Definition at line 92 of file RooRealIntegral.h. Constructor & Destructor Documentation. ◆ RooRealIntegral() [1/3]. RooRealIntegral::RooRealIntegral ; (; ). Definition at line 282 of file RooRealIntegral.cxx. ◆ RooRealIntegral() [2/3]. RooRealIntegral::RooRealIntegral ; (; const char * ; name, . const char * ; title, . const RooAbsReal & ; function, . const RooArgSet & ; depList, . const RooArgSet * ; funcNormSet = nullptr, . const RooNumIntConfig * ; config = nullptr, . const char * ; rangeName = nullptr . ). Construct integral of 'function' over observables in 'depList' in range 'rangeName' with normalization observables 'funcNormSet' (for p.d.f.s). ; In the integral is performed to the maximum extent possible the internal (analytical) integrals advertised by function. The other integrations are performed numerically. The optional config object prescribes how these numeric integrations are configured.; \Note If pdf component selection was globally overridden to always include all components (either with RooAbsReal::globalSelectComp(bool) or a RooAbsReal::GlobalSelectComponentRAII), then any created integral will ignore component selections during its lifetime. This is especially useful when creating normalization or projection integrals. ; Definition at line 300 of file RooRealIntegral.cxx. ◆ RooRealIntegral() [3/3]. RooRealIntegral::RooRealIntegral ; (; const RooRealIntegral & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 710 of file RooRealIntegral.cxx. ◆ ~RooRealIntegral(). RooRealIntegral::~RooRealIntegral ; (; ). override . Definition at line 739 of file RooRealIntegral.cxx. Member Function Documentation. ◆ actualFuncNormSet(). RooArgSet const * RooRealIntegral::actualFuncNormSet ; (; ); const. inlineprotected . Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:64681,perform,performed,64681,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['perform'],['performed']
Performance,"Fit are; 104 specialized method for least-square and also likelihood minimizations. They require then that the given function implements in addition; 105 the `ROOT::Math::FitMethodFunction` interface.; 106 - The interface for setting the initial values for the function variables (which are the parameters in; 107 of the model function in case of solving for fitting) and specifying their limits.; 108 - The interface to set and retrieve basic minimization parameters. These parameter are controlled by the class `ROOT::Math::MinimizerOptions`.; 109 When no parameters are specified the default ones are used. Specific Minimizer options can also be passed via the `MinimizerOptions` class.; 110 For the list of the available option parameter one must look at the documentation of the corresponding derived class.; 111 - The interface to retrieve the result of minimization ( minimum X values, function value, gradient, error on the minimum, etc...); 112 - The interface to perform a Scan, Hesse or a Contour plot (for the minimizers that support this, i.e. Minuit and Minuit2); 113 ; 114 An example on how to use this interface is the tutorial NumericalMinimization.C in the tutorials/fit directory.; 115 ; 116 @ingroup MultiMin; 117*/; 118 ; 119class Minimizer {; 120 ; 121public:; 122 ; 123 /// Default constructor.; 124 Minimizer () {}; 125 ; 126 /// Destructor (no operations).; 127 virtual ~Minimizer () {}; 128 ; 129 // usually copying is non trivial, so we delete this; 130 Minimizer(Minimizer const&) = delete;; 131 Minimizer &operator=(Minimizer const&) = delete;; 132 Minimizer(Minimizer &&) = delete;; 133 Minimizer &operator=(Minimizer &&) = delete;; 134 ; 135 /// reset for consecutive minimization - implement if needed; 136 virtual void Clear() {}; 137 ; 138 /// set the function to minimize; 139 virtual void SetFunction(const ROOT::Math::IMultiGenFunction & func) = 0;; 140 ; 141 /// set the function implementing Hessian computation (re-implemented by Minimizer using it); 142 virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:5055,perform,perform,5055,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricFunctionMultiDim.html:2987,cache,cached,2987,root/html528/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,"Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricFunctionMultiDim.html:2989,cache,cached,2989,root/html532/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,"Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:38809,perform,performed,38809,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['perform'],['performed']
Performance,"Fit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf212_plottingInRanges_blindingDefinition rf212_plottingInRanges_blinding.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [20,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_right' created with bounds [20,30]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(expo_over_expo_Int[x|left,right]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_expo_over_expo_Int[x|left,right]_expoData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; Now plotting with unique normalisation for each slice.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'full', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right', curve is normalized to data in given range; ; ; Now plotting with correct norm ranges:; [#1] INFO:Plo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html:7711,optimiz,optimization,7711,doc/master/rf212__plottingInRanges__blinding_8C.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html,2,['optimiz'],['optimization']
Performance,"FitMethodRuleFit(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodRuleFitMethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodRuleFit.html:9783,Optimiz,OptimizeTuningParameters,9783,root/html530/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodRuleFit.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"FitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf503_wspacereadDefinition rf503_wspaceread.py:1; ; 0x559b3dca42c0 RooAddPdf::model = 0.9/1 [Auto,Clean] ; 0x559b3deb0210/V- RooChebychev::bkg = 0.8 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3c2d1250/V- RooRealVar::a0 = 0.5; 0x559b3c353b60/V- RooRealVar::a1 = 0.2; 0x559b3df69400/V- RooRealVar::bkgfrac = 0.5; 0x559b3defe0a0/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x559b3ded9e50/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3d77d310/V- RooRealVar::mean = 5; 0x559b3d6274d0/V- RooRealVar::sigma1 = 0.5; 0x559b3bf56940/V- RooRealVar::sig1frac = 0.8; 0x559b3def8000/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3d77d310/V- RooRealVar::mean = 5; 0x559b3d7146b0/V- RooRealVar::sigma2 = 1; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf503_wspaceread.C. tutorialsroofitrf503_wspaceread.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf503__wspaceread_8C.html:5895,optimiz,optimization,5895,doc/master/rf503__wspaceread_8C.html,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8C.html,2,['optimiz'],['optimization']
Performance,"Fixed(). virtual Bool_t TVirtualFitter::IsFixed ; (; Int_t ; ipar); const. pure virtual . Implemented in TBackCompFitter, TFumili, TFitter, and TLinearFitter. ◆ operator=(). TVirtualFitter & TVirtualFitter::operator= ; (; const TVirtualFitter & ; tvf). protected . assignment operator ; Definition at line 116 of file TVirtualFitter.cxx. ◆ PrintResults(). virtual void TVirtualFitter::PrintResults ; (; Int_t ; level, . Double_t ; amin . ); const. pure virtual . Implemented in TFumili, TBackCompFitter, TFitter, and TLinearFitter. ◆ ReleaseParameter(). virtual void TVirtualFitter::ReleaseParameter ; (; Int_t ; ipar). pure virtual . Implemented in TBackCompFitter, TFumili, TFitter, and TLinearFitter. ◆ SetCache(). Double_t * TVirtualFitter::SetCache ; (; Int_t ; npoints, . Int_t ; psize . ). virtual . Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point. ; if (npoints*psize > fCacheSize) the existing cache is deleted and a new array is created. The function returns a pointer to the cache ; Definition at line 281 of file TVirtualFitter.cxx. ◆ SetDefaultFitter(). void TVirtualFitter::SetDefaultFitter ; (; const char * ; name = """"). static . static: set name of default fitter ; Definition at line 245 of file TVirtualFitter.cxx. ◆ SetErrorDef(). void TVirtualFitter::SetErrorDef ; (; Double_t ; errdef = 1). static . static: Set the Error Definition (default=1) For Minuit this is the value passed with the ""SET ERR"" command (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html) ; Definition at line 308 of file TVirtualFitter.cxx. ◆ SetFCN(). void TVirtualFitter::SetFCN ; (; void(*)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t) ; fcn). virtual . To set the address of the minimization objective function called by the native compiler (see function below when called by CINT) ; Reimplemented in TBackCompFitter, and TFitter.; Definition at line 267 of file TVirtualFitter.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFitter.html:26032,cache,cache,26032,doc/master/classTVirtualFitter.html,https://root.cern,https://root.cern/doc/master/classTVirtualFitter.html,1,['cache'],['cache']
Performance,"FoamMethodPDEFoam(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodPDEFoamMethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); TMVA::PDEFoam*ReadClonedFoamFromFile(TFile*, const TString&); voidReadFoamsFromFile(); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDEFoam.html:9805,Optimiz,OptimizeTuningParameters,9805,root/html530/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDEFoam.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"Folders and Tasks”). You can build a folder structure and create a tree with branches for each of the sub-folders:; TTree folder_tree(""MyFolderTree"",""/MyFolder"");; The second argument ""/MyFolder""is the top folder, and the “/” signals the TTree constructor that this is a folder not just the title. You fill the tree by placing the data into the folder structure and calling TTree::Fill.; 12.7.2 Tree and TRef Objects; MyTree->BranchRef();; This call requests the construction of an optional branch supporting table of references (TRefTable). This branch (TBranchRef) will keep all the information needed to find the branches containing referenced objects at each Tree::Fill, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via TTree::Write for example), the branch is saved, keeping the information with the pointers to the branches having referenced objects. Enabling this optional table, allow TTree::Draw to automatically load the branches needed to dereference a TRef (or TRefArray) object.; 12.7.3 Autosave; Autosave gives the option to save all branch buffers every n byte. We recommend using Autosave for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last Autosave. To set the number of bytes between Autosave you can use the TTree::SetAutosave() method. You can also call TTree::Autosave in the acquisition loop every nentry.; 12.7.4 Trees with Circular Buffers; When a TTree is memory resident, you set it up so that it retains retain only the last few entries. For example, this can be very useful for monitoring purpose.; void TTree::SetCircular(Long64_t maxEntries);; where maxEntries is the maximum number of entries to be kept in the buffers. When the number of entries exceeds this value, the first entries in the Tree are deleted and the buffers used again. An example of a script using a circular buffer is shown below:; void circular() {; gR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:531926,load,load,531926,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"For citation information, please visit: http://tmva.sf.net/citeTMVA.html; <HEADER> Factory : Booking method: BDTG_fold2; : ; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; : Regression Loss Function: Huber; : Training 500 Decision Trees ... patience please; : Elapsed time for training with 5000 events: 1.31 sec ; : Dataset[datasetcvreg] : Create results for training; : Dataset[datasetcvreg] : Evaluation of BDTG_fold2 on training sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 5000 events: 0.209 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; : Creating xml weight file: datasetcvreg/weights/TMVACrossValidationRegression_BDTG_fold2.weights.xml; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG_fold2 for Regression performance; : ; : Dataset[datasetcvreg] : Create results for testing; : Dataset[datasetcvreg] : Evaluation of BDTG_fold2 on testing sample; : Dataset[datasetcvreg] : Elapsed time for evaluation of 4999 events: 0.209 sec ; : Create variable histograms; : Create regression target histograms; : Create regression average deviation; : Results created; <HEADER> Factory : Evaluate all methods; : Evaluate regression method: BDTG_fold2; : TestRegression (testing); : Calculate regression for all events; : Elapsed time for evaluation of 4999 events: 0.208 sec ; : TestRegression (training); : Calculate regression for all events; : Elapsed time for evaluation of 5000 events: 0.208 sec ; : ; : Evaluation results ranked by smallest RMS on test sample:; : (""Bias"" quotes the mean deviation of the regression from true target.; : ""MutInf"" is the ""Mutual Information"" between regression and target.; : Indicated by ""_T"" are the corresponding ""truncated"" quantities ob-; : tained when removing events deviating more than 2sigma from average.); : -------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:7218,perform,performance,7218,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['perform'],['performance']
Performance,"For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ; Definition at line 43 of file RooFFTConvPdf.h. ◆ bufferStrategy(). BufStrat RooFFTConvPdf::bufferStrategy ; (; ); const. inline . Return the strategy currently used to fill the buffer: 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range 'Flat' means that the buffer is filled with the p.d.f. ; value at the boundary of the observable range 'Mirror' means that the buffer is filled with a mirror image of the p.d.f. around the convolution observable boundary ; Definition at line 52 of file RooFFTConvPdf.h. ◆ cacheObservables(). const RooArgSet & RooFFTConvPdf::cacheObservables ; (; ); const. inline . Definition at line 39 of file RooFFTConvPdf.h. ◆ calcParams(). void RooFFTConvPdf::calcParams ; (; ). protected . (Re)calculate effective parameters of this p.d.f. ; Definition at line 957 of file RooFFTConvPdf.cxx. ◆ Class(). static TClass * RooFFTConvPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFFTConvPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFFTConvPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 124 of file RooFFTConvPdf.h. ◆ clone(). TObject * RooFFTConvPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 34 of file RooFFTConvPdf.h. ◆ createCache(). RooFFTConvPdf::PdfCacheElem * RooFFTConvPdf::createCache ; (; const RooArgSet * ; nset); const. overrideprotecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:88726,cache,cacheObservables,88726,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cacheObservables']
Performance,"Formula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNtuple.html:10810,Load,LoadTree,10810,root/html528/TNtuple.html,https://root.cern,https://root.cern/root/html528/TNtuple.html,2,['Load'],['LoadTree']
Performance,"Formula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNtuple.html:10932,Load,LoadTree,10932,root/html530/TNtuple.html,https://root.cern,https://root.cern/root/html530/TNtuple.html,6,['Load'],['LoadTree']
Performance,"Formula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tTTree::LoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:11297,Load,LoadTree,11297,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,4,['Load'],['LoadTree']
Performance,"Formula.h. ◆ fLeaves. TObjArray TTreeFormula::fLeaves. protected . ! List of leaf used in this formula. ; Definition at line 103 of file TTreeFormula.h. ◆ fLookupType. Int_t* TTreeFormula::fLookupType. protected . [fNindex] Array indicating how each leaf should be looked-up ; Definition at line 102 of file TTreeFormula.h. ◆ fManager. TTreeFormulaManager* TTreeFormula::fManager. protected . ! The dimension coordinator. ; Definition at line 124 of file TTreeFormula.h. ◆ fMethods. TObjArray TTreeFormula::fMethods. protected . ! List of leaf method calls ; Definition at line 105 of file TTreeFormula.h. ◆ fMultiplicity. Int_t TTreeFormula::fMultiplicity. protected . Indicator of the variability of the formula. ; Definition at line 100 of file TTreeFormula.h. ◆ fNcodes. Int_t TTreeFormula::fNcodes. protected . Number of leaves referenced in formula. ; Definition at line 98 of file TTreeFormula.h. ◆ fNdata. Int_t TTreeFormula::fNdata[kMAXCODES]. protected . ! This caches the physical number of element in the leaf or data member. ; Definition at line 97 of file TTreeFormula.h. ◆ fNdimensions. Int_t TTreeFormula::fNdimensions[kMAXCODES]. protected . Number of array dimensions in each leaf. ; Definition at line 113 of file TTreeFormula.h. ◆ fNeedLoading. bool TTreeFormula::fNeedLoading. protected . ! If true, the current entry has not been loaded yet. ; Definition at line 111 of file TTreeFormula.h. ◆ fNindex. Int_t TTreeFormula::fNindex. protected . Size of fIndex. ; Definition at line 101 of file TTreeFormula.h. ◆ fQuickLoad. bool TTreeFormula::fQuickLoad. protected . ! If true, branch GetEntry is only called when the entry number changes. ; Definition at line 110 of file TTreeFormula.h. ◆ fRealInstanceCache. RealInstanceCache TTreeFormula::fRealInstanceCache. protected . ! Cache accelerating the GetRealInstance function ; Definition at line 132 of file TTreeFormula.h. ◆ fTree. TTree* TTreeFormula::fTree. protected . ! Pointer to Tree ; Definition at line 95 of file TTreeFor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:54876,cache,caches,54876,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['cache'],['caches']
Performance,"ForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmulatedProxystatic TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)Generate emulated collection proxy for a given class.Definition TCollectionProxyFactory.cxx:63; TCollectionProxyFactory::GenEmulatedClassStreamerstatic TClassStreamer * GenEmulatedClassStreamer(const char *class_name, Bool_t silent)Generate emulated class streamer for a given collection class.Definition TCollectionProxyFactory.cxx:71; TCollectionProxyFactory::GenExplicitProxystatic Proxy_t * GenExplicitProxy(const ::ROOT::TCollectionProxyInfo &info, TClass *cl)Generate proxy from static functions.Definition TCollectionProxyFactory.cxx:90; TCollectionProxyFactory::GenExplicitClassStreamerstatic TClassStreamer * GenExplicitCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255893,load,load,255893,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['load']
Performance,"Frame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; virtual intIsVisited(const char*); Bool_tTObject::IsZombie() const; virtual Bool_tItemLayout(); virtual voidTGView::Layout(); TGString*ListTokens(TGHtmlElement* p, TGHtmlElement* pEnd); virtual TImage*LoadImage(const char* uri, int w = 0, int h = 0); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseDown(const char* uri)SIGNAL ; virtual voidMouseOver(const char* uri)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); voidMoveVertically(TGHtmlElement* p, TGHtmlElement* pLast, int dy); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static voidTObject::operator delete(void* ptr); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:11526,Load,LoadImage,11526,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,1,['Load'],['LoadImage']
Performance,"Frame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; virtual intIsVisited(const char*); Bool_tTObject::IsZombie() const; virtual Bool_tItemLayout(); virtual voidTGView::Layout(); TGString*ListTokens(TGHtmlElement* p, TGHtmlElement* pEnd); virtual TImage*LoadImage(const char* uri, int w = 0, int h = 0); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseDown(const char* uri)SIGNAL ; virtual voidMouseOver(const char* uri)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); voidMoveVertically(TGHtmlElement* p, TGHtmlElement* pLast, int dy); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGHtml.html:11526,Load,LoadImage,11526,root/html530/TGHtml.html,https://root.cern,https://root.cern/root/html530/TGHtml.html,3,['Load'],['LoadImage']
Performance,"Frame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; virtual intIsVisited(const char*); Bool_tTObject::IsZombie() const; virtual Bool_tItemLayout(); virtual voidTGView::Layout(); TGString*ListTokens(TGHtmlElement* p, TGHtmlElement* pEnd); virtual TImage*LoadImage(const char* uri, int w = 0, int h = 0); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseDown(const char* uri)SIGNAL ; virtual voidMouseOver(const char* uri)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); voidMoveVertically(TGHtmlElement* p, TGHtmlElement* pLast, int dy); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:11473,Load,LoadImage,11473,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,2,['Load'],['LoadImage']
Performance,"Frame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrd2Editor.html:22081,Perform,Perform,22081,root/html604/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html604/TGeoTrd2Editor.html,1,['Perform'],['Perform']
Performance,"Frame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd2Editor.html:22081,Perform,Perform,22081,root/html602/TGeoTrd2Editor.html,https://root.cern,https://root.cern/root/html602/TGeoTrd2Editor.html,1,['Perform'],['Perform']
Performance,"Frame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600); TGTextEditor constructor with file name as first argument. TGTextEditor(TMacro* macro, const TGWindow* p = 0, UInt_t w = 0, UInt_t h = 0); TGTextEditor constructor with pointer to a TMacro as first argument. ~TGTextEditor(); TGTextEditor destructor. void DeleteWindow(); Delete TGTextEditor Window. void Build(); Build TGTextEditor widget. void DataDropped(char* fname); Update file informations when receiving the signal; DataDropped from TGTextEdit widget. void LoadFile(char* fname = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary file. void InterruptMacro(); Interrupt execution of a macro. void About(); Display ROOT s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEditor.html:27562,Load,LoadFile,27562,root/html528/TGTextEditor.html,https://root.cern,https://root.cern/root/html528/TGTextEditor.html,6,['Load'],"['Load', 'LoadFile']"
Performance,"Func, RooHistPdf, RooLinearCombination, RooLinearVar, RooMoment, RooMultiVarGaussian, RooNumConvolution, RooNumConvPdf, RooNumRunningInt, RooPolyFunc, RooPolyVar, RooProdPdf, RooProduct, RooProfileLL, RooProjectedPdf, RooPullVar, RooRangeBoolean, RooRatio, RooRealIntegral, RooRealMPFE, RooRealSumFunc, RooRealSumPdf, RooRealVar, RooRecursiveFraction, RooSecondMoment, RooSimultaneous, RooTruthModel, RooWrapperPdf, RooGenProdProj, RooNormalizedPdf, RooFixedProdPdf, RooHypatia2, RooLegendre, RooNonCentralChiSquare, RooSpHarmonic, RooStats::Heaviside, ProgressMonitor, xRooProjectedPdf, and PdfWrapper. ◆ fillDataHist(). RooDataHist * RooAbsReal::fillDataHist ; (; RooDataHist * ; hist, . const RooArgSet * ; normSet, . double ; scaleFactor, . bool ; correctForBinSize = false, . bool ; showProgress = false . ); const. Fill a RooDataHist with values sampled from this function at the bin centers. ; If extendedMode is true, the p.d.f. values is multiplied by the number of expected events in each bin; An optional scaling by a given scaleFactor can be performed. Returns a pointer to the input RooDataHist, or zero in case of an error.; If correctForBinSize is true the RooDataHist is filled with the functions density (function value times the bin volume) rather than function value.; If showProgress is true a process indicator is printed on stdout in steps of one percent, which is mostly useful for the sampling of expensive functions such as likelihoods ; Definition at line 1152 of file RooAbsReal.cxx. ◆ fillHistogram(). TH1 * RooAbsReal::fillHistogram ; (; TH1 * ; hist, . const RooArgList & ; plotVars, . double ; scaleFactor = 1, . const RooArgSet * ; projectedVars = nullptr, . bool ; scaleForDensity = true, . const RooArgSet * ; condObs = nullptr, . bool ; setError = true . ); const. Fill the ROOT histogram 'hist' with values sampled from this function at the bin centers. ; Our value is calculated by first integrating out any variables in projectedVars and then scaling the result ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:103433,perform,performed,103433,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"FuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 1659////////////////////////////////////////////////////////////////////////////////; 1660/// Internal routine returning, and creating if necessary, the list; 1661/// of global function.; 1662 ; 1663TListOfFunctions *TROOT::GetGlobalFunctions(); 1664{; 1665 if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(nullptr);; 1666 return fGlobalFunctions;; 1667}; 1668 ; 1669///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:63129,load,load,63129,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"Function*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name) const; TCollection*GetListOfFunctions() const; TCollection*GetListOfFunctionTemplates(); TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:7319,load,load,7319,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"FunctionMultiDim>::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(const double* x, const double* p) const. double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricFunctionMultiDim.html:3021,cache,cached,3021,root/html526/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,"FunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimTemplGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:44795,perform,performing,44795,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['perform'],['performing']
Performance,"FunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:603; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3465; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:400231,Load,LoadClassstatic,400231,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['Load'],"['LoadClass', 'LoadClassstatic']"
Performance,"Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return the observables to be cached given the normalization set nset. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters on which the cache depends given normalization set nset. ;  ; void calcParams ();  (Re)calculate effective parameters of this p.d.f. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Return specialized cache subclass for FFT calculations. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the contents of the cache the FFT convolution output. ;  ; void fillCacheSlice (FFTCacheElem &cache, const RooArgSet &slicePosition) const;  Fill a slice of cachePdf with the output of the FFT convolution calculation. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create appropriate generator context for this convolution. ;  ; TString histNameSuffix () const override;  Suffix for cache histogram (added in addition to suffix for cache name) ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ;  ; RooAbsArg & pdfObservable (RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:68590,cache,cache,68590,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t * fAllocSize;  number of known ProcessIDs ;  ; Int_t fDefaultSize;  current parent ID in fParents (latest call to SetParent) ;  ; std::vector< Int_t > fMapPIDtoInternal;  ; Int_t * fN;  [fNumPIDs] allocated size of array fParentIDs for each ProcessID ;  ; Int_t fNumPIDs;  ; TObject * fOwner;  ; Int_t fParentID;  [fNumPIDs][fAllocSize] array of Parent IDs ;  ; Int_t ** fParentIDs;  [fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID ;  ; TObjArray * fParents;  ; std::vector< std::string > fProcessGUIDs;  ; Int_t fSize;  TProcessID the current uid is referring to. ;  ; UInt_t fUID;  default size for a new PID array ;  ; TProcessID * fUIDContext;  Current uid (set by TRef::GetObject) ;  . Static Protected Attributes; static TRefTable * fgRefTable = nullptr;  cache of pid to index in fProcessGUIDs ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TRefTable.h>. Inheritance diagram for TRefTable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TRefTable::EStatusBits. EnumeratorkHaveWarnedReadingOld . Definition at line 62 of file TRefTable.h. Constructor & Destructor Documentation. ◆ TRefTable() [1/3]. TRefTable::TRefTable ; (; ). Default constructor for I/O. ; Definition at line 52 of file TRefTable.cxx. ◆ TRefTable() [2/3]. TRefTable::TRefTable ; (; TObject * ; owner, . Int_t ; size . ). Create a TRefTable with initial size. ; Definition at line 61 of file TRefTable.cxx. ◆ ~TRefTable(). TRefTable::~TRefTable ; (; ). virtual . Destructor. ; Definition at line 71 of file TRefTable.cxx. ◆ TRefTable() [3/3]. TRefTable::TRefTable ; (; const TRefTabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefTable.html:14078,cache,cache,14078,doc/master/classTRefTable.html,https://root.cern,https://root.cern/doc/master/classTRefTable.html,1,['cache'],['cache']
Performance,"Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TString _rangeName;  ; RooRealProxy _x;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRangeBoolean.html:55293,Cache,Cache,55293,doc/master/classRooRangeBoolean.html,https://root.cern,https://root.cern/doc/master/classRooRangeBoolean.html,1,['Cache'],['Cache']
Performance,"Functions |; Private Attributes |; List of all members ; TMVA::MethodCuts Class ReferenceTMVA. ; Multivariate optimisation of signal efficiency for given background efficiency, applying rectangular minimum and maximum requirements. ; Also implemented is a ""decorrelate/diagonalized cuts approach"", which improves over the uncorrelated cuts approach by transforming linearly the input variables into a diagonal space, using the square-root of the covariance matrix.; Other optimisation criteria, such as maximising the signal significance- squared, \( \frac{S^2}{(S+B)} \), with S and B being the signal and background yields, correspond to a particular point in the optimised background rejection versus signal efficiency curve. This working point requires the knowledge of the expected yields, which is not the case in general. Note also that for rare signals, Poissonian statistics should be used, which modifies the significance criterion.; The rectangular cut of a volume in the variable space is performed using a binary tree to sort the training events. This provides a significant reduction in computing time (up to several orders of magnitudes, depending on the complexity of the problem at hand).; Technically, optimisation is achieved in TMVA by two methods:. Monte Carlo generation using uniform priors for the lower cut value, and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample. The GA is configurable by many external settings through the option string. For difficult cases (such as many variables), some tuning may be necessary to achieve satisfying results. Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown superior results, and often failed due to convergence at local minima.; The tests we have performed so far showed that in generic applications, the GA is superior to MC sampling, and hence GA is the default method. It is worthwhile trying both anyway.; Decorrelated (or ""diagonali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:1298,perform,performed,1298,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['perform'],['performed']
Performance,Functions* TROOT::fGlobalFunctions. protected . List of global functions. ; Definition at line 144 of file TROOT.h. ◆ fGlobals. TListOfDataMembers* TROOT::fGlobals. protected . List of global variables. ; Definition at line 143 of file TROOT.h. ◆ fgRootInit. Bool_t TROOT::fgRootInit = kFALSE. staticprivate . Singleton initialization flag. ; Definition at line 103 of file TROOT.h. ◆ fInterpreter. TInterpreter* TROOT::fInterpreter. protected . Command interpreter. ; Definition at line 125 of file TROOT.h. ◆ fInterrupt. Bool_t TROOT::fInterrupt. protected . True if macro should be interrupted. ; Definition at line 134 of file TROOT.h. ◆ fIsWebDisplay. Bool_t TROOT::fIsWebDisplay. protected . True if session uses web widgets. ; Definition at line 128 of file TROOT.h. ◆ fIsWebDisplayBatch. Bool_t TROOT::fIsWebDisplayBatch. protected . True if web widgets are not displayed. ; Definition at line 129 of file TROOT.h. ◆ fLineIsProcessing. Int_t TROOT::fLineIsProcessing. private . To synchronize multi-threads. ; Definition at line 100 of file TROOT.h. ◆ fMappedFiles. TSeqCollection* TROOT::fMappedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:85502,multi-thread,multi-threads,85502,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['multi-thread'],['multi-threads']
Performance,"Functions.cxx. ◆ IndexOf(). Int_t TListOfFunctions::IndexOf ; (; const TObject * ; obj); const. overridevirtual . Return index of object in collection. ; Returns -1 when object not found. Uses member IsEqual() to find object. ; Reimplemented from TSeqCollection.; Definition at line 532 of file TListOfFunctions.cxx. ◆ IsA(). TClass * TListOfFunctions::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 102 of file TListOfFunctions.h. ◆ Last(). TObject * TListOfFunctions::Last ; (; ); const. overridevirtual . Return the last object in the list. Returns 0 when list is empty. ; Reimplemented from TList.; Definition at line 507 of file TListOfFunctions.cxx. ◆ LastLink(). TObjLink * TListOfFunctions::LastLink ; (; ); const. overridevirtual . Reimplemented from TList.; Definition at line 515 of file TListOfFunctions.cxx. ◆ Load(). void TListOfFunctions::Load ; (; ). Load all the functions known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 374 of file TListOfFunctions.cxx. ◆ MakeIterator(). TIterator * TListOfFunctions::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 451 of file TListOfFunctions.cxx. ◆ MapObject(). void TListOfFunctions::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 51 of file TListOfFunctions.cxx. ◆ operator=(). TListOfFunctions & TListOfFunctions::operator= ; (; const TListOfFunctions & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctions::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:32088,Load,Load,32088,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['Load'],['Load']
Performance,"G(y) \). In this construction, \( F \) is only normalised w.r.t \( x\), and \( G \) is normalised w.r.t \( y \). The product in this construction is properly normalised.; If exactly one of the component PDFs supports extended likelihood fits, the product will also be usable in extended mode, returning the number of expected events from the extendable component PDF. The extendable component does not have to appear in any specific place in the list. PyROOT; RooProdPdf() constructor takes a RooCmdArg as argument also supports keyword arguments. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; model = ROOT.RooProdPdf(; ""model"", ""model"", ROOT.RooArgSet(shapePdf), ROOT.RooFit.Conditional(ROOT.RooArgSet(effPdf), ROOT.RooArgSet(cut)); ); ; # With keyword arguments:; model = ROOT.RooProdPdf(; ""model"", ""model"", ROOT.RooArgSet(shapePdf), Conditional=(ROOT.RooArgSet(effPdf), ROOT.RooArgSet(cut)); ). Definition at line 33 of file RooProdPdf.h. Classes; class  CacheElem;  . Public Member Functions;  RooProdPdf ();  Default constructor. ;  ;  RooProdPdf (const char *name, const char *title, const RooArgList &pdfList, double cutOff=0.0);  Constructor from a list of PDFs. ;  ;  RooProdPdf (const char *name, const char *title, const RooArgSet &fullPdfSet, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Constructor from named argument list. ;  ;  RooProdPdf (const char *name, const char *title, const RooArgSet &fullPdfSet, const RooLinkedList &cmdArgList);  Internal constructor from list of named arguments. ;  ;  RooProdPdf (const char *name, const char *title, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Constructor from named a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:1815,Cache,CacheElem,1815,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['Cache'],['CacheElem']
Performance,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMaterialEditor.html:21413,Perform,Perform,21413,root/html528/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html528/TGeoMaterialEditor.html,1,['Perform'],['Perform']
Performance,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoMaterialEditor.html:21513,Perform,Perform,21513,root/html530/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html530/TGeoMaterialEditor.html,1,['Perform'],['Perform']
Performance,"GC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMaterialEditor.h 32718 2010-03-23 15:58:34Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoMaterialEditor.html:21513,Perform,Perform,21513,root/html532/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html532/TGeoMaterialEditor.html,1,['Perform'],['Perform']
Performance,"GExpModel, RooHistConstraint, RooIntegralMorph, RooJeffreysPrior, RooJohnson, RooKeysPdf, RooLandau, RooLegacyExpPoly, RooLognormal, RooMomentMorph, RooNDKeysPdf, RooNonCPEigenDecay, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooPowerSum, RooTFnPdfBinding, RooUniform, RooVoigtian, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooCachedPdf, RooEfficiency, RooEffProd, RooExtendedTerm, RooExtendPdf, RooFFTConvPdf, RooGenericPdf, RooHistPdf, RooMultiVarGaussian, RooNumConvPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooResolutionModel, RooSimultaneous, RooTruthModel, RooWrapperPdf, and RooNonCentralChiSquare. ◆ StreamerNVirtual(). void RooAbsPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 351 of file RooAbsPdf.h. ◆ syncNormalization(). bool RooAbsPdf::syncNormalization ; (; const RooArgSet * ; nset, . bool ; adjustProxies = true . ); const. protectedvirtual . Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ; If not, the cached normalization integral (if any) is deleted and a new integral is constructed for use with 'nset'. Elements in 'nset' can be discrete and real, but must be lvalues.; For functions that declare to be self-normalized by overloading the selfNormalized() function, a unit normalization is always constructed. ; Definition at line 481 of file RooAbsPdf.cxx. ◆ traceEvalPdf(). bool RooAbsPdf::traceEvalPdf ; (; double ; value); const. private . Check that passed value is positive and not 'not-a-number'. ; If not, print an error, until the error counter reaches its set maximum. ; Definition at line 384 of file RooAbsPdf.cxx. ◆ verboseEval() [1/2]. Int_t RooAbsPdf::verboseEval ; (; ). static . Return global level of verbosity for p.d.f. evaluations. ; Definition at line 2418 of file RooAbsPdf.cxx. ◆ verboseEval() [2/2]. void RooAbsPdf::verboseEval ; (; Int_t ; stat). static . Change global level of verbosity for p.d.f. ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:156126,cache,cached,156126,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['cache'],['cached']
Performance,"GFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1Editor.html:21138,Perform,Perform,21138,root/html534/TGeoTrd1Editor.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1Editor.html,1,['Perform'],['Perform']
Performance,"GFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMaterialEditor.html:21532,Perform,Perform,21532,root/html534/TGeoMaterialEditor.html,https://root.cern,https://root.cern/root/html534/TGeoMaterialEditor.html,1,['Perform'],['Perform']
Performance,"GLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTEveTrackGL::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTEveTrackGL::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackProjectedGL.html:1887,cache,cached,1887,root/html528/TEveTrackProjectedGL.html,https://root.cern,https://root.cern/root/html528/TEveTrackProjectedGL.html,3,['cache'],['cached']
Performance,"GLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; TEvePolygonSetProjectedGL&operator=(const TEvePolygonSetProjectedGL&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TEvePolygonSetProjectedGL(); TEvePolygonSetProjectedGL(const TEvePolygonSetProjectedGL&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePolygonSetProjectedGL.html:1963,cache,cached,1963,root/html602/TEvePolygonSetProjectedGL.html,https://root.cern,https://root.cern/root/html602/TEvePolygonSetProjectedGL.html,2,['cache'],['cached']
Performance,"GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 9.46654 L(-10 - 10) ""x""; 2) y = 0.0174204 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; 1) RooRealVar:: y = 0.0106407; 2) RooRealVar:: x = -0.79919; 1) RooRealVar:: x = 0.0106407; 2) RooRealVar:: y = -0.79919; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[y,x] = 64 entries; ; -----------------------; Reading data from ASCII; ; Original data, line 20:; ; Read-back data, line 20:; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:6944,load,loadValues,6944,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['load'],['loadValues']
Performance,"GRAD command. ;  ; virtual void mnhelp (const char *command="""");  interface to Minuit help ;  ; virtual void mnhelp (TString comd);  HELP routine for MINUIT interactive commands. ;  ; virtual void mnhes1 ();  Calculate first derivatives (GRD) and uncertainties (DGRD) ;  ; virtual void mnhess ();  Calculates the full second-derivative matrix of FCN. ;  ; virtual void mnimpr ();  Attempts to improve on a good local minimum. ;  ; virtual void mninex (Double_t *pint);  Transforms from internal coordinates (PINT) to external (U) ;  ; virtual void mninit (Int_t i1, Int_t i2, Int_t i3);  Main initialization member function for MINUIT. ;  ; virtual void mnlims ();  Interprets the SET LIM command, to reset the parameter limits. ;  ; virtual void mnline (Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler);  Perform a line search from position START. ;  ; virtual void mnmatu (Int_t kode);  Prints the covariance matrix v when KODE=1. ;  ; virtual void mnmigr ();  Performs a local function minimization. ;  ; virtual void mnmnos ();  Performs a MINOS error analysis. ;  ; virtual void mnmnot (Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi);  Performs a MINOS error analysis on one parameter. ;  ; virtual void mnparm (Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg);  Implements one parameter definition. ;  ; virtual void mnpars (TString &crdbuf, Int_t &icondn);  Implements one parameter definition. ;  ; virtual void mnpfit (Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p);  To fit a parabola to npar2p points. ;  ; virtual void mnpint (Double_t &pexti, Int_t i, Double_t &pinti);  Calculates the internal parameter value PINTI. ;  ; virtual void mnplot (Double_t *xpt, Double_t *ypt, char *chpt, Int_t nxypt, Int_t npagwd, Int_t npagln);  Plots points in array xypt onto one page with labelled axes. ;  ; virtual void mnpout (Int_t iuext, TString &chnam, Double_t &val, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:20097,Perform,Performs,20097,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,2,['Perform'],['Performs']
Performance,"GWin32VirtualXProxy.cxx:68; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TIOFeatures.hxx; TNamed.h; TObjArray.h; ROOT::Experimental::Internal::TBulkBranchReadHelper class for reading many branch entries at once to optimize throughput.Definition TBranch.h:68; ROOT::Experimental::Internal::TBulkBranchRead::TBulkBranchReadTBulkBranchRead(TBranch &parent)Definition TBranch.h:83; ROOT::Experimental::Internal::TBulkBranchRead::GetEntriesSerializedInt_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf)See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:321; ROOT::Experimental::Internal::TBulkBranchRead::fParentTBranch & fParentDefinition TBranch.h:87; ROOT::Experimental::Internal::TBulkBranchRead::SupportsBulkReadbool SupportsBulkRead() constReturn true if the branch can be read through the bulk interfaces.Definition TBranch.h:323; ROOT::Experimental::Internal::TBulkBranchRead::GetBulkEntriesInt_t GetBulkEntries(Long64_t evt, TBuffer &user_buf)See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);.Definition TBranch.h:320; ROOT::Internal::TBranchCacheInfoDefinition TBranchCacheInfo.h:35; ROOT::Internal::TBranchIMT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8h_source.html:19581,optimiz,optimize,19581,doc/master/TBranch_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html,2,"['optimiz', 'throughput']","['optimize', 'throughput']"
Performance,"G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableWrappers(bool value = true); Enable call wrappers (also known as stubs) if value is true;; disable if value is false. void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(char *(*)(const char* prompt) getlineFunc, void (*)(char* line) histaddFunc); Set a getlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:20576,Load,LoadMacro,20576,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,2,['Load'],"['Load', 'LoadMacro']"
Performance,"GaussRooCmdArg FitGauss(bool flag=true)Definition RooGlobalFunc.cxx:944; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::LayoutRooCmdArg Layout(double xmin, double xmax=0.99, double ymin=0.95)Definition RooGlobalFunc.cxx:783; RooFit::MinosRooCmdArg Minos(bool flag=true)Definition RooGlobalFunc.cxx:681; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657. PyROOT; The RooMCStudy::plotError() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 1087 of file RooMCStudy.cxx. ◆ plotPull() [2/2]. RooPlot * RooMCStudy::plotPull ; (; const RooRealVar & ; param, . double ; lo = -3.0, . double ; hi = 3.0, . Int_t ; nbins = 25, . bool ; fitGauss = false . ). Create a RooPlot of the pull distribution for the given parameter. ; The range lo-hi is plotted in nbins. If fitGauss is set, an unbinned ML fit of the distribution to a Gaussian p.d.f is performed. The fit result is overlaid on the returned RooPlot and a box with the fitted mean and sigma is added.; If the parameters of the models for generation and fit differ, simple heuristics are used to find the corresponding parameters:; Parameters have the same name: They will be used to compute pulls.; Parameters have different names: The position of the fit parameter in the set of fit parameters will be computed. The parameter at the same position in the set of generator parameters will be used. . Definition at line 1242 of file RooMCStudy.cxx. ◆ RecursiveRemove(). void RooMCStudy::RecursiveRemove ; (; TObject * ; obj). overrideprotectedvirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 1275 of file RooMCStudy.cxx. ◆ refit(). RooFit::OwningPtr< RooFitResult > RooMCStudy::refit ; (; RooAbsData * ; genSample = nullptr). protected . Redo fit on 'current' toy sample, or if genSample is not nullptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:38951,perform,performed,38951,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['perform'],['performed']
Performance,"Gaussian::GenData & RooMultiVarGaussian::genData ; (; Int_t ; code); const. protected . WVE – CHECK THAT GENDATA IS VALID GIVEN CURRENT VALUES OF _MU. ; Definition at line 501 of file RooMultiVarGaussian.cxx. ◆ generateEvent(). void RooMultiVarGaussian::generateEvent ; (; Int_t ; code). overridevirtual . Retrieve generator config from cache. ; Reimplemented from RooAbsPdf.; Definition at line 434 of file RooMultiVarGaussian.cxx. ◆ getAnalyticalIntegral(). Int_t RooMultiVarGaussian::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 194 of file RooMultiVarGaussian.cxx. ◆ getGenerator(). Int_t RooMultiVarGaussian::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Special case: generate all observables. ; Reimplemented from RooAbsPdf.; Definition at line 374 of file RooMultiVarGaussian.cxx. ◆ initGenerator(). void RooMultiVarGaussian::initGenerator ; (; Int_t ; code). overridevirtual . Clear the GenData cache as its content is not invariant under changes in the mu vector. ; Reimplemented from RooAbsPdf.; Definition at line 422 of file RooMultiVarGaussian.cxx. ◆ IsA(). TClass * RooMultiVarGaussian::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 112 of file RooMultiVarGaussian.h. ◆ muVec(). const RooArgList & RooMultiVarGaussian::muVec ; (; ); const. inline . De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:79632,perform,performed,79632,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['perform'],['performed']
Performance,"GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& mome",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:34869,perform,performs,34869,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,6,['perform'],['performs']
Performance,"Gen ; (; ). inlineprotected . Return expected number of events from generator model. ; Definition at line 166 of file RooAbsMCStudyModule.h. ◆ processAfterFit(). virtual bool RooAbsMCStudyModule::processAfterFit ; (; Int_t ; ). inlinevirtual . Method called after fit has been performed. ; Reimplemented in RooChi2MCSModule, and RooDLLSignificanceMCSModule.; Definition at line 69 of file RooAbsMCStudyModule.h. ◆ processBeforeGen(). virtual bool RooAbsMCStudyModule::processBeforeGen ; (; Int_t ; ). inlinevirtual . Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ; Reimplemented in RooRandomizeParamMCSModule.; Definition at line 57 of file RooAbsMCStudyModule.h. ◆ processBetweenGenAndFit(). virtual bool RooAbsMCStudyModule::processBetweenGenAndFit ; (; Int_t ; ). inlinevirtual . Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ; Any modifications to fit parameters will apply to next fit operation. Note that setConstant flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist ; Reimplemented in RooStats::UpperLimitMCSModule.; Definition at line 64 of file RooAbsMCStudyModule.h. ◆ projDeps(). RooArgSet * RooAbsMCStudyModule::projDeps ; (; ). inlineprotected . Return projected observables. ; Definition at line 112 of file RooAbsMCStudyModule.h. ◆ randProto(). bool RooAbsMCStudyModule::randProto ; (; ). inlineprotected . If true randomization of prototype data order is requested. ; Definition at line 171 of file RooAbsMCStudyModule.h. ◆ refit(). RooFit::OwningPtr< RooFitResult > RooAbsMCStudyModule::refit ; (; RooAbsData * ; inGenSample = nullptr). protected . Refit model using original or specified data sample. ; Definition at line 67 of file RooAbsMCStudyModule.cxx. ◆ Streamer(). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMCStudyModule.html:21358,perform,performed,21358,doc/master/classRooAbsMCStudyModule.html,https://root.cern,https://root.cern/doc/master/classRooAbsMCStudyModule.html,1,['perform'],['performed']
Performance,"GenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Loop over components for plot sampling hints and merge them if there are multiple. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. const RooArgSet& getCoefNormalization() const; { return _refCoefNorm ; }. const char* getCoefRange() const; { return _refCoefRangeName?RooNameReg::str(_refCoefRangeName):"""" ; }. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Fri Dec 2 14:26:40 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:50497,Cache,CacheElem,50497,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['Cache'],['CacheElem']
Performance,"General Options.; ; TString dnnOptions (""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=G:""; ""WeightInitialization=XAVIER"");; dnnOptions.Append ("":""); dnnOptions.Append (inputLayoutString);; dnnOptions.Append ("":""); dnnOptions.Append (batchLayoutString);; dnnOptions.Append ("":""); dnnOptions.Append (layoutString);; dnnOptions.Append ("":""); dnnOptions.Append (trainingStrategyString);; ; TString dnnMethodName = ""DNN_CPU"";; if (useDLGPU) {; dnnOptions += "":Architecture=GPU"";; dnnMethodName = ""DNN_GPU"";; } else {; dnnOptions += "":Architecture=CPU"";; }; ; factory.BookMethod(loader, TMVA::Types::kDL, dnnMethodName, dnnOptions);; }; ; // Keras deep learning; if (useKeras) {; ; Info(""TMVA_Higgs_Classification"", ""Building deep neural network with keras "");; // create python script which can be executed; // create 2 conv2d layer + maxpool + dense; TMacro m;; m.AddLine(""import tensorflow"");; m.AddLine(""from tensorflow.keras.models import Sequential"");; m.AddLine(""from tensorflow.keras.optimizers import Adam"");; m.AddLine(""from tensorflow.keras.layers import Input, Dense"");; m.AddLine("""");; m.AddLine(""model = Sequential() "");; m.AddLine(""model.add(Dense(64, activation='relu',input_dim=7))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(2, activation='sigmoid'))"");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('Higgs_model.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_higgs_model.py"");; ; if (gSystem->AccessPathName(""Higgs_model.h5"")) {; Warning(""TMVA_Higgs_Classification"", ""Error creating Keras model file - skip using Keras"");; } e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:67623,optimiz,optimizers,67623,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['optimiz'],['optimizers']
Performance,"GeoNavigator.h:155; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:173; TGeoNavigator::fLastPWSaftyPntDouble_t fLastPWSaftyPnt[3]last point for which safety was computedDefinition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:19283,cache,cached,19283,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cached']
Performance,"GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 5996 Warning(""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 info->CompareContent(this,nullptr,kTRUE,kTRUE,nullptr);; 6017 SetBit(kWarned);; 6018 }; 6019 }; 6020 }; 6021 if (fCollectionProxy) {; 6022 // Update the related pair's TClass if it has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:230562,load,load,230562,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 6050 {; 6051 Bool_t warn = ! TestBit(kWarned);; 6052 if (warn && info->GetOldVersion()<=2) {; 6053 // Names of STL base classes was modified in vers==3. Allocators removed; 6054 //; 6055 TIter nextBC(GetListOfBases());; 6056 TBaseClass *bc;; 6057 while ((bc=(TBaseClass*)nextBC())); 6058 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 6059 }; 6060 ; 6061 if (warn) {; 6062 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 6063 Warning(""PostLoadCheck"",""\n\; 6064 The class %s transitioned from not having a specified class version\n\; 6065 to having a specified class version (the current class version is %d).\n\; 6066 However too many different non-versioned layouts of the class have\n\; 6067 already been loaded so far. To work around this problem you can\n\; 6068 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6069 describing the class %s before opening the files or increase the version\n\; 6070 number of the class for example ClassDef(%s,%d).\n\; 6071 Do not try to write objects with the current class definition,\n\; 6072 the files might not be readable.\n"",; 6073 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6074 } else {; 6075 Warning(""PostLoadCheck"",""\n\; 6076 The StreamerInfo version %d for the class %s which was read\n\; 6077 from a file previously opened has the same version as the active class\n\; 6078 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6079 Do not try to write objects with the current class definition,\n\; 6080 the files will not be readable.\n""; 6081 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6082 }; 6083 info->CompareContent(this,nullptr,kTRUE,kTRUE,nullptr);; 6084 SetBit(kWarned);; 6085 }; 6086 }; 6087 }; 6088 if (fCollectionProxy) {; 6089 // Update the related pair's TClass if it has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:233313,load,load,233313,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:401899,load,load,401899,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['load']
Performance,"GetColor(Int_t color) constTROOT; GetConfigFeatures() constTROOTinline; GetConfigOptions() constTROOTinline; GetCutClassName() constTROOTinline; GetDataDir()TROOTstatic; GetDefCanvasName() constTROOTinline; GetDirectory(const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch() constTROOTinline; GetGitCommit() constTROOTinline; GetGitDate()TROOT; GetGlobal(const char *name, Bool_t load=kFALSE) constTROOT; GetGlobal(const TObject *obj, Bool_t load=kFALSE) constTROOT; GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)TROOT; GetGlobalFunctions()TROOTprotected; GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)TROOT; GetIconName() constTObjectvirtual; GetIconPath()TROOTstatic; GetIncludeDir()TROOTstatic; GetInterpreter() constTROOTinline; GetKey(const char *, Short_t=9999) constTDirectoryinlinevirtual; GetLibDir()TROOTstatic; GetList() constTDirectoryinlinevirtual; GetListOfBrowsables() constTROOTinline; GetListOfBrowsers() constTROOTinline; GetListOfCanvases() constTROOTinline; GetListOfClasses() constTROOTinline; GetListOfClassGenerators() constTROOTinline; GetListOfCleanups() constTROOTinline; GetListOfClosedObjects() constTROOTinline; GetListOfColors() constTROOTinline; GetListOfDataSets() constTROOTinline; GetListOfEnums(Bool_t load=kFALSE)TROOT; GetListOfFiles() constTROOTinline; GetListOfFunctionOverloads(const char *name) constTROOT; GetListOfFu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:7416,load,load,7416,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"GetDataSetInfo().GetDataSetManager(); // DSMTEST; 422 methBoost->SetFile(fgTargetFile);; 423 methBoost->SetSilentFile(IsSilentFile());; 424 }; 425 ; 426 MethodBase *method = dynamic_cast<MethodBase *>(im);; 427 if (method == 0); 428 return 0; // could not create method; 429 ; 430 // set fDataSetManager if MethodCategory (to enable Category to create datasetinfo objects) // DSMTEST; 431 if (method->GetMethodType() == Types::kCategory) { // DSMTEST; 432 MethodCategory *methCat = (dynamic_cast<MethodCategory *>(im)); // DSMTEST; 433 if (!methCat) { // DSMTEST; 434 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Factory""; 435 << Endl; // DSMTEST; 436 return nullptr;; 437 }; 438 if (fModelPersistence); 439 methCat->SetWeightFileDir(fileDir);; 440 methCat->SetModelPersistence(fModelPersistence);; 441 methCat->fDataSetManager = loader->GetDataSetInfo().GetDataSetManager(); // DSMTEST; 442 methCat->SetFile(fgTargetFile);; 443 methCat->SetSilentFile(IsSilentFile());; 444 } // DSMTEST; 445 ; 446 if (!method->HasAnalysisType(fAnalysisType, loader->GetDataSetInfo().GetNClasses(),; 447 loader->GetDataSetInfo().GetNTargets())) {; 448 Log() << kWARNING << ""Method "" << method->GetMethodTypeName() << "" is not capable of handling "";; 449 if (fAnalysisType == Types::kRegression) {; 450 Log() << ""regression with "" << loader->GetDataSetInfo().GetNTargets() << "" targets."" << Endl;; 451 } else if (fAnalysisType == Types::kMulticlass) {; 452 Log() << ""multiclass classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 453 } else {; 454 Log() << ""classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 455 }; 456 return 0;; 457 }; 458 ; 459 if (fModelPersistence); 460 method->SetWeightFileDir(fileDir);; 461 method->SetModelPersistence(fModelPersistence);; 462 method->SetAnalysisType(fAnalysisType);; 463 method->SetupMethod();; 464 method->ParseOptions();; 465 method->ProcessSetup();; 466 meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:18293,load,loader,18293,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"GetEntryAndTree (Long64_t index, Int_t &treenum);  Return the index of ""index""-th non-zero entry in the TTree or TChain and the # of the corresponding tree in the chain. ;  ; virtual TEntryList * GetEntryList (const char *treename, const char *filename, Option_t *opt="""");  Return the entry list, corresponding to treename and filename By default, the filename is first tried as is, and then, if the corresponding list is not found, the filename is expanded to the absolute path, and compared again. ;  ; virtual const char * GetFileName () const;  ; virtual TList * GetLists () const;  ; virtual Long64_t GetN () const;  ; virtual bool GetReapplyCut () const;  ; virtual const char * GetTreeName () const;  ; virtual Int_t GetTreeNumber () const;  ; bool IsValid () const;  ; virtual Int_t Merge (TCollection *list);  Merge this list with the lists from the collection. ;  ; virtual Long64_t Next ();  Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than GetEntry() ;  ; virtual void OptimizeStorage ();  Checks if the array representation is more economical and if so, switches to it. ;  ; void Print (const Option_t *option="""") const override;  Print this list. ;  ; virtual Int_t RelocatePaths (const char *newloc, const char *oldloc=nullptr);  Relocate the file paths. ;  ; virtual Int_t ScanPaths (TList *roots, bool notify=true);  Scan the paths to find the common roots. ;  ; virtual void SetDirectory (TDirectory *dir);  Add reference to directory dir. dir can be 0. ;  ; virtual void SetEntriesToProcess (Long64_t nen);  ; virtual void SetFileName (const char *filename);  ; virtual void SetReapplyCut (bool apply=false);  ; virtual void SetShift (bool shift);  ; virtual void SetTreeName (const char *treename);  ; virtual void SetTreeNumber (Int_t index);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListArray.html:7899,Optimiz,OptimizeStorage,7899,doc/master/classTEntryListArray.html,https://root.cern,https://root.cern/doc/master/classTEntryListArray.html,1,['Optimiz'],['OptimizeStorage']
Performance,"GetEntryNumber(). Long64_t TChain::GetEntryNumber ; (; Long64_t ; entry); const. overridevirtual . Return entry number corresponding to entry. ; if no TEntryList set returns entry else returns entry #entry from this entry list and also computes the global entry number (loads all tree headers) ; Reimplemented from TTree.; Definition at line 995 of file TChain.cxx. ◆ GetEntryWithIndex(). Int_t TChain::GetEntryWithIndex ; (; Int_t ; major, . Int_t ; minor = 0 . ). overridevirtual . Return entry corresponding to major and minor number. ; The function returns the total number of bytes read. If the Tree has friend trees, the corresponding entry with the index values (major,minor) is read. Note that the master Tree and its friend may have different entry serial numbers corresponding to (major,minor). ; Reimplemented from TTree.; Definition at line 1028 of file TChain.cxx. ◆ GetFile(). TFile * TChain::GetFile ; (; ); const. Return a pointer to the current file. ; If no file is connected, the first file is automatically loaded. ; Definition at line 1039 of file TChain.cxx. ◆ GetLeaf() [1/2]. TLeaf * TChain::GetLeaf ; (; const char * ; branchname, . const char * ; leafname . ). overridevirtual . Return a pointer to the leaf name in the current tree. ; Reimplemented from TTree.; Definition at line 1052 of file TChain.cxx. ◆ GetLeaf() [2/2]. TLeaf * TChain::GetLeaf ; (; const char * ; name). overridevirtual . Return a pointer to the leaf name in the current tree. ; Reimplemented from TTree.; Definition at line 1073 of file TChain.cxx. ◆ GetListOfBranches(). TObjArray * TChain::GetListOfBranches ; (; ). overridevirtual . Return a pointer to the list of branches of the current tree. ; Warning: If there is no current TTree yet, this routine will open the first in the chain.; Returns 0 on failure. ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 1099 of file TChain.cxx. ◆ GetListOfFiles(). TObjArray * TChain::GetListOfFiles ; (; ); const. inline . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:76041,load,loaded,76041,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['loaded']
Performance,"GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFitter.html:11191,cache,cache,11191,root/html528/TVirtualFitter.html,https://root.cern,https://root.cern/root/html528/TVirtualFitter.html,4,['cache'],['cache']
Performance,"GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFitter.html:12102,cache,cache,12102,root/html602/TVirtualFitter.html,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html,2,['cache'],['cache']
Performance,"GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:52858,load,load,52858,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['load'],['load']
Performance,"GetIncrement() const {; 1005 if (!fValue.load(std::memory_order_relaxed)) {; 1006 Initialize(kFALSE);; 1007 }; 1008 return fValDiff;; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Return the sizeof the collection object.; 1013 ; 1014UInt_t TGenCollectionProxy::Sizeof() const; 1015{; 1016 return fClass->Size();; 1017}; 1018 ; 1019////////////////////////////////////////////////////////////////////////////////; 1020/// Return true if the content is of type 'pointer to'; 1021 ; 1022Bool_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:33148,load,load,33148,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"GetLimitsFinder ; (; ). static . Return pointer to the current finder. ; Create one if none exists Use SetLimitsFinder to set a user defined finder. ; Definition at line 153 of file THLimitsFinder.cxx. ◆ IsA(). TClass * THLimitsFinder::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder.; Definition at line 46 of file THLimitsFinder.h. ◆ Optimize(). void THLimitsFinder::Optimize ; (; Double_t ; A1, . Double_t ; A2, . Int_t ; nold, . Double_t & ; BinLow, . Double_t & ; BinHigh, . Int_t & ; nbins, . Double_t & ; BinWidth, . Option_t * ; option = """" . ). static . Static function to compute reasonable axis limits. ; Input parameters:; Parameters. [in]A1,A2: Original axis limits ; [in]BinLow,BinHigh: Optimized axis limits. They should be initialized by the calling method for instance to 0. ; [out]nold: Original number of divisions. ; [out]nbins: Optimized number of divisions. ; [out]BinWidth: Optimized bin width. It should be initialized by the calling method for instance to 0. ; [in]option: ""T"" means Time axis. . Definition at line 184 of file THLimitsFinder.cxx. ◆ OptimizeLimits(). void THLimitsFinder::OptimizeLimits ; (; Int_t ; nbins, . Int_t & ; newbins, . Double_t & ; xmin, . Double_t & ; xmax, . Bool_t ; isInteger . ). static . Optimize axis limits. ; When isInter=kTRUE, the function makes an integer binwidth and recompute the number of bins accordingly. ; Definition at line 367 of file THLimitsFinder.cxx. ◆ SetLimitsFinder(). void THLimitsFinder::SetLimitsFinder ; (; THLimitsFinder * ; finder). static . This static function can be used to specify a finder derived from THLimitsFinder. ; The finder may redefine the functions FindGoodLimits. Note that the redefined functions may call THLimitsFinder::FindGoodLimits. ; Definition at line 165 of file THLimitsFinder.cxx. ◆ Streamer(). void THLimitsFinder::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:14873,Optimiz,Optimized,14873,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,1,['Optimiz'],['Optimized']
Performance,"GetListOfBranches() override;; 109 // Warning, GetListOfFiles returns the list of TChainElements (not the list of files); 110 // see TChain::AddFile to see how to get the corresponding TFile objects; 111 TObjArray *GetListOfFiles() const {return fFiles;}; 112 TObjArray *GetListOfLeaves() override;; 113 const char *GetAlias(const char *aliasName) const override;; 114 Double_t GetMaximum(const char *columname) override;; 115 Double_t GetMinimum(const char *columname) override;; 116 Int_t GetNbranches() override;; 117 Long64_t GetReadEntry() const override;; 118 TList *GetStatus() const { return fStatus; }; 119 TTree *GetTree() const override { return fTree; }; 120 Int_t GetTreeNumber() const override { return fTreeNumber; }; 121 Long64_t *GetTreeOffset() const { return fTreeOffset; }; 122 Int_t GetTreeOffsetLen() const { return fTreeOffsetLen; }; 123 Double_t GetWeight() const override;; 124 bool InPlaceClone(TDirectory *newdirectory, const char *options = """") override;; 125 Int_t LoadBaskets(Long64_t maxmemory) override;; 126 Long64_t LoadTree(Long64_t entry) override;; 127 void Lookup(bool force = false);; 128 virtual void Loop(Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0); // *MENU*; 129 void ls(Option_t *option="""") const override;; 130 virtual Long64_t Merge(const char *name, Option_t *option = """");; 131 Long64_t Merge(TCollection *list, Option_t *option = """") override;; 132 Long64_t Merge(TCollection *list, TFileMergeInfo *info) override;; 133 virtual Long64_t Merge(TFile *file, Int_t basketsize, Option_t *option="""");; 134 void Print(Option_t *option="""") const override;; 135 Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0) override; // *MENU*; 136 Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0) override;; 137 void RecursiveRemove(TObject *obj) override;; 138 void RemoveFriend(TTree*) override;; 139 vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8h_source.html:6029,Load,LoadBaskets,6029,doc/master/TChain_8h_source.html,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html,1,['Load'],['LoadBaskets']
Performance,"GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *ind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exampleFit3D_8C.html:3528,perform,performing,3528,doc/master/exampleFit3D_8C.html,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html,1,['perform'],['performing']
Performance,"GetNkeys ; (; ); const. inlinevirtual . Reimplemented in TDirectoryFile.; Definition at line 227 of file TDirectory.h. ◆ GetObject(). template<class T > . void TDirectory::GetObject ; (; const char * ; namecycle, . T *& ; ptr . ). inline . Get an object with proper type checking. ; If the object doesn't exist in the file or if the type doesn't match, a nullptr is returned. Also see TDirectory::Get(). ; Definition at line 212 of file TDirectory.h. ◆ GetObjectChecked() [1/2]. void * TDirectory::GetObjectChecked ; (; const char * ; namecycle, . const char * ; classname . ). virtual . See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl) ; Reimplemented in TDirectoryFile.; Definition at line 929 of file TDirectory.cxx. ◆ GetObjectChecked() [2/2]. void * TDirectory::GetObjectChecked ; (; const char * ; namecycle, . const TClass * ; expectedClass . ). virtual . Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ; namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to the type described by the 2 arguments (i.e. cl): MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; Note: We recommend using the method TDirectory::GetObject: MyClass *obj = nullptr;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }; whatstatic const char * whatDefinition stlLoader.cc:5. Reimplemented in TDirectoryFile.; Definition at line 958 of file TDirectory.cxx. ◆ GetObjectUnchecked(). void * TDirectory::GetObjectUnchecked ; (; const char * ; namecycle). virtual . Return pointer to object identified by namecycle. ; The returned object may or may not derive fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:38094,perform,performed,38094,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['perform'],['performed']
Performance,"GetNkeys() const; Int_tGetNtypes() const; virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() const; virtual Long64_tTDirectory::GetSeekKeys() const; virtual Long64_tTDirectory::GetSeekParent() const; TVirtualPad*GetSelectedPad() const; const TObject*GetSelectedPrimitive() const; TStyle*GetStyle(const char* name) const; virtual const char*TNamed::GetTitle() const; static const char*GetTutorialsDir(); TDataType*GetType(const char* name, Bool_t load = kFALSE) const; virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; TProcessUUID*GetUUIDs() const; const char*GetVersion() const; Int_tGetVersionCode() const; Int_tGetVersionDate() const; Int_tGetVersionInt() const; Int_tGetVersionTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:9148,load,load,9148,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions;  RooSimSplitGenContext (const RooSimSplitGenContext &other);  ; RooDataSet * createDataSet (const char *name, const char *title, const RooArgSet &obs) override;  this method is empty because it is not used by this context ;  ; void generateEvent (RooArgSet &theEvent, Int_t remaining) override;  this method is empty because it is not used in this type of context ;  ; void initGenerator (const RooArgSet &theEvent) override;  Perform one-time initialization of generator context. ;  ;  Protected Member Functions inherited from RooAbsGenContext; void resampleData (double &ratio);  Rescale existing output buffer with given ratio. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooArgSet _allVarsPdf;  All pdf variables. ;  ; double * _fracThresh;  fraction thresholds ;  ; std::vector< int > _gcIndex;  Index value corresponding to component. ;  ; std::vector< RooAbsGenContext * > _gcList;  List of component generator contexts. ;  ; RooAbsCategoryLValue * _idxCat;  Clone of index category. ;  ; TString _idxCatName;  Name of index",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimSplitGenContext.html:14336,Perform,Perform,14336,doc/master/classRooSimSplitGenContext.html,https://root.cern,https://root.cern/doc/master/classRooSimSplitGenContext.html,1,['Perform'],['Perform']
Performance,"GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tfgBytesReadNumber of bytes read by all TFile objects; static Long64_tfgBytesWriteNumber of bytes written by all TFile objects; static TStringfgCacheFileDirDirectory where to locally stage files; static Bool_tfgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tfgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tfgFileCounterCounter for all opened files; static Bool_tfgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:21775,cache,cache,21775,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance,"GetPathSeparator() + ""ROOT.modulemap"";; 1456 ModuleMaps.push_back(TROOT::GetIncludeDir().Data() + ModuleMapSuffix);; 1457 GetEnvVarPath(""CLING_MODULEMAP_FILES"", ModuleMaps);; 1458 ; 1459 std::string cwd = gSystem->WorkingDirectory();; 1460 // Give highest precedence of the modulemap in the cwd if any.; 1461 if (llvm::sys::fs::exists(cwd + ModuleMapSuffix)); 1462 ModuleMaps.push_back(cwd + ModuleMapSuffix);; 1463 ; 1464 for (const std::string& M : ModuleMaps); 1465 clingArgsStorage.push_back(""-fmodule-map-file="" + M);; 1466 ; 1467 std::string ModulesCachePath;; 1468 EnvOpt = llvm::sys::Process::GetEnv(""CLING_MODULES_CACHE_PATH"");; 1469 if (EnvOpt.has_value()){; 1470 StringRef Env(*EnvOpt);; 1471 assert(llvm::sys::fs::exists(Env) && ""Path does not exist!"");; 1472 ModulesCachePath = Env.str();; 1473 } else {; 1474 ModulesCachePath = TROOT::GetSharedLibDir();; 1475 }; 1476 ; 1477 clingArgsStorage.push_back(""-fmodules-cache-path="" + ModulesCachePath);; 1478 }; 1479 ; 1480 std::vector<const char*> interpArgs;; 1481 for (std::vector<std::string>::const_iterator iArg = clingArgsStorage.begin(),; 1482 eArg = clingArgsStorage.end(); iArg != eArg; ++iArg); 1483 interpArgs.push_back(iArg->c_str());; 1484 ; 1485 // Activate C++ modules support. If we are running within rootcling, it's up; 1486 // to rootcling to set this flag depending on whether it wants to produce; 1487 // C++ modules.; 1488 TString vfsArg;; 1489 if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:54334,cache,cache-path,54334,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['cache'],['cache-path']
Performance,"GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Private method to generate a ROCCurve instance for a given method.Definition Factory.cxx:749; TMVA::Factory::IsSilentFileBool_t IsSilentFile() constDefinition Factory.h:151; TMVA::Factory::EvaluateImportanceShortTH1F * EvaluateImportanceShort(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2358; TMVA::Factory::fAnalysisTypeTypes::EAnalysisType fAnalysisType! the training typeDefinition Factory.h:221; TMVA::Factory::fJobNameTString fJobName! jobname, used as extension in weight file namesDefinition Factory.h:219; TMVA::Factory::HasMethodBool_t HasMethod(const TString &datasetname, const TString &title) constChecks whether a given method name is defined for a given dataset.Definition Factory.cxx:586; TMVA::Factory::GetROCCurveTGraph * GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Argument iClass specifies the class to generate the ROC curve in a multiclass setting.Definition Factory.cxx:912; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *, TMVA::Types::EMVA, TString, TString, TMVA::Types::EMVA, TString)Definition Factory.h:102; TMVA::Factory::TrainAllMethodsForRegressionvoid TrainAllMethodsForRegression(void)Definition Factory.h:116; TMVA::Factory::EvaluateImportanceAllTH1F * EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2246; TMVA::Factory::SetVerbosevoid SetVerbose(Bool_t v=kTRUE)Definition Factory.cxx:343; TMVA::Factory::fgTargetFileTFile * fgTargetFile! ROOT output fileDefinition Factory.h:205; TMVA::Factory::fDefaultTrfsstd::vector< TMVA::VariableTransformBase * > fDefaultTrfs! list of transformations on default DataSetDefinition Factory.h:208; TMVA::Factory::GetMethodIMethod * GetMethod(const TString &datasetn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:17930,load,loader,17930,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:3379,optimiz,optimize,3379,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['optimiz'],['optimize']
Performance,"GetStreamer() const;; 490 ClassStreamerFunc_t GetStreamerFunc() const;; 491 ClassConvStreamerFunc_t GetConvStreamerFunc() const;; 492 const TObjArray *GetStreamerInfos() const { return fStreamerInfo; }; 493 TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0, Bool_t isTransient = kFALSE) const;; 494 TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;; 495 TVirtualStreamerInfo *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;; 496 const std::type_info *GetTypeInfo() const { return fTypeInfo; };; 497 ; 498 /// @brief Return 'true' if we can guarantee that if this class (or any class in; 499 /// this class inheritance hierarchy) overload TObject::Hash it also starts; 500 /// the RecursiveRemove process from its own destructor.; 501 Bool_t HasConsistentHashMember(); 502 {; 503 if (!fRuntimeProperties); 504 SetRuntimeProperties();; 505 return fRuntimeProperties.load() & ERuntimeProperties::kConsistentHash;; 506 }; 507 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 508 Bool_t HasCustomStreamerMember() const { return fHasCustomStreamerMember; }; 509 Bool_t HasDictionary() const;; 510 static Bool_t HasDictionarySelection(const char* clname);; 511 Bool_t HasLocalHashMember() const;; 512 void GetMissingDictionaries(THashTable& result, bool recurse = false);; 513 void IgnoreTObjectStreamer(Bool_t ignore=kTRUE);; 514 Bool_t InheritsFrom(const char *cl) const override;; 515 Bool_t InheritsFrom(const TClass *cl) const override;; 516 void InterpretedShowMembers(void* obj, TMemberInspector &insp, Bool_t isTransient);; 517 Bool_t IsFolder() const override { return kTRUE; }; 518 Bool_t IsLoaded() const;; 519 Bool_t IsForeign() const;; 520 Bool_t IsStartingWithTObject() const;; 521 Bool_t IsSyntheticPair() const { return fIsSyntheticPair; }; 522 Bool_t IsVersioned() const { return !( GetClassVersion()<=1 && IsForeign() ); }; 523 Bool_t IsTObject() const;; 524 stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:25699,load,load,25699,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['load']
Performance,"GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TList.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; ROOT::Experimental::Internal::RVirtualCanvasPainter::Createstatic std::unique_ptr< RVirtualCanvasPainter > Create(RCanvas &canv)Loads the plugin that implements this class.Definition RVirtualCanvasPainter.cxx:42; ROOT::Experimental::RCanvasA window's topmost RPad.Definition RCanvas.hxx:47; ROOT::Experimental::RCanvas::GetCanvasesstatic const std::vector< std::shared_ptr< RCanvas > > GetCanvases()Returns list of created canvases.Definition RCanvas.cxx:45; ROOT::Experimental::RCanvas::ReleaseHeldCanvasesstatic void ReleaseHeldCanvases()Release list of held canvases pointers If no other shared pointers exists on the canvas,...Definition RCanvas.cxx:56; ROOT::Experimental::RCanvas::SaveAsbool SaveAs(const std::string &filename)Save canvas in image file.Definition RCanvas.cxx:181; ROOT::Experimental::RCanvas::GetWindowUrlstd::string GetWindowUrl(bool remote)Returns window URL which can be used for connection.Definition RCanvas.cxx:159; ROOT::Experimental::RCanvas::IsModifiedbool IsModified() constReturns true is canvas was modified since last painting.Definition RCanvas.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:13472,Load,Loads,13472,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['Load'],['Loads']
Performance,"GetTitle());; 3982 fTopVolume->SaveAs(filename);; 3983 return 1;; 3984 }; 3985 if (sfile.Contains("".gdml"")) {; 3986 // Save geometry as a gdml file; 3987 if (fgVerboseLevel > 0); 3988 Info(""Export"", ""Exporting %s %s as gdml code"", GetName(), GetTitle());; 3989 // C++ version; 3990 TString cmd;; 3991 cmd = TString::Format(""TGDMLWrite::StartGDMLWriting(gGeoManager,\""%s\"",\""%s\"")"", filename, option);; 3992 gROOT->ProcessLineFast(cmd);; 3993 return 1;; 3994 }; 3995 if (sfile.Contains("".root"") || sfile.Contains("".xml"")) {; 3996 // Save geometry as a root file; 3997 TFile *f = TFile::Open(filename, ""recreate"");; 3998 if (!f || f->IsZombie()) {; 3999 Error(""Export"", ""Cannot open file"");; 4000 return 0;; 4001 }; 4002 TString keyname = name;; 4003 if (keyname.IsNull()); 4004 keyname = GetName();; 4005 TString opt = option;; 4006 opt.ToLower();; 4007 if (opt.Contains(""v"")) {; 4008 fStreamVoxels = kTRUE;; 4009 if (fgVerboseLevel > 0); 4010 Info(""Export"", ""Exporting %s %s as root file. Optimizations streamed."", GetName(), GetTitle());; 4011 } else {; 4012 fStreamVoxels = kFALSE;; 4013 if (fgVerboseLevel > 0); 4014 Info(""Export"", ""Exporting %s %s as root file. Optimizations not streamed."", GetName(), GetTitle());; 4015 }; 4016 ; 4017 const char *precision_dbl = TBufferText::GetDoubleFormat();; 4018 const char *precision_flt = TBufferText::GetFloatFormat();; 4019 TString new_format_dbl = TString::Format(""%%.%dg"", TGeoManager::GetExportPrecision());; 4020 if (sfile.Contains("".xml"")) {; 4021 TBufferText::SetDoubleFormat(new_format_dbl.Data());; 4022 TBufferText::SetFloatFormat(new_format_dbl.Data());; 4023 }; 4024 Int_t nbytes = Write(keyname);; 4025 if (sfile.Contains("".xml"")) {; 4026 TBufferText::SetFloatFormat(precision_dbl);; 4027 TBufferText::SetDoubleFormat(precision_flt);; 4028 }; 4029 ; 4030 fStreamVoxels = kFALSE;; 4031 delete f;; 4032 return nbytes;; 4033 }; 4034 return 0;; 4035}; 4036 ; 4037////////////////////////////////////////////////////////////////////////////////;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:146765,Optimiz,Optimizations,146765,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Optimiz'],['Optimizations']
Performance,"GetV2 ();  ; virtual Double_t * GetV3 ();  ; virtual Double_t * GetV4 ();  ; virtual Double_t * GetVal (Int_t i);  ; TTreeFormula * GetVar (Int_t i);  ; TTreeFormula * GetVar1 ();  ; TTreeFormula * GetVar2 ();  ; TTreeFormula * GetVar3 ();  ; TTreeFormula * GetVar4 ();  ; virtual Double_t * GetW ();  ; virtual Double_t GetWeight () const;  ; virtual Long64_t GetZipBytes () const;  ; virtual void IncrementTotalBuffers (Int_t nbytes);  ; virtual bool InPlaceClone (TDirectory *newdirectory, const char *options="""");  Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ;  ; bool IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; virtual Int_t LoadBaskets (Long64_t maxmemory=2000000000);  Read in memory all baskets from all branches up to the limit of maxmemory bytes. ;  ; virtual Long64_t LoadTreeFriend (Long64_t entry, TTree *T);  Load entry on behalf of our master tree, we may use an index. ;  ; virtual Int_t MakeClass (const char *classname=nullptr, Option_t *option="""");  Generate a skeleton analysis class for this tree. ;  ; virtual Int_t MakeCode (const char *filename=nullptr);  Generate a skeleton function for this tree. ;  ; virtual Int_t MakeProxy (const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3);  Generate a skeleton analysis class for this Tree using TBranchProxy. ;  ; virtual Int_t MakeSelector (const char *selector=nullptr, Option_t *option="""");  Generate skeleton selector class for this tree. ;  ; bool MemoryFull (Int_t nbytes);  Check if adding nbytes to memory we are still below MaxVirtualsize. ;  ; virtual Long64_t Merge (TCollection *list, Option_t *option="""");  Merge the trees in the TList into this tree. ;  ; virtual Long64_t Merge (TCollection *list, TFileMergeInfo *info);  Merge the trees in the TLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:14419,Load,LoadTreeFriend,14419,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,2,['Load'],"['Load', 'LoadTreeFriend']"
Performance,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52995,cache,cache,52995,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,6,['cache'],['cache']
Performance,"Global activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:33834,cache,cache,33834,root/html532/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,1,['cache'],['cache']
Performance,"Global activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:33834,cache,cache,33834,root/html532/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,1,['cache'],['cache']
Performance,"Global observables: explicit obs - obs from data - constant observables; Parameters of interest: empty,; Nuisance parameters: all parameters except parameters of interest. We use nullptr to mean not set, so we don't want to fill with empty RooArgSets. ; Definition at line 87 of file ModelConfig.cxx. ◆ ImportDataInWS(). void RooStats::ModelConfig::ImportDataInWS ; (; RooAbsData & ; data). protected . internal function to import data in WS ; Definition at line 330 of file ModelConfig.cxx. ◆ ImportPdfInWS(). void RooStats::ModelConfig::ImportPdfInWS ; (; const RooAbsPdf & ; pdf). protected . internal function to import Pdf in WS ; Definition at line 314 of file ModelConfig.cxx. ◆ IsA(). TClass * RooStats::ModelConfig::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 368 of file ModelConfig.h. ◆ LoadSnapshot(). void RooStats::ModelConfig::LoadSnapshot ; (; ); const. load the snapshot from ws if it exists ; Definition at line 279 of file ModelConfig.cxx. ◆ Print(). void RooStats::ModelConfig::Print ; (; Option_t * ; option = """"); const. overridevirtual . overload the print method ; print contents of Model on the default print stream It can be changed using RooPrintable ; Reimplemented from TObject.; Definition at line 137 of file ModelConfig.cxx. ◆ ReplaceWS(). void RooStats::ModelConfig::ReplaceWS ; (; RooWorkspace * ; ws). inlineoverridevirtual . Remove the existing reference to a workspace and replace it with this new one. ; Implements RooWorkspaceHandle.; Definition at line 74 of file ModelConfig.h. ◆ SetConditionalObservables() [1/2]. virtual void RooStats::ModelConfig::SetConditionalObservables ; (; const char * ; argList). inlinevirtual . Specify the conditional observables through a comma-separated list of arguments already in the workspace. ; Definition at line 186 of file ModelConfig.h. ◆ SetConditionalObservables() [2/2]. void RooStats::ModelConfig::SetConditionalObservables ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html:28346,load,load,28346,doc/master/classRooStats_1_1ModelConfig.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html,1,['load'],['load']
Performance,"Global(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TColle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:24320,load,load,24320,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"Gradient must be implemented by the derived classes in addition to those inherited by the base abstract classes. ; Definition at line 327 of file IParamFunction.h. Public Types; typedef IParametricFunctionOneDim::BaseFunc BaseFunc;  ; typedef IGradientFunctionOneDim BaseGradFunc;  ; typedef IParametricFunctionOneDim BaseParamFunc;  ;  Public Types inherited from ROOT::Math::IParametricFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  ;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . Public Member Functions;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; virtual void ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html:1738,cache,cached,1738,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__FumiliFCNBase.html:2815,cache,cached,2815,root/html534/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,"Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id: FumiliFCNBase.h 34992 2010-08-25 10:36:11Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__FumiliFCNBase.html:2813,cache,cached,2813,root/html528/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,"Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id: FumiliFCNBase.h 34992 2010-08-25 10:36:11Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__FumiliFCNBase.html:2815,cache,cached,2815,root/html530/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,"Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id: FumiliFCNBase.h 34992 2010-08-25 10:36:11Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__FumiliFCNBase.html:2815,cache,cached,2815,root/html532/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,"GradientFunctionMultiDimTempl<T> BaseGrad;; 173 ; 174 ; 175 /// Evaluate all the vector of function derivatives (gradient) at a point x.; 176 /// Derived classes must re-implement it if more efficient than evaluating one at a time; 177 virtual void Gradient(const T *x, T *grad) const; 178 {; 179 unsigned int ndim = NDim();; 180 for (unsigned int icoord = 0; icoord < ndim; ++icoord) {; 181 grad[icoord] = Derivative(x, icoord);; 182 }; 183 }; 184 ; 185 /// In some cases, the gradient algorithm will use information from the previous step, these can be passed; 186 /// in with this overload. The `previous_*` arrays can also be used to return second derivative and step size; 187 /// so that these can be passed forward again as well at the call site, if necessary.; 188 virtual void GradientWithPrevResult(const T *x, T *grad, T *previous_grad, T *previous_g2, T *previous_gstep) const; 189 {; 190 unsigned int ndim = NDim();; 191 for (unsigned int icoord = 0; icoord < ndim; ++icoord) {; 192 grad[icoord] = Derivative(x, icoord, previous_grad, previous_g2, previous_gstep);; 193 }; 194 }; 195 ; 196 using BaseFunc::NDim;; 197 ; 198 /// Optimized method to evaluate at the same time the function value and derivative at a point x.; 199 /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; 200 /// Derived class should implement this method if performances play an important role and if it is faster to; 201 /// evaluate value and derivative at the same time; 202 virtual void FdF(const T *x, T &f, T *df) const; 203 {; 204 f = BaseFunc::operator()(x);; 205 Gradient(x, df);; 206 }; 207 ; 208 /// Return the partial derivative with respect to the passed coordinate.; 209 T Derivative(const T *x, unsigned int icoord = 0) const { return DoDerivative(x, icoord); }; 210 ; 211 /// In some cases, the derivative algorithm will use information from the previous step, these can be passed; 212 /// in with this overload. The `previous_*` array",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/IFunction_8h_source.html:8154,Optimiz,Optimized,8154,doc/master/IFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/IFunction_8h_source.html,1,['Optimiz'],['Optimized']
Performance,"GraphErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 533 Int_t obegin); 534{; 535 if (TGraph::CopyPoints(arrays ? arrays + 2 : nullptr, ibegin, iend, obegin)) {; 536 Int_t n = (iend - ibegin) * sizeof(Double_t);; 537 if (arrays) {; 538 memmove(&arrays[0][obegin], &fEX[ibegin], n);; 539 memmove(&arrays[1][obegin], &fEY[ibegin], n);; 540 } else {; 541 memmove(&fEX[obegin], &fEX[ibegin], n);; 542 memmove(&fEY[obegin], &fEY[ibegin], n);; 543 }; 544 return kTRUE;; 545 } else {; 546 return kFALSE;; 547 }; 548}; 549 ; 550 ; 551////////////////////////////////////////////////////////////////////////////////; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:18349,perform,perform,18349,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"GroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; Bool_tfOpenPermsTrue if file permissions must be open; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are already initialized by the base constructor. const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManagerFile.html:11978,cache,cache,11978,root/html534/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html534/TDataSetManagerFile.html,6,['cache'],['cache']
Performance,"GroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid win",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:32273,cache,cache,32273,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"GroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 416 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid win",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:32277,cache,cache,32277,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"H1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function at; the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. void Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. SPECIAL CASE (Average/Efficiency histograms); For histograms representing averages or efficiencies, one should compute the average; of the two histograms and not the sum. One can mark ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:39480,Perform,Performs,39480,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['Perform'],['Performs']
Performance,"H1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH1I*fProcPcktHist!histogram of packets being processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPerfStats.html:8550,latency,latency,8550,root/html534/TPerfStats.html,https://root.cern,https://root.cern/root/html534/TPerfStats.html,3,['latency'],['latency']
Performance,"H2D * GetUnfoldCovMatrix (const TH2D *cov, Int_t ntoys, Int_t seed=1);  Determine for given input error matrix covariance matrix of unfolded spectrum from toy simulation given the passed covariance matrix on measured spectrum ""cov"" - covariance matrix on the measured spectrum, to be propagated ""ntoys"" - number of pseudo experiments used for the propagation ""seed"" - seed for pseudo experiments Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. ;  ; TH2D * GetXinv () const;  Returns the computed inverse of the covariance matrix. ;  ; TH2D * GetXtau () const;  Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor. ;  ; TClass * IsA () const override;  ; void SetNormalize (Bool_t normalize);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; TH1D * Unfold (Int_t kreg);  Perform the unfolding with regularisation parameter kreg. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:5871,Perform,Perform,5871,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['Perform'],['Perform']
Performance,"H2D, nxn bins) . Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TSVDUnfoldSVD Approach to Data Unfolding.Definition TSVDUnfold.h:46; TSVDUnfold::UnfoldTH1D * Unfold(Int_t kreg)Perform the unfolding with regularisation parameter kreg.Definition TSVDUnfold.cxx:237; where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i| that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments. ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:1996,Perform,Perform,1996,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['Perform'],['Perform']
Performance,"HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.940e-01; : 2 : var1 : 2.619e-01; : 3 : var2 : 1.849e-01; : 4 : var3 : 1.592e-01; : --------------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; Single-event inference: 0.233873; ; RTensor input for inference on data of multiple events:; { { -1.14361, -0.822373, -0.495426, -0.629427 } { 2.14344, -0.0189228, 0.26703, 1.26749 } { -0.443913, 0.486827, 0.139535, 0.611483 } }; ; Prediction performed on multiple events: { 0.173541, -0.0540229, 0.266502 }; ; DateJuly 2019 ; AuthorStefan Wunsch ; Definition in file tmva003_RReader.C. tutorialstmvatmva003_RReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:11267,perform,performed,11267,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['perform'],['performed']
Performance,"HLimitsFinder.cxx. ◆ IsA(). TClass * THLimitsFinder::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder.; Definition at line 46 of file THLimitsFinder.h. ◆ Optimize(). void THLimitsFinder::Optimize ; (; Double_t ; A1, . Double_t ; A2, . Int_t ; nold, . Double_t & ; BinLow, . Double_t & ; BinHigh, . Int_t & ; nbins, . Double_t & ; BinWidth, . Option_t * ; option = """" . ). static . Static function to compute reasonable axis limits. ; Input parameters:; Parameters. [in]A1,A2: Original axis limits ; [in]BinLow,BinHigh: Optimized axis limits. They should be initialized by the calling method for instance to 0. ; [out]nold: Original number of divisions. ; [out]nbins: Optimized number of divisions. ; [out]BinWidth: Optimized bin width. It should be initialized by the calling method for instance to 0. ; [in]option: ""T"" means Time axis. . Definition at line 184 of file THLimitsFinder.cxx. ◆ OptimizeLimits(). void THLimitsFinder::OptimizeLimits ; (; Int_t ; nbins, . Int_t & ; newbins, . Double_t & ; xmin, . Double_t & ; xmax, . Bool_t ; isInteger . ). static . Optimize axis limits. ; When isInter=kTRUE, the function makes an integer binwidth and recompute the number of bins accordingly. ; Definition at line 367 of file THLimitsFinder.cxx. ◆ SetLimitsFinder(). void THLimitsFinder::SetLimitsFinder ; (; THLimitsFinder * ; finder). static . This static function can be used to specify a finder derived from THLimitsFinder. ; The finder may redefine the functions FindGoodLimits. Note that the redefined functions may call THLimitsFinder::FindGoodLimits. ; Definition at line 165 of file THLimitsFinder.cxx. ◆ Streamer(). void THLimitsFinder::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder. ◆ StreamerNVirtual(). void THLimitsFinder::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:15050,Optimiz,OptimizeLimits,15050,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,1,['Optimiz'],['OptimizeLimits']
Performance,"Handle &)=delete; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::~TFileOpenHandle~TFileOpenHandle() overrideDefinition TFile.h:375; TFileOpenHandle::GetCompressInt_t GetCompress() constDefinition TFile.h:380; TFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a bloc...Definition TFilePrefetch.h:33; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::fgBytesReadstatic std::atomic< Long64_t > fgBytesReadNumber of bytes read by all TFile objects.Definition TFile.h:131; TFile::fReadCallsInt_t fReadCallsNumber of read calls ( not counting the cache calls )Definition TFile.h:89; TFile::SetFileBytesWrittenstatic void SetFileBytesWritten(Long64_t bytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::GetSeekFreevirtual Long64_t GetSeekFree() constDefinition TFile.h:252; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:26655,CACHE,CACHEREAD,26655,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['CACHE'],['CACHEREAD']
Performance,"Handler.h. ◆ IsA(). TClass * THttpWSHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 114 of file THttpWSHandler.h. ◆ IsDisabled(). Bool_t THttpWSHandler::IsDisabled ; (; ); const. inline . Returns true when processing of websockets is disabled, set shortly before handler need to be destroyed. ; Definition at line 91 of file THttpWSHandler.h. ◆ IsSyncMode(). Bool_t THttpWSHandler::IsSyncMode ; (; ); const. inline . Returns processing mode of WS handler If sync mode is TRUE (default), all event processing and data sending performed in main thread All send functions are blocking and must be performed from main thread If sync mode is false, WS handler can be used from different threads and starts its own sending threads. ; Definition at line 72 of file THttpWSHandler.h. ◆ PerformSend(). Int_t THttpWSHandler::PerformSend ; (; std::shared_ptr< THttpWSEngine > ; engine). private . Perform send operation, stored in buffer. ; Definition at line 323 of file THttpWSHandler.cxx. ◆ ProcessBatchHolder(). virtual Bool_t THttpWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 56 of file THttpWSHandler.h. ◆ ProcessWS(). virtual Bool_t THttpWSHandler::ProcessWS ; (; THttpCallArg * ; arg). pure virtual . Implemented in ROOT::RWebWindowWSHandler. ◆ RemoveEngine(). void THttpWSHandler::RemoveEngine ; (; std::shared_ptr< THttpWSEngine > & ; engine, . Bool_t ; terminate = kFALSE . ). private . Remove and destroy WS connection. ; Definition at line 157 of file THttpWSHandler.cxx. ◆ RunSendingThrd(). Int_t THttpWSHandler::RunSendingThrd ; (; std::shared_ptr< THttpWSEngine > ; engine). private . Send data stored in the buffer. ; Returns:. 0 - when operation was executed immediately; 1 - when send operation will be performed in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:22159,Perform,Perform,22159,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['Perform'],['Perform']
Performance,"HasCounter ; (; ); const. virtual . Return true if any of underlying data has a array size counter. ; Reimplemented in TFormLeafInfoCollection, and TFormLeafInfoReference.; Definition at line 341 of file TFormLeafInfo.cxx. ◆ IsInteger(). bool TFormLeafInfo::IsInteger ; (; ); const. virtual . Return true if the underlying data is an integral value. ; Reimplemented in TFormLeafInfoMethod, and TFormLeafInfoReference.; Definition at line 374 of file TFormLeafInfo.cxx. ◆ IsReference(). virtual bool TFormLeafInfo::IsReference ; (; ); const. inlinevirtual . Reimplemented in TFormLeafInfoReference.; Definition at line 99 of file TFormLeafInfo.h. ◆ IsString(). bool TFormLeafInfo::IsString ; (; ); const. virtual . Return true if the underlying data is a string. ; Reimplemented in TFormLeafInfoNumerical, TFormLeafInfoMethod, and TFormLeafInfoReference.; Definition at line 351 of file TFormLeafInfo.cxx. ◆ LoadSizes(). void TFormLeafInfo::LoadSizes ; (; TBranch * ; branch). virtual . Load the current array sizes. ; Reimplemented in TFormLeafInfoMultiVarDim, TFormLeafInfoMultiVarDimCollection, and TFormLeafInfoMultiVarDimClones.; Definition at line 467 of file TFormLeafInfo.cxx. ◆ operator=(). TFormLeafInfo & TFormLeafInfo::operator= ; (; const TFormLeafInfo & ; orig). Exception safe assignment operator. ; Definition at line 98 of file TFormLeafInfo.cxx. ◆ ReadCounterValue(). Int_t TFormLeafInfo::ReadCounterValue ; (; char * ; where). virtual . Return the size of the underlying array for the current entry in the TTree. ; Reimplemented in TFormLeafInfoClones, TFormLeafInfoCollection, and TFormLeafInfoReference.; Definition at line 588 of file TFormLeafInfo.cxx. ◆ ReadTypedValue(). template<typename T > . T TFormLeafInfo::ReadTypedValue ; (; char * ; where, . Int_t ; instance = 0 . ). inline . Definition at line 124 of file TFormLeafInfo.h. ◆ ReadValue(). virtual Double_t TFormLeafInfo::ReadValue ; (; char * ; where, . Int_t ; instance = 0 . ). inlinevirtual . Reimplemented in TFor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormLeafInfo.html:25510,Load,Load,25510,doc/master/classTFormLeafInfo.html,https://root.cern,https://root.cern/doc/master/classTFormLeafInfo.html,1,['Load'],['Load']
Performance,"HasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the list of conversion streamerInfos.; 4257 ; 4258void TClass::ls(Option_t *options) const; 4259{; 4260 TNamed::ls(opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:159964,load,load,159964,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"HasTClassInit) {; 4267 if (fStreamerInfo->GetEntries() != 0) {; 4268 fState = TClass::kEmulated;; 4269 } else {; 4270 fState = TClass::kForwardDeclared;; 4271 }; 4272 } else {; 4273 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Resets the menu list to it's standard value.; 4309 ; 4310void TClass::ResetMenuList(); 4311{; 4312 if (fClassMenuList); 4313 fClassMenuList->Delete();; 4314 else; 4315 fClassMenuList = new TList();; 4316 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4317}; 4318 ; 4319////////////////////////////////////////////////////////////////////////////////; 4320/// The ls function lists the contents of a class on stdout. Ls output; 4321/// is typically much less verbose then Dump().; 4322/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4323/// and the list of conversion streamerInfos.; 4324 ; 4325void TClass::ls(Option_t *options) const; 4326{; 4327 TNamed::ls(opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:162715,load,load,162715,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"HasUUID enum valueTObject; kInconsistent enum valueTObject; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kKnown enum valueTInterpreter; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNoError enum valueTInterpreter; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kProcessing enum valueTInterpreter; kRecoverable enum valueTInterpreter; kSingleKey enum valueTObject; kUnknown enum valueTInterpreter; kWithClassDefInline enum valueTInterpreter; kWriteDelete enum valueTObject; kZombie enum valueTObject; Load(const char *filenam, Bool_t system=kFALSE)=0TInterpreterpure virtual; LoadEnums(TListOfEnums &cl) const =0TInterpreterpure virtual; LoadFile(const char *) constTInterpreterinlinevirtual; LoadFunctionTemplates(TClass *cl) const =0TInterpreterpure virtual; LoadLibraryMap(const char *rootmapfile=nullptr)=0TInterpreterpure virtual; LoadMacro(const char *filename, EErrorCode *error=nullptr)=0TInterpreterpure virtual; LoadText(const char *) constTInterpreterinlinevirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeInterpreterValue() constTInterpreterinlinevirtual; MakeZombie()TObjectinlineprotected; MapCppName(const char *) constTInterpreterinlinevirtual; MayNotUse(const char *method) constTObject; MembersMap_t typedefTInterpreter; MethodArgInfo_DefaultValue(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Delete(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Factory() constTInterpreterinlinevirtual; MethodArgInfo_Factory(MethodInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_FactoryCopy(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_IsValid(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Name(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Next(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Prope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter-members.html:21007,Load,LoadMacro,21007,doc/master/classTInterpreter-members.html,https://root.cern,https://root.cern/doc/master/classTInterpreter-members.html,1,['Load'],['LoadMacro']
Performance,"HasWS ; (; UInt_t ; wsid). inline . Return kTRUE if websocket with given ID exists. ; Definition at line 97 of file THttpWSHandler.h. ◆ IsA(). TClass * THttpWSHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 114 of file THttpWSHandler.h. ◆ IsDisabled(). Bool_t THttpWSHandler::IsDisabled ; (; ); const. inline . Returns true when processing of websockets is disabled, set shortly before handler need to be destroyed. ; Definition at line 91 of file THttpWSHandler.h. ◆ IsSyncMode(). Bool_t THttpWSHandler::IsSyncMode ; (; ); const. inline . Returns processing mode of WS handler If sync mode is TRUE (default), all event processing and data sending performed in main thread All send functions are blocking and must be performed from main thread If sync mode is false, WS handler can be used from different threads and starts its own sending threads. ; Definition at line 72 of file THttpWSHandler.h. ◆ PerformSend(). Int_t THttpWSHandler::PerformSend ; (; std::shared_ptr< THttpWSEngine > ; engine). private . Perform send operation, stored in buffer. ; Definition at line 323 of file THttpWSHandler.cxx. ◆ ProcessBatchHolder(). virtual Bool_t THttpWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 56 of file THttpWSHandler.h. ◆ ProcessWS(). virtual Bool_t THttpWSHandler::ProcessWS ; (; THttpCallArg * ; arg). pure virtual . Implemented in ROOT::RWebWindowWSHandler. ◆ RemoveEngine(). void THttpWSHandler::RemoveEngine ; (; std::shared_ptr< THttpWSEngine > & ; engine, . Bool_t ; terminate = kFALSE . ). private . Remove and destroy WS connection. ; Definition at line 157 of file THttpWSHandler.cxx. ◆ RunSendingThrd(). Int_t THttpWSHandler::RunSendingThrd ; (; std::shared_ptr< THttpWSEngine > ; engine). private . Send data st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:22051,Perform,PerformSend,22051,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['Perform'],['PerformSend']
Performance,"HashList.; 9268 // We must update hashlists if we change the name; 9269 TFile *file = nullptr;; 9270 TTreeCache *pf = nullptr;; 9271 if (fDirectory) {; 9272 fDirectory->Remove(this);; 9273 if ((file = GetCurrentFile())) {; 9274 pf = GetReadCache(file);; 9275 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9276 }; 9277 }; 9278 // This changes our hash value.; 9279 fName = name;; 9280 fTitle = title;; 9281 if (fDirectory) {; 9282 fDirectory->Append(this);; 9283 if (pf) {; 9284 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9285 }; 9286 }; 9287}; 9288 ; 9289////////////////////////////////////////////////////////////////////////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != dynamic_cast<TTreeCacheUnzip*>(pf)))) {; 9310 // done with opt and type are in agreement.; 9311 return;; 9312 }; 9313 delete pf;; 9314 auto cacheSize = GetCacheAutoSize(true);; 9315 if (opt) {; 9316 auto unzip = new TTreeCacheUnzip(this, cacheSize);; 9317 unzip->SetUnzipBufferSize( Long64_t(cacheSize * RelSize) );; 9318 } else {; 9319 pf = new TTreeCache(this, cacheSize);; 9320 }; 9321#else; 9322 (void)opt;; 9323 (void)RelSize;; 9324#endif; 9325}; 9326 ; 9327////////////////////////////////////////////////////////////////////////////////; 9328/// Set perf stats; 9329 ; 9330void TTree::SetPerfStats(TVirtualPerfStats *perf); 9331{; 9332 fPerfStats = perf;; 9333}; 9334 ; 9335////////////////////////////////////////////////////////////////////////////////; 9336/// The current TreeIndex is replaced by the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:359362,Load,LoadTree,359362,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"Header; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet*_ccdCloneSet; Bool_t_ccdRefresh; RooSuperCategory*_ccdSuperSuperCategory of Common category dependents; Double_t*_ccdTable; RooArgSet_commonCatsCommon category dependents; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; TIterator*_gcIter! Iterator over gcList; TList_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; RooArgSet_ownedMultiProdsOwned auxilary multi-term product PDFs; const RooProdPdf*_pdfOriginal PDF; RooRealIntegral*_pdfCcdInt; RooAbsPdf*_pdfClone; RooArgSet*_pdfCloneSet; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-time initialization of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdGenContext.html:8130,load,load,8130,root/html526/RooProdGenContext.html,https://root.cern,https://root.cern/root/html526/RooProdGenContext.html,1,['load'],['load']
Performance,"Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: myTreeOrChain.GetTree()->PrintCacheStats();. Definition at line 32 of file TTreeCache.h. Classes; struct  IOPos;  ; struct  MissCache;  . Public Types; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x0800",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:10381,cache,cache,10381,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit and it assumes now that the; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__Fitter.html:11489,perform,performing,11489,root/html530/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html,1,['perform'],['performing']
Performance,"Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:12904,perform,performing,12904,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,3,['perform'],['performing']
Performance,"Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. » Author: L. Moneta Wed Aug 30 11:05:19 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Fitter.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2010-11-19 17:34; This page has be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__Fitter.html:7327,perform,performing,7327,root/html528/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__Fitter.html,1,['perform'],['performing']
Performance,"HiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. void DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. void LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:27744,Load,LoadWeights,27744,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['Load'],"['LoadWeights', 'Loads']"
Performance,Hist! Histogram recording number of calls per convolution integral calculation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF ; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:36305,cache,cache,36305,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"Hist!histogram of latency due to packet requests; TVirtualMonitoringWriter*fMonitoringWriter!Monitoring engine; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Connect to SQL server and register query log used for quotas.; The proofquerylog table has the format:; CREATE TABLE proofquerylog (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; user VARCHAR(32) NOT NULL,; group VARCHAR(32),; begin DATETIME,; end DATETIME,; walltime INT,; cputime FLOAT,; bytesread BIGINT,; events BIGINT,; workers INT; ); The same info ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfStats.html:7698,latency,latency,7698,root/html528/TPerfStats.html,https://root.cern,https://root.cern/root/html528/TPerfStats.html,1,['latency'],['latency']
Performance,"HnSparse::Add(). void Add(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consist binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnSparses. All THnSparses provided; in the list must have the same bin layout!. void Multiply(const THnSparse* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:22145,Perform,Performs,22145,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,3,['Perform'],['Performs']
Performance,"Hook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3519,cache,cache,3519,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:26179,Load,LoadClass,26179,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['Load'],['LoadClass']
Performance,"HttpTerminator (const char *start, const char *peeked, Int_t peeklen);  Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new line [\r]\n. ;  ; void Init (Bool_t readHeadOnly) override;  Initialize a TWebFile object. ;  ; virtual void ProcessHttpHeader (const TString &headerLine);  Process the HTTP header in the argument. ;  ; virtual Bool_t ReadBuffer10 (char *buf, Int_t len);  Read specified byte range from remote file via HTTP 1.0 daemon (without mod-root installed). ;  ; virtual Bool_t ReadBuffers10 (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read specified byte ranges from remote file via HTTP 1.0 daemon (without mod-root installed). ;  ; virtual void SetMsgReadBuffer10 (const char *redirectLocation=nullptr, Bool_t tempRedirect=kFALSE);  Set GET command for use by ReadBuffer(s)10(), handle redirection if needed. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:31446,cache,cache,31446,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cache']
Performance,"ID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:. fLocalMaster transform; fColor; fTransparency. attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. If either does not meet this requirement the object may not be displayed.; 9.13.4.8 Scene Rebuilds; TBuffer3D::AddObject is not an explicit command to the viewer - it may for various reasons decide to ignore it:. It already has the object internally cached.; The object falls outside some ‘interest’ limits of the viewer camera.; The object is too small to be worth drawing. In all these cases TBuffer3D::AddObject() returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:415603,cache,cached,415603,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['cache'],['cached']
Performance,"IGradientFunctionOneDim : virtual public IBaseFunctionOneDim {; 255 ; 256 public:; 257 ; 258 typedef IBaseFunctionOneDim BaseFunc;; 259 typedef IGradientFunctionOneDim BaseGrad;; 260 ; 261 /// Return the derivative of the function at a point x; 262 /// Use the private method DoDerivative; 263 double Derivative(double x) const { return DoDerivative(x); }; 264 ; 265 /// Compatibility method with multi-dimensional interface for partial derivative.; 266 double Derivative(const double *x) const { return DoDerivative(*x); }; 267 ; 268 /// Compatibility method with multi-dimensional interface for Gradient.; 269 void Gradient(const double *x, double *g) const { g[0] = DoDerivative(*x); }; 270 ; 271 /// Optimized method to evaluate at the same time the function value and derivative at a point x.; 272 /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; 273 /// Derived class should implement this method if performances play an important role and if it is faster to; 274 /// evaluate value and derivative at the same time.; 275 virtual void FdF(double x, double &f, double &df) const; 276 {; 277 f = operator()(x);; 278 df = Derivative(x);; 279 }; 280 ; 281 /// Compatibility method with multi-dimensional interface for Gradient and function evaluation.; 282 void FdF(const double *x, double &f, double *df) const { FdF(*x, f, *df); }; 283 ; 284 bool HasGradient() const override { return true; }; 285 ; 286 private:; 287 ; 288 /// Function to evaluate the derivative with respect each coordinate. To be implemented by the derived class.; 289 virtual double DoDerivative(double x) const = 0;; 290 };; 291 ; 292 ; 293 ; 294 } // namespace Math; 295} // namespace ROOT; 296 ; 297#endif /* ROOT_Math_IFunction */; IFunctionfwd.h; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/IFunction_8h_source.html:12183,perform,performances,12183,doc/master/IFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/IFunction_8h_source.html,1,['perform'],['performances']
Performance,"IN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Long64_t fBytesWrite {0};  Number of bytes written to this file. ;  ; TFileCacheRead * fCacheRead {nullptr};  !Pointer to the read cache (if any) ;  ; TMap * fCacheReadMap {nullptr};  !Pointer to the read cache (if any) ;  ; TFileCacheWrite * fCacheWrite {nullptr};  !Pointer to the write cache (if any) ;  ; TArrayC * fClassIndex {nullptr};  !Index of TStreamerInfo classes written to this file ;  ; Int_t fCompress {0};  Compression level and algorithm. ;  ; Int_t fD {-1};  File descriptor. ;  ; Long64_t fEND {0};  Last used byte in file. ;  ; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes for StreamerInfo record. ;  ; Bool_t fNoAnchorInName {kFALSE};  !True if we don't want to force the anchor to be appended to the file name ;  ; Int_t fNProcessIDs {0};  Number of TProcessID written to this file. ;  ; Long64_t fOffset {0};  !Seek offset cache ;  ; TList * fOpenPhases {nullptr};  !Time info about open phases ;  ; TString fOption;  File options. ;  ; TObjArray * fProcessIDs {nullptr};  !Array of pointers to TProcessIDs ;  ; Int_t fReadCalls {0};  Number of read calls ( not counting the cache calls ) ;  ; TString fR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:38456,Cache,Cached,38456,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['Cache'],['Cached']
Performance,"INE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static THLimitsFinder * GetLimitsFinder ();  Return pointer to the current finder. ;  ; static void Optimize (Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""");  Static function to compute reasonable axis limits. ;  ; static void OptimizeLimits (Int_t nbins, Int_t &newbins, Double_t &xmin, Double_t &xmax, Bool_t isInteger);  Optimize axis limits. ;  ; static void SetLimitsFinder (THLimitsFinder *finder);  This static function can be used to specify a finder derived from THLimitsFinder. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Static Protected Attributes; static THLimitsFinder * fgLimitsFinder = nullptr;  ! Pointer to hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:9200,Optimiz,Optimize,9200,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,1,['Optimiz'],['Optimize']
Performance,"INE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TString GetPathName (TObject *o);  Return the path name contained in object 'o' allowing for TUrl, TObjString or TFileInfo. ;  ; static TFileStager * Open (const char *stager);  Open a stager, after having loaded the relevant plug-in. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileStager.html:10148,load,loaded,10148,doc/master/classTFileStager.html,https://root.cern,https://root.cern/doc/master/classTFileStager.html,1,['load'],['loaded']
Performance,"INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_genPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_genPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DataStore pxData_binned (Generated From px_binned); Contains 40 entries; Observables: ; 1) x = 9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf403__weightedevts_8C.html:12495,optimiz,optimization,12495,doc/master/rf403__weightedevts_8C.html,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html,8,['optimiz'],['optimization']
Performance,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnixSystem.html:42807,load,load,42807,root/html604/TUnixSystem.html,https://root.cern,https://root.cern/root/html604/TUnixSystem.html,3,['load'],['load']
Performance,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:42807,load,load,42807,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,3,['load'],['load']
Performance,"IT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits. Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions. ; Fumili: library providing the implementation of the original Fumili fitting algorithm. Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:. Matrix: general matrix package providing matrix TMatrix and vector TVector classes and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/MATH_Index.html:2950,optimiz,optimization,2950,root/html602/MATH_Index.html,https://root.cern,https://root.cern/root/html602/MATH_Index.html,2,['optimiz'],['optimization']
Performance,"ITOR) will be started.; This command is extremely versatile. You may want to have a couple of aliases defined in your .gitconfig file (see attached gitconfig for ideas). Working in your local repository. Obtain differences with; git status. Move files from one part of your directory tree to another:; git mv <old-path> <new-path>. Delete unwanted tracked files:; git rm <path>. Add un-tracked files:; git add <un-tracked-file>. Stage a modified file for commit:; git add <file>. Commit currently-staged files:; git commit -m <log-message>. Commit only specific files (regardless of what is staged):; git commit -m <log-message>. Commit all modified files:; git commit -a -m <log-message>. Un-stage a previously staged (but not yet committed) file:; git reset HEAD <file>. Examine a representation of your change tree with log files and patch descriptions:; gitk. Get differences with respect to the committed (or staged) version of a file:; git diff <file>. Get differences between local file and committed version:; git diff --cached <file>. Basic interaction with local branches. Create (but do not switch to) a new local branch based on the current branch:; git branch <new-branch>. Create and switch to a local branch based on the current branch:; git checkout -b <new-branch>. Change to an existing local branch:; git checkout <branch>. Examine the list of commits in the current branch not reflected in another branch:; git cherry -v <branch>. Merge another branch into the current one:; git merge <branch>. Delete a local branch (eg after merging):; git branch -d <branch>. OR (if changes have not been completely merged but you're sure you want to delete anyway):; git branch -D <branch>. Basic interaction with a remote branch; Assuming you created your local repository with git clone, there is already one configured remote origin and you will have a local branch for each remote branch that existed at the time of your last pull or clone. Get the current list of remotes (including URIs) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:8300,cache,cached,8300,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['cache'],['cached']
Performance,"IdMap()TClassprivatestatic; GetDelete() constTClass; GetDeleteArray() constTClass; GetDestructor() constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForPairElements(TCollection &result, TCollecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9523,load,load,9523,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec, it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more information on those variables.; This method is used to implement the following feature:; Synopsis:; The purpose of this addition is to allow the user to use an external compiler to create a shared library from its C++ macro (scripts). Currently in order to execute a script, a user has to type at the root prompt .X myfunc.C(arg1,arg2); We allow them to type: .X myfunc.C++(arg1,arg2); or .X myfunc.C+(arg1,arg2); In which case an external compiler will be called to create a shared library. This shared library will then be loaded and the function myfunc will be called with the two arguments. With '++' the shared library is always recompiled. With '+' the shared library is recompiled only if it does not exist yet or the macro file is newer than the shared library.; Of course the + and ++ notation is supported in similar way for .x and .L.; Through the function TSystem::SetMakeSharedLib(), the user will be able to indicate, with shell commands, how to build a shared library (a good default will be provided). The most common change, namely where to find header files, will be available through the function TSystem::SetIncludePath(). A good default will be provided so that a typical user session should be at most: root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:43720,load,loaded,43720,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24193,load,load,24193,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"IgnoreInclude (const char *fname, const char *expandedfname);  Return 1 if the name of the given include file corresponds to a class that is known to ROOT, e.g. ;  ; TClass * IsA () const override;  ; Bool_t IsBatch () const;  ; Bool_t IsEscaped () const;  ; Bool_t IsExecutingMacro () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsInterrupted () const;  ; Bool_t IsLineProcessing () const;  ; Bool_t IsProofServ () const;  ; Bool_t IsRootFile (const char *filename) const;  Return true if the file is local and is (likely) to be a ROOT file. ;  ; Bool_t IsWebDisplay () const;  ; Bool_t IsWebDisplayBatch () const;  ; Int_t LoadClass (const char *classname, const char *libname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:10323,Load,LoadClass,10323,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,2,['Load'],['LoadClass']
Performance,"Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a class (autoload mechanism), see the AutoLoad() methods below. ; Implements TInterpreter.; Definition at line 5741 of file TCling.cxx. ◆ LoadMacro(). void TCling::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). finalvirtual . Load a macro file in cling's memory. ; Implements TInterpreter.; Definition at line 3552 of file TCling.cxx. ◆ LoadPCM(). void TCling::LoadPCM ; (; std::string ; pcmFileNameFullPath). private . Tries to load a rdict PCM, issues diagnostics if it fails. ; Definition at line 1811 of file TCling.cxx. ◆ LoadPCMImpl(). void TCling::LoadPCMImpl ; (; TFile & ; pcmFile). private . Tries to load a PCM from TFile; returns true on success. ; Definition at line 1696 of file TCling.cxx. ◆ LoadText(). Bool_t TCling::LoadText ; (; const char * ; text); const. finalvirtual . Load the declarations from text into the interpreter. ; Note that this cannot be (top level) statements; text must contain top level declarations. Returns true on success, false on failure. ; Reimplemented from TInterpreter.; Definition at line 7515 of file TCling.cxx. ◆ MakeInterpreterValue(). std::unique_ptr< TInterpreterValue > TCling::MakeInterpreterValue ; (; ); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7663 of file TCling.cxx. ◆ MapCppName(). const char * TCling::MapCppName ; (; const char * ; name); const. finalvirtual . Interface to cling function. ; Reimplemented from TInterpreter.; Definition at line 7523 of file TCling.cxx. ◆ MethodArgInfo_DefaultValue(). const char * TCling::MethodArgInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:114504,Load,LoadPCMImpl,114504,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadPCMImpl']
Performance,"Implements TVirtualTreePlayer.; Definition at line 2968 of file TTreePlayer.cxx. ◆ Streamer(). void TTreePlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TTreePlayer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 130 of file TTreePlayer.h. ◆ UnbinnedFit(). Int_t TTreePlayer::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection, . Option_t * ; option, . Long64_t ; nentries, . Long64_t ; firstentry . ). overridevirtual . Unbinned fit of one or more variable(s) from a Tree. ; funcname is a TF1 function.; See TTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing); option = ""V"" Verbose mode (default is between Q and V); option = ""E"" Perform better Errors estimation using Minos technique; option = ""M"" More. Improve fit results; option = ""D"" Draw the projected histogram with the fitted function normalized to the number of selected rows and multiplied by the bin width. You can specify boundary limits for some or all parameters via func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do: func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100.; For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter settings. Otherwise the fit will effectively just maximize the area.; It is man",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:50779,Perform,Perform,50779,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['Perform'],['Perform']
Performance,"InCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGPicture.h>. Inheritance diagram for TGPicturePool:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGPicturePool() [1/2]. TGPicturePool::TGPicturePool ; (; const TGPicturePool & ; pp). protected . copy constructor ; Definition at line 56 of file TGPicture.cxx. ◆ TGPicturePool() [2/2]. TGPicturePool::TGPicturePool ; (; const TGClient * ; client, . const char * ; path . ). inline . Definition at line 100 of file TGPicture.h. ◆ ~TGPicturePool(). TGPicturePool::~TGPicturePool ; (; ). override . Delete picture cache. ; Definition at line 293 of file TGPicture.cxx. Member Function Documentation. ◆ Class(). static TClass * TGPicturePool::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGPicturePool::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGPicturePool::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 113 of file TGPicture.h. ◆ DeclFileName(). static const char * TGPicturePool::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 113 of file TGPicture.h. ◆ FreePicture(). void TGPicturePool::FreePicture ; (; const TGPicture * ; pic). Remove picture from cache if nobody is using it anymore. ; Definition at line 277 of file TGPicture.cxx. ◆ GetPath(). const char * TGPicturePool::GetPath ; (; ); const. inline . Definition at line 104 of file TGPicture.h. ◆ GetPicture() [1/4]. c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGPicturePool.html:11478,cache,cache,11478,doc/master/classTGPicturePool.html,https://root.cern,https://root.cern/doc/master/classTGPicturePool.html,1,['cache'],['cache']
Performance,"IncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTemporary(const TInterpreterValue &value)Definition TCling.cxx:7687; TCling::fInitialMutexMutexStateAndRecurseCount fInitialMutexDefinition TCling.h:174; TCling::GetSharedLibsconst char * GetSharedLibs() finalReturn the list of shared libraries loaded into the process.Definition TCling.cxx:6989; TCling::MethodArgInfo_Nextint MethodArgInfo_Next(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9280; TCling::SnapshotMutexStatevoid SnapshotMutexState(ROOT::TVirtualRWMutex *mtx) finalDefinition TCling.cxx:9603; TCling::TypeInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template described by ft_info.Definition TCling.cxx:8860; TCling::fTemporariesstd::vector< cling::Value > * fTemporariesDefinition TCling.h:133; TCling::RegisterModulevoid RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *paylo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:442185,load,loaded,442185,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"IncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTemporary(const TInterpreterValue &value)Definition TCling.cxx:7687; TCling::fInitialMutexMutexStateAndRecurseCount fInitialMutexDefinition TCling.h:174; TCling::GetSharedLibsconst char * GetSharedLibs() finalReturn the list of shared libraries loaded into the process.Definition TCling.cxx:6989; TCling::MethodArgInfo_Nextint MethodArgInfo_Next(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9280; TCling::SnapshotMutexStatevoid SnapshotMutexState(ROOT::TVirtualRWMutex *mtx) finalDefinition TCling.cxx:9603; TCling::TypeInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::kNullArgvstatic constexpr const char * kNullArgv[]Definition TCling.h:185; TCling::TCling__RegisterRdictForLoadPCMfriend void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Definition TCling.cxx:588; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template describ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:68539,load,loaded,68539,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"Increment (Double_t dalpha);  ;  Public Member Functions inherited from TMVA::IPruneTool;  IPruneTool ();  ; virtual ~IPruneTool ();  ; Double_t GetPruneStrength () const;  ; Bool_t IsAutomatic () const;  ; void SetAutomatic ();  ; void SetPruneStrength (Double_t alpha);  . Private Member Functions; Int_t CountNodes (DecisionTreeNode *node, Int_t icount=0);  ; void FindListOfNodes (DecisionTreeNode *node);  recursive pruning of nodes using the Expected Error Pruning (EEP) ;  ; Double_t GetNodeError (DecisionTreeNode *node) const;  Calculate an UPPER limit on the error made by the classification done by this node. ;  ; Double_t GetSubTreeError (DecisionTreeNode *node) const;  calculate the expected statistical error on the subtree below ""node"" which is used in the expected error pruning ;  ; MsgLogger & Log () const;  . Private Attributes; Double_t fDeltaPruneStrength;  ! the stepsize for optimizing the pruning strength parameter ;  ; MsgLogger * fLogger;  ! message logger ;  ; Double_t fNodePurityLimit;  ! the purity limit for labelling a terminal node as signal ;  ; std::vector< DecisionTreeNode * > fPruneSequence;  ! the (optimal) prune sequence ;  . Additional Inherited Members;  Public Types inherited from TMVA::IPruneTool; typedef std::vector< const Event * > EventSample;  ;  Protected Attributes inherited from TMVA::IPruneTool; Double_t B;  ; Double_t fPruneStrength;  ! regularization parameter in pruning ;  ; Double_t S;  . #include <TMVA/ExpectedErrorPruneTool.h>. Inheritance diagram for TMVA::ExpectedErrorPruneTool:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ExpectedErrorPruneTool(). TMVA::ExpectedErrorPruneTool::ExpectedErrorPruneTool ; (; ). Definition at line 62 of file ExpectedErrorPruneTool.cxx. ◆ ~ExpectedErrorPruneTool(). TMVA::ExpectedErrorPruneTool::~ExpectedErrorPruneTool ; (; ). virtual . Definition at line 71 of file ExpectedErrorPruneTool.cxx. Member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html:2222,optimiz,optimizing,2222,doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ExpectedErrorPruneTool.html,1,['optimiz'],['optimizing']
Performance,"Info (TVirtualStreamerInfo *info, Bool_t force)=0;  ; virtual void ForceWriteInfoClones (TClonesArray *a)=0;  ; virtual Int_t GetBufferDisplacement () const =0;  ; Int_t GetBufferVersion () const;  ; char * GetCurrent () const;  ; virtual TVirtualStreamerInfo * GetInfo ()=0;  ; virtual TProcessID * GetLastProcessID (TRefTable *reftable) const =0;  ; virtual Int_t GetMapCount () const =0;  ; virtual void GetMappedObject (UInt_t tag, void *&ptr, TClass *&ClassPtr) const =0;  ; TObject * GetParent () const;  Return pointer to parent of this buffer. ;  ; virtual UShort_t GetPidOffset () const =0;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; virtual UInt_t GetTRefExecId ()=0;  ; virtual Int_t GetVersionOwner () const =0;  ; virtual void IncrementLevel (TVirtualStreamerInfo *info)=0;  ; virtual void InitMap ()=0;  ; TClass * IsA () const override;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual void MapObject (const TObject *obj, UInt_t offset=1)=0;  ; virtual void MapObject (const void *obj, const TClass *cl, UInt_t offset=1)=0;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; virtual Int_t ReadArray (Bool_t *&b)=0;  ; virtual Int_t ReadArray (Char_t *&c)=0;  ; virtual Int_t ReadArray (Double_t *&d)=0;  ; virtual Int_t ReadArray (Float_t *&f)=0;  ; virtual Int_t ReadArray (Int_t *&i)=0;  ; virtual Int_t ReadArray (Long64_t *&l)=0;  ; virtual Int_t ReadArray (Long_t *&l)=0;  ; virtual Int_t ReadArray (Short_t *&h)=0;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:4291,cache,cache,4291,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['cache'],['cache']
Performance,"Info *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ; 5693////////////////////////////////////////////////////////////////////////////////; 5694/// Set pointer to current TVirtualStreamerInfo; 5695 ; 5696void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5697{; 5698 fCurrentInfo = info;; 5699}; 5700 ; 5701////////////////////////////////////////////////////////////////////////////////; 5702/// Return size of object of this class.; 5703 ; 5704Int_t TClass::Size() const; 5705{; 5706 if (fSizeof!=-1) return fSizeof;; 5707 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5708 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5709 return GetStreamerInfo()->GetSize();; 5710}; 5711 ; 5712////////////////////////////////////////////////////////////////////////////////; 5713/// Load class description from I/O buffer and return class object.; 5714 ; 5715TClass *TClass::Load(TBuffer &b); 5716{; 5717 UInt_t maxsize = 256;; 5718 char *s = new char[maxsize];; 5719 ; 5720 Int_t pos = b.Length();; 5721 ; 5722 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5723 while (strlen(s) == (maxsize - 1)) {; 5724 // The classname is too large, try again with a large buffer.; 5725 b.SetBufferOffset(pos);; 5726 maxsize = 2*maxsize;; 5727 delete [] s;; 5728 s = new char[maxsize];; 5729 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5730 }; 5731 ; 5732 TClass *cl = TClass::GetClass(s, kTRUE);; 5733 if (!cl); 5734 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5735 ; 5736 delete [] s;; 5737 return cl;; 5738}; 5739 ; 5740////////////////////////////////////////////////////////////////////////////////; 5741/// Helper function used by TClass::GetClass().; 5742/// This function attempts to load the dictionary for 'classname'; 5743/// either from the TClassTable or from the list of generator.; 5744/// If silent is 'true', do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:218976,Load,Load,218976,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"Info *)(fStreamerInfo->At(fClassVersion));; 5756 }; 5757 return fCurrentInfo;; 5758}; 5759 ; 5760////////////////////////////////////////////////////////////////////////////////; 5761/// Set pointer to current TVirtualStreamerInfo; 5762 ; 5763void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5764{; 5765 fCurrentInfo = info;; 5766}; 5767 ; 5768////////////////////////////////////////////////////////////////////////////////; 5769/// Return size of object of this class.; 5770 ; 5771Int_t TClass::Size() const; 5772{; 5773 if (fSizeof!=-1) return fSizeof;; 5774 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5775 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5776 return GetStreamerInfo()->GetSize();; 5777}; 5778 ; 5779////////////////////////////////////////////////////////////////////////////////; 5780/// Load class description from I/O buffer and return class object.; 5781 ; 5782TClass *TClass::Load(TBuffer &b); 5783{; 5784 UInt_t maxsize = 256;; 5785 char *s = new char[maxsize];; 5786 ; 5787 Int_t pos = b.Length();; 5788 ; 5789 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5790 while (strlen(s) == (maxsize - 1)) {; 5791 // The classname is too large, try again with a large buffer.; 5792 b.SetBufferOffset(pos);; 5793 maxsize = 2*maxsize;; 5794 delete [] s;; 5795 s = new char[maxsize];; 5796 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5797 }; 5798 ; 5799 TClass *cl = TClass::GetClass(s, kTRUE);; 5800 if (!cl); 5801 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5802 ; 5803 delete [] s;; 5804 return cl;; 5805}; 5806 ; 5807////////////////////////////////////////////////////////////////////////////////; 5808/// Helper function used by TClass::GetClass().; 5809/// This function attempts to load the dictionary for 'classname'; 5810/// either from the TClassTable or from the list of generator.; 5811/// If silent is 'true', do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:221727,Load,Load,221727,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"Info() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasDefaultConstructor() const; virtual ULong_tTNamed::Hash() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:8387,Load,Load,8387,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['Load'],['Load']
Performance,"Info->fType+TStreamerInfo::kSkip,aElement,n,0);; 1643 } else {; 1644 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1645 void *cached_start = (*cached)[0];; 1646 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1647 config->fAction(b,cached_start,cached_end,&cached_config);; 1648 }; 1649 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1650 if (config->fNeedRepeat) {; 1651 b.SetBufferOffset(bufpos);; 1652 }; 1653 return 0;; 1654 }; 1655 ; 1656 INLINE_TEMPLATE_ARGS Int_t UseCacheGenericCollection(TBuffer &b, void *, const void *, const TLoopConfiguration *loopconfig, const TConfiguration *conf); 1657 {; 1658 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1659 ; 1660 Int_t bufpos = b.Length();; 1661 TVirtualArray *cached = b.PeekDataCache();; 1662 if (cached==0) {; 1663 TStreamerElement *aElement = config->fCompInfo->fElem;; 1664 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1665 ; 1666 TVirtualCollectionProxy *proxy = ((TGenericLoopConfig*)loopconfig)->fProxy;; 1667 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1668 UInt_t n = proxy->Size();; 1669 info->ReadBufferSkip(b, *proxy,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1670 } else {; 1671 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1672 void *cached_start = (*cached)[0];; 1673 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1674 config->fAction(b,cached_start,cached_end,&cached_config);; 1675 }; 1676 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1677 if (config->fNeedRepeat) {; 1678 b.SetBufferOffset(bufpos);; 1679 }; 1680 return 0;; 1681 }; 1682 ; 1683 // Support for collections.; 1684 ; 1685 Int_t ReadLoopInvalid(TBuffer &, void *, const void *, const TConfiguration *config); 1686 {; 1687 Fatal(""ApplySequence"",""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:68980,cache,cached,68980,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"Info::IsOptimized() const; Int_tTVirtualStreamerInfo::IsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidTVirtualStreamerInfo::Optimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; voidPrintValueClones(const char* name, TClonesArray* clones, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; voidPrintValueSTL(const char* name, TVirtualCollectionProxy* cont, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; virtual Int_tTObject::Read(const char* name); Int_tReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset); Int_tReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:7596,Optimiz,Optimize,7596,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,1,['Optimiz'],['Optimize']
Performance,"InfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::MustFlushvirtual Bool_t MustFlush() constDefinition TFile.h:269; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallss",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:46153,cache,cacheDir,46153,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"Info_Factory(ClassInfo_t *, ClassInfo_t *) constDefinition TInterpreter.h:442; TInterpreter::FuncTempInfo_TemplateMinReqArgsvirtual UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const =0; TInterpreter::GetDeclIdvirtual DeclId_t GetDeclId(FuncTempInfo_t *info) const =0; TInterpreter::TypedefInfo_Factoryvirtual TypedefInfo_t * TypedefInfo_Factory(const char *) constDefinition TInterpreter.h:541; TInterpreter::AddIncludePathvirtual void AddIncludePath(const char *path)=0; TInterpreter::ResetGlobalVarvirtual void ResetGlobalVar(void *obj)=0; TInterpreter::IsLoadedvirtual Bool_t IsLoaded(const char *filename) const =0; TInterpreter::ClassInfo_TmpltNamevirtual const char * ClassInfo_TmpltName(ClassInfo_t *) constDefinition TInterpreter.h:436; TInterpreter::IsPointerTypevirtual Bool_t IsPointerType(const void *) constDefinition TInterpreter.h:558; TInterpreter::SetProcessLineLockvirtual void SetProcessLineLock(Bool_t lock=kTRUE)=0; TInterpreter::Loadvirtual Int_t Load(const char *filenam, Bool_t system=kFALSE)=0; TInterpreter::TypeInfo_Factoryvirtual TypeInfo_t * TypeInfo_Factory(const char *) constDefinition TInterpreter.h:526; TInterpreter::CallFunc_GetWrapperCodevirtual std::string CallFunc_GetWrapperCode(CallFunc_t *func) const =0; TInterpreter::ClassInfo_Propertyvirtual Long_t ClassInfo_Property(ClassInfo_t *) constDefinition TInterpreter.h:429; TInterpreter::Evaluatevirtual int Evaluate(const char *, TInterpreterValue &)Definition TInterpreter.h:281; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Int_t param) constDefinition TInterpreter.h:342; TInterpreter::TypeInfo_Factoryvirtual TypeInfo_t * TypeInfo_Factory() constDefinition TInterpreter.h:525; TInterpreter::MethodInfo_NDefaultArgvirtual int MethodInfo_NDefaultArg(MethodInfo_t *) constDefinition TInterpreter.h:495; TInterpreter::LoadFunctionTemplatesvirtual void LoadFunctionTemplates(TClass *cl) const =0; TInterpreter::IsUnsignedIntegerTypevirtual Bool_t IsUnsignedIntegerType(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:53729,Load,Loadvirtual,53729,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,2,['Load'],"['Load', 'Loadvirtual']"
Performance,"Inheritance Chart:. TObject. ←; TQpVar. Function documentation; TQpVar(); Default constructor. TQpVar(TVectorD& x_in, TVectorD& s_in, TVectorD& y_in, TVectorD& z_in, TVectorD& v_in, TVectorD& gamma_in, TVectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); Constructor. TQpVar(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpVar(const TQpVar& another); Copy constructor. Double_t GetMu(); compute complementarity gap, obtained by taking the inner product of the; complementary vectors and dividing by the total number of components; computes mu = (t'lambda +u'pi + v'gamma + w'phi)/(mclow+mcupp+nxlow+nxupp). Double_t MuStep(TQpVar* step, Double_t alpha); Compute the complementarity gap resulting from a step of length ""alpha"" along; direction ""step"". void Saxpy(TQpVar* b, Double_t alpha); Perform a ""saxpy"" operation on all data vectors : x += alpha*y. void Negate(); Perform a ""negate"" operation on all data vectors : x = -x. Double_t StepBound(TQpVar* b); calculate the largest alpha in (0,1] such that the/ nonnegative variables stay; nonnegative in the given search direction. In the general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpVar.html:8872,Perform,Perform,8872,root/html602/TQpVar.html,https://root.cern,https://root.cern/root/html602/TQpVar.html,2,['Perform'],['Perform']
Performance,"Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0); constructor from pdf and parameters; the pdf must contain eventually the nuisance parameters. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); construct from a ModelConfig. Assume data model.GetPdf() will provide full description of model including; constraint term on the nuisances parameters. ~ProfileLikelihoodCalculator(); destructor; cannot delete prod pdf because it will delete all the composing pdf's; if (fOwnPdf) delete fPdf;; fPdf = 0;. void DoReset() const; reset and clear fit result; to be called when a new model or data are set in the calculator. RooAbsReal * DoGlobalFit() const; perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. RooFitResult * DoMinimizeNLL(RooAbsReal* nll); Minimizer the given NLL using the default options. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. ProfileLikelihoodCalculator(); default constructor (needed for I/O). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html:7723,perform,perform,7723,root/html602/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html,2,['perform'],['perform']
Performance,"Inherited Members; Includes; Libraries. Function documentation; TQpVar(); Default constructor. TQpVar(TVectorD& x_in, TVectorD& s_in, TVectorD& y_in, TVectorD& z_in, TVectorD& v_in, TVectorD& gamma_in, TVectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); Constructor. TQpVar(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpVar(const TQpVar& another); Copy constructor. Double_t GetMu(); compute complementarity gap, obtained by taking the inner product of the; complementary vectors and dividing by the total number of components; computes mu = (t'lambda +u'pi + v'gamma + w'phi)/(mclow+mcupp+nxlow+nxupp). Double_t MuStep(TQpVar* step, Double_t alpha); Compute the complementarity gap resulting from a step of length ""alpha"" along; direction ""step"". void Saxpy(TQpVar* b, Double_t alpha); Perform a ""saxpy"" operation on all data vectors : x += alpha*y. void Negate(); Perform a ""negate"" operation on all data vectors : x = -x. Double_t StepBound(TQpVar* b); calculate the largest alpha in (0,1] such that the/ nonnegative variables stay; nonnegative in the given search direction. In the general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpVar.html:8126,Perform,Perform,8126,root/html528/TQpVar.html,https://root.cern,https://root.cern/root/html528/TQpVar.html,4,['Perform'],['Perform']
Performance,"InitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; const ROOT::Minuit2::ParametricFunction*fModelFunction; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient(). Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id: FumiliFCNBase.h 23522 2008-04-24 15:09:19Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__FumiliFCNBase.html:2875,cache,cached,2875,root/html526/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__FumiliFCNBase.html,1,['cache'],['cached']
Performance,InitTMinuit ; (; int ; ndim). protected . initialize the TMinuit instance ; Definition at line 117 of file TMinuitMinimizer.cxx. ◆ IsA(). virtual TClass * TMinuitMinimizer::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 272 of file TMinuitMinimizer.h. ◆ IsFixedVariable(). bool TMinuitMinimizer::IsFixedVariable ; (; unsigned int ; ivar); const. overridevirtual . query if an existing variable is fixed (i.e. ; considered constant in the minimization) note that by default all variables are not fixed ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 404 of file TMinuitMinimizer.cxx. ◆ MinGradient(). const double * TMinuitMinimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 123 of file TMinuitMinimizer.h. ◆ Minimize(). bool TMinuitMinimizer::Minimize ; (; ). overridevirtual . method to perform the minimization ; Implements ROOT::Math::Minimizer.; Definition at line 440 of file TMinuitMinimizer.cxx. ◆ MinosStatus(). int TMinuitMinimizer::MinosStatus ; (; ); const. inlineoverridevirtual . minos status code of last Minos run minos status = -1 : Minos is not run = 0 : last MINOS run was successful > 0 : some problems encountered when running MINOS ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 182 of file TMinuitMinimizer.h. ◆ MinValue(). double TMinuitMinimizer::MinValue ; (; ); const. overridevirtual . return minimum function value ; Implements ROOT::Math::Minimizer.; Definition at line 644 of file TMinuitMinimizer.cxx. ◆ NCalls(). unsigned int TMinuitMinimizer::NCalls ; (; ); const. overridevirtual . number of function calls to reach the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 638 of file TMinuitMinimizer.cxx. ◆ NDim(). unsigned int TMinuitMinimizer::NDim ; (; ); const. inlineoverridevirtual . this is <= Function().NDim() which is the total num,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuitMinimizer.html:19473,perform,perform,19473,doc/master/classTMinuitMinimizer.html,https://root.cern,https://root.cern/doc/master/classTMinuitMinimizer.html,1,['perform'],['perform']
Performance,"InitY = 0;  ; static Long_t fgMenuHidingTimeout = 400;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Types inherited from TGLViewerBase; typedef OverlayElmVec_t::iterator OverlayElmVec_i;  ; typedef std::vector< TGLOverlayElement * > OverlayElmVec_t;  ; typedef SceneInfoList_t::iterator SceneInfoList_i;  ; typedef std::list< TGLSceneInfo * > SceneInfoList_t;  ; typedef SceneInfoVec_t::iterator SceneInfoVec_i;  ; typedef std::vector< TGLSceneInfo * > SceneInfoVec_t;  ; typedef void(TGLSceneBase::* SubRender_foo) (TGLRnrCtx &);  ;  Protected Member Functions inherited from TGLViewer; void FadeView (Float_t alpha);  Draw a rectangle (background color and given alpha) across the whole viewport. ;  ; void InitGL ();  Initialise GL state. ;  ; void MakeCurrent () const;  Make GL context current. ;  ; void PostDraw ();  Perform GL work which must be done after each draw. ;  ; void PreDraw ();  Perform GL work which must be done before each draw. ;  ; void SetupCameras (Bool_t reset);  Setup cameras for current bounding box. ;  ; void SetupClipObject () override;  allow simple guide axes labels to be scaled relative to scene units ;  ; void SetViewport (const TGLRect &vp);  ; void SetViewport (Int_t x, Int_t y, Int_t width, Int_t height);  Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ;  ; void SwapBuffers () const;  Swap GL buffers. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TGLViewerBase; SceneInfoList_i FindScene (TGLSceneBase *scene);  Find scene-info corresponding to scene. ;  ; void SubRenderScenes (SubRender_foo render_foo);  Call sub-rendering function render_foo on all currently visible scenes. ;  ;  Protected Member Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:34315,Perform,Perform,34315,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['Perform'],['Perform']
Performance,"Inline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooSetProxy_compCSet; TIterator*_compRIter! do not persist; RooSetProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:30837,cache,cache,30837,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,6,['cache'],"['cache', 'caches']"
Performance,"InspectorPrintFormat. strong . EnumeratorkTable ; kCSV . Definition at line 42 of file RNTupleInspector.hxx. ◆ ENTupleStructure. enum ROOT::Experimental::ENTupleStructure. The fields in the ntuple model tree can carry different structural information about the type system. ; Leaf fields contain just data, collection fields resolve to offset columns, record fields have no materialization on the primitive column layer. . EnumeratorkLeaf ; kCollection ; kRecord ; kVariant ; kReference ; kInvalid . Definition at line 38 of file RNTupleUtil.hxx. Function Documentation. ◆ Add(). template<int DIMENSIONS, class PRECISION , template< int D_, class P_ > class... STAT_TO, template< int D_, class P_ > class... STAT_FROM> . void ROOT::Experimental::Add ; (; RHist< DIMENSIONS, PRECISION, STAT_TO... > & ; to, . const RHist< DIMENSIONS, PRECISION, STAT_FROM... > & ; from . ). Add two histograms. ; This operation may currently only be performed if the two histograms have the same axis configuration, use the same precision, and if from records at least the same statistics as to (recording more stats is fine).; Adding histograms with incompatible axis binning will be reported at runtime with an std::runtime_error. Insufficient statistics in the source histogram will be detected at compile-time and result in a compiler error.; In the future, we may either adopt a more relaxed definition of histogram addition or provide a mechanism to convert from one histogram type to another. We currently favor the latter path. ; Definition at line 342 of file RHist.hxx. ◆ CanMap(). ROOT::Experimental::EAxisCompatibility ROOT::Experimental::CanMap ; (; const RAxisEquidistant & ; target, . const RAxisEquidistant & ; source . ). noexcept . Whether (and how) the source axis can be merged into the target axis. ; Definition at line 126 of file RAxis.cxx. ◆ FitPanelLog(). ROOT::Experimental::RLogChannel & ROOT::Experimental::FitPanelLog ; (; ). Log channel for FitPanel diagnostics. ; Definition at line 22 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:42422,perform,performed,42422,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['perform'],['performed']
Performance,"Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d79e4210 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[cpsi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[cpsi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a58030 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Mf_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a58030 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(T_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf210_angularconv.C. tutorialsroofitrf210_angularconv.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8C.html:10200,optimiz,optimization,10200,doc/master/rf210__angularconv_8C.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). overridevirtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; The pointer coordinates returned to win_x and win_y are relative to the origin of the specified window. In this case, QueryPointer returns the child that contains the pointer, if any, or else kNone to childw. QueryPointer returns the current logical state of the keyboard buttons and the modifier keys in mask. ; Reimplemented from TVirtualX.; Definition at line 7017 of file TGWin32.cxx. ◆ RaiseWindow(). void TGWin32::RaiseWindow ; (; Window_t ; id). overridevirtual . Put window on top of window stack. ; Reimplemented from TVirtualX.; Definition at line 4695 of file TGWin32.cxx. ◆ ReadGIF(). Pixmap_t TGWin32::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id = 0 . ). overridevirtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ; Reimplemented from TVirtualX.; Definition at line 4526 of file TGWin32.cxx. ◆ ReadPictureDataFromFile(). Bool_t TGWin32::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). overridevirtual . Read picture data from file and store in ret_data. ; Returns kTRUE in case of success, kFALSE otherwise. ; Reimplemented from TVirtualX.; Definition at line 5673 of file TGWin32.cxx. ◆ RemovePixmap(). void TGWin32::RemovePixmap ; (; GdkDrawable * ; pix). private . Remove the pixmap pix. ; Definition at line 2276 of file TGWin32.cxx. ◆ RemoveWindow(). void TGWin32::RemoveWindow ; (; ULongptr_t ; qwid). overridevirtual . Remove a window created by Qt (like CloseWindow1()). ; Reimplemented from TVirtualX.; Definition at line 7527 of file TGWin32.cxx. ◆ RenderString(). void TGWin32::RenderString ; (; Int_t ; x, . Int_t ; y, . ETextMode ; mode . ). private . Perform the string rendering i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:98584,load,loads,98584,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['load'],['loads']
Performance,"Int_t GetGid(const char *group = nullptr);; 460 virtual Int_t GetEffectiveUid();; 461 virtual Int_t GetEffectiveGid();; 462 virtual UserGroup_t *GetUserInfo(Int_t uid);; 463 virtual UserGroup_t *GetUserInfo(const char *user = nullptr);; 464 virtual UserGroup_t *GetGroupInfo(Int_t gid);; 465 virtual UserGroup_t *GetGroupInfo(const char *group = nullptr);; 466 ; 467 //---- Environment Manipulation; 468 virtual void Setenv(const char *name, const char *value);; 469 virtual void Unsetenv(const char *name);; 470 virtual const char *Getenv(const char *env);; 471 ; 472 //---- System Logging; 473 virtual void Openlog(const char *name, Int_t options, ELogFacility facility);; 474 virtual void Syslog(ELogLevel level, const char *mess);; 475 virtual void Closelog();; 476 ; 477 //---- Standard Output redirection; 478 virtual Int_t RedirectOutput(const char *name, const char *mode = ""a"", RedirectHandle_t *h = nullptr);; 479 virtual void ShowOutput(RedirectHandle_t *h);; 480 ; 481 //---- Dynamic Loading; 482 virtual void AddDynamicPath(const char *pathname);; 483 virtual const char *GetDynamicPath();; 484 virtual void SetDynamicPath(const char *pathname);; 485 char *DynamicPathName(const char *lib, Bool_t quiet = kFALSE);; 486 virtual const char *FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE);; 487 virtual Func_t DynFindSymbol(const char *module, const char *entry);; 488 virtual int Load(const char *module, const char *entry = """", Bool_t system = kFALSE);; 489 virtual void Unload(const char *module);; 490 virtual UInt_t LoadAllLibraries();; 491 virtual void ListSymbols(const char *module, const char *re = """");; 492 virtual void ListLibraries(const char *regexp = """");; 493 virtual const char *GetLibraries(const char *regexp = """",; 494 const char *option = """",; 495 Bool_t isRegexp = kTRUE);; 496 ; 497 //---- RPC; 498 virtual TInetAddress GetHostByName(const char *server);; 499 virtual TInetAddress GetPeerName(int sock);; 500 virtual TInetAddress GetSockName(int sock);; 501 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:21270,Load,Loading,21270,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['Load'],['Loading']
Performance,"Int_t bufsize);  Creates key for object and converts data to buffer. ;  ; void Delete (const char *namecycle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; virtual void Flush ();  Synchronize a file's in-memory and on-disk states. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:3701,cache,cache,3701,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['cache'],['cache']
Performance,"Int_t bufsize);  Creates key for object and converts data to buffer. ;  ; void Delete (const char *namecycle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; virtual void Flush ();  Synchronize a file's in-memory and on-disk states. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:6381,cache,cache,6381,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,10,['cache'],['cache']
Performance,"Int_t chunkSize = 1024 * 16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnBase* CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024 * 16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024 * 16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnBase.html:12852,perform,performed,12852,root/html602/THnBase.html,https://root.cern,https://root.cern/root/html602/THnBase.html,4,['perform'],"['performance', 'performed']"
Performance,"Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::clon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:2300,cache,cacheUniqueSuffix,2300,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,6,['cache'],['cacheUniqueSuffix']
Performance,"Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:2880,cache,cacheUniqueSuffix,2880,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['cache'],['cacheUniqueSuffix']
Performance,"Int_t code, const char* rangeName) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:2663,cache,cacheUniqueSuffix,2663,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,1,['cache'],['cacheUniqueSuffix']
Performance,"Int_t code, const char* rangeName) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:2663,cache,cacheUniqueSuffix,2663,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,2,['cache'],['cacheUniqueSuffix']
Performance,"Int_t current = 0;; 3186 Int_t nested = 0;; 3187 Bool_t hasversion = false;; 3188 ; 3189 while ((c = fgetc(depfile)) != EOF) {; 3190 if (c=='#') {; 3191 // skip comment; 3192 while ((c = fgetc(depfile)) != EOF) {; 3193 if (c=='\n') {; 3194 break;; 3195 }; 3196 }; 3197 continue;; 3198 }; 3199 if (current && line[current-1]=='=' && strncmp(version_var.Data(),line,current)==0) {; 3200 ; 3201 // The next word will be the version number.; 3202 hasversion = kTRUE;; 3203 line[0] = 0;; 3204 current = 0;; 3205 } else if (isspace(c) && !nested) {; 3206 if (current) {; 3207 if (line[current-1]!=':') {; 3208 // ignore target; 3209 line[current] = 0;; 3210 ; 3211 Long_t filetime;; 3212 if (hasversion) {; 3213 modified |= strcmp(ROOT_RELEASE,line)!=0;; 3214 hasversion = kFALSE;; 3215 } else if ( gSystem->GetPathInfo( line, nullptr, (Long_t*)nullptr, nullptr, &filetime ) == 0 ) {; 3216 modified |= ( lib_time <= filetime );; 3217 }; 3218 }; 3219 }; 3220 current = 0;; 3221 line[0] = 0;; 3222 } else {; 3223 if (current==sz-1) {; 3224 sz = 2*sz;; 3225 char *newline = new char[sz];; 3226 memcpy(newline,line, current);; 3227 delete [] line;; 3228 line = newline;; 3229 }; 3230 if (c=='""') nested = !nested;; 3231 else {; 3232 line[current] = c;; 3233 current++;; 3234 }; 3235 }; 3236 }; 3237 delete [] line;; 3238 fclose(depfile);; 3239 recompile = modified;; 3240 ; 3241 }; 3242 ; 3243 }; 3244 }; 3245 ; 3246 if ( gInterpreter->IsLibraryLoaded(library); 3247 || strlen(GetLibraries(library,""D"",kFALSE)) != 0 ) {; 3248 // The library has already been built and loaded.; 3249 ; 3250 Bool_t reload = kFALSE;; 3251 TNamed *libinfo = (TNamed*)fCompiled->FindObject(library);; 3252 if (libinfo) {; 3253 Long_t load_time = libinfo->GetUniqueID();; 3254 Long_t lib_time;; 3255 if ( gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time ) == 0; 3256 && (lib_time>load_time)) {; 3257 reload = kTRUE;; 3258 }; 3259 }; 3260 ; 3261 if ( !recompile && reload ) {; 3262 ; 3263 if (withInfo) {; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:108415,load,loaded,108415,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"Int_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:28915,cache,cache,28915,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,57,['cache'],['cache']
Performance,"Int_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetOptions(TString options); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:27180,cache,cache,27180,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,1,['cache'],['cache']
Performance,"Int_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t e); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDerivative.html:24457,cache,cache,24457,root/html534/RooDerivative.html,https://root.cern,https://root.cern/root/html534/RooDerivative.html,1,['cache'],['cache']
Performance,"Int_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:24070,cache,cache,24070,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"Int_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRegexp.h; TRootSnifferStore.h; TRootSniffer.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TThread.h; TTimer.h; TUrl.h; mime_typeconst char * mime_typeDefinition civetweb.c:8027; ext_lensize_t ext_lenDefinition civetweb.c:8026; free#define freeDefinition civetweb.c:1539; extensionconst char * extensionDefinition civetweb.c:8025; builtin_mime_typesstatic const struct @142 builtin_mime_types[]; malloc#define mallocDefinition civetweb.c:1536; TCivetwebTHttpEngine implementation, based on civetweb embedded server.Definition TCivetweb.h:21; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:55509,Load,LoadClassstatic,55509,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,2,['Load'],"['LoadClass', 'LoadClassstatic']"
Performance,"Int_t i);  ; TTreeFormula * GetVar (Int_t i);  ; TTreeFormula * GetVar1 ();  ; TTreeFormula * GetVar2 ();  ; TTreeFormula * GetVar3 ();  ; TTreeFormula * GetVar4 ();  ; virtual Double_t * GetW ();  ; virtual Double_t GetWeight () const;  ; virtual Long64_t GetZipBytes () const;  ; virtual void IncrementTotalBuffers (Int_t nbytes);  ; virtual bool InPlaceClone (TDirectory *newdirectory, const char *options="""");  Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ;  ; TClass * IsA () const override;  ; bool IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; virtual Int_t LoadBaskets (Long64_t maxmemory=2000000000);  Read in memory all baskets from all branches up to the limit of maxmemory bytes. ;  ; virtual Long64_t LoadTree (Long64_t entry);  Set current entry. ;  ; virtual Long64_t LoadTreeFriend (Long64_t entry, TTree *T);  Load entry on behalf of our master tree, we may use an index. ;  ; virtual Int_t MakeClass (const char *classname=nullptr, Option_t *option="""");  Generate a skeleton analysis class for this tree. ;  ; virtual Int_t MakeCode (const char *filename=nullptr);  Generate a skeleton function for this tree. ;  ; virtual Int_t MakeProxy (const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3);  Generate a skeleton analysis class for this Tree using TBranchProxy. ;  ; virtual Int_t MakeSelector (const char *selector=nullptr, Option_t *option="""");  Generate skeleton selector class for this tree. ;  ; bool MemoryFull (Int_t nbytes);  Check if adding nbytes to memory we are still below MaxVirtualsize. ;  ; virtual Long64_t Merge (TCollection *list, Option_t *option="""");  Merge the trees in the TList into this tree. ;  ; virtual Long64_t Merge (TCollection *list, TFileMergeInfo *info);  Merge the trees in the TLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:15412,Load,LoadTreeFriend,15412,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,10,['Load'],"['Load', 'LoadTreeFriend']"
Performance,"Int_t index) constReturn registered cache object by index.Definition RooAbsArg.cxx:2145; RooAbsArg::clientsconst RefCountList_t & clients() constList of all clients of this object.Definition RooAbsArg.h:166; RooAbsArg::isValueDirtybool isValueDirty() constDefinition RooAbsArg.h:393; RooAbsArg::setProxyNormSetvoid setProxyNormSet(const RooArgSet *nset)Forward a change in the cached normalization argset to all the registered proxies.Definition RooAbsArg.cxx:1468; RooAbsArg::branchNodeServerListvoid branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::numCachesInt_t numCaches() constReturn number of registered caches.Definition RooAbsArg.cxx:2136; RooAbsArg::findServerRooAbsArg * findServer(const char *name) constReturn server of this with name name. Returns nullptr if not found.Definition RooAbsArg.h:184; RooAbsArg::operModeOperMode operMode() constQuery the operation mode of this node.Definition RooAbsArg.h:456; RooAbsCacheElement::_ownerRooAbsArg * _owner! Pointer to owning RooAbsArgDefinition RooAbsCacheElement.h:53; RooAbsCachedReal::setInterpolationOrdervoid setInterpolationOrder(Int_t order)Set interpolation order of RooHistFunct representing cache histogram.Definition RooAbsCachedReal.cxx:254; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::removevirtual bool remove(const RooAbsArg &var, bool silent=false, bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:138904,cache,caches,138904,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['caches']
Performance,"Int_t len=-1, const char *=nullptr);  writes string value, processing all kind of special characters ;  ; template<typename T > ; void JsonWriteFastArray (const T *arr, Long64_t arrsize, const char *typname, void(TBufferJSON::*method)(const T *, Int_t, const char *));  Template method to write array of arbitrary dimensions Different methods can be used for store last array dimension - either JsonWriteArrayCompress<T>() or JsonWriteConstChar() ;  ; TString JsonWriteMember (const void *ptr, TDataMember *member, TClass *memberClass, Int_t arraylen);  Convert single data member to JSON structures Returns string with converted member. ;  ; void JsonWriteObject (const void *obj, const TClass *objClass, Bool_t check_map=kTRUE);  Write object to buffer If object was written before, only pointer will be stored If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the map. ;  ; void PerformPostProcessing (TJSONStackObj *stack, const TClass *obj_cl=nullptr);  Function is converts TObject and TString structures to more compact representation. ;  ; TJSONStackObj * PopStack ();  remove one level from stack ;  ; TJSONStackObj * PushStack (Int_t inclevel=0, void *readnode=nullptr);  add new level to the structures stack ;  ; TJSONStackObj * Stack ();  ; void WorkWithClass (TStreamerInfo *info, const TClass *cl=nullptr);  Prepares buffer to stream data of specified class. ;  ; void WorkWithElement (TStreamerElement *elem, Int_t);  This is call-back from streamer which indicates that class member will be streamed Name of element used in JSON. ;  ; void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse) final;  Write object to buffer. Only used from TBuffer. ;  ;  Protected Member Functions inherited from TBufferText;  TBufferText ();  Default constructor. ;  ;  TBufferText (TBuffer::EMode mode, TObject *parent=nullptr);  Normal constructor. ;  ;  Protected Member Functions inherited from TBufferIO;  TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:46756,Perform,PerformPostProcessing,46756,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['Perform'],['PerformPostProcessing']
Performance,"Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfCPUParList of par files to be loaded for CPU benchmarks; TStringfCPUSelSelector to be used for CPU benchmarks; TProofBenchDataSet*fDSInstance to handle datasets operations; TStringfDataGenParList of par files to be loaded to generate data for benchmarks; TStringfDataGenSelSelector to be used for generate data for benchmarks; TStringfDataParList of par files to be loaded for data benchmarks; TStringfDataSelSelector to be used for data benchmarks; TStringfDataSetName of the dataset; Bool_tfDebugDebug switch; TPBHistType*fHistTypeType of histograms for CPU runs; Int_tfNFilesWrkNumber of files generated files per worker; Int_tfNHistNumber of histograms to be created in default CPU runs; Int_tfNtriesNumber of times a measurement is repeated; TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBench.html:6653,load,loaded,6653,root/html532/TProofBench.html,https://root.cern,https://root.cern/root/html532/TProofBench.html,3,['load'],['loaded']
Performance,"Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferSize;  Allocated size of fBuffer. ;  ; TFile * fFile;  Pointer to file. ;  ; Int_t fNtot;  Total size of cached blocks. ;  ; Bool_t fRecursive;  flag to avoid recursive calls ;  ; Long64_t fSeekStart;  Seek value of first block in cache. ;  . Private Member Functions;  TFileCacheWrite (const TFileCacheWrite &)=delete;  ; TFileCacheWrite & operator= (const TFileCacheWrite &)=delete;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:10216,cache,cached,10216,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,1,['cache'],['cached']
Performance,"Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassGenerator.html:2222,load,load,2222,root/html526/TClassGenerator.html,https://root.cern,https://root.cern/root/html526/TClassGenerator.html,7,['load'],['load']
Performance,"Int_t result = gSystem->Exec(cmd);; 3592 if (result) {; 3593 if (result == 139); 3594 ::Error(""ACLiC"", ""Executing '%s' failed with a core dump!"", cmd.Data());; 3595 else; 3596 ::Error(""ACLiC"", ""Executing '%s' failed!"", cmd.Data());; 3597 }; 3598 return !result;; 3599 };; 3600 ; 3601 Bool_t result = ExecAndReport(rcling);; 3602 TString depLibraries;; 3603 ; 3604 // ======= Load the library the script might depend on; 3605 if (result) {; 3606 TString linkedlibs = GetLibraries("""", ""S"");; 3607 TString libtoload;; 3608 TString all_libtoload;; 3609 std::ifstream liblist(mapfileout);; 3610 ; 3611 while ( liblist >> libtoload ) {; 3612 // Load the needed library except for the library we are currently building!; 3613 if (libtoload == ""#"") {; 3614 // The comment terminates the list of libraries.; 3615 std::string toskipcomment;; 3616 std::getline(liblist,toskipcomment);; 3617 break;; 3618 }; 3619 if (libtoload != library && libtoload != libname && libtoload != libname_ext) {; 3620 if (produceRootmap) {; 3621 if (loadLib || linkDepLibraries /* For GetLibraries to Work */) {; 3622 result = gROOT->LoadClass("""", libtoload) >= 0;; 3623 if (!result) {; 3624 // We failed to load one of the dependency.; 3625 break;; 3626 }; 3627 }; 3628 if (!linkedlibs.Contains(libtoload)) {; 3629 all_libtoload.Append("" "").Append(libtoload);; 3630 depLibraries.Append("" "");; 3631 depLibraries.Append(GetLibraries(libtoload,""DSL"",kFALSE));; 3632 depLibraries = depLibraries.Strip(); // Remove any trailing spaces.; 3633 }; 3634 } else {; 3635 gROOT->LoadClass("""", libtoload);; 3636 }; 3637 }; 3638 unsigned char c = liblist.peek();; 3639 if (c=='\n' || c=='\r') {; 3640 // Consume the character; 3641 liblist.get();; 3642 break;; 3643 }; 3644 }; 3645 ; 3646// depLibraries = all_libtoload;; 3647// depLibraries.ReplaceAll("" lib"","" -l"");; 3648// depLibraries.ReplaceAll(TString::Format("".%s"",fSoExt.Data()),"""");; 3649 }; 3650 ; 3651 // ======= Calculate the libraries for linking:; 3652 TString linkLibraries;; 3653",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:122444,load,loadLib,122444,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,3,"['Load', 'load']","['LoadClass', 'load', 'loadLib']"
Performance,"Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:30343,cache,cache,30343,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,5,['cache'],['cache']
Performance,"Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:34554,load,loaded,34554,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,3,['load'],['loaded']
Performance,Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:18642,cache,cache,18642,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChainIndex.html:9067,Load,LoadTree,9067,root/html534/TChainIndex.html,https://root.cern,https://root.cern/root/html534/TChainIndex.html,1,['Load'],['LoadTree']
Performance,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TChainIndex.html:9541,Load,LoadTree,9541,root/html604/TChainIndex.html,https://root.cern,https://root.cern/root/html604/TChainIndex.html,1,['Load'],['LoadTree']
Performance,"Int_t> GetSubTreeIndex(Long64_t major, Long64_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const TTree* parent); Updates the parent formulae.; Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); See TTreeIndex::SetTree. TChainIndex(). const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fEntries.size();}. » Author: Marek Biskup 07/06/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TChainIndex.html:9541,Load,LoadTree,9541,root/html602/TChainIndex.html,https://root.cern,https://root.cern/root/html602/TChainIndex.html,1,['Load'],['LoadTree']
Performance,"Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStringVar.html:9537,optimiz,optimizeCacheMode,9537,root/html530/RooStringVar.html,https://root.cern,https://root.cern/root/html530/RooStringVar.html,3,['optimiz'],['optimizeCacheMode']
Performance,"Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_pidPID of child process; Int_t_pipeToClient[2]Pipe to client process; Int_t_pipeToServer[2]Pipe to server process; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooAbsReal::ErrorLoggingMode_remoteEvalErrorLoggingState; RooArgList_saveVarsCopy of variables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; static RooMPSentinel_sentinel; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooRealMPFE::State_state; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooListProxy_varsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:33882,cache,cache,33882,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,2,['cache'],['cache']
Performance,"Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:21094,optimiz,optimizeCacheMode,21094,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,"Int_t ; iend, . Int_t ; obegin . ). overrideprotectedvirtual . Copy and release. ; Reimplemented from TGraph.; Definition at line 278 of file TGraphBentErrors.cxx. ◆ CopyPoints(). Bool_t TGraphBentErrors::CopyPoints ; (; Double_t ** ; arrays, . Int_t ; ibegin, . Int_t ; iend, . Int_t ; obegin . ). overrideprotectedvirtual . Copy errors from fE***to arrays[***] or to f*** Copy points. ; Reimplemented from TGraph.; Definition at line 312 of file TGraphBentErrors.cxx. ◆ CtorAllocate(). Bool_t TGraphBentErrors::CtorAllocate ; (; ). protected . Should be called from ctors after fNpoints has been set. ; Definition at line 346 of file TGraphBentErrors.cxx. ◆ DeclFileName(). static const char * TGraphBentErrors::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 101 of file TGraphBentErrors.h. ◆ DoMerge(). Bool_t TGraphBentErrors::DoMerge ; (; const TGraph * ; g). overrideprotectedvirtual . Protected function to perform the merge operation of a graph with asymmetric errors. ; Reimplemented from TGraph.; Definition at line 367 of file TGraphBentErrors.cxx. ◆ FillZero(). void TGraphBentErrors::FillZero ; (; Int_t ; begin, . Int_t ; end, . Bool_t ; from_ctor = kTRUE . ). overrideprotectedvirtual . Set zero values for point arrays in the range [begin, end] ; Reimplemented from TGraph.; Definition at line 474 of file TGraphBentErrors.cxx. ◆ GetErrorX(). Double_t TGraphBentErrors::GetErrorX ; (; Int_t ; bin); const. overridevirtual . It returns the error along X at point i. ; Reimplemented from TGraph.; Definition at line 402 of file TGraphBentErrors.cxx. ◆ GetErrorXhigh(). Double_t TGraphBentErrors::GetErrorXhigh ; (; Int_t ; bin); const. overridevirtual . Get high error on X[i]. ; Reimplemented from TGraph.; Definition at line 430 of file TGraphBentErrors.cxx. ◆ GetErrorXlow(). Double_t TGraphBentErrors::GetErrorXlow ; (; Int_t ; bin); const. overridevirtual . Get low error on X[i]. ; Reimplemented from TGraph.; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:39295,perform,perform,39295,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,1,['perform'],['perform']
Performance,"Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:7200,cache,cached,7200,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],['cached']
Performance,"Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGedEditor * GetFrameCreator ();  Returns TGedEditor that currently creates TGedFrames. ;  ; static void SetFrameCreator (TGedEditor *e);  Set the TGedEditor that currently creates TGedFrames. ;  ;  Static Public Member Functions inherited from TVirtualPadEditor; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static const char * GetEditorName ();  Returns the type of the default pad editor. Static method. ;  ; static TVirtualPadEditor * GetPadEditor (Bool_t load=kTRUE);  Returns the pad editor dialog. Static method. ;  ; static void HideEditor ();  Hide the pad editor. Static method. ;  ; static TVirtualPadEditor * LoadEditor ();  Static function returning a pointer to a new pad editor. ;  ; static void SetPadEditorName (const char *name);  Set type of default pad editor. Static method. ;  ; static void ShowEditor ();  Show the global pad editor. Static method. ;  ; static void Terminate ();  Close the global pad editor. Static method. ;  ; static void UpdateFillAttributes (Int_t col, Int_t sty);  Update fill attributes via the pad editor. ;  ; static void UpdateLineAttributes (Int_t col, Int_t sty, Int_t width);  Update line attributes via the pad editor. ;  ; static void UpdateMarkerAttributes (Int_t col, Int_t sty, Float_t msiz);  Update marker attributes via the pad editor. ;  ; static void UpdateTextAttributes (Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize);  Update text attributes via the pad editor. ;  ;  St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGedEditor.html:27396,load,load,27396,doc/master/classTGedEditor.html,https://root.cern,https://root.cern/doc/master/classTGedEditor.html,1,['load'],['load']
Performance,"Int_t WriteBasket (TBasket *basket, Int_t where);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TString fClassName;  Class name of referenced object. ;  ; TObject * fOldObject;  !Pointer to old object ;  ;  Protected Attributes inherited from TBranch; char * fAddress;  ! Address of 1st leaf (variable or object) ;  ; Int_t * fBasketBytes;  [fMaxBaskets] Length of baskets on file ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] Table of first entry in each basket ;  ; TObjArray fBaskets;  -> List of baskets of this branch ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] Addresses of baskets on file ;  ; Int_t fBasketSize;  Initial Size of Basket Buffer. ;  ; TObjArray fBranches;  -> List of Branches of this branch ;  ; TList * fBrowsables;  ! List of TVirtualBranchBrowsables used for Browse() ;  ; BulkObj fBulk;  ! Helper for performing bulk IO ;  ; CacheInfo_t fCacheInfo;  ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ;  ; Int_t fCompress;  Compression level and algorithm. ;  ; TBasket * fCurrentBasket;  ! Pointer to the current basket. ;  ; TDirectory * fDirectory;  ! Pointer to directory where this branch buffers are stored ;  ; Long64_t fEntries;  Number of entries. ;  ; TBuffer * fEntryBuffer;  ! Buffer used to directly pass the content without streaming ;  ; Long64_t fEntryNumber;  Current entry number (last one filled in this branch) ;  ; Int_t fEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TBasket * fExtraBasket;  ! Allocated basket not currently holding any data. ;  ; TString fFileName;  Name of file where buffers are stored ("""" if in same file as Tree header) ;  ; FillLeaves_t fFillLeaves;  ! Pointer to the FillLeaves implementation to use. ;  ; Long64_t fFirstBasketEntry;  ! First entry in the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:24456,perform,performing,24456,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,3,"['cache', 'perform']","['cache', 'performing']"
Performance,"Integral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet* nset=nullptr, const RooNumIntConfig* cfg=nullptr, const char* rangeName=nullptr) const ;; 224 ; 225 ; 226 void setParameterizeIntegral(const RooArgSet& paramVars) ;; 227 ; 228 // Create running integrals; 229 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset={}) ;; 230 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 231 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 232 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 233 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 234 RooFit::OwningPtr<RooAbsReal> createIntRI(const RooArgSet& iset, const RooArgSet& nset={}) ;; 235 RooFit::OwningPtr<RooAbsReal> createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder) ;; 236 ; 237 ; 238 // Optimized accept/reject generator support; 239 virtual Int_t getMaxVal(const RooArgSet& vars) const ;; 240 virtual double maxVal(Int_t code) const ;; 241 virtual Int_t minTrialSamples(const RooArgSet& /*arGenObs*/) const { return 0 ; }; 242 ; 243 ; 244 // Plotting options; 245 void setPlotLabel(const char *label);; 246 const char *getPlotLabel() const;; 247 ; 248 virtual double defaultErrorLevel() const {; 249 // Return default level for MINUIT error analysis; 250 return 1.0 ;; 251 }; 252 ; 253 const RooNumIntConfig* getIntegratorConfig() const ;; 254 RooNumIntConfig* getIntegratorConfig() ;; 255 static RooNumIntConfig* defaultIntegratorConfig() ;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:11920,Optimiz,Optimized,11920,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['Optimiz'],['Optimized']
Performance,"IntegralMorph.h. ◆ clone(). TObject * RooIntegralMorph::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 35 of file RooIntegralMorph.h. ◆ createCache(). RooAbsCachedPdf::PdfCacheElem * RooIntegralMorph::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create and return a derived MorphCacheElem. ; Reimplemented from RooAbsCachedPdf.; Definition at line 210 of file RooIntegralMorph.cxx. ◆ DeclFileName(). static const char * RooIntegralMorph::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 110 of file RooIntegralMorph.h. ◆ evaluate(). double RooIntegralMorph::evaluate ; (; ); const. overrideprotectedvirtual . Dummy. ; Implements RooAbsReal.; Definition at line 656 of file RooIntegralMorph.cxx. ◆ fillCacheObject(). void RooIntegralMorph::fillCacheObject ; (; PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache with the interpolated shape. ; Implements RooAbsCachedPdf.; Definition at line 178 of file RooIntegralMorph.cxx. ◆ inputBaseName(). const char * RooIntegralMorph::inputBaseName ; (; ); const. overrideprotectedvirtual . Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ; Implements RooAbsCachedPdf.; Definition at line 165 of file RooIntegralMorph.cxx. ◆ IsA(). TClass * RooIntegralMorph::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 110 of file RooIntegralMorph.h. ◆ preferredObservableScanOrder(). void RooIntegralMorph::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. overridevirtual . Indicate to the RooAbsCachedPdf base class that for the filling of the cache the traversal of the x should be in the innermost loop, to minimize recalculation of the one-dimensional internal cache for a fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:84062,cache,cache,84062,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"IntegralMorph::MorphCacheElem*_cacheCurrent morph cache element in use; Bool_t_cacheAlphaIf true, both (x,alpha) are cached; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:45562,cache,cache,45562,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epsrel : Specified relative accuracy.; epsabs : Specified absolute accuracy.; The integration algorithm will attempt to reach either the relative or the absolute accuracy.; In case the maximum funcion called is reached the algorithm will stop earlier without having reached; the desired accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. The default method used is the Genz-Mallik adaptive multidimensional algorithm; using the class ROOT::Math::AdaptiveIntegratorMultiDim; (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); to different integrators.; Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:60394,perform,performed,60394,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['perform'],['performed']
Performance,"IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epsrel : Specified relative accuracy.; epsabs : Specified absolute accuracy.; The integration algorithm will attempt to reach either the relative or the absolute accuracy.; In case the maximum funcion called is reached the algorithm will stop earlier without having reached; the desired accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. The defult method used is the Genz-Mallik adaptive multidimensional algorithm; using the class ROOT::Math::AdaptiveIntegratorMultiDim; (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); to different integrators.; Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsValid() const; Return kTRUE if the function is valid. void Print(Option_t* option = """") const. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:53177,perform,performed,53177,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['perform'],['performed']
Performance,"Interpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, const RooMomentMorph::Setting& setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, const RooMomentMorph::Setting& setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Mon Jul 4 15:23:22 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMomentMorph.html:42275,Cache,CacheElem,42275,root/html530/RooMomentMorph.html,https://root.cern,https://root.cern/root/html530/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"Interpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, const RooMomentMorph::Setting& setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, const RooMomentMorph::Setting& setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Sat Oct 9 06:58:34 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMomentMorph.html:41715,Cache,CacheElem,41715,root/html528/RooMomentMorph.html,https://root.cern,https://root.cern/root/html528/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"Interpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, const RooMomentMorph::Setting& setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, const RooMomentMorph::Setting& setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Thu Nov 3 20:08:39 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMomentMorph.html:42682,Cache,CacheElem,42682,root/html532/RooMomentMorph.html,https://root.cern,https://root.cern/root/html532/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"Interpreter; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNoError enum valueTInterpreter; kNotDeleted enum valueTObject; kNullArgvTClingprivatestatic; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kProcessing enum valueTInterpreter; kRecoverable enum valueTInterpreter; kSingleKey enum valueTObject; kUnknown enum valueTInterpreter; kWithClassDefInline enum valueTInterpreter; kWriteDelete enum valueTObject; kZombie enum valueTObject; LazyFunctionCreatorAutoload(const std::string &mangled_name)TCling; LibraryLoaded(const void *dyLibHandle, const char *canonicalName)TCling; LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)TCling; LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)TCling; Load(const char *filenam, Bool_t system=kFALSE) finalTClingvirtual; LoadEnums(TListOfEnums &cl) const finalTClingvirtual; LoadFile(const char *path) const finalTClingvirtual; LoadFunctionTemplates(TClass *cl) const finalTClingvirtual; LoadLibraryMap(const char *rootmapfile=nullptr) finalTClingvirtual; LoadMacro(const char *filename, EErrorCode *error=nullptr) finalTClingvirtual; LoadPCM(std::string pcmFileNameFullPath)TClingprivate; LoadPCMImpl(TFile &pcmFile)TClingprivate; LoadText(const char *text) const finalTClingvirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeInterpreterValue() const finalTClingvirtual; MakeZombie()TObjectinlineprotected; MapCppName(const char *) const finalTClingvirtual; MayNotUse(const char *method) constTObject; MembersMap_t typedefTInterpreter; MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalTClingvirtual; MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalTClingvirtual; MethodArgInfo_Factory() const finalTClingvirtual; MethodArgInfo_Factory(MethodInfo_t *minfo) const finalTClingvirtual; MethodArgInfo_FactoryCopy(MethodArgInfo_t *marginfo) const finalTClingvirtual; MethodArgInfo_IsValid(MethodArgInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling-members.html:23462,Load,LoadFunctionTemplates,23462,doc/master/classTCling-members.html,https://root.cern,https://root.cern/doc/master/classTCling-members.html,1,['Load'],['LoadFunctionTemplates']
Performance,"InvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kKnown enum valueTInterpreter; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNoError enum valueTInterpreter; kNotDeleted enum valueTObject; kNullArgvTClingprivatestatic; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kProcessing enum valueTInterpreter; kRecoverable enum valueTInterpreter; kSingleKey enum valueTObject; kUnknown enum valueTInterpreter; kWithClassDefInline enum valueTInterpreter; kWriteDelete enum valueTObject; kZombie enum valueTObject; LazyFunctionCreatorAutoload(const std::string &mangled_name)TCling; LibraryLoaded(const void *dyLibHandle, const char *canonicalName)TCling; LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)TCling; LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)TCling; Load(const char *filenam, Bool_t system=kFALSE) finalTClingvirtual; LoadEnums(TListOfEnums &cl) const finalTClingvirtual; LoadFile(const char *path) const finalTClingvirtual; LoadFunctionTemplates(TClass *cl) const finalTClingvirtual; LoadLibraryMap(const char *rootmapfile=nullptr) finalTClingvirtual; LoadMacro(const char *filename, EErrorCode *error=nullptr) finalTClingvirtual; LoadPCM(std::string pcmFileNameFullPath)TClingprivate; LoadPCMImpl(TFile &pcmFile)TClingprivate; LoadText(const char *text) const finalTClingvirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeInterpreterValue() const finalTClingvirtual; MakeZombie()TObjectinlineprotected; MapCppName(const char *) const finalTClingvirtual; MayNotUse(const char *method) constTObject; MembersMap_t typedefTInterpreter; MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalTClingvirtual; MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalTClingvirtual; MethodArgInfo_Factory() const finalTClingvirtual; MethodArgInfo_Factory(MethodInfo_t *minfo) const finalTClingvirtual; M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling-members.html:23355,Load,LoadEnums,23355,doc/master/classTCling-members.html,https://root.cern,https://root.cern/doc/master/classTCling-members.html,1,['Load'],['LoadEnums']
Performance,"IsCollectionProxy< T >::value >::type >;  Classes behaving as a collection of elements that can be queried via the TVirtualCollectionProxy interface The use of a collection proxy for a particular class can be enabled via: ;  ; class  RField< T, typename std::enable_if< std::is_enum_v< T > >::type >;  ; class  RField< void >;  Template specializations for concrete C++ types. More...;  ; class  RFieldBase;  A field translates read and write calls from/to underlying columns to/from tree values. More...;  ; class  RFieldDescriptor;  Meta-data stored for every field of an ntuple. More...;  ; class  RFieldZero;  The container field for an ntuple model, which itself has no physical representation. More...;  ; class  RFile;  A ROOT file. More...;  ; class  RFilePtr;  Points to an object that stores or reads objects in ROOT's binary format. More...;  ; class  RFitPanel;  ; struct  RFitPanelModel;  Data structure for the fit panel. More...;  ; class  RFitResult;  ; class  RFrame;  Holds an area where drawing on user coordinate-system can be performed. More...;  ; class  RFunction;  ; class  RHist;  Histogram class for histograms with DIMENSIONS dimensions, where each bin count is stored by a value of type PRECISION. More...;  ; class  RHist1Drawable;  ; class  RHist1StatBox;  ; class  RHist2Drawable;  ; class  RHist2StatBox;  ; class  RHist3Drawable;  ; class  RHist3StatBox;  ; class  RHist< DIMENSIONS, PRECISION >;  RHist with no STAT parameter uses RHistStatContent by default. More...;  ; class  RHistBufferedFill;  Buffers calls to Fill(). More...;  ; class  RHistConcurrentFiller;  Buffers a thread's Fill calls and submits them to the RHistConcurrentFillManager. More...;  ; class  RHistConcurrentFillManager;  Manages the synchronization of calls to FillN(). More...;  ; class  RHistDataMomentUncert;  For now do as RH1: calculate first (xw) and second (x^2w) moment. More...;  ; class  RHistDisplayItem;  ; class  RHistDrawable;  ; class  RHistDrawableBase;  ; class  RHistStatB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:13846,perform,performed,13846,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['perform'],['performed']
Performance,"IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualPerfStats.html:4232,latency,latency,4232,root/html530/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html530/TVirtualPerfStats.html,2,['latency'],['latency']
Performance,"IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:4178,latency,latency,4178,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,1,['latency'],['latency']
Performance,"IsFolder() const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::v5::TF1Data&operator=(const ROOT::v5::TF1Data&); voidROOT::v5::TFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidROOT::v5::TFormula::Print(Option_t* option = """") constMENU ; virtual voidROOT::v5::TFormula::ProcessLinear(TString& replaceformula); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); virtual voidTAttMarker::ResetAttMarker(Option_t* toption = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTAttMarker::SaveMarkerAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t sizdef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TF1Data.html:5696,Optimiz,Optimize,5696,root/html604/ROOT__v5__TF1Data.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TF1Data.html,1,['Optimiz'],['Optimize']
Performance,"IsLeafString(). bool TTreeFormula::IsLeafString ; (; Int_t ; code); const. protectedvirtual . Return TRUE if the leaf or data member corresponding to code is a string. ; Definition at line 4748 of file TTreeFormula.cxx. ◆ IsQuickLoad(). bool TTreeFormula::IsQuickLoad ; (; ); const. inline . Definition at line 204 of file TTreeFormula.h. ◆ IsString() [1/2]. bool TTreeFormula::IsString ; (; ); const. virtual . Return TRUE if the formula is a string. ; Definition at line 4726 of file TTreeFormula.cxx. ◆ IsString() [2/2]. bool TTreeFormula::IsString ; (; Int_t ; oper); const. overrideprotectedvirtual . Return true if the expression at the index 'oper' is to be treated as as string. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 4736 of file TTreeFormula.cxx. ◆ LoadBranches(). void TTreeFormula::LoadBranches ; (; ). protected . Make sure that all the branches have been loaded properly. ; Definition at line 5369 of file TTreeFormula.cxx. ◆ LoadCurrentDim(). bool TTreeFormula::LoadCurrentDim ; (; ). protected . Calculate the actual dimension for the current entry. ; Definition at line 5393 of file TTreeFormula.cxx. ◆ Notify(). bool TTreeFormula::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 206 of file TTreeFormula.h. ◆ operator=(). TTreeFormula & TTreeFormula::operator= ; (; const TTreeFormula & ; ). privatedelete . ◆ ParseWithLeaf(). Int_t TTreeFormula::ParseWithLeaf ; (; TLeaf * ; leaf, . const char * ; subExpression,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:44871,Load,LoadCurrentDim,44871,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['Load'],['LoadCurrentDim']
Performance,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15241,cache,cache,15241,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:15242,cache,cache,15242,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"IsReading member to reading (default=kTRUE). ; fIsReading (used via gStyle->IsReading()) can be used in the functions myclass::UseCurrentStyle to read from the current style or write to the current style ; Definition at line 1374 of file TStyle.cxx. ◆ SetJoinLinePS(). void TStyle::SetJoinLinePS ; (; Int_t ; joinline = 0). inline . Set the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin for details. ; Definition at line 306 of file TStyle.h. ◆ SetLabelColor(). void TStyle::SetLabelColor ; (; Color_t ; color = 1, . Option_t * ; axis = ""X"" . ). Set axis labels color. ; axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 1393 of file TStyle.cxx. ◆ SetLabelFont(). void TStyle::SetLabelFont ; (; Style_t ; font = 62, . Option_t * ; axis = ""X"" . ). Set font number used to draw axis labels. . font : Text font code = 10*fontnumber + precision; Font numbers must be between 1 and 14; precision = 1 fast hardware fonts (steps in the size); precision = 2 scalable and rotatable hardware fonts The default font number is 62. axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes . Definition at line 1413 of file TStyle.cxx. ◆ SetLabelOffset(). void TStyle::SetLabelOffset ; (; Float_t ; offset = 0.005, . Option_t * ; axis = ""X"" . ). Set offset between axis and axis labels. ; The offset is expressed as a percent of the pad height. axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 1429 of file TStyle.cxx. ◆ SetLabelSize(). void TStyle::SetLabelSize ; (; Float_t ; size = 0.04, . Option_t * ; axis = ""X"" . ). Set size of axis labels. ; The size is expressed as a percent of the pad height. axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 1444 of file TStyle.cxx. ◆ SetLegendBorderSize(). void TStyle::SetLegendBorderSize ; (; Width_t ; size = 4). inline . Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:74981,scalab,scalable,74981,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,1,['scalab'],['scalable']
Performance,"It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:417146,cache,cache,417146,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['cache'],['cache']
Performance,"Iter; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TEventIter * Create (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num);  Create and instance of the appropriate iterator. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void PreProcessEvent (Long64_t ent) override;  Actions to be done just before processing entry 'entry'. ;  ;  Protected Member Functions inherited from TEventIter; Int_t LoadDir ();  Load directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; TTree * GetTrees (TDSetElement *elem);  Create a Tree for the main TDSetElement and for all the friends. ;  ; TTree * Load (TDSetElement *elem, Bool_t &localfile, const char *objname=0);  Load a tree from s TDSetElement. ;  . Private Attributes; Long64_t fCacheSize;  ; Bool_t fDontCacheFiles;  ; TList * fFileTrees;  ; TTree * fTree;  ; TTreeCache * fTreeCache;  ; Bool_t fTreeCacheIsLearning;  ; TString fTreeName;  ; Bool_t fUseParallelUnzip;  ; Bool_t fUseTreeCache;  . Additional Inherited Members;  Public Types inherited from TEventIter; enum  EIterType { kData = 15; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterTree.html:10541,Load,LoadDir,10541,doc/master/classTEventIterTree.html,https://root.cern,https://root.cern/doc/master/classTEventIterTree.html,2,['Load'],"['Load', 'LoadDir']"
Performance,"K, not zero failure. ;  . Private Attributes; IRootFinderMethod * fSolver;  . #include <Math/RootFinder.h>; Member Enumeration Documentation. ◆ EType. enum ROOT::Math::RootFinder::EType. EnumeratorkBRENT ; kGSL_BISECTION ; kGSL_FALSE_POS ; kGSL_BRENT ; kGSL_NEWTON ; kGSL_SECANT ; kGSL_STEFFENSON . Definition at line 77 of file RootFinder.h. Constructor & Destructor Documentation. ◆ RootFinder() [1/3]. ROOT::Math::RootFinder::RootFinder ; (; RootFinder::EType ; type = RootFinder::kBRENT). Construct a Root-Finder algorithm. ; Definition at line 40 of file RootFinder.cxx. ◆ ~RootFinder(). ROOT::Math::RootFinder::~RootFinder ; (; ). virtual . Definition at line 142 of file RootFinder.cxx. ◆ RootFinder() [2/3]. ROOT::Math::RootFinder::RootFinder ; (; const RootFinder & ; ). delete . ◆ RootFinder() [3/3]. ROOT::Math::RootFinder::RootFinder ; (; RootFinder && ; ). delete . Member Function Documentation. ◆ Iterate(). int ROOT::Math::RootFinder::Iterate ; (; ). inline . Perform a single iteration and return the Status. ; Definition at line 148 of file RootFinder.h. ◆ Iterations(). int ROOT::Math::RootFinder::Iterations ; (; ); const. inline . Return the number of iteration performed to find the Root. ; Definition at line 141 of file RootFinder.h. ◆ Name(). const char * ROOT::Math::RootFinder::Name ; (; ); const. inline . Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms) ; Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms) Get Name of the Root-finding solver algorithm ; Definition at line 185 of file RootFinder.h. ◆ operator=() [1/2]. RootFinder & ROOT::Math::RootFinder::operator= ; (; const RootFinder & ; rhs). delete . ◆ operator=() [2/2]. RootFinder & ROOT::Math::RootFinder::operator= ; (; RootFinder && ; rhs). delete . ◆ Root(). double ROOT::Math::RootFinder::Root ; (; ); const. inline . Return the current and latest estimate of the Root. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RootFinder.html:4125,Perform,Perform,4125,doc/master/classROOT_1_1Math_1_1RootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RootFinder.html,1,['Perform'],['Perform']
Performance,"Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification of the original tree and the input file name.; - Definition of an analysis class (data members and member functions).; - The following member functions:; - constructor (by default opening the tree file),; - GetEntry(Long64_t entry),; - Init(TTree* tree) to initialize a new TTree,; - Show(Long64_t entry) to read and dump entry. The generated code in classname.C includes only the main; analysis function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:95809,Load,LoadTree,95809,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['Load'],['LoadTree']
Performance,"L << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAddPdf.h>. Inheritance diagram for RooAddPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAddPdf() [1/6]. RooAddPdf::RooAddPdf ; (; ). inline . Definition at line 36 of file RooAddPdf.h. ◆ RooAddPdf() [2/6]. RooAddPdf::RooAddPdf ; (; const char * ; name, . const char * ; title = nullptr . ). Dummy constructor. ; Definition at line 99 of file RooAddPdf.cxx. ◆ RooAddPdf() [3/6]. RooAddPdf::RooAddPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; pdf1, . RooAbsPdf & ; pdf2, . RooAbsReal & ; coef1 . ). Constructor with two PDFs and one coefficient. ; Definition at line 136 of file RooAddPdf.cxx. ◆ RooAddPdf() [4/6]. RooAddPdf::RooAddPdf ; (; const char * ; name, . const char * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:79115,cache,cache,79115,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,1,['cache'],['cache']
Performance,"L, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.; 1767 *; 1768 * #define OPENSSL_free free */; 1769#define free free; 1770// disable for boringssl; 1771#define CONF_modules_unload(a) ((void)0); 1772#define ENGINE_cleanup() ((void)0); 1773#endif; 1774 ; 1775/* If OpenSSL headers are included, automatically select the API version */; 1776#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1777#if !defined(OPENSSL_API_3_0); 1778#define OPENSSL_API_3_0; 1779#endif; 1780#define OPENSSL_REMOVE_THREAD_STATE(); 1781#else; 1782#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1783#if !defined(OPENSSL_API_1_1); 1784#define OPENSSL_API_1_1; 1785#endif; 1786#define OPENSSL_REMOVE_THREAD_STATE(); 1787#else; 1788#if !defined(OPENSSL_API_1_0); 1789#define OPENSSL_API_1_0; 1790#endif; 1791#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1792#endif; 1793#endif; 1794 ; 1795 ; 1796#else; 1797/* SSL loaded dynamically from DLL / shared object */; 1798/* Add all prototypes here, to be independent from OpenSSL source; 1799 * installation. */; 1800#include ""openssl_dl.inl""; 1801 ; 1802#endif /* Various SSL bindings */; 1803 ; 1804 ; 1805#if !defined(NO_CACHING); 1806static const char month_names[][4] = {""Jan"",; 1807 ""Feb"",; 1808 ""Mar"",; 1809 ""Apr"",; 1810 ""May"",; 1811 ""Jun"",; 1812 ""Jul"",; 1813 ""Aug"",; 1814 ""Sep"",; 1815 ""Oct"",; 1816 ""Nov"",; 1817 ""Dec""};; 1818#endif /* !NO_CACHING */; 1819 ; 1820 ; 1821/* Unified socket address. For IPv6 support, add IPv6 address structure in; 1822 * the union u. */; 1823union usa {; 1824 struct sockadd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:55106,load,loaded,55106,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['loaded']
Performance,"L, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767 * the standard memory functions.; 1768 *; 1769 * #define OPENSSL_free free */; 1770#define free free; 1771// disable for boringssl; 1772#define CONF_modules_unload(a) ((void)0); 1773#define ENGINE_cleanup() ((void)0); 1774#endif; 1775 ; 1776/* If OpenSSL headers are included, automatically select the API version */; 1777#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1778#if !defined(OPENSSL_API_3_0); 1779#define OPENSSL_API_3_0; 1780#endif; 1781#define OPENSSL_REMOVE_THREAD_STATE(); 1782#else; 1783#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1784#if !defined(OPENSSL_API_1_1); 1785#define OPENSSL_API_1_1; 1786#endif; 1787#define OPENSSL_REMOVE_THREAD_STATE(); 1788#else; 1789#if !defined(OPENSSL_API_1_0); 1790#define OPENSSL_API_1_0; 1791#endif; 1792#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1793#endif; 1794#endif; 1795 ; 1796 ; 1797#else; 1798/* SSL loaded dynamically from DLL / shared object */; 1799/* Add all prototypes here, to be independent from OpenSSL source; 1800 * installation. */; 1801#include ""openssl_dl.inl""; 1802 ; 1803#endif /* Various SSL bindings */; 1804 ; 1805 ; 1806#if !defined(NO_CACHING); 1807static const char month_names[][4] = {""Jan"",; 1808 ""Feb"",; 1809 ""Mar"",; 1810 ""Apr"",; 1811 ""May"",; 1812 ""Jun"",; 1813 ""Jul"",; 1814 ""Aug"",; 1815 ""Sep"",; 1816 ""Oct"",; 1817 ""Nov"",; 1818 ""Dec""};; 1819#endif /* !NO_CACHING */; 1820 ; 1821 ; 1822/* Unified socket address. For IPv6 support, add IPv6 address structure in; 1823 * the union u. */; 1824union usa {; 1825 struct sockadd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:55138,load,loaded,55138,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['loaded']
Performance,"LCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; voidEnforceTriangles(); static Bool_tGetEnforceTriangles(); TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); UInt_tGetNbPols(); vector<Double_t>&GetNormals(); vector<Int_t>&GetPolyDesc(); TGLScene*TGLLogicalShape::GetScene() const; vector<Double_t>&GetVertices(); TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidSetEnforceTriangles(Bool_t e); voidSetFromMesh(const RootCsg::TBaseMesh* m); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLFaceSet.html:2074,cache,cached,2074,root/html534/TGLFaceSet.html,https://root.cern,https://root.cern/root/html534/TGLFaceSet.html,1,['cache'],['cached']
Performance,"LDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boole",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:7872,perform,performs,7872,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['perform'],['performs']
Performance,"LFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compression. The default for ROOT is one. The compression level can be set with the method TFile::SetCompressionLevel. The experience with this algorithm shows that a compression level of 1.3 for raw data files and around two on most DST files is the optimum. The choice of one for the default is a compromise between the time it takes to read and write the object vs. the disk space savings.; To specify no compression, set the level to zero.; We recommend using compression when the time spent in I/O is small compared to the total processing time. If the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may compress the data by a factor of 10. On the other hand if the time spend on I/O is large, compression may have a large impact on the program’s performance.; The compression factor, i.e. the savings of disk space, varies with the type of data. A buffer with a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:512519,Perform,Performance,512519,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Performance']
Performance,"LIMITS"";; 4689 if (kint <= 0) {; 4690 fGsteps[ifx-1] = TMath::Abs(fGsteps[ifx-1]);; 4691 } else {; 4692 mndxdi(fX[kint-1], kint-1, dxdi);; 4693 if (TMath::Abs(dxdi) < .01) dxdi = .01;; 4694 fGstep[kint-1] = TMath::Abs(fGstep[kint-1]*dxdi);; 4695 fGrd[kint-1] *= dxdi;; 4696 }; 4697 fNvarl[i2-1] = 1;; 4698 } else {; 4699 Printf("" NO LIMITS SPECIFIED. PARAMETER %3d IS ALREADY UNLIMITED. NO CHANGE."",i2);; 4700 }; 4701 goto L900;; 4702// put on limits; 4703L235:; 4704 fAlim[i2-1] = TMath::Min(fWord7[1],fWord7[2]);; 4705 fBlim[i2-1] = TMath::Max(fWord7[1],fWord7[2]);; 4706 fNvarl[i2-1] = 4;; 4707 if (fISW[4] > 0) {; 4708 Printf("" PARAMETER %3d LIMITS SET TO %15.5g%15.5g"",i2,fAlim[i2-1],fBlim[i2-1]);; 4709 }; 4710 fCstatu = ""NEW LIMITS"";; 4711 if (kint <= 0) fGsteps[ifx-1] = -.1;; 4712 else fGstep[kint-1] = -.1;; 4713 ; 4714L900:; 4715 if (fCstatu != ""NO CHANGE "") {; 4716 mnexin(fX);; 4717 mnrset(1);; 4718 }; 4719}; 4720 ; 4721////////////////////////////////////////////////////////////////////////////////; 4722/// Perform a line search from position START; 4723///; 4724/// along direction STEP, where the length of vector STEP; 4725/// gives the expected position of minimum.; 4726/// - FSTART is value of function at START; 4727/// - SLOPE (if non-zero) is df/dx along STEP at START; 4728/// - TOLER is initial tolerance of minimum in direction STEP; 4729///; 4730/// SLAMBG and ALPHA control the maximum individual steps allowed.; 4731/// The first step is always =1. The max length of second step is SLAMBG.; 4732/// The max size of subsequent steps is the maximum previous successful; 4733/// step multiplied by ALPHA + the size of most recent successful step,; 4734/// but cannot be smaller than SLAMBG.; 4735 ; 4736void TMinuit::mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler); 4737{; 4738 /* Local variables */; 4739 Double_t xpq[12], ypq[12], slam, sdev, coeff[3], denom, flast;; 4740 Double_t fvals[3], xvals[3], f1, fvmin, xvmin, ratio, f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:156559,Perform,Perform,156559,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['Perform'],['Perform']
Performance,"LL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  . Public Member Functions;  RooKeysPdf ();  coverity[UNINIT_CTOR] ;  ;  RooKeysPdf (const char *name, const char *title, RooAbsReal &x, RooDataSet &data, Mirror mirror=NoMirror, double rho=1);  cache stuff about x ;  ;  RooKeysPdf (const char *name, const char *title, RooAbsReal &x, RooRealVar &xdata, RooDataSet &data, Mirror mirror=NoMirror, double rho=1);  cache stuff about x ;  ;  RooKeysPdf (const RooKeysPdf &other, const char *name=nullptr);  ;  ~RooKeysPdf () override;  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TObject * clone (const char *newname) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; Int_t getMaxVal (const RooArgSet &vars) const override;  Advertise capability to determine maximum value of function for given set of observables. ;  ; TClass * IsA () const override;  ; void LoadDataSet (RooDataSet &data);  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; void Streamer (TBuffer &) ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:3291,cache,cache,3291,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,2,['cache'],['cache']
Performance,"LL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TEnum ();  ;  TEnum (const char *name, DeclId_t declid, TClass *cls);  Constructor for TEnum class. ;  ;  TEnum (const TEnum &);  Copy constructor. ;  ; virtual ~TEnum ();  Destructor. ;  ; void AddConstant (TEnumConstant *constant);  Add a EnumConstant to the list of constants of the Enum Type. ;  ; TClass * GetClass () const;  ; const TEnumConstant * GetConstant (const char *name) const;  ; const TSeqCollection * GetConstants () const;  ; DeclId_t GetDeclId () const;  ; const char * GetQualifiedName () const;  ; EDataType GetUnderlyingType () const;  Get the underlying integer type of the enum: enum E { kOne }; // ==> int enum F: long; // ==> long Returns kNumDataTypes if the enum is unknown / invalid. ;  ; TClass * IsA () const override;  ; Bool_t IsValid ();  Return true if this enum object is pointing to a currently loaded enum. ;  ; TEnum & operator= (const TEnum &);  Assign operator. ;  ; Long_t Property () const override;  Get property description word. For meaning of bits see EProperty. ;  ; void SetClass (TClass *cl);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Update (DeclId_t id);  ;  Public Member Functions inherited from TDictionary;  TDictionary ();  ;  TDictionary (const char *name);  ;  TDictionary (const TDictionary &dict);  ; virtual ~TDictionary ();  ; void CreateAttributeMap ();  ; TDictAttributeMap * GetAttributeMap () const;  ; TDictionary & operator= (const TDictionary &other);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTEnum.html:2731,load,loaded,2731,doc/v632/classTEnum.html,https://root.cern,https://root.cern/doc/v632/classTEnum.html,2,['load'],['loaded']
Performance,"LL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check if given RooRealVar maps to a RooRealVar in this dataset. ;  ; void initializeVars (RooArgSet const &vars);  ; virtual void optimizeReadingWithCaching (RooAbsArg &arg, const RooArgSet &cacheList, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:24995,cache,cachedVars,24995,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,2,['cache'],"['cache', 'cachedVars']"
Performance,"LSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetIntegratorConfig(); voidsetIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:21889,cache,cache,21889,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,1,['cache'],['cache']
Performance,"LSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:22709,cache,cache,22709,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,3,['cache'],['cache']
Performance,"LSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:70486,load,load,70486,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,8,['load'],['load']
Performance,"LSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 4752 }; 4753 Printf("" j=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762 }; 4763}; 4764 ; 4765////////////////////////////////////////////////////////////////////////////////; 4766/// An emulated object is created at address obj, if obj is null we; 4767/// allocate memory for the object.; 4768 ; 4769void* TStreamerInfo::New(void *obj); 4770{; 4771 //???FIX ME: What about varying length array elements?; 4772 ; 4773 char* p = (char*) obj;; 4774 ; 4775 TIter next(fElements);; 4776 ; 4777 if (!p) {; 4778 // Alloc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:191461,optimiz,optimized,191461,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"L_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4108 ; 4109#else /* NO_CACHING */; 4110 ; 4111 send_no_cache_header(conn);; 4112#endif /* !NO_CACHING */; 4113}; 4114 ; 4115 ; 4116static void; 4117send_additional_header(stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:121029,cache,cached,121029,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['cache'],['cached']
Performance,"L_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4109 ; 4110#else /* NO_CACHING */; 4111 ; 4112 send_no_cache_header(conn);; 4113#endif /* !NO_CACHING */; 4114}; 4115 ; 4116 ; 4117static void; 4118send_additional_header(stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:121061,cache,cached,121061,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['cache'],['cached']
Performance,"Last ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 57 of file TClonesArray.h. ◆ AddrAt(). TObject * TClonesArray::AddrAt ; (; Int_t ; idx). inline . Definition at line 86 of file TClonesArray.h. ◆ BypassStreamer(). void TClonesArray::BypassStreamer ; (; Bool_t ; bypass = kTRUE). When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::WriteBuffer. ; Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However there is a drawback: When a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfo of the class in the array being optimized, one cannot use later the TClonesArray with split>0. For example, there is a problem with the following scenario:; A class Foo has a TClonesArray of Bar objects; The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.; In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1; When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfo had been generated in optimized mode or not. . Definition at line 321 of file TClonesArray.cxx. ◆ CanBypassStreamer(). Bool_t TClonesArray::CanBypassStreamer ; (; ); const. inline . Definition at line 64 of file TClonesArray.h. ◆ Class(). static TClass * TClonesArray::Class ; (; ). static . ReturnsT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:31704,optimiz,optimized,31704,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" ("";; 1413 optimParameters += TString::Format(""%s=%g"", key.Data(), value);; 1414 }; 1415 if (!optimParameters.IsNull()); 1416 optimParameters += "")"";; 1417 return optimParameters;; 1418 };; 1419 ; 1420 Log() << ""Training phase "" << trainingPhase << "" of "" << this->GetTrainingSettings().size() << "": ""; 1421 << "" Optimizer "" << settings.optimizerName; 1422 << optimParametersString(); 1423 << "" Learning rate = "" << settings.learningRate << "" regularization "" << (char)settings.regularization; 1424 << "" minimum error = "" << minValError << Endl;; 1425 if (!fInteractive) {; 1426 std::string separator(62, '-');; 1427 Log() << separator << Endl;; 1428 Log() << std::setw(10) << ""Epoch""; 1429 << "" | "" << std::setw(12) << ""Train Err."" << std::setw(12) << ""Val. Err."" << std::setw(12); 1430 << ""t(s)/epoch"" << std::setw(12) << ""t(s)/Loss"" << std::setw(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:55864,optimiz,optimizerName,55864,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerName']
Performance,"Leaf::GetBranchTBranch * GetBranch() constDefinition TLeaf.h:116; TLeaf::fOffsetInt_t fOffsetOffset in ClonesArray object (if one)Definition TLeaf.h:74; TLeaf::GetOffsetHeaderSizevirtual Int_t GetOffsetHeaderSize() constDefinition TLeaf.h:61; TLeaf::fBranchTBranch * fBranch! Pointer to supporting branch (we do not own the branch)Definition TLeaf.h:78; TLeaf::fIsUnsignedbool fIsUnsigned(=true if unsigned, false otherwise)Definition TLeaf.h:76; TLeaf::fLeafCountTLeaf * fLeafCountPointer to Leaf count if variable length (we do not own the counter)Definition TLeaf.h:77; TLeaf::kNewValue@ kNewValueSet if we own the value buffer and so must delete it ourselves.Definition TLeaf.h:96; TLeaf::SetLeafCountvirtual void SetLeafCount(TLeaf *leaf)Set the leaf count of this leaf.Definition TLeaf.cxx:465; TLeaf::GetFullNamevirtual TString GetFullName() constReturn the full name (including the parent's branch names) of the leaf.Definition TLeaf.cxx:224; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Classstatic TClass * Class(); TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:22240,Cache,Cache,22240,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['Cache'],['Cache']
Performance,"LeafElement::PrintValue ; (; Int_t ; i = 0); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 71 of file TLeafElement.h. ◆ ReadBasketFast(). bool TLeafElement::ReadBasketFast ; (; TBuffer & ; input_buf, . Long64_t ; N . ). overridevirtual . Deserialize N events from an input buffer. ; Reimplemented from TLeaf.; Definition at line 144 of file TLeafElement.cxx. ◆ SetLeafCount(). void TLeafElement::SetLeafCount ; (; TLeaf * ; leaf). inlineoverridevirtual . Set the leaf count of this leaf. ; Reimplemented from TLeaf.; Definition at line 72 of file TLeafElement.h. ◆ Streamer(). void TLeafElement::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TLeaf. ◆ StreamerNVirtual(). void TLeafElement::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 74 of file TLeafElement.h. Member Data Documentation. ◆ fAbsAddress. char* TLeafElement::fAbsAddress. protected . ! Absolute leaf Address ; Definition at line 35 of file TLeafElement.h. ◆ fDataTypeCache. std::atomic<EDataType> TLeafElement::fDataTypeCache {EDataType::kOther_t}. mutableprotected . ! Cache of the EDataType of deserialization. ; Definition at line 39 of file TLeafElement.h. ◆ fDeserializeTypeCache. std::atomic<DeserializeType> TLeafElement::fDeserializeTypeCache { DeserializeType::kInvalid }. mutableprotected . ! Cache of the type of deserialization. ; Definition at line 38 of file TLeafElement.h. ◆ fID. Int_t TLeafElement::fID. protected . element serial number in fInfo ; Definition at line 36 of file TLeafElement.h. ◆ fType. Int_t TLeafElement::fType. protected . leaf type ; Definition at line 37 of file TLeafElement.h. Libraries for TLeafElement:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TLeafElement.h; tree/tree/src/TLeafElement.cxx. TLeafElement. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:54 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafElement.html:23331,Cache,Cache,23331,doc/master/classTLeafElement.html,https://root.cern,https://root.cern/doc/master/classTLeafElement.html,2,['Cache'],['Cache']
Performance,"LearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:55076,cache,cache,55076,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,Len[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; TTree*TTreeCache::fOwner! pointer to the owner Tree/chain; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:9437,cache,cache,9437,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,4,['cache'],['cache']
Performance,Length of baskets on file ; Definition at line 141 of file TBranch.h. ◆ fBasketEntry. Long64_t* TBranch::fBasketEntry. protected . [fMaxBaskets] Table of first entry in each basket ; Definition at line 142 of file TBranch.h. ◆ fBaskets. TObjArray TBranch::fBaskets. protected . -> List of baskets of this branch ; Definition at line 140 of file TBranch.h. ◆ fBasketSeek. Long64_t* TBranch::fBasketSeek. protected . [fMaxBaskets] Addresses of baskets on file ; Definition at line 143 of file TBranch.h. ◆ fBasketSize. Int_t TBranch::fBasketSize. protected . Initial Size of Basket Buffer. ; Definition at line 118 of file TBranch.h. ◆ fBranches. TObjArray TBranch::fBranches. protected . -> List of Branches of this branch ; Definition at line 138 of file TBranch.h. ◆ fBrowsables. TList* TBranch::fBrowsables. protected . ! List of TVirtualBranchBrowsables used for Browse() ; Definition at line 152 of file TBranch.h. ◆ fBulk. BulkObj TBranch::fBulk. protected . ! Helper for performing bulk IO ; Definition at line 153 of file TBranch.h. ◆ fCacheInfo. CacheInfo_t TBranch::fCacheInfo. protected . ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ; Definition at line 158 of file TBranch.h. ◆ fCompress. Int_t TBranch::fCompress. protected . Compression level and algorithm. ; Definition at line 117 of file TBranch.h. ◆ fCurrentBasket. TBasket* TBranch::fCurrentBasket. protected . ! Pointer to the current basket. ; Definition at line 133 of file TBranch.h. ◆ fDirectory. TDirectory* TBranch::fDirectory. protected . ! Pointer to directory where this branch buffers are stored ; Definition at line 148 of file TBranch.h. ◆ fEntries. Long64_t TBranch::fEntries. protected . Number of entries. ; Definition at line 134 of file TBranch.h. ◆ fEntryBuffer. TBuffer* TBranch::fEntryBuffer. protected . ! Buffer used to directly pass the content without streaming ; Definition at line 150 of file TBranch.h. ◆ fEntryNumber. Long64_t TBranch::fEntryNumber. p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:70985,perform,performing,70985,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['perform'],['performing']
Performance,"Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFrien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:33646,cache,cache,33646,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['cache'],['cache']
Performance,"LibraryLoaded(const char* libname, cling::Interpreter* fInterpreter); 3130{; 3131 // Check shared library.; 3132 TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:121825,load,loaded,121825,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"Likelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodLikelihoodMethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromStream(TFile& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLikelihood.html:11227,Optimiz,OptimizeTuningParameters,11227,root/html530/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLikelihood.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"LimitsFinder::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder.; Definition at line 46 of file THLimitsFinder.h. ◆ Optimize(). void THLimitsFinder::Optimize ; (; Double_t ; A1, . Double_t ; A2, . Int_t ; nold, . Double_t & ; BinLow, . Double_t & ; BinHigh, . Int_t & ; nbins, . Double_t & ; BinWidth, . Option_t * ; option = """" . ). static . Static function to compute reasonable axis limits. ; Input parameters:; Parameters. [in]A1,A2: Original axis limits ; [in]BinLow,BinHigh: Optimized axis limits. They should be initialized by the calling method for instance to 0. ; [out]nold: Original number of divisions. ; [out]nbins: Optimized number of divisions. ; [out]BinWidth: Optimized bin width. It should be initialized by the calling method for instance to 0. ; [in]option: ""T"" means Time axis. . Definition at line 184 of file THLimitsFinder.cxx. ◆ OptimizeLimits(). void THLimitsFinder::OptimizeLimits ; (; Int_t ; nbins, . Int_t & ; newbins, . Double_t & ; xmin, . Double_t & ; xmax, . Bool_t ; isInteger . ). static . Optimize axis limits. ; When isInter=kTRUE, the function makes an integer binwidth and recompute the number of bins accordingly. ; Definition at line 367 of file THLimitsFinder.cxx. ◆ SetLimitsFinder(). void THLimitsFinder::SetLimitsFinder ; (; THLimitsFinder * ; finder). static . This static function can be used to specify a finder derived from THLimitsFinder. ; The finder may redefine the functions FindGoodLimits. Note that the redefined functions may call THLimitsFinder::FindGoodLimits. ; Definition at line 165 of file THLimitsFinder.cxx. ◆ Streamer(). void THLimitsFinder::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TProofLimitsFinder. ◆ StreamerNVirtual(). void THLimitsFinder::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 46",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHLimitsFinder.html:15089,Optimiz,OptimizeLimits,15089,doc/master/classTHLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTHLimitsFinder.html,1,['Optimiz'],['OptimizeLimits']
Performance,"Line width; 50 - 67 2; 68 - 85 3; 86 - 103 4; 104 - 121 5; ...; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56. Marker size; Various marker sizes are shown in the figure below. The default marker size=1 is shown in the top left corner. Marker sizes smaller than 1 can be specified. The marker size does not refer to any coordinate systems, it is an absolute value. Therefore the marker size is not affected by any change in TPad's scale. A marker size equal to 1 correspond to 8 pixels. That is, a square marker with size 1 will be drawn with a side equal to 8 pixels on the screen.; The marker size of any class inheriting from TAttMarker can be changed using the method SetMarkerSize and retrieved using the method GetMarkerSize. Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They are meant to be very fast to draw and are always drawn with the same number of pixels; therefore SetMarkerSize does not apply on them. To have a ""scalable dot"" a filled circle should be used instead, i.e. the marker style number 20. By default (if SetMarkerStyle is not specified), the marker style used is 1. That's the most common one to draw scatter plots. ; Definition at line 19 of file TAttMarker.h. Public Member Functions;  TAttMarker ();  TAttMarker default constructor. ;  ;  TAttMarker (Color_t color, Style_t style, Size_t msize);  TAttMarker normal constructor. ;  ; virtual ~TAttMarker ();  TAttMarker destructor. ;  ; void Copy (TAttMarker &attmarker) const;  Copy this marker attributes to a new TAttMarker. ;  ; virtual Color_t GetMarkerColor () const;  Return the marker color. ;  ; virtual Size_t GetMarkerSize () const;  Return the marker size. ;  ; virtual Style_t GetMarkerStyle () const;  Return the marker style. ;  ; virtual TClass * IsA () const;  ; virtual void Modify ();  Change current marker attributes if necessary. ;  ; virtual void ResetAttMarker (Option_t *toption="""");  Reset this marker attributes to the default values. ;  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttMarker.html:6977,scalab,scalable,6977,doc/master/classTAttMarker.html,https://root.cern,https://root.cern/doc/master/classTAttMarker.html,1,['scalab'],['scalable']
Performance,Line::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNvarNumber of columns; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch styl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtuple.html:25033,load,loading,25033,root/html534/TNtuple.html,https://root.cern,https://root.cern/root/html534/TNtuple.html,6,['load'],['loading']
Performance,"Line; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:40526,cache,cache,40526,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,5,['cache'],"['cache', 'caches']"
Performance,"LinearCombination, RooLinearVar, RooMoment, RooMultiVarGaussian, RooNumConvolution, RooNumConvPdf, RooNumRunningInt, RooPolyFunc, RooPolyVar, RooProdPdf, RooProduct, RooProfileLL, RooProjectedPdf, RooPullVar, RooRangeBoolean, RooRatio, RooRealIntegral, RooRealSumFunc, RooRealSumPdf, RooRealVar, RooRecursiveFraction, RooSecondMoment, RooSimultaneous, RooTruthModel, RooWrapperPdf, RooAbsTestStatistic, RooGenProdProj, RooNormalizedPdf, RooFixedProdPdf, RooRealMPFE, RooHypatia2, RooLegendre, RooNonCentralChiSquare, RooSpHarmonic, RooStats::Heaviside, ProgressMonitor, xRooProjectedPdf, and PdfWrapper. ◆ fillDataHist(). RooDataHist * RooAbsReal::fillDataHist ; (; RooDataHist * ; hist, . const RooArgSet * ; normSet, . double ; scaleFactor, . bool ; correctForBinSize = false, . bool ; showProgress = false . ); const. Fill a RooDataHist with values sampled from this function at the bin centers. ; If extendedMode is true, the p.d.f. values is multiplied by the number of expected events in each bin; An optional scaling by a given scaleFactor can be performed. Returns a pointer to the input RooDataHist, or zero in case of an error.; If correctForBinSize is true the RooDataHist is filled with the functions density (function value times the bin volume) rather than function value.; If showProgress is true a process indicator is printed on stdout in steps of one percent, which is mostly useful for the sampling of expensive functions such as likelihoods ; Definition at line 1124 of file RooAbsReal.cxx. ◆ fillHistogram(). TH1 * RooAbsReal::fillHistogram ; (; TH1 * ; hist, . const RooArgList & ; plotVars, . double ; scaleFactor = 1, . const RooArgSet * ; projectedVars = nullptr, . bool ; scaleForDensity = true, . const RooArgSet * ; condObs = nullptr, . bool ; setError = true . ); const. Fill the ROOT histogram 'hist' with values sampled from this function at the bin centers. ; Our value is calculated by first integrating out any variables in projectedVars and then scaling the result ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:102174,perform,performed,102174,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,"Linearflag for linear functions ; vector<double>fParamscached vector with parameter values; static doublefgEpsepsilon used in derivative calculation h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. {}. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(const double* x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoParameterDerivative(const double* x, const double* p, unsigned int ipar) const; eva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__WrappedMultiTF1.html:2739,cache,cached,2739,root/html528/ROOT__Math__WrappedMultiTF1.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__WrappedMultiTF1.html,1,['cache'],['cached']
Performance,"LinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817//////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:23905,cache,cached,23905,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryList. class TEntryList: public TNamed. TEntryList: a List of entry numbers in a TTree or TChain; There are two types of entry lists:. for a TTree (fBlocks data member is non-zero); Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored; in the TObjArray fBlocks. The range of the entry numbers is cut into intervals; of kBlockSize entries (currently 64000), so that the first block contains; information which entries out of the first 64000 pass the selection, the second; block - which entries out of the 64000-127999 interval pass the selection, etc.; Some blocks, obviously, might be empty. The internal representation of entry; numbers in the blocks is described in the TEntryListBlock class description, and; this representation might be changed by calling OptimizeStorage() function; (when the list is filled via the Enter() function, this is done automatically,; except for the last block).; Individual entry lists can be merged (functions Merge() and Add()); to make an entry list for a TChain of corresponding TTrees. Picture; Source. {; //=========Macro generated from canvas: c/c; //========= (Tue Jan 23 16:58:56 2007) by ROOT version5.15/01; TCanvas *c = new TCanvas(""c"", ""c"",213,172,460,253);; c->Range(0,0,1,1);; c->SetBorderSize(2);; c->SetFrameFillColor(0);. TPaveText *pt = new TPaveText(0.00518135,0.810811,0.507772,0.989189,""br"");; pt->SetFillColor(19);; pt->SetTextColor(4);; TText *text = pt->AddText(""TEntryList for a TTree"");; pt->Draw();. pt = new TPaveText(0.0387597,0.483696,0.307494,0.657609,""br"");; pt->SetFillColor(19);; text = pt->AddText(""TEntryList"");; pt->Draw();. pt = new TPaveText(0.0363636,0.107527,0.306494,0.489247,""br"");; pt->SetFillColor(19);; pt->SetTextFont(42);; text = pt->AddText(""fBlocks"");; text ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryList.html:1037,Optimiz,OptimizeStorage,1037,root/html602/TEntryList.html,https://root.cern,https://root.cern/root/html602/TEntryList.html,2,['Optimiz'],['OptimizeStorage']
Performance,"Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryList. class TEntryList: public TNamed. TEntryList: a List of entry numbers in a TTree or TChain; There are two types of entry lists:. for a TTree (fBlocks data member is non-zero); Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored; in the TObjArray fBlocks. The range of the entry numbers is cut into intervals; of kBlockSize entries (currently 64000), so that the first block contains; information which entries out of the first 64000 pass the selection, the second; block - which entries out of the 64000-127999 interval pass the selection, etc.; Some blocks, obviously, might be empty. The internal representation of entry; numbers in the blocks is described in the TEntryListBlock class description, and; this representation might be changed by calling OptimizeStorage() function; (when the list is filled via the Enter() function, this is done automatically,; except for the last block).; Individual entry lists can be merged (functions Merge() and Add()); to make an entry list for a TChain of corresponding TTrees. Picture; Source. {; //=========Macro generated from canvas: c/c; //========= (Tue Jan 23 16:58:56 2007) by ROOT version5.15/01; TCanvas *c = new TCanvas(""c"", ""c"",213,172,460,253);; c->Range(0,0,1,1);; c->SetBorderSize(2);; c->SetFrameFillColor(0);; ; TPaveText *pt = new TPaveText(0.00518135,0.810811,0.507772,0.989189,""br"");; pt->SetFillColor(19);; pt->SetTextColor(4);; TText *text = pt->AddText(""TEntryList for a TTree"");; pt->Draw();; ; pt = new TPaveText(0.0387597,0.483696,0.307494,0.657609,""br"");; pt->SetFillColor(19);; text = pt->AddText(""TEntryList"");; pt->Draw();; ; pt = new TPaveText(0.0363636,0.107527,0.306494,0.489247,""br"");; pt->SetFillColor(19);; pt->SetTextFont(42);; text = pt->AddText(""fBlocks"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryList.html:1037,Optimiz,OptimizeStorage,1037,root/html528/TEntryList.html,https://root.cern,https://root.cern/root/html528/TEntryList.html,4,['Optimiz'],['OptimizeStorage']
Performance,"List& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Jun 2 15:32:20 2015 » Last generated: 2015-06-02 15:32; This p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMultiVarGaussian.html:46961,cache,cache,46961,root/html604/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html604/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"List& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Jun 30 14:34:14 2015 » Last generated: 2015-06-30 14:34; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:46961,cache,cache,46961,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"List& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Mar 10 17:18:02 2015 » Last generated: 2015-03-10 17:18; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:45224,cache,cache,45224,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"List(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:26854,cache,cache,26854,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['cache'],['cache']
Performance,"List* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetPlayer(TVirtualProofPlayer* player); static void*SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t attach = kFALSE); static voidSystemCmd(const char* cmd, Int_t fdout); voidUpdateDialog(); virtual voidValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:18990,cache,cachedir,18990,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['cache'],['cachedir']
Performance,"ListBlock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print()) to; print the corrent values. void OptimizeStorage(); if there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. void Transform(Bool_t dir, UShort_t* indexnew); Transform the existing fIndices; dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits. void ResetIndices(); {fLastIndexQueried = -1, fLastIndexReturned = -1;}. Int_t GetType(); { return fType; }. » Author: Anna Kreshuk 27/10/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TEntryListBlock.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListBlock.html:16247,Optimiz,OptimizeStorage,16247,root/html528/TEntryListBlock.html,https://root.cern,https://root.cern/root/html528/TEntryListBlock.html,1,['Optimiz'],['OptimizeStorage']
Performance,"ListBlock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print()) to; print the corrent values. void OptimizeStorage(); if there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. void Transform(Bool_t dir, UShort_t* indexnew); Transform the existing fIndices; dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits. void ResetIndices(); {fLastIndexQueried = -1, fLastIndexReturned = -1;}. Int_t GetType(); { return fType; }. » Author: Anna Kreshuk 27/10/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TEntryListBlock.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEntryListBlock.html:16316,Optimiz,OptimizeStorage,16316,root/html530/TEntryListBlock.html,https://root.cern,https://root.cern/root/html530/TEntryListBlock.html,1,['Optimiz'],['OptimizeStorage']
Performance,"ListBlock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print()) to; print the corrent values. void OptimizeStorage(); if there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. void Transform(Bool_t dir, UShort_t* indexnew); Transform the existing fIndices; dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits. void ResetIndices(); {fLastIndexQueried = -1, fLastIndexReturned = -1;}. Int_t GetType(); { return fType; }. » Author: Anna Kreshuk 27/10/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TEntryListBlock.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEntryListBlock.html:16316,Optimiz,OptimizeStorage,16316,root/html532/TEntryListBlock.html,https://root.cern,https://root.cern/root/html532/TEntryListBlock.html,1,['Optimiz'],['OptimizeStorage']
Performance,"ListOfMediaTList * GetListOfMedia() constDefinition TGeoManager.h:472; TGeoManager::SetCldirCheckedvoid SetCldirChecked(Double_t *dir)Definition TGeoManager.h:523; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetUserPaintVolumevoid SetUserPaintVolume(TGeoVolume *vol)Definition TGeoManager.h:235; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::IsVisLeavesBool_t IsVisLeaves() constDefinition TGeoManager.h:223; TGeoManager::IsNullStepBool_t IsNullStep() constDefinition TGeoManager.h:408; TGeoManager::GetListOfTracksTObjArray * GetListOfTracks() constDefinition TGeoManager.h:478; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::IsStartSafeBool_t IsStartSafe() constDefinition TGeoManager.h:395; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::SetLoopVolumesvoid SetLoopVolumes(Bool_t flag=kTRUE)Definition TGeoManager.h:155; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:44394,load,loaded,44394,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['load'],['loaded']
Performance,"ListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; RooArgList _ownedList;  List of owned components. ;  ; RooListProxy _set;  set of terms to be summed ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:55039,cache,cache,55039,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['cache'],['cache']
Performance,"ListProxy _catSet;  List of categories to check. ;  ; bool _checkVal = false;  Check contents as well if true. ;  ; bool _init = false;  ; std::vector< double > _realRef;  Reference values for reals. ;  ; RooListProxy _realSet;  List of reals to track. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:56269,Cache,Cache,56269,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,1,['Cache'],['Cache']
Performance,"ListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Thu Sep 23 20:00:21 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumCdf.html:34431,cache,cache,34431,root/html528/RooNumCdf.html,https://root.cern,https://root.cern/root/html528/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"ListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Tue Mar 10 17:18:12 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumCdf.html:37558,cache,cache,37558,root/html534/RooNumCdf.html,https://root.cern,https://root.cern/root/html534/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"Listlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsSelfCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsSelfCachedReal(const RooAbsSelfCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsSelfCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Fill cache with sampling of function as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. RooAbsSelfCachedReal(); {}. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Tue Jun 30 14:30:33 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:39295,cache,cache,39295,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"List{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to ./configure); 303 TString fBuildCompiler; //Compiler used to build this ROOT; 304 TString fBuildCompilerVersion; //Compiler version used to build this ROOT; 305 TString fBuildCompilerVersionStr; //Compiler version identifier string used to build this ROOT; 306 TString fBuildNode; //Detailed information where ROOT was built; 307 TString fBuildDir; //Location where to build ACLiC shared library and use as scratch area.; 308 TString fFlagsDebug; //Flags for debug compilation; 309 TString fFlagsOpt; //Flags for optimized compilation; 310 TString fListPaths; //List of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:12321,Cache,Cache,12321,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['Cache'],['Cache']
Performance,"Load plugin handlers specified in config file, like: ; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). ; Definition at line 391 of file TPluginManager.cxx. ◆ LoadHandlersFromPluginDirs(). void TPluginManager::LoadHandlersFromPluginDirs ; (; const char * ; base = nullptr). Load plugin handlers specified via macros in a list of plugin directories. ; The $ROOTSYS/etc/plugins is the default top plugin directory specified in $ROOTSYS/etc/system.rootrc. The macros must have names like <BaseClass>/PX0_<PluginClass>.C, e.g. //TSQLServer/P20_TMySQLServer.C, to allow easy sorting and grouping. If the BaseClass is in a namespace the directory must have the name NameSpace@BaseClass as : is a reserved pathname character on some operating systems. Macros not beginning with 'P' and ending with "".C"" are ignored. If base is specified only plugin macros for that base class are loaded. The macros typically should look like: void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global ROOT state via, e.g. gSystem calls, etc. However, in specific cases this might be useful, e.g. adding a library search path, adding a specific dependency, check on some OS or ROOT capability or downloading of the plugin. ; Definition at line 490 of file TPluginManager.cxx. ◆ operator=(). TPluginManager & TPluginManager::operator= ; (; const TPluginManager & ; ). privatedelete . ◆ Print(). void TPluginManager::Print ; (; Option_t * ; opt = """"); const. overridevirtual . Print list of registered plugin handlers. ; If option is ""a"" print also the ctor's that will be used. ; Reimplemented from TObject.; Definition at line 637 of file TPluginManager.cxx. ◆ RemoveHandler(). void TPluginManag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginManager.html:18746,load,loaded,18746,doc/master/classTPluginManager.html,https://root.cern,https://root.cern/doc/master/classTPluginManager.html,1,['load'],['loaded']
Performance,"Loader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; #; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # To also specify the number of testing events, use:; ; loader.PrepareTrainingAndTestTree(; mycuts, mycutb, nTrain_Signal=7000, nTrain_Background=7000, SplitMode=""Random"", NormMode=""NumEvents"", V=False; ); ; ## Booking Methods; ; # Here we book the TMVA methods. We book first a Likelihood based on KDE (Kernel Density Estimation), a Fischer discriminant, a BDT; # and a shallow neural network; # Likelihood (""naive Bayes estimator""); if useLikelihood:; factory.BookMethod(; loader,; TMVA.Types.kLikelihood,; ""Likelihood"",; H=True,; V=False,; TransformOutput=True,; PDFInterpol=""Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10"",; NSmooth=1,; NAvEvtPerBin=50,; ); ; # Use a kernel density estimator to approximate the PDFs; if useLikelihoodKDE:; factory.BookMethod(; loader,; TMVA.Types.kLikelihood,; ""LikelihoodKDE"",; H=False,; V=False,; TransformOutput=False,; PDFInterpol=""KDE"",; KDE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:60628,load,loader,60628,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,2,['load'],['loader']
Performance,"LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCurrentNavigator->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return fCurrentNavigator->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return fCurrentNavigator->PushPath(startlevel);}. Bool_t PopPath(); {return fCurrentNavigator->PopPath();}. Bool_t PopPath(Int_t index); {return fCurrentNavigator->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return fCurrentNavigator->PushPoint(startlevel);}. Bool_t PopPoint(); {return fCurrentNavigator->PopPoint();}. Bool_t PopPoint(Int_t index); {return fCurrentNavigator->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return fCurrentNavigator->PopDummy(ipop);}. » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoManager.h 35047 2010-08-27 14:38:41Z agheata $ » Last generated: 2010-11-12 16:59; This page has been automatically generated. For comments or suggestions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:76954,cache,cache,76954,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,2,['cache'],['cache']
Performance,"LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCurrentNavigator->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return fCurrentNavigator->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return fCurrentNavigator->PushPath(startlevel);}. Bool_t PopPath(); {return fCurrentNavigator->PopPath();}. Bool_t PopPath(Int_t index); {return fCurrentNavigator->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return fCurrentNavigator->PushPoint(startlevel);}. Bool_t PopPoint(); {return fCurrentNavigator->PopPoint();}. Bool_t PopPoint(Int_t index); {return fCurrentNavigator->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return fCurrentNavigator->PopDummy(ipop);}. » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoManager.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoManager.html:77481,cache,cache,77481,root/html530/TGeoManager.html,https://root.cern,https://root.cern/root/html530/TGeoManager.html,2,['cache'],['cache']
Performance,"Log.cxx. ◆ DeclFileName(). static const char * TProofProgressLog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TProofProgressLog.h. ◆ DoLog(). void TProofProgressLog::DoLog ; (; Bool_t ; grep = kFALSE). Display logs. ; 'grep' is set to kTRUE if it is invoked by pressing the 'Filter' button. ; Definition at line 388 of file TProofProgressLog.cxx. ◆ Init(). void TProofProgressLog::Init ; (; Int_t ; w = 700, . Int_t ; h = 600 . ). private . Init window frame for log messages. ; Definition at line 70 of file TProofProgressLog.cxx. ◆ IsA(). TClass * TProofProgressLog::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 93 of file TProofProgressLog.h. ◆ LoadBuffer(). void TProofProgressLog::LoadBuffer ; (; const char * ; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. ◆ LoadFile(). void TProofProgressLog::LoadFile ; (; const char * ; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. ◆ LogMessage(). void TProofProgressLog::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame, if open. ; Definition at line 519 of file TProofProgressLog.cxx. ◆ NoLineEntry(). void TProofProgressLog::NoLineEntry ; (; ). Enable/disable the line number entry. ; Definition at line 599 of file TProofProgressLog.cxx. ◆ Popup(). void TProofProgressLog::Popup ; (; ). Show log window. ; Definition at line 263 of file TProofProgressLog.cxx. ◆ Rebuild(). void TProofProgressLog::Rebuild ; (; ). Rebuild the log info for a new entered session. ; Definition at line 635 of file TProofProgressLog.cxx. ◆ SaveToFile(). void TProofProgressLog::SaveToFile ; (; ). Save the logs to a file Only the name of the file is taken, no expansion. ; Definition at line 534 of file TProofProgressLog.cxx. ◆ Select(). void TProofPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:41208,Load,LoadFile,41208,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['Load'],['LoadFile']
Performance,"LogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveStraightLineSetGL.html:1897,cache,cached,1897,root/html534/TEveStraightLineSetGL.html,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetGL.html,2,['cache'],['cached']
Performance,"Long64_t *size, Long_t *flags, Long_t *modtime);  Get info about a file: id, size, flags, modification time. ;  ; int GetPathInfo (const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime);  Get info about a file: id, size, flags, modification time. ;  ; virtual const char * GetSoExt () const;  Get the shared library extension. ;  ; virtual void IgnoreInterrupt (Bool_t ignore=kTRUE);  If ignore is true ignore the interrupt signal, else restore previous behaviour. ;  ; Bool_t InControl () const;  ; virtual void InnerLoop ();  Inner event loop. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void Openlog (const char *name, Int_t options, ELogFacility facility);  Open connection to system log daemon. ;  ; const char * pwd ();  ; void RemoveOnExit (TObject *obj);  Objects that should be deleted on exit of the OS interface. ;  ; virtual TStdExceptionHandler * RemoveStdExceptionHandler (TStdExceptionHandler *eh);  Remove an exception handler from list of exception handlers. ;  ; virtual void ResetTimer (TTimer *);  ; virtual void Run ();  System event loop. ;  ; virtual void SetAclicMode (EAclicMode mode);  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual void SetBuildDir (const char *build_dir, Bool_t isflat=kFALSE);  Set the location where ACLiC will create libraries and use as a scratch area. ;  ; virtual void SetDisplay ();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:18464,Load,LoadAllLibraries,18464,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,['Load'],"['Load', 'LoadAllLibraries']"
Performance,"Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:17837,queue,queue,17837,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,3,['queue'],['queue']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidReadLeaves(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidReset(Option_t* option = """"); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchRef.html:6035,Load,LoadBaskets,6035,root/html526/TBranchRef.html,https://root.cern,https://root.cern/root/html526/TBranchRef.html,1,['Load'],['LoadBaskets']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidReset(Option_t* option = """"); virtual voidTBranch::ResetAddress(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchRef.html:6080,Load,LoadBaskets,6080,root/html528/TBranchRef.html,https://root.cern,https://root.cern/root/html528/TBranchRef.html,1,['Load'],['LoadBaskets']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBranchRef.html:6237,Load,LoadBaskets,6237,root/html530/TBranchRef.html,https://root.cern,https://root.cern/root/html530/TBranchRef.html,3,['Load'],['LoadBaskets']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TBranchRef&operator=(const TBranchRef&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchRef.html:6162,Load,LoadBaskets,6162,root/html602/TBranchRef.html,https://root.cern,https://root.cern/root/html602/TBranchRef.html,2,['Load'],['LoadBaskets']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTBranch::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TBranch* b); virtual voidTBranch::Reset(Option_t* option = """"); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookBranch.html:5517,Load,LoadBaskets,5517,root/html528/THbookBranch.html,https://root.cern,https://root.cern/root/html528/THbookBranch.html,1,['Load'],['LoadBaskets']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTBranch::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THbookBranch.html:5674,Load,LoadBaskets,5674,root/html530/THbookBranch.html,https://root.cern,https://root.cern/root/html530/THbookBranch.html,3,['Load'],['LoadBaskets']
Performance,"Long64_tTBranch::GetTotBytes(Option_t* option = """") const; TTree*TBranch::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTBranch::GetWriteBasket() const; Long64_tTBranch::GetZipBytes(Option_t* option = """") const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTBranch::IsAutoDelete() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTBranch::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTBranch::KeepCircular(Long64_t maxEntries); virtual Int_tTBranch::LoadBaskets(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttFill::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); THbookBranch&operator=(const THbookBranch&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTBranch::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTBranch::ReadBasket(TBuffer& b); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTBranch::Refresh(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THbookBranch.html:5351,Load,LoadBaskets,5351,root/html602/THbookBranch.html,https://root.cern,https://root.cern/root/html602/THbookBranch.html,2,['Load'],['LoadBaskets']
Performance,"Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); Bool_tfCanChangeConfig! variable indicates can be basic configuration changed or not; TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfIdsTableExists! indicate if IdsTable exists; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNby",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:29667,Cache,Cached,29667,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,1,['Cache'],['Cached']
Performance,"Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; TStopwatchfSaveOutputmeasures time spent saving the partial result; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as whic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:19663,queue,queue,19663,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['queue'],['queue']
Performance,"Long64_tfLogFileMaxSizemax size for log files (enabled if > 0); Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfOutputFilepath with the temporary results of the current or last query; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; TStopwatchfSaveOutputmeasures time spent saving the partial result; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster; TStringfUseruser as which",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:20410,queue,queue,20410,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,2,['queue'],['queue']
Performance,"Long_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TString.h; TrainingHistory.h; TransformationHandler.h; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; ClassificationClass to perform two class classification.; TMVA::ConfigurableDefinition Configurable.h:45; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetInfo::GetNVariablesUInt_t GetNVariables() constDefinition DataSetInfo.h:127; TMVA::DataSetInfo::GetNTargetsUInt_t GetNTargets() constDefinition DataSetInfo.h:128; TMVA::DataSetInfo::GetDataSetDataSet * GetDataSet() constreturns data setDefinition DataSetInfo.cxx:493; TMVA::DataSetInfo::GetVariableInfoVariableInfo & GetVariableInfo(Int_t i)Definition DataSetInfo.h:105; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::DataSet::GetNEventsLong64_t GetNEvents(Types::ETreeType type=Types::kMaxTreeType) constDefinition DataSet.h:206; TMVA::DataSet::GetNTrainingEventsLong64_t GetNTrainingEvents() constDefinition DataSet.h:68; TMVA::EventDefinition Event.h:51; TMVA::Experimental::ClassificationDefinition Classification.h:162; TMVA::FactoryThis is the main MVA steering cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:36017,perform,perform,36017,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['perform'],['perform']
Performance,"Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:33923,optimiz,optimizes,33923,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""RtypesCore.h\""\n"";; 1309 } else {; 1310 if (!hasCxxModules); 1311 PreIncludes += ""#include \""Rtypes.h\""\n"";; 1312 ; 1313 PreIncludes +=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:46341,Load,LoadModules,46341,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadModules']
Performance,"M Trans ;  ►CRooRandomThis class provides a static interface for generating random numbers ;  CGuard;  ►CRooRandomizeParamMCSModuleRooRandomizeParamMCSModule is an add-on modules to RooMCStudy that allows you to randomize input generation parameters ;  CGausParam;  CGausParamSet;  CUniParam;  CUniParamSet;  CRooRangeBinningRooRangeBinning is binning/range definition that only defines a range but no binning ;  CRooRangeBooleanRooRangeBoolean ;  CRooRealAnalyticLightweight RooAbsFunc interface adaptor that binds an analytic integral of a RooAbsReal object (specified by a code) to a set of dependent variables ;  CRooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present it as a simple array oriented interface ;  CRooRealConstantRooRealConstant provides static functions to create and keep track of RooRealVar constants ;  CRooRealIntegralRooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects The class performs none of the actual integration, but only manages the logic of what variables can be integrated analytically, accounts for eventual jacobian terms and defines what numerical integrations needs to be done to complement the analytical integral ;  CRooRealMPFERooRealMPFE is the multi-processor front-end for parallel calculation of RooAbsReal objects ;  CRooRealProxyRooRealProxy is the concrete proxy for RooAbsReal objects A RooRealProxy is the general mechanism to store references to RooAbsReals inside a RooAbsArg ;  ►CRooRealSumFunc;  CCacheElem;  ►CRooRealSumPdfClass RooRealSumPdf implements a PDF constructed from a sum of functions: ;  CCacheElem;  CRooRealVarRooRealVar represents a fundamental (non-derived) real valued object ;  CRooRealVarSharedPropertiesClass RooRealVarSharedProperties is an implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones ;  CRooRecursiveFractionClass RooRecursiveFraction is a RooAbsReal implementation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:118387,perform,performs,118387,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['perform'],['performs']
Performance,"M Trans ;  ►CRooRandomThis class provides a static interface for generating random numbers ;  CGuard;  ►CRooRandomizeParamMCSModuleRooRandomizeParamMCSModule is an add-on modules to RooMCStudy that allows you to randomize input generation parameters ;  CGausParam;  CGausParamSet;  CUniParam;  CUniParamSet;  CRooRangeBinningRooRangeBinning is binning/range definition that only defines a range but no binning ;  CRooRangeBooleanRooRangeBoolean ;  CRooRealAnalyticLightweight RooAbsFunc interface adaptor that binds an analytic integral of a RooAbsReal object (specified by a code) to a set of dependent variables ;  CRooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present it as a simple array oriented interface ;  CRooRealConstantRooRealConstant provides static functions to create and keep track of RooRealVar constants ;  CRooRealIntegralRooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects The class performs none of the actual integration, but only manages the logic of what variables can be integrated analytically, accounts for eventual jacobian terms and defines what numerical integrations needs to be done to complement the analytical integral ;  CRooRealMPFERooRealMPFE is the multi-processor front-end for parallel calculation of RooAbsReal objects ;  CRooRealProxyRooRealProxy is the concrete proxy for RooAbsReal objects A RooRealProxy is the general mechanism to store references to RooAbsReals inside a RooAbsArg ;  ►CRooRealSumPdfClass RooRealSumPdf implements a PDF constructed from a sum of functions: ;  CCacheElem;  CRooRealVarRooRealVar represents a fundamental (non-derived) real valued object ;  CRooRealVarSharedPropertiesClass RooRealVarSharedProperties is an implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones ;  CRooRecursiveFractionClass RooRecursiveFraction is a RooAbsReal implementation that calculates the plain fract",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:102230,perform,performs,102230,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['perform'],['performs']
Performance,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:12535,perform,performed,12535,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,18,['perform'],['performed']
Performance,"MENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBase.html:11796,tune,tuneParameters,11796,root/html602/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBase.html,2,['tune'],['tuneParameters']
Performance,"MENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAnalysisType(TMVA::Types::EAnalysisType type); voidSetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMethodBaseDir(TDirectory* methodDir); voidSetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalReferenceCut(Double_t cut); voidSetSignalReferenceCutOrientation(Double_t cutOrientation); voidSetTestTime(Double_t testTime); voidSetTestvarName(const TString& v = """"); voidSetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestClassification(); virtual voidTestMulticlass(); virtual voidTestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteEvaluationHis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:11285,tune,tuneParameters,11285,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,1,['tune'],['tuneParameters']
Performance,"MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printing level. void optimizeConst(Bool_t flag); If flag is true, perform constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinimizer construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value and the full correlation matrix. RooPlot* contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); Create and draw a TH2 with the error contours in parameters var1 and v2 at up to 6 'sigma' settings; where 'sigma' is calculated as n*n*errorLevel. void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void applyCovarianceMatrix(TMatrixDSym& V); Apply results of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinimizer.html:10876,optimiz,optimizeConst,10876,root/html526/RooMinimizer.html,https://root.cern,https://root.cern/root/html526/RooMinimizer.html,9,"['optimiz', 'perform']","['optimization', 'optimizeConst', 'perform']"
Performance,"MINUIT operation. Int_t minos(const RooArgSet& minosParamList); Execute MINOS for given list of parameters. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t seek(); Execute SEEK. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t simplex(); Execute SIMPLEX. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t improve(); Execute IMPROVE. Changes in parameter values; and calculated errors are automatically; propagated back the RooRealVars representing; the floating parameters in the MINUIT operation. Int_t setPrintLevel(Int_t newLevel); Change the MINUIT internal printing level. void optimizeConst(Int_t flag); If flag is true, perform constant term optimization on; function being minimized. RooFitResult* save(const char* name = 0, const char* title = 0); Save and return a RooFitResult snaphot of current minimizer status.; This snapshot contains the values of all constant parameters,; the value of all floating parameters at RooMinimizer construction and; after the last MINUIT operation, the MINUIT status, variance quality,; EDM setting, number of calls with evaluation problems, the minimized; function value and the full correlation matrix. RooPlot* contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); Create and draw a TH2 with the error contours in parameters var1 and v2 at up to 6 'sigma' settings; where 'sigma' is calculated as n*n*errorLevel. void profileStart(); Start profiling timer. void profileStop(); Stop profiling timer and report results of last session. void applyCovarianceMatrix(TMatrixDSym& V); Apply results of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinimizer.html:11030,optimiz,optimizeConst,11030,root/html532/RooMinimizer.html,https://root.cern,https://root.cern/root/html532/RooMinimizer.html,12,"['optimiz', 'perform']","['optimization', 'optimizeConst', 'perform']"
Performance,"ML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.LoadAllLibs(); // Load all rootmap'ed libraries; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.Ou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THtml.html:1529,Load,LoadAllLibs,1529,root/html602/THtml.html,https://root.cern,https://root.cern/root/html602/THtml.html,12,['Load'],"['Load', 'LoadAllLibs']"
Performance,"MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:45670,Perform,Perform,45670,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['Perform'],['Perform']
Performance,"MPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. Note: See the comments in TBranchElement::SetAddress() for the; object ownership policy of the underlying (user) data. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:99202,perform,performs,99202,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 542 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:20462,perform,performs,20462,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 543 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:20423,perform,performs,20423,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:25243,perform,performs,25243,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:23481,perform,performs,23481,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:32028,perform,performs,32028,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 596 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:19733,perform,performs,19733,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['perform'],['performs']
Performance,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 597 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:19825,perform,performs,19825,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['perform'],['performs']
Performance,"MT use case, implemented in TTree::GetEntry, spawns a task for each branch of the tree. Therefore, a task takes care of the reading, decompression and deserialisation of a given branch. ; Definition at line 420 of file TROOT.cxx. ◆ EvalParMultiDim(). void ROOT::Internal::EvalParMultiDim ; (; TF1 * ; func, . Double_t * ; out, . const Double_t * ; x, . std::size_t ; size, . std::size_t ; rows, . Double_t * ; params . ). inline . Definition at line 796 of file TF1.h. ◆ GenericShowMembers(). void ROOT::Internal::GenericShowMembers ; (; const char * ; topClassName, . void * ; obj, . TMemberInspector & ; R__insp, . bool ; transientMember . ). inline . Definition at line 24 of file RtypesImp.h. ◆ GetArrayType(). TString ROOT::Internal::GetArrayType ; (; TStreamerElement * ; element, . const char * ; subtype, . TTreeProxyGenerator::EContainer ; container . ). Definition at line 131 of file TTreeProxyGenerator.cxx. ◆ GetClassHelper() [1/2]. template<typename T > . TClass * ROOT::Internal::GetClassHelper ; (; Bool_t ; load, . Bool_t ; silent, . std::false_type ;  . ). Definition at line 646 of file TClass.h. ◆ GetClassHelper() [2/2]. template<typename T > . TClass * ROOT::Internal::GetClassHelper ; (; Bool_t ; , . Bool_t ; , . std::true_type ;  . ). Definition at line 624 of file TClass.h. ◆ GetDemangledTypeName(). std::string ROOT::Internal::GetDemangledTypeName ; (; const std::type_info & ; t). Definition at line 31 of file TGenericClassInfo.cxx. ◆ GetErrorSystemMsgHandler(). ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ; (; ). Definition at line 51 of file TError.cxx. ◆ GetGlobalTaskArena(). std::shared_ptr< ROOT::Internal::RTaskArenaWrapper > ROOT::Internal::GetGlobalTaskArena ; (; unsigned ; maxConcurrency = 0). Factory function returning a shared pointer to the instance of the global RTaskArenaWrapper. ; Allows for reinstantiation of the global RTaskArenaWrapper once all the references to the previous one are gone and the object destroyed. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:33880,load,load,33880,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['load'],['load']
Performance,"MTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; Calculations are expressed in terms of a type-safe functional chain of actions and transformations, RDataFrame takes care of their execution. The implementation automatically puts in place several low level optimisations such as multi-thread parallelization and caching. For the impatient user; You can directly see RDataFrame in action in our tutorials, in C++ or Python. Table of Contents. Cheat sheet; Introduction; Crash course; Working with collections; Transformations: manipulating data; Actions: getting results; Distributed execution in Python; Performance tips and parallel execution; More features; Systematic variations; RDataFrame objects as function arguments and return values; Storing RDataFrame objects in collections; Executing callbacks every N events; Default column lists; Special helper columns: `rdfentry_` and `rdfslot_`; Just-in-time compilation: column type inference and explicit declaration of column types; User-defined custom actions; Dataset joins with friend trees; Reading data formats other than ROOT trees; Computation graphs (storing and reusing sets of transformations); Visualizing the computation graph; Activating RDataFrame execution logs; Creating an RDataFrame from a dataset specification file; Adding a progress bar. Efficient analysis in Python; Class reference. Cheat sheet; These are the operations which can be performed with RDataFrame. Transformations; Transformations are a way to manipulate the data. Transformation Description . Alias() Introduce an alias for a particular column name. . Define() Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the pts of ""good"" muons). . DefinePerSample() Define a new column that is updated when the input sampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:1874,Perform,Performance,1874,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['Perform'],['Performance']
Performance,"MVA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. enum EPruneMethod { kExpectedErrorPruning; kCostComplexityPruning; kNoPruning; };. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted ; Bool_tfRandomisedTreechoose at each node splitting a random set of variables ; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:6842,perform,perform,6842,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['perform'],['perform']
Performance,"MVA::MethodBase::MethodBaseDir() const; TMVA::MethodPDERSMethodPDERS(const TMVA::MethodPDERS&); TMVA::MethodPDERSMethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); TMVA::MethodPDERSMethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodPDERS&operator=(const TMVA::MethodPDERS&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromStream(TFile& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDERS.html:11137,Optimiz,OptimizeTuningParameters,11137,root/html602/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDERS.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"MVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D* TMVA::OptimizeConfigParameters::fMvaBkg. private . MVA distribution for bakgr. events, used for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMvaSig. private . MVA distribution for signal events, used for spline fit. ; Definition at line 89 of file OptimizeConfigParameters.h. ◆ fMvaSigFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaSigFineBin. private . MVA distribution for signal events. ; Definition at line 92 of file OptimizeConfigParameters.h. ◆ fNotDoneYet. Bool_t TMVA::OptimizeConfigParameters::fNotDoneYet. private . flat to indicate of Method Transformations have been obtained yet or not (normally done in MethodBase::TrainMethod) ; Definition at line 95 of file OptimizeConfigParameters.h. ◆ fOptimizationFitType. TString TMVA::OptimizeConfigParameters::fOptimizationFitType. private . which type of optimisation procedure to be used ; Definition at line 88 of file OptimizeConfigParameters.h. ◆ fTunedParameters. std::map<TString,Double_t> TMVA::OptimizeConfigParameters::fTunedParameters. private . parameters included in the tuning ; Definition at line 85 of file OptimizeConfigParameters.h. ◆ fTuneParameters. std::map<TString,TMVA::Interval*> TMVA::OptimizeConfigParameters::fTuneParameters. private . parameters included in the tuning ; Definition at line 84 of file OptimizeConfigParameters.h. ◆ TestOptimizeConfigParameters. friend TMVA::OptimizeConfigParameters::TestOptimizeConfigParameters. Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:11904,Optimiz,OptimizeConfigParameters,11904,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"MVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemented.. ; Definition at line 87 of file OptimizeConfigParameters.h. ◆ fFOMvsIter. std::vector<Float_t> TMVA::OptimizeConfigParameters::fFOMvsIter. private . graph showing the development of the Figure Of Merit values during the fit ; Definition at line 83 of file OptimizeConfigParameters.h. ◆ fLogger. MsgLogger* TMVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:10219,Optimiz,OptimizeConfigParameters,10219,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"MVA::SVKernelFunction::EKernelType > TMVA::MethodSVM::MakeKernelList ; (; std::string ; multiKernels, . TString ; kernel . ). MakeKernelList Function providing string manipulation for product or sum of kernels functions to take list of kernels specified in the booking of the method and provide a vector of SV kernels to iterate over in SVKernelFunction. ; Example:; ""KernelList=RBF*Polynomial"" would use a product of the RBF and Polynomial kernels. ; Definition at line 1054 of file MethodSVM.cxx. ◆ OptimizeTuningParameters(). std::map< TString, Double_t > TMVA::MethodSVM::OptimizeTuningParameters ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""Minuit"" . ). virtual . Optimize Tuning Parameters This is used to optimise the kernel function parameters and cost. ; All kernel parameters are optimised by default with default ranges, however the parameters to be optimised can be set when booking the method with the option Tune.; Example:; ""Tune=Gamma[0.01;1.0;100]"" would only tune the RBF Gamma between 0.01 and 1.0 with 100 steps. ; Reimplemented from TMVA::MethodBase.; Definition at line 760 of file MethodSVM.cxx. ◆ ProcessOptions(). void TMVA::MethodSVM::ProcessOptions ; (; ). privatevirtual . option post processing (if necessary) ; Implements TMVA::MethodBase.; Definition at line 268 of file MethodSVM.cxx. ◆ ReadWeightsFromStream() [1/4]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/4]. void TMVA::MethodSVM::ReadWeightsFromStream ; (; std::istream & ; istr). virtual . Implements TMVA::MethodBase.; Definition at line 513 of file MethodSVM.cxx. ◆ ReadWeightsFromStream() [3/4]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromStream() [4/4]. void TMVA::MethodSVM::ReadWeightsFromStream ; (; TFile & ; fFin). virtual . TODO write ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html:36131,tune,tune,36131,doc/master/classTMVA_1_1MethodSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html,1,['tune'],['tune']
Performance,"MakeZombie(). private:. TBaseClass(const TBaseClass&); TBaseClass&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClassReffClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TBaseClass.h 32336 2010-02-12 15:03:23Z pcanal $ » Last generated: 2010-09-23 20:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBaseClass.html:6427,load,load,6427,root/html528/TBaseClass.html,https://root.cern,https://root.cern/root/html528/TBaseClass.html,1,['load'],['load']
Performance,"MakeZombie(). private:. TBaseClass(const TBaseClass&); TBaseClass&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClassReffClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TBaseClass.h 32336 2010-02-12 15:03:23Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBaseClass.html:6496,load,load,6496,root/html530/TBaseClass.html,https://root.cern,https://root.cern/root/html530/TBaseClass.html,1,['load'],['load']
Performance,"MakeZombie(). private:. TBaseClass(const TBaseClass&); TBaseClass&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClassReffClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TBaseClass.h 32336 2010-02-12 15:03:23Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBaseClass.html:6635,load,load,6635,root/html532/TBaseClass.html,https://root.cern,https://root.cern/root/html532/TBaseClass.html,1,['load'],['load']
Performance,"Manager<RooAbsCacheElement>::wireCache(). Data Members; protected:. Bool_t_allowOptimize; static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4194,cache,cache,4194,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,1,['cache'],['cache']
Performance,"Manager<vector<double,allocator<double> > >(); Int_tcacheSize() const; static TClass*Class(); virtual voidRooAbsCache::findConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); vector<double,allocator<double> >*getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); vector<double,allocator<double> >*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); vector<double,allocator<double> >*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); vector<double,allocator<double> >*getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(vector<double,allocator<double> >&); virtual TClass*IsA() const; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<vector<double,allocator<double> > >&operator=(const RooCacheManager<vector<double,allocator<double> > >&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<vector<double,allocator<double> > >(Int_t maxSize = 2); RooCacheManager<vector<double,allocator<double> > >(RooAbsArg* owner, Int_t maxSize = 2); RooCacheManager<vector<double,allocator<double> > >(const RooCacheManager<vector<double,allocator<double> > >& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_vector_double___.html:2270,optimiz,optimizeCacheMode,2270,root/html534/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_vector_double___.html,1,['optimiz'],['optimizeCacheMode']
Performance,"Managerbase geometry; Bool_tfIsClosed! Closed flag; TGeoPhysicalNode*fLastState! Last PN touched; TStringTNamed::fNameobject identifier; TObjArray*fPathsarray of paths; TObjArray*fPhysical! array of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParallelWorld.html:7632,optimiz,optimization,7632,root/html534/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html,1,['optimiz'],['optimization']
Performance,"Managerbase geometry; Bool_tfIsClosed! Closed flag; TGeoPhysicalNode*fLastState! Last PN touched; TStringTNamed::fNameobject identifier; TObjArray*fPathsarray of paths; TObjArray*fPhysical! array of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParallelWorld.html:8105,optimiz,optimization,8105,root/html604/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html604/TGeoParallelWorld.html,1,['optimiz'],['optimization']
Performance,"Map; static TDictionary::ESTLTypeTDictionary::kUnorderedMultimap; static TDictionary::ESTLTypeTDictionary::kUnorderedMultiset; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fClasspointer to the class (if any).; FuncTempInfo_t*fInfopointer to Interpreter function template info; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionTemplate(FuncTempInfo_t* info, TClass* cl); Default TFunctionTemplate ctor. TFunctionTemplate(const TFunctionTemplate& orig); Copy operator. TFunctionTemplate& operator=(const TFunctionTemplate& rhs); Assignment operator. ~TFunctionTemplate(); TFunctionTemplate dtor deletes adopted CINT FuncTempInfo. TObject * Clone(const char* newname = """") const; Clone method. Bool_t IsValid(); Return true if this function template object is pointing to a currently; loaded function. If a function is unloaded after the TFunction; is created, the TFunction will be set to be invalid. UInt_t GetTemplateNargs() const; Number of function arguments. UInt_t GetTemplateMinReqArgs() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TDictionary::DeclId_t GetDeclId() const. Bool_t Update(FuncTempInfo_t* info); Update the TFunctionTemplate to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Philippe Canal November 2013. » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta: » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFunctionTemplate.html:7959,load,loaded,7959,root/html604/TFunctionTemplate.html,https://root.cern,https://root.cern/root/html604/TFunctionTemplate.html,1,['load'],['loaded']
Performance,"Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function. More...;  ; class  MCMCInterval;  MCMCInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  MCMCIntervalPlot;  This class provides simple and straightforward utilities to plot a MCMCInterval object. More...;  ; class  MetropolisHastings;  This class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo. More...;  ; class  MinNLLTestStat;  MinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic. More...;  ; class  ModelConfig;  ModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools. More...;  ; class  NeymanConstruction;  NeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction. More...;  ; class  NuisanceParametersSampler;  Helper class for ToyMCSampler. More...;  ; class  NumberCountingPdfFactory;  A factory for building PDFs and data for a number counting combination. More...;  ; class  NumEventsTestStat;  NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting. More...;  ; class  PdfProposal;  PdfProposal is a concrete implementation of the ProposalFunction interface. More...;  ; class  PointSetInterval;  PointSetInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  PosteriorCdfFunction;  ; class  PosteriorFunction;  ; class  PosteriorFunctionFromToyMC;  Posterior function obtaining sampling toy MC for the nuisance according to their pdf. More...;  ; class  ProfileInspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:5228,perform,performs,5228,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['perform'],['performs']
Performance,"Match, TSchemaType, RStl, ROOT::TROOTAllocator, TSchemaRuleProcessor, TStdBitsetHelper, TInitBehavior, TDefaultInitBehavior, DefineBehavior, THnBaseBrowsable, THnBaseBinIter, GenericShowMembers, TOperatorNewHelper and BranchProxy implementations classes.; Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in ‘expert’ level code and have a lower level of backward compatibility requirement. This includes TCollectionProxyInfo, TSchemaRuleSet.; Interpreter; ROOT can now dump the context of STL collections, for instance map<string,int>. A few ROOT types print their content, too.; Fixed the handling of the current directory in #include of system headers, avoid problem with local files named new or vector.; Fixed the issue with the ROOT special variable where the objects were read from the file at each and every access by caching those object. See ROOT-7830 for example.; This release contains several bug fixes and improvements, notably in unloading and performance. NOTE: The GCC 5 ABI is not supported yet, due to a lack of support in clang. I/O Libraries; hadd; We extended the hadd options to allow more control on the compression settings use for the output file. In particular the new option -fk allows for a copy of the input files with no decompressions/recompression of the TTree baskets even if they do not match the requested compression setting.; New options:. -ff allows to force the compression setting to match the one from the first input; -fk[0-209] allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; -a option append to existing file; The verbosity level is now optional after -v. Command line utilities; We added command line utilities to streamline very common operations performed on root files, like listing their content or creating directories. The command line utilities are: - r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:7377,perform,performance,7377,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['perform'],['performance']
Performance,"Matches. viewer3DLocal.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Demonstrates 3D viewer architecture TVirtualViewer3D and TBuffer3D in the local frame. ; Here each shape is described in a TBuffer3D class, with a suitible translation matrix to place each instance NOTE: to be executed via .x viewer3DLocal.C+; NOTE: We don't implement raw tesselation of sphere - hence this will not appear in viewers which don't support directly (non-OpenGL) Shows that viewers can at least deal gracefully with these cases; Our abstract base shape class.; As we overload TObject::Paint which is called directly from compiled code, this script must also be compiled to work correctly.; #if defined(__CINT__) && !defined(__MAKECINT__); {; gSystem->CompileMacro(""viewer3DLocal.C"");; viewer3DLocal();; }; #else; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; ; #include ""TVirtualViewer3D.h""; #include ""TBuffer3D.h""; #include ""TBuffer3DTypes.h""; ; #include ""TObject.h""; #include ""TVirtualPad.h""; #include ""TAtt3D.h""; ; #include <vector>; ; class Shape : public TObject; {; public:; Shape(Int_t color, Double_t x, Double_t y, Double_t z);; ~Shape() override {};; virtual TBuffer3D & GetBuffer3D(UInt_t reqSections) = 0;; ; protected:; Double_t fX, fY, fZ; // Origin; Int_t fColor;; ; ClassDefOverride(Shape,0);; };; ; ClassImp(Shape);; ; Shape::Shape(Int_t color, Double_t x, Double_t y, Double_t z) :; fX(x), fY(y), fZ(z), fColor(color); {}; ; class Sphere : public Shape; {; public:; Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius);; ~Sphere() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fRadius;; ; ClassDefOverride(Sphere,0);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:1186,load,loads,1186,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['load'],['loads']
Performance,"Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DistSampler.html:2010,cache,cached,2010,root/html528/ROOT__Math__DistSampler.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DistSampler.html,4,['cache'],['cached']
Performance,"Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the other arguments same consideration as in the previous method. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer(). return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN(). return p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__Fitter.html:6019,perform,perform,6019,root/html526/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__Fitter.html,1,['perform'],['perform']
Performance,Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Integration.html:1567,perform,performing,1567,doc/master/group__Integration.html,https://root.cern,https://root.cern/doc/master/group__Integration.html,1,['perform'],['performing']
Performance,"Matrix_t > & GetFirstMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentWeights ();  ; std::vector< Matrix_t > & GetFirstMomentWeightsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentBiases ();  ; std::vector< Matrix_t > & GetSecondMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentWeights ();  ; std::vector< Matrix_t > & GetSecondMomentWeightsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fBeta1;  The Beta1 constant used by the optimizer. ;  ; Scalar_t fBeta2;  The Beta2 constant used by the optimizer. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fFirstMomentBiases;  The decaying average of the first moment of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fFirstMomentWeights;  The decaying average of the first moment of the past weight gradients associated with the deep net. ;  ; std::vector< std::vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:2414,Perform,Performs,2414,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,2,"['Perform', 'optimiz']","['Performs', 'optimization']"
Performance,"Matrixcov matrix (stored as cov[ i * dim + j] ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; unsigned intfNFreedimension of the internal function to be minimized ; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:7930,perform,perform,7930,root/html534/ROOT__Math__GSLNLSMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html,1,['perform'],['perform']
Performance,"MaxEpochs=20""; ""DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:""; ) # + ""|"" + trainingString2; # General Options.; trainingString1.Append(archString); dnnName = ""TMVA_DNN""; factory.BookMethod(; dataloader,; TMVA.Types.kDL,; dnnName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; RandomSeed=0,; InputLayout=""1|1|"" + str(ntime * ninput),; Layout=""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"",; TrainingStrategy=trainingString1; ); ; ; ## Book Keras recurrent models; ; # Book the different types of recurrent models in Keras (SimpleRNN, LSTM or GRU); ; ; if useKeras:; for i in range(3):; if use_rnn_type[i]:; modelName = ""model_"" + rnn_types[i] + "".h5""; trainedModelName = ""trained_"" + modelName; print(""Building recurrent keras model using a"", rnn_types[i], ""layer""); # create python script which can be executed; # create 2 conv2d layer + maxpool + dense; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, SimpleRNN, GRU, LSTM, Reshape, BatchNormalization; ; model = Sequential(); model.add(Reshape((10, 30), input_shape=(10 * 30,))); # add recurrent neural network depending on type / Use option to return the full output; if rnn_types[i] == ""LSTM"":; model.add(LSTM(units=10, return_sequences=True)); elif rnn_types[i] == ""GRU"":; model.add(GRU(units=10, return_sequences=True)); else:; model.add(SimpleRNN(units=10, return_sequences=True)); # m.AddLine(""model.add(BatchNormalization())"");; model.add(Flatten()) # needed if returning the full time output sequence; model.add(Dense(64, activation=""tanh"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(modelName); model.summary(); print(""saved recurrent model"", modelName); ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:59230,optimiz,optimizers,59230,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['optimiz'],['optimizers']
Performance,"Maximum level in geometry. ;  ; static Int_t fgMaxLevel = 1;  Verbosity level for Info messages (no IO). ;  ; static Int_t fgMaxXtruVert = 1;  Maximum number of daughters. ;  ; static std::mutex fgMutex;  ; static Int_t fgVerboseLevel = 1;  Lock preventing a second geometry to be loaded. ;  . Private Types; typedef std::map< std::string, Double_t > ConstPropMap_t;  ; typedef std::map< std::thread::id, TGeoNavigatorArray * > NavigatorsMap_t;  bits used for voxelization ;  ; typedef NavigatorsMap_t::iterator NavigatorsMapIt_t;  ; typedef std::map< std::thread::id, Int_t > ThreadsMap_t;  ; typedef ThreadsMap_t::const_iterator ThreadsMapIt_t;  . Private Member Functions; void Init ();  Initialize manager class. ;  ; Bool_t InitArrayPNE () const;  Initialize PNE array for fast access via index and unique-id. ;  ; Bool_t InsertPNEId (Int_t uid, Int_t ientry);  Insert a PN entry in the sorted array of indexes. ;  ; Bool_t IsLoopingVolumes () const;  ; void SetLoopVolumes (Bool_t flag=kTRUE);  ; void UpdateElements ();  Update element flags when geometry is loaded from a file. ;  ; void Voxelize (Option_t *option=nullptr);  Voxelize all non-divided volumes. ;  . Private Attributes; Bool_t fActivity;  flag for GL reflections ;  ; TObjArray * fArrayPNE;  ; UChar_t * fBits;  ; TObjArray * fBorderSurfaces;  ; TGeoShape * fClippingShape;  ; Bool_t fClosed;  ; TGeoNavigator * fCurrentNavigator;  Lock existing navigators. ;  ; TVirtualGeoTrack * fCurrentTrack;  ; TGeoVolume * fCurrentVolume;  current navigator ;  ; Bool_t fDrawExtra;  ; TGeoElementTable * fElementTable;  clipping shape for raytracing ;  ; Int_t fExplodedView;  ; TObjArray * fGDMLMatrices;  ; TGeoHMatrix * fGLMatrix;  ; TObjArray * fGShapes;  ; TObjArray * fGVolumes;  list of runtime shapes ;  ; THashList * fHashGVolumes;  hash list of volumes providing fast search ;  ; THashList * fHashPNE;  hash list of group volumes providing fast search ;  ; THashList * fHashVolumes;  ; Bool_t fIsGeomCleaning;  flag set when rea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:63384,load,loaded,63384,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['load'],['loaded']
Performance,"Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:1821,Cache,Cache,1821,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['Cache'],['Cache']
Performance,"Mean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxyRooAbsMoment::_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_tRooAbsMoment::_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsMoment::_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxyRooAbsMoment::_xObservable; RooRealProxy_xf(X-offset)*F; Double_t_xfOffsetoffset; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSecondMoment(); Default cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:36682,cache,cache,36682,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,4,['cache'],['cache']
Performance,"Medium2(). void TGeoManagerEditor::DoSelectMedium2 ; (; ). Slot for selecting an existing medium for making a volume. ; Definition at line 1408 of file TGeoManagerEditor.cxx. ◆ DoSelectShape(). void TGeoManagerEditor::DoSelectShape ; (; ). Slot for selecting an existing shape. ; Definition at line 1338 of file TGeoManagerEditor.cxx. ◆ DoSelectShape2(). void TGeoManagerEditor::DoSelectShape2 ; (; ). Slot for selecting a shape for making a volume. ; Definition at line 1352 of file TGeoManagerEditor.cxx. ◆ DoSelectTopVolume(). void TGeoManagerEditor::DoSelectTopVolume ; (; ). Slot for setting top geometry volume. ; Definition at line 1436 of file TGeoManagerEditor.cxx. ◆ DoSelectVolume(). void TGeoManagerEditor::DoSelectVolume ; (; ). Slot for selecting an existing volume. ; Definition at line 1422 of file TGeoManagerEditor.cxx. ◆ DoSetTopVolume(). void TGeoManagerEditor::DoSetTopVolume ; (; ). Set top volume for the geometry. ; Definition at line 1256 of file TGeoManagerEditor.cxx. ◆ LoadLib(). void TGeoManagerEditor::LoadLib ; (; ). static . Dummy static function, used to load plugin. ; Definition at line 1527 of file TGeoManagerEditor.cxx. ◆ SelectedSlot(). void TGeoManagerEditor::SelectedSlot ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; event . ). virtual . Connected to TCanvas::Selected. ; TGeoManagerEditor takes this function from TGedEditor and only uses it if obj is a TGeoVolume. ; Definition at line 708 of file TGeoManagerEditor.cxx. ◆ SetModel(). void TGeoManagerEditor::SetModel ; (; TObject * ; obj). overridevirtual . Refresh editor according the selected obj. ; Implements TGedFrame.; Definition at line 795 of file TGeoManagerEditor.cxx. ◆ ShowSelectMaterial(). void TGeoManagerEditor::ShowSelectMaterial ; (; Bool_t ; show = kTRUE). protected . Show/hide interface for material selection. ; Definition at line 1491 of file TGeoManagerEditor.cxx. ◆ ShowSelectMatrix(). void TGeoManagerEditor::ShowSelectMatrix ; (; Bool_t ; show = kTRUE). protected . Show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManagerEditor.html:47883,Load,LoadLib,47883,doc/master/classTGeoManagerEditor.html,https://root.cern,https://root.cern/doc/master/classTGeoManagerEditor.html,1,['Load'],['LoadLib']
Performance,"Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void ClearResults (void) override;  Clear all data members which depend on the unfolding results. ;  ; void DoBackgroundSubtraction (void);  perform background subtraction ;  ; void GetEmatrixFromVyy (const TMatrixDSparse *vyy, TH2 *ematrix, const Int_t *binMap, Bool_t clearEmat);  propagate an error matrix on the input vector to the unfolding result ;  ; TMatrixDSparse * GetSummedErrorMatrixXX (void);  determine total error matrix on the vector x ;  ; TMatrixDSparse * GetSummedErrorMatrixYY (void);  determine total error matrix on the vector Ax ;  ; virtual TMatrixDSparse * PrepareCorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixDSparse *dsys);  propagate correlated systematic shift to an output vector ;  ; virtual void PrepareSysError (void);  Matrix calculations required to propagate systematic errors. ;  ; virtual TMatrixDSparse * PrepareUncorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2);  propagate uncorrelated systematic errors to a covariance matrix ;  ; void ScaleColumnsByVector (TMatrixDSparse *m, const TMatrixTBase< Double_t > *v) const;  scale columns of a matrix by the corresponding rows of a vector ;  ; void VectorMapToHist (TH1 *hist_delta, const TMatrixDSparse *delta, const Int_t *binMap);  map delta to hist_delta, possibly summing up bins ;  ;  Protected Member Functions inherited from TUnfold; void AddMSparse (TMatrixDSparse *dest, Double_t f, const TMatrixDSparse *src) const;  add a sparse ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:22911,perform,perform,22911,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['perform'],['perform']
Performance,"Member Functions |; Protected Attributes |; Friends |; List of all members ; RooNumRunningInt Class ReferenceRooFit » RooFit Core. ; Implementation of RooAbsCachedReal that represents a running integral. . \[ RI(f(x)) = \int_{xlow}^{x} f(x') dx' \]. that is calculated internally with a numeric technique: The input function is first sampled into a histogram, which is then numerically integrated. The output function is an interpolated version of the integrated histogram. The sampling density is controlled by the binning named ""cache"" in the observable x. The shape of the p.d.f is always calculated for the entire domain in x and cached in a histogram. The cache histogram is automatically recalculated when any of the parameters of the input p.d.f. has changed. ; Definition at line 22 of file RooNumRunningInt.h. Classes; class  RICacheElem;  . Public Member Functions;  RooNumRunningInt (const char *name, const char *title, RooAbsReal &_func, RooRealVar &_x, const char *binningName=""cache"");  Construct running integral of function '_func' over x_print from the lower bound on _x to the present value of _x using a numeric sampling technique. ;  ;  RooNumRunningInt (const RooNumRunningInt &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumRunningInt () override;  Destructor. ;  ; TObject * clone (const char *newname) const override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsCachedReal;  RooAbsCachedReal ();  ;  RooAbsCachedReal (const char *name, const char *title, Int_t ipOrder=0);  Constructor. ;  ;  RooAbsCachedReal (const RooAbsCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward call to implementation in relevant RooHistFunc instance. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:1220,cache,cache,1220,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"Member.h:31; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjectMother of all ROOT objects.Definition TObject.h:41; TStreamerBasicTypeDefinition TStreamerElement.h:269; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfo::TCompInfoDefinition TStreamerInfo.h:41; TStreamerInfo::TCompInfo::TCompInfoTCompInfo()Definition TStreamerInfo.h:57; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owned.Definition TStreamerInfo.h:53; TStreamerInfo::TCompInfo::fStreamerTMemberStreamer * fStreamerNot Owned.Definition TStreamerInfo.h:56; TStreamerInfo::TCompInfo::fOffsetInt_t fOffsetDefinition TStreamerInfo.h:49; TStreamerInfo::TCompInfo::fElemTStreamerElement * fElemNot Owned.Definition TStreamerInfo.h:51; TStreamerInfo::TCompInfo::fNewClassTClass * fNewClassNot Owned.Definition TStreamerInfo.h:54; TStreamerInfo::TCompInfo::fClassNameTString fClassNameDefinition TStreamerInfo.h:55; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::~TCompInfo~TCompInfo()Definition TStreamerInfo.h:59; TStreamerInfo::TCompInfo::fNewTypeInt_t fNewTypeDefinition TStreamerInfo.h:48; TStreamerInfo::TCompInfo::fLengthInt_t fLen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:20905,cache,cached,20905,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['cache'],['cached']
Performance,"Members(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TGPack.h 29129 2009-06-22 09:39:20Z brun $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFrameElementPack.html:5265,cache,cached,5265,root/html528/TGFrameElementPack.html,https://root.cern,https://root.cern/root/html528/TGFrameElementPack.html,1,['cache'],['cached']
Performance,"Members(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TGPack.h 29129 2009-06-22 09:39:20Z brun $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGFrameElementPack.html:5336,cache,cached,5336,root/html530/TGFrameElementPack.html,https://root.cern,https://root.cern/root/html530/TGFrameElementPack.html,1,['cache'],['cached']
Performance,"Members(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TGPack.h 29129 2009-06-22 09:39:20Z brun $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFrameElementPack.html:5336,cache,cached,5336,root/html532/TGFrameElementPack.html,https://root.cern,https://root.cern/root/html532/TGFrameElementPack.html,1,['cache'],['cached']
Performance,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fA[fMaxParam] Fit parameter array; Double_tfAKAPPA; Double_t*fAMN[fMaxParam] Minimum param value; Double_t*fAMX[fMaxParam] Maximum param value; TString*fANames[fMaxParam] Parameter names; Double_t*fCmPar[fMaxParam] parameters of commands; TStringfCwordCommand st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:13186,cache,cache,13186,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,4,['cache'],['cache']
Performance,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:9511,cache,cache,9511,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,4,['cache'],['cache']
Performance,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSym",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:17361,cache,cache,17361,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,4,['cache'],['cache']
